<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cute Maze Adventure - SVG.js</title>
  <!-- Load svg.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.2.0/svg.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: "Comic Sans MS", "Trebuchet MS", sans-serif;
      background: linear-gradient(135deg, #ffe0f7, #e3f2fd);
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    #leftPanel {
      width: 260px;
      padding: 15px;
      box-sizing: border-box;
      background: rgba(255,255,255,0.9);
      box-shadow: 2px 0 10px rgba(0,0,0,0.15);
      display: flex;
      flex-direction: column;
      z-index: 1;
    }
    #leftPanel h1 {
      margin: 0 0 10px 0;
      font-size: 22px;
      color: #ff7043;
    }
    #leftPanel p {
      margin: 4px 0;
      font-size: 13px;
      color: #555;
    }
    #leftPanel button {
      margin-top: 8px;
      padding: 8px 10px;
      font-size: 14px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      background: #42a5f5;
      color: white;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    #leftPanel button:hover {
      background: #1e88e5;
    }
    #leftPanel button.secondary {
      background: #66bb6a;
    }
    #leftPanel button.secondary:hover {
      background: #43a047;
    }
    #infoBox {
      margin-top: 10px;
      padding: 8px;
      border-radius: 6px;
      background: #fff3e0;
      border: 1px solid #ffe0b2;
      font-size: 13px;
      color: #6d4c41;
    }
    #gameArea {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
  </style>
</head>
<body>
  <div id="leftPanel">
    <h1>Maze Adventure</h1>
    <p>Help the happy sun reach the candy star!</p>
    <p>Use the <strong>arrow keys</strong> to move.</p>
    <p>The friendly monsters want hugs, but if they catch you the game restarts.</p>
    <p>Your hero leaves a bubble trail while moving.</p>
    <button id="newMazeBtn" class="secondary">New Maze</button>
    <button id="showPathBtn">Show Solution Path</button>

    <div id="infoBox">
      <strong>Tips for grown-ups:</strong>
      <ul style="padding-left: 18px; margin: 4px 0;">
        <li>Maze: 20 Ã— 20 cells, always solvable.</li>
        <li>Obstacles can be moved with the mouse.</li>
        <li>Path button shows the correct route.</li>
      </ul>
    </div>
  </div>

  <div id="gameArea"></div>

<script>
/* -------------------------------------------------------
   Cute Maze Adventure - SVG.js Single-File Game
   -------------------------------------------------------
   - 20x20 random maze with guaranteed solution.
   - Hero controlled by arrow keys, cannot pass walls.
   - Friendly monsters roam the corridors and "catch" hero.
   - Hero leaves bubble trail while moving.
   - Button shows the current solution path.
   -----------------------------------------------------*/

// --- Maze & Drawing Constants ---
const ROWS = 20;
const COLS = 20;
const CELL_SIZE = 25;
const MARGIN = 30;

let draw;               // svg.js root
let mazeGroup;          // Group for maze walls
let heroGroup;          // Group for hero graphics
let monsterGroup;       // Group for monsters
let trailGroup;         // Group for hero trail
let solutionGroup;      // Group for solution path
let goalGroup;          // Group for goal (candy star)

// Maze data structure
let cells = [];         // 2D array of cells with wall info
let solutionPath = [];  // Array of {r, c} for solution

// Hero state
let heroRow = 0;
let heroCol = 0;
let heroMoveInterval = null;
let trailInterval = null;
let currentDir = null;
let isGameOver = false;

// Monster state
let monsters = [];
let monsterInterval = null;

// Trail management
let trailDots = [];
const MAX_TRAIL_DOTS = 250;

// Utility: get center pixel for a cell
function cellCenter(row, col) {
  const x = MARGIN + col * CELL_SIZE + CELL_SIZE / 2;
  const y = MARGIN + row * CELL_SIZE + CELL_SIZE / 2;
  return { x, y };
}

/* -------------------------------------------------------
   Maze Generation: Recursive Backtracker
   Each cell has walls: top, right, bottom, left.
   -----------------------------------------------------*/
function generateMaze() {
  cells = [];
  for (let r = 0; r < ROWS; r++) {
    cells[r] = [];
    for (let c = 0; c < COLS; c++) {
      cells[r][c] = {
        r,
        c,
        visited: false,
        walls: { top: true, right: true, bottom: true, left: true }
      };
    }
  }

  const stack = [];
  let current = cells[0][0];
  current.visited = true;
  let visitedCount = 1;
  const totalCells = ROWS * COLS;

  while (visitedCount < totalCells) {
    const neighbors = [];
    const r = current.r;
    const c = current.c;

    if (r > 0 && !cells[r - 1][c].visited) neighbors.push({ dir: 'top', cell: cells[r - 1][c] });
    if (c < COLS - 1 && !cells[r][c + 1].visited) neighbors.push({ dir: 'right', cell: cells[r][c + 1] });
    if (r < ROWS - 1 && !cells[r + 1][c].visited) neighbors.push({ dir: 'bottom', cell: cells[r + 1][c] });
    if (c > 0 && !cells[r][c - 1].visited) neighbors.push({ dir: 'left', cell: cells[r][c - 1] });

    if (neighbors.length > 0) {
      // Choose a random neighbor
      const choice = neighbors[Math.floor(Math.random() * neighbors.length)];
      const next = choice.cell;
      // Remove walls between current and chosen neighbor
      removeWalls(current, next, choice.dir);
      stack.push(current);
      current = next;
      current.visited = true;
      visitedCount++;
    } else if (stack.length > 0) {
      current = stack.pop();
    }
  }
}

function removeWalls(a, b, dir) {
  if (dir === 'top') {
    a.walls.top = false;
    b.walls.bottom = false;
  } else if (dir === 'right') {
    a.walls.right = false;
    b.walls.left = false;
  } else if (dir === 'bottom') {
    a.walls.bottom = false;
    b.walls.top = false;
  } else if (dir === 'left') {
    a.walls.left = false;
    b.walls.right = false;
  }
}

/* -------------------------------------------------------
   Drawing the Maze with svg.js
   -----------------------------------------------------*/
function drawMaze() {
  mazeGroup.clear();

  // Soft colored background behind maze
  mazeGroup.rect(COLS * CELL_SIZE + 2 * MARGIN, ROWS * CELL_SIZE + 2 * MARGIN)
    .move(0, 0)
    .fill('#fffde7')
    .radius(20)
    .stroke({ color: '#ffcc80', width: 4 });

  // Draw walls
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const cell = cells[r][c];
      const x = MARGIN + c * CELL_SIZE;
      const y = MARGIN + r * CELL_SIZE;

      const strokeStyle = { color: '#8d6e63', width: 3, linecap: 'round' };

      if (cell.walls.top) {
        mazeGroup.line(x, y, x + CELL_SIZE, y).stroke(strokeStyle);
      }
      if (cell.walls.left) {
        mazeGroup.line(x, y, x, y + CELL_SIZE).stroke(strokeStyle);
      }
      if (r === ROWS - 1 && cell.walls.bottom) {
        mazeGroup.line(x, y + CELL_SIZE, x + CELL_SIZE, y + CELL_SIZE).stroke(strokeStyle);
      }
      if (c === COLS - 1 && cell.walls.right) {
        mazeGroup.line(x + CELL_SIZE, y, x + CELL_SIZE, y + CELL_SIZE).stroke(strokeStyle);
      }
    }
  }
}

/* -------------------------------------------------------
   BFS to Compute Solution Path (start: 0,0; end: ROWS-1,COLS-1)
   -----------------------------------------------------*/
function computeSolutionPath() {
  solutionPath = [];
  const visited = [];
  const prev = [];
  for (let r = 0; r < ROWS; r++) {
    visited[r] = [];
    prev[r] = [];
    for (let c = 0; c < COLS; c++) {
      visited[r][c] = false;
      prev[r][c] = null;
    }
  }

  const queue = [];
  queue.push({ r: 0, c: 0 });
  visited[0][0] = true;

  const getNeighbors = (r, c) => {
    const res = [];
    const cell = cells[r][c];
    if (!cell.walls.top && r > 0) res.push({ r: r - 1, c: c });
    if (!cell.walls.right && c < COLS - 1) res.push({ r: r, c: c + 1 });
    if (!cell.walls.bottom && r < ROWS - 1) res.push({ r: r + 1, c: c });
    if (!cell.walls.left && c > 0) res.push({ r: r, c: c - 1 });
    return res;
  };

  while (queue.length > 0) {
    const { r, c } = queue.shift();
    if (r === ROWS - 1 && c === COLS - 1) break;
    const neighs = getNeighbors(r, c);
    for (const n of neighs) {
      if (!visited[n.r][n.c]) {
        visited[n.r][n.c] = true;
        prev[n.r][n.c] = { r, c };
        queue.push(n);
      }
    }
  }

  let r = ROWS - 1, c = COLS - 1;
  if (!visited[r][c]) return; // Should not happen in a perfect maze

  const path = [];
  while (!(r === 0 && c === 0)) {
    path.push({ r, c });
    const p = prev[r][c];
    r = p.r;
    c = p.c;
  }
  path.push({ r: 0, c: 0 });
  solutionPath = path.reverse();
}

/* -------------------------------------------------------
   Show Solution Path
   -----------------------------------------------------*/
function showSolutionPath() {
  solutionGroup.clear();
  if (!solutionPath || solutionPath.length === 0) return;

  const points = solutionPath.map(cell => {
    const { x, y } = cellCenter(cell.r, cell.c);
    return [x, y];
  });

  solutionGroup.polyline(points)
    .fill('none')
    .stroke({
      color: '#ff4081',
      width: CELL_SIZE * 0.4,
      linecap: 'round',
      linejoin: 'round',
      opacity: 0.7
    });

  // Cute footprints along the path
  solutionPath.forEach((cell, i) => {
    if (i % 3 === 0) {
      const { x, y } = cellCenter(cell.r, cell.c);
      solutionGroup.circle(6).center(x, y).fill('#ffd54f').stroke({ color: '#fbc02d', width: 1 });
    }
  });

  solutionGroup.front();
}

/* -------------------------------------------------------
   Hero (Cute Sun) Setup & Movement
   -----------------------------------------------------*/
function createHero() {
  heroGroup.clear();

  // Create a happy sun hero
  const body = heroGroup.circle(CELL_SIZE * 0.7)
    .fill('#fff59d')
    .stroke({ color: '#fbc02d', width: 3 });

  const eyeOffsetX = CELL_SIZE * 0.12;
  const eyeOffsetY = CELL_SIZE * -0.05;
  heroGroup.circle(4).fill('#5d4037').center(body.cx() - eyeOffsetX, body.cy() + eyeOffsetY);
  heroGroup.circle(4).fill('#5d4037').center(body.cx() + eyeOffsetX, body.cy() + eyeOffsetY);

  // Smile
  const smile = heroGroup.path('M -8 3 Q 0 10 8 3')
    .fill('none')
    .stroke({ color: '#f57f17', width: 2 });
  smile.center(body.cx(), body.cy() + 4);
}

function placeHeroAt(row, col, animate = false) {
  heroRow = row;
  heroCol = col;
  const { x, y } = cellCenter(row, col);
  if (animate) {
    heroGroup.animate(150).center(x, y);
  } else {
    heroGroup.center(x, y);
  }
  heroGroup.front();
}

function tryMoveHero(direction) {
  if (isGameOver) return;
  if (!direction) return;

  const cell = cells[heroRow][heroCol];
  let newRow = heroRow;
  let newCol = heroCol;

  if (direction === 'up' && !cell.walls.top && heroRow > 0) newRow--;
  if (direction === 'down' && !cell.walls.bottom && heroRow < ROWS - 1) newRow++;
  if (direction === 'left' && !cell.walls.left && heroCol > 0) newCol--;
  if (direction === 'right' && !cell.walls.right && heroCol < COLS - 1) newCol++;

  if (newRow !== heroRow || newCol !== heroCol) {
    placeHeroAt(newRow, newCol, true);
    checkWin();
    checkCollisions();
  }
}

/* -------------------------------------------------------
   Hero Trail (Bubble Dots)
   -----------------------------------------------------*/
function startTrail() {
  if (trailInterval) return;
  trailInterval = setInterval(() => {
    if (isGameOver) return;
    const { x, y } = cellCenter(heroRow, heroCol);
    const dot = trailGroup.circle(6)
      .center(x, y)
      .fill('rgba(129,212,250,0.7)')
      .stroke({ color: '#4fc3f7', width: 1 });
    trailDots.push(dot);
    if (trailDots.length > MAX_TRAIL_DOTS) {
      const old = trailDots.shift();
      old.remove();
    }
  }, 220);
}

function stopTrail() {
  if (trailInterval) {
    clearInterval(trailInterval);
    trailInterval = null;
  }
}

/* -------------------------------------------------------
   Monsters (Cute Creatures) Random Walk
   -----------------------------------------------------*/
function createMonsterGraphic(color) {
  const g = monsterGroup.group();
  const body = g.circle(CELL_SIZE * 0.6).fill(color).stroke({ color: '#5e35b1', width: 2 });

  // Eyes
  const eyeOffsetX = CELL_SIZE * 0.12;
  g.circle(4).fill('#fff').center(body.cx() - eyeOffsetX, body.cy() - 3);
  g.circle(4).fill('#fff').center(body.cx() + eyeOffsetX, body.cy() - 3);
  g.circle(2).fill('#3e2723').center(body.cx() - eyeOffsetX, body.cy() - 3);
  g.circle(2).fill('#3e2723').center(body.cx() + eyeOffsetX, body.cy() - 3);

  // Friendly smile
  const smile = g.path('M -7 5 Q 0 9 7 5')
    .fill('none')
    .stroke({ color: '#4e342e', width: 1.5 });
  smile.center(body.cx(), body.cy() + 2);

  return g;
}

function spawnMonsters() {
  monsterGroup.clear();
  monsters = [];

  const monsterColors = ['#ce93d8', '#ffab91', '#80deea'];
  const numMonsters = 3;

  for (let i = 0; i < numMonsters; i++) {
    let mr, mc;
    // Avoid spawning on hero start or goal cell
    do {
      mr = Math.floor(Math.random() * ROWS);
      mc = Math.floor(Math.random() * COLS);
    } while ((mr === 0 && mc === 0) || (mr === ROWS - 1 && mc === COLS - 1));

    const g = createMonsterGraphic(monsterColors[i % monsterColors.length]);
    const { x, y } = cellCenter(mr, mc);
    g.center(x, y);

    monsters.push({ row: mr, col: mc, group: g });
  }
}

function moveMonsters() {
  if (isGameOver) return;
  for (const m of monsters) {
    const cell = cells[m.row][m.col];
    const options = [];

    if (!cell.walls.top && m.row > 0) options.push({ r: m.row - 1, c: m.col });
    if (!cell.walls.bottom && m.row < ROWS - 1) options.push({ r: m.row + 1, c: m.col });
    if (!cell.walls.left && m.col > 0) options.push({ r: m.row, c: m.col - 1 });
    if (!cell.walls.right && m.col < COLS - 1) options.push({ r: m.row, c: m.col + 1 });

    if (options.length > 0) {
      const choice = options[Math.floor(Math.random() * options.length)];
      m.row = choice.r;
      m.col = choice.c;
      const { x, y } = cellCenter(m.row, m.col);
      m.group.animate(200).center(x, y);
    }
  }
  checkCollisions();
}

/* -------------------------------------------------------
   Goal (Candy Star) Drawing
   -----------------------------------------------------*/
function drawGoal() {
  goalGroup.clear();
  const { x, y } = cellCenter(ROWS - 1, COLS - 1);

  // Simple star-like shape
  const star = goalGroup.polygon('0,-12 4,-4 12,-4 6,2 8,10 0,6 -8,10 -6,2 -12,-4 -4,-4')
    .fill('#ffcc80')
    .stroke({ color: '#fb8c00', width: 2 });
  star.center(x, y);
}

/* -------------------------------------------------------
   Collisions, Win/Lose Logic
   -----------------------------------------------------*/
function checkCollisions() {
  for (const m of monsters) {
    if (m.row === heroRow && m.col === heroCol) {
      gameOver('Oh no! A friendly monster gave you a big hug!\nLet\'s try a new maze!');
      break;
    }
  }
}

function checkWin() {
  if (heroRow === ROWS - 1 && heroCol === COLS - 1) {
    gameOver('Yay! You reached the candy star!\nHere comes a brand new maze!');
  }
}

function gameOver(message) {
  if (isGameOver) return;
  isGameOver = true;
  stopHeroMovement();
  stopTrail();
  if (monsterInterval) {
    clearInterval(monsterInterval);
    monsterInterval = null;
  }
  // Small delay so last movement finishes, then alert & restart
  setTimeout(() => {
    alert(message);
    startNewGame();
  }, 150);
}

/* -------------------------------------------------------
   Keyboard Controls
   -----------------------------------------------------*/
function startHeroMovement() {
  if (heroMoveInterval) return;
  heroMoveInterval = setInterval(() => {
    tryMoveHero(currentDir);
  }, 140);
  startTrail();
}

function stopHeroMovement() {
  if (heroMoveInterval) {
    clearInterval(heroMoveInterval);
    heroMoveInterval = null;
  }
  stopTrail();
}

function handleKeyDown(e) {
  if (isGameOver) return;
  const key = e.key;

  let newDir = null;
  if (key === 'ArrowUp') newDir = 'up';
  if (key === 'ArrowDown') newDir = 'down';
  if (key === 'ArrowLeft') newDir = 'left';
  if (key === 'ArrowRight') newDir = 'right';

  if (newDir) {
    e.preventDefault();
    currentDir = newDir;
    // Immediate small move on key press feels more responsive
    tryMoveHero(currentDir);
    startHeroMovement();
  }
}

function handleKeyUp(e) {
  const key = e.key;
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) {
    e.preventDefault();
    // Stop continuous movement when any arrow is released
    stopHeroMovement();
    currentDir = null;
  }
}

/* -------------------------------------------------------
   Game Initialization & Restart
   -----------------------------------------------------*/
function startNewGame() {
  // Clear any existing timers
  stopHeroMovement();
  stopTrail();
  isGameOver = false;
  if (monsterInterval) {
    clearInterval(monsterInterval);
    monsterInterval = null;
  }

  // Clear svg content and re-create groups
  draw.clear();

  // Create base groups for organization
  mazeGroup = draw.group();
  solutionGroup = draw.group();
  trailGroup = draw.group();
  monsterGroup = draw.group();
  heroGroup = draw.group();
  goalGroup = draw.group();

  // Random new maze
  generateMaze();
  drawMaze();
  computeSolutionPath();

  // Place hero and goal
  createHero();
  placeHeroAt(0, 0);
  drawGoal();

  // Monsters
  spawnMonsters();
  monsterInterval = setInterval(moveMonsters, 350);
}

/* -------------------------------------------------------
   Bootstrapping
   -----------------------------------------------------*/
document.addEventListener('DOMContentLoaded', () => {
  // Create the SVG drawing surface
  const width = COLS * CELL_SIZE + 2 * MARGIN;
  const height = ROWS * CELL_SIZE + 2 * MARGIN;
  draw = SVG().addTo('#gameArea').size(width, height).viewbox(0, 0, width, height);

  // Setup UI buttons
  document.getElementById('newMazeBtn').addEventListener('click', () => {
    startNewGame();
  });
  document.getElementById('showPathBtn').addEventListener('click', () => {
    showSolutionPath();
  });

  // Keyboard events
  document.addEventListener('keydown', handleKeyDown);
  document.addEventListener('keyup', handleKeyUp);

  // Start first game
  startNewGame();
});
</script>
</body>
</html>