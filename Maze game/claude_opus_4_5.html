<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåü Magical Maze Adventure üåü</title>
    <!-- Load SVG.js library -->
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2/dist/svg.min.js"></script>
    <style>
        /* ========== Page Styling ========== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            /* Colorful gradient background for kids */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            font-family: 'Comic Sans MS', 'Chalkboard', cursive, sans-serif;
        }
        
        /* Game title styling */
        h1 {
            color: #fff;
            text-shadow: 3px 3px 0 #ff6b6b, 6px 6px 0 #4ecdc4;
            font-size: 2.5em;
            margin-bottom: 10px;
            animation: bounce 1s ease infinite;
        }
        
        /* Bouncing animation for title */
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        /* Instructions text */
        .instructions {
            color: #fff;
            font-size: 1.2em;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        /* Game container */
        #game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        /* SVG canvas */
        #maze-svg {
            display: block;
            border-radius: 10px;
            border: 4px solid #4ecdc4;
        }
        
        /* Button container */
        .button-container {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        /* Colorful buttons for kids */
        button {
            padding: 15px 30px;
            font-size: 1.2em;
            font-family: inherit;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        /* Show path button - blue */
        #show-path-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        /* New game button - green */
        #new-game-btn {
            background: linear-gradient(135deg, #11998e, #38ef7d);
            color: white;
            box-shadow: 0 4px 15px rgba(56, 239, 125, 0.4);
        }
        
        button:hover {
            transform: translateY(-3px) scale(1.05);
        }
        
        button:active {
            transform: translateY(0) scale(0.98);
        }
        
        /* Status message */
        #status {
            color: #fff;
            font-size: 1.5em;
            margin-top: 15px;
            padding: 10px 25px;
            border-radius: 25px;
            background: rgba(0,0,0,0.3);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        /* Legend showing game elements */
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #fff;
            font-size: 1.1em;
            background: rgba(0,0,0,0.2);
            padding: 8px 15px;
            border-radius: 20px;
        }
        
        .legend-icon {
            font-size: 1.5em;
        }
    </style>
</head>
<body>
    <!-- Game Title -->
    <h1>üåü Magical Maze Adventure üåü</h1>
    
    <!-- Instructions for children -->
    <div class="instructions">
        Use ‚¨ÜÔ∏è ‚¨áÔ∏è ‚¨ÖÔ∏è ‚û°Ô∏è arrow keys to help Bunny üê∞ reach the Star ‚≠ê!<br>
        Watch out for the friendly monsters! üëæ
    </div>
    
    <!-- Game container -->
    <div id="game-container">
        <div id="maze-svg"></div>
    </div>
    
    <!-- Control buttons -->
    <div class="button-container">
        <button id="show-path-btn">üó∫Ô∏è Show Path</button>
        <button id="new-game-btn">üéÆ New Game</button>
    </div>
    
    <!-- Status message -->
    <div id="status">üéØ Find the Star!</div>
    
    <!-- Legend -->
    <div class="legend">
        <div class="legend-item"><span class="legend-icon">üê∞</span> You</div>
        <div class="legend-item"><span class="legend-icon">‚≠ê</span> Goal</div>
        <div class="legend-item"><span class="legend-icon">üëæ</span> Monster</div>
        <div class="legend-item"><span class="legend-icon">üí´</span> Your Trail</div>
    </div>

    <script>
        // ============================================================
        // GAME CONFIGURATION
        // ============================================================
        
        const MAZE_SIZE = 20;           // 20x20 maze grid
        const CELL_SIZE = 25;           // Size of each cell in pixels
        const HERO_SIZE = 18;           // Hero sprite size
        const MONSTER_COUNT = 4;        // Number of monsters
        const MONSTER_SPEED = 400;      // Monster move interval (ms)
        const TRAIL_INTERVAL = 150;     // Trail dot interval (ms)
        
        // ============================================================
        // GAME STATE VARIABLES
        // ============================================================
        
        let draw;                       // SVG.js drawing instance
        let maze = [];                  // 2D array representing the maze
        let hero = { x: 1, y: 1 };      // Hero position
        let goal = { x: 18, y: 18 };    // Goal position
        let monsters = [];              // Array of monster objects
        let heroElement;                // SVG element for hero
        let solutionPath = [];          // Path from start to goal
        let pathElements = [];          // SVG elements for solution path
        let trailElements = [];         // SVG elements for hero trail
        let gameRunning = true;         // Game state flag
        let lastTrailTime = 0;          // Timestamp for trail dots
        let heroMoving = false;         // Track if hero is moving
        
        // ============================================================
        // MAZE GENERATION - Recursive Backtracking Algorithm
        // This creates a perfect maze with exactly one path between
        // any two points, guaranteeing the maze is always solvable
        // ============================================================
        
        function generateMaze() {
            // Initialize maze with all walls (1 = wall, 0 = path)
            maze = Array(MAZE_SIZE).fill(null).map(() => 
                Array(MAZE_SIZE).fill(1)
            );
            
            // Start carving from position (1,1)
            carvePath(1, 1);
            
            // Ensure start and goal are open paths
            maze[1][1] = 0;
            maze[goal.y][goal.x] = 0;
            
            // Make sure there's a valid path (should always be true)
            if (!findPath()) {
                // If somehow no path exists, regenerate
                generateMaze();
            }
        }
        
        /**
         * Recursive function to carve paths through the maze
         * Uses depth-first search with randomized direction order
         */
        function carvePath(x, y) {
            // Mark current cell as path
            maze[y][x] = 0;
            
            // Define possible directions: right, down, left, up
            const directions = [
                { dx: 2, dy: 0 },   // Right (move 2 cells)
                { dx: 0, dy: 2 },   // Down
                { dx: -2, dy: 0 },  // Left
                { dx: 0, dy: -2 }   // Up
            ];
            
            // Shuffle directions for randomness
            shuffleArray(directions);
            
            // Try each direction
            for (const dir of directions) {
                const newX = x + dir.dx;
                const newY = y + dir.dy;
                
                // Check if new position is valid and unvisited
                if (newX > 0 && newX < MAZE_SIZE - 1 && 
                    newY > 0 && newY < MAZE_SIZE - 1 && 
                    maze[newY][newX] === 1) {
                    
                    // Carve the wall between current and new cell
                    maze[y + dir.dy / 2][x + dir.dx / 2] = 0;
                    
                    // Recursively carve from new position
                    carvePath(newX, newY);
                }
            }
        }
        
        /**
         * Fisher-Yates shuffle algorithm for randomizing array
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        // ============================================================
        // PATHFINDING - Breadth-First Search Algorithm
        // Finds the shortest path from hero to goal
        // ============================================================
        
        function findPath() {
            // BFS queue with starting position
            const queue = [{ x: hero.x, y: hero.y, path: [] }];
            const visited = new Set();
            visited.add(`${hero.x},${hero.y}`);
            
            // Possible movement directions
            const directions = [
                { dx: 1, dy: 0 },
                { dx: -1, dy: 0 },
                { dx: 0, dy: 1 },
                { dx: 0, dy: -1 }
            ];
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                // Check if we reached the goal
                if (current.x === goal.x && current.y === goal.y) {
                    solutionPath = [...current.path, { x: goal.x, y: goal.y }];
                    return true;
                }
                
                // Explore neighbors
                for (const dir of directions) {
                    const newX = current.x + dir.dx;
                    const newY = current.y + dir.dy;
                    const key = `${newX},${newY}`;
                    
                    // Check bounds and if cell is a path
                    if (newX >= 0 && newX < MAZE_SIZE && 
                        newY >= 0 && newY < MAZE_SIZE && 
                        maze[newY][newX] === 0 && 
                        !visited.has(key)) {
                        
                        visited.add(key);
                        queue.push({
                            x: newX,
                            y: newY,
                            path: [...current.path, { x: current.x, y: current.y }]
                        });
                    }
                }
            }
            
            return false; // No path found
        }
        
        // ============================================================
        // DRAWING FUNCTIONS - Using SVG.js
        // ============================================================
        
        /**
         * Initialize the SVG canvas and draw all game elements
         */
        function initializeGame() {
            // Clear existing SVG content
            document.getElementById('maze-svg').innerHTML = '';
            
            // Create SVG.js drawing canvas
            const canvasSize = MAZE_SIZE * CELL_SIZE;
            draw = SVG().addTo('#maze-svg').size(canvasSize, canvasSize);
            
            // Add colorful background gradient
            const gradient = draw.gradient('linear', function(add) {
                add.stop(0, '#e0f7fa');
                add.stop(1, '#b2ebf2');
            });
            draw.rect(canvasSize, canvasSize).fill(gradient);
            
            // Reset game state
            hero = { x: 1, y: 1 };
            monsters = [];
            pathElements = [];
            trailElements = [];
            gameRunning = true;
            
            // Generate new maze
            generateMaze();
            
            // Draw the maze
            drawMaze();
            
            // Draw goal (star)
            drawGoal();
            
            // Draw hero (bunny)
            drawHero();
            
            // Create monsters
            createMonsters();
            
            // Update status
            updateStatus('üéØ Find the Star!');
        }
        
        /**
         * Draw the maze walls and paths
         */
        function drawMaze() {
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    const cellX = x * CELL_SIZE;
                    const cellY = y * CELL_SIZE;
                    
                    if (maze[y][x] === 1) {
                        // Draw wall with cute rounded corners
                        const wall = draw.rect(CELL_SIZE - 1, CELL_SIZE - 1)
                            .move(cellX, cellY)
                            .fill('#8b5cf6')    // Purple walls
                            .stroke({ color: '#7c3aed', width: 1 })
                            .radius(4);         // Rounded corners
                        
                        // Add subtle shadow effect
                        wall.attr({ filter: 'url(#shadow)' });
                    } else {
                        // Draw path
                        draw.rect(CELL_SIZE, CELL_SIZE)
                            .move(cellX, cellY)
                            .fill('#fef3c7');   // Light yellow paths
                    }
                }
            }
            
            // Add a subtle shadow filter for walls
            const defs = draw.defs();
            const filter = defs.filter();
            filter.attr('id', 'shadow');
            filter.offset(2, 2).in(filter.$source).result('offset');
            filter.gaussianBlur(2);
        }
        
        /**
         * Draw the goal (sparkling star)
         */
        function drawGoal() {
            const goalGroup = draw.group();
            const centerX = goal.x * CELL_SIZE + CELL_SIZE / 2;
            const centerY = goal.y * CELL_SIZE + CELL_SIZE / 2;
            
            // Glowing background circle
            const glow = goalGroup.circle(CELL_SIZE)
                .center(centerX, centerY)
                .fill('#fef08a')
                .opacity(0.5);
            
            // Animate glow pulsing
            glow.animate(800, '<>').attr({ opacity: 0.8 })
                .animate(800, '<>').attr({ opacity: 0.5 })
                .loop();
            
            // Star emoji
            const star = goalGroup.text('‚≠ê')
                .font({ size: 20, anchor: 'middle' })
                .center(centerX, centerY);
            
            // Animate star rotation
            star.animate(2000, '<>').rotate(15)
                .animate(2000, '<>').rotate(-15)
                .loop();
        }
        
        /**
         * Draw the hero (cute bunny)
         */
        function drawHero() {
            const heroGroup = draw.group();
            heroGroup.attr('id', 'hero');
            
            const centerX = hero.x * CELL_SIZE + CELL_SIZE / 2;
            const centerY = hero.y * CELL_SIZE + CELL_SIZE / 2;
            
            // Hero shadow
            heroGroup.ellipse(HERO_SIZE * 0.8, HERO_SIZE * 0.4)
                .center(centerX, centerY + HERO_SIZE / 3)
                .fill('#00000033');
            
            // Hero bunny emoji with bounce animation
            const bunny = heroGroup.text('üê∞')
                .font({ size: HERO_SIZE, anchor: 'middle' })
                .center(centerX, centerY);
            
            // Idle bounce animation
            bunny.animate(500, '<>').dy(-3)
                .animate(500, '<>').dy(3)
                .loop();
            
            heroElement = heroGroup;
        }
        
        /**
         * Create and position monsters
         */
        function createMonsters() {
            // Clear any existing monster intervals
            monsters.forEach(m => clearInterval(m.intervalId));
            monsters = [];
            
            // Find valid positions for monsters (not near hero or goal)
            const validPositions = [];
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    if (maze[y][x] === 0) {
                        const distFromHero = Math.abs(x - hero.x) + Math.abs(y - hero.y);
                        const distFromGoal = Math.abs(x - goal.x) + Math.abs(y - goal.y);
                        
                        // Position must be at least 5 cells from hero and goal
                        if (distFromHero > 5 && distFromGoal > 3) {
                            validPositions.push({ x, y });
                        }
                    }
                }
            }
            
            // Shuffle and pick positions for monsters
            shuffleArray(validPositions);
            
            // Monster emoji options for variety
            const monsterEmojis = ['üëæ', 'üëª', 'üêô', 'ü§ñ', 'üëΩ'];
            const monsterColors = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3', '#f38181'];
            
            for (let i = 0; i < Math.min(MONSTER_COUNT, validPositions.length); i++) {
                const pos = validPositions[i];
                const monster = {
                    x: pos.x,
                    y: pos.y,
                    emoji: monsterEmojis[i % monsterEmojis.length],
                    color: monsterColors[i % monsterColors.length],
                    element: null,
                    intervalId: null
                };
                
                // Draw monster
                drawMonster(monster);
                
                // Start monster movement
                monster.intervalId = setInterval(() => moveMonster(monster), MONSTER_SPEED);
                
                monsters.push(monster);
            }
        }
        
        /**
         * Draw a single monster
         */
        function drawMonster(monster) {
            const monsterGroup = draw.group();
            const centerX = monster.x * CELL_SIZE + CELL_SIZE / 2;
            const centerY = monster.y * CELL_SIZE + CELL_SIZE / 2;
            
            // Monster glow circle
            const glow = monsterGroup.circle(CELL_SIZE * 0.9)
                .center(centerX, centerY)
                .fill(monster.color)
                .opacity(0.4);
            
            // Pulse animation for glow
            glow.animate(600, '<>').attr({ opacity: 0.6 })
                .animate(600, '<>').attr({ opacity: 0.4 })
                .loop();
            
            // Monster emoji
            monsterGroup.text(monster.emoji)
                .font({ size: 18, anchor: 'middle' })
                .center(centerX, centerY);
            
            monster.element = monsterGroup;
        }
        
        /**
         * Move a monster in a random valid direction
         */
        function moveMonster(monster) {
            if (!gameRunning) return;
            
            // Possible directions
            const directions = [
                { dx: 1, dy: 0 },
                { dx: -1, dy: 0 },
                { dx: 0, dy: 1 },
                { dx: 0, dy: -1 }
            ];
            
            // Shuffle for random movement
            shuffleArray(directions);
            
            // Try to find a valid move
            for (const dir of directions) {
                const newX = monster.x + dir.dx;
                const newY = monster.y + dir.dy;
                
                // Check if valid move
                if (newX >= 0 && newX < MAZE_SIZE && 
                    newY >= 0 && newY < MAZE_SIZE && 
                    maze[newY][newX] === 0) {
                    
                    // Update monster position
                    monster.x = newX;
                    monster.y = newY;
                    
                    // Animate monster movement
                    const newCenterX = newX * CELL_SIZE + CELL_SIZE / 2;
                    const newCenterY = newY * CELL_SIZE + CELL_SIZE / 2;
                    
                    monster.element.animate(200, '<>').center(newCenterX, newCenterY);
                    
                    // Check collision with hero
                    checkMonsterCollision();
                    break;
                }
            }
        }
        
        /**
         * Check if any monster caught the hero
         */
        function checkMonsterCollision() {
            for (const monster of monsters) {
                if (monster.x === hero.x && monster.y === hero.y) {
                    gameOver(false);
                    return;
                }
            }
        }
        
        // ============================================================
        // HERO MOVEMENT - Keyboard Controls
        // ============================================================
        
        /**
         * Handle keyboard input for hero movement
         */
        function handleKeyDown(event) {
            if (!gameRunning) return;
            
            let newX = hero.x;
            let newY = hero.y;
            
            // Determine new position based on arrow key
            switch (event.key) {
                case 'ArrowUp':
                    newY -= 1;
                    break;
                case 'ArrowDown':
                    newY += 1;
                    break;
                case 'ArrowLeft':
                    newX -= 1;
                    break;
                case 'ArrowRight':
                    newX += 1;
                    break;
                default:
                    return; // Ignore other keys
            }
            
            // Prevent default scrolling
            event.preventDefault();
            
            // Check if move is valid (not into a wall)
            if (newX >= 0 && newX < MAZE_SIZE && 
                newY >= 0 && newY < MAZE_SIZE && 
                maze[newY][newX] === 0) {
                
                // Add trail before moving
                addTrail(hero.x, hero.y);
                
                // Update hero position
                hero.x = newX;
                hero.y = newY;
                heroMoving = true;
                
                // Animate hero movement
                const newCenterX = newX * CELL_SIZE + CELL_SIZE / 2;
                const newCenterY = newY * CELL_SIZE + CELL_SIZE / 2;
                
                heroElement.animate(100, '<>').center(newCenterX, newCenterY);
                
                // Check if reached goal
                if (hero.x === goal.x && hero.y === goal.y) {
                    gameOver(true);
                    return;
                }
                
                // Check collision with monsters
                checkMonsterCollision();
            } else {
                // Bump animation when hitting wall
                heroElement.animate(50).dx(5 * (newX - hero.x))
                    .animate(50).dx(0);
            }
        }
        
        /**
         * Add a trail dot at the specified position
         */
        function addTrail(x, y) {
            const currentTime = Date.now();
            
            // Only add trail at intervals
            if (currentTime - lastTrailTime < TRAIL_INTERVAL) return;
            lastTrailTime = currentTime;
            
            const centerX = x * CELL_SIZE + CELL_SIZE / 2;
            const centerY = y * CELL_SIZE + CELL_SIZE / 2;
            
            // Create sparkle trail dot
            const trail = draw.circle(8)
                .center(centerX, centerY)
                .fill('#fbbf24')
                .opacity(0.8);
            
            // Add to trail array
            trailElements.push(trail);
            
            // Fade out animation
            trail.animate(2000).opacity(0.2);
            
            // Limit trail length
            if (trailElements.length > 50) {
                const oldTrail = trailElements.shift();
                oldTrail.remove();
            }
        }
        
        // ============================================================
        // SOLUTION PATH DISPLAY
        // ============================================================
        
        /**
         * Show or hide the solution path
         */
        function toggleSolutionPath() {
            if (pathElements.length > 0) {
                // Hide path
                pathElements.forEach(el => el.remove());
                pathElements = [];
            } else {
                // Recalculate path from current position
                findPath();
                
                // Show path
                for (let i = 0; i < solutionPath.length; i++) {
                    const pos = solutionPath[i];
                    const centerX = pos.x * CELL_SIZE + CELL_SIZE / 2;
                    const centerY = pos.y * CELL_SIZE + CELL_SIZE / 2;
                    
                    // Draw path dot with delay animation
                    const dot = draw.circle(10)
                        .center(centerX, centerY)
                        .fill('#10b981')
                        .opacity(0);
                    
                    // Animate appearance with delay
                    dot.delay(i * 30).animate(200).opacity(0.7);
                    
                    pathElements.push(dot);
                }
            }
        }
        
        // ============================================================
        // GAME STATE MANAGEMENT
        // ============================================================
        
        /**
         * Handle game over (win or lose)
         */
        function gameOver(won) {
            gameRunning = false;
            
            // Stop all monsters
            monsters.forEach(m => clearInterval(m.intervalId));
            
            if (won) {
                // Victory!
                updateStatus('üéâ YOU WIN! Amazing job! üåü');
                
                // Victory animation
                const victoryGroup = draw.group();
                
                // Confetti effect
                for (let i = 0; i < 30; i++) {
                    const confetti = victoryGroup.text(['üéä', 'üéâ', '‚≠ê', 'üåü', 'üí´'][Math.floor(Math.random() * 5)])
                        .font({ size: 20 })
                        .move(Math.random() * MAZE_SIZE * CELL_SIZE, -30);
                    
                    confetti.animate(2000, '<>')
                        .move(Math.random() * MAZE_SIZE * CELL_SIZE, MAZE_SIZE * CELL_SIZE + 30)
                        .opacity(0);
                }
                
                // Enlarge hero
                heroElement.animate(500, '<>').scale(1.5);
                
            } else {
                // Caught by monster
                updateStatus('üò¢ Oh no! Try again! Press "New Game"');
                
                // Sad animation
                heroElement.animate(300).opacity(0.5)
                    .animate(300).opacity(1)
                    .loop(3);
            }
        }
        
        /**
         * Update the status message
         */
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        // ============================================================
        // EVENT LISTENERS
        // ============================================================
        
        // Keyboard controls
        document.addEventListener('keydown', handleKeyDown);
        
        // Button controls
        document.getElementById('show-path-btn').addEventListener('click', toggleSolutionPath);
        document.getElementById('new-game-btn').addEventListener('click', initializeGame);
        
        // ============================================================
        // INITIALIZE GAME ON PAGE LOAD
        // ============================================================
        
        window.addEventListener('load', initializeGame);
    </script>
</body>
</html>