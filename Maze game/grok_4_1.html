<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy Maze Adventure!</title>
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2.0/dist/svg.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(to bottom, #87CEEB, #98FB98);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            width: 900px;
            height: 700px;
            background: #fff;
            border-radius: 20px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        #maze-svg {
            width: 100%;
            height: 100%;
        }
        .title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 42px;
            color: #ff6b6b;
            text-shadow: 3px 3px 0 #fff;
            z-index: 10;
        }
        .instructions {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.9);
            padding: 15px 30px;
            border-radius: 20px;
            font-size: 20px;
            color: #333;
            text-align: center;
            z-index: 10;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
        }
        button {
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: all 0.3s;
        }
        button:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.4);
        }
        button:active {
            transform: translateY(0);
        }
        #showSolution {
            background: #4ecdc4;
        }
        #newMaze {
            background: #45b7d1;
        }
        .win-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.95);
            padding: 40px;
            border-radius: 30px;
            text-align: center;
            font-size: 50px;
            color: #ff6b6b;
            display: none;
            z-index: 100;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }
        .win-message.show {
            display: block;
            animation: bounce 1s infinite;
        }
        @keyframes bounce {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="title">Happy Maze Adventure!</div>
        <div class="instructions">Use arrow keys to move your hero! Avoid the monsters!</div>
        
        <svg id="maze-svg"></svg>
        
        <div class="controls">
            <button id="showSolution">Show Path</button>
            <button id="newMaze">New Maze</button>
        </div>
        
        <div class="win-message" id="winMessage">
            You Win!<br>
            <span style="font-size: 80px;">Congratulations!</span>
        </div>
    </div>

    <script>
        // === MAZE GAME FOR KINDERGARTEN CHILDREN ===
        // Everything in one file using SVG.js
        
        class MazeGame {
            constructor() {
                this.size = 20;           // 20x20 grid
                this.cellSize = 35;       // Size of each cell in pixels
                this.svg = SVG('#maze-svg').size('100%', '100%');
                this.maze = [];
                this.player = { x: 1, y: 1 };
                this.monsters = [];
                this.trail = [];
                this.solutionPath = [];
                this.showSolution = false;
                
                this.init();
            }
            
            init() {
                this.generateMaze();
                this.drawMaze();
                this.spawnMonsters();
                this.drawPlayer();
                this.setupControls();
                this.gameLoop();
            }
            
            // === Recursive Backtracking Maze Generation (always solvable) ===
            generateMaze() {
                // Initialize grid with walls
                this.maze = Array(this.size).fill().map(() => 
                    Array(this.size).fill().map(() => ({ 
                        walls: { top: true, right: true, bottom: true, left: true },
                        visited: false
                    }))
                );
                
                const stack = [];
                const start = { x: 1, y: 1 };
                this.maze[start.y][start.x].visited = true;
                stack.push(start);
                
                while (stack.length > 0) {
                    const current = stack[stack.length - 1];
                    const neighbors = this.getUnvisitedNeighbors(current.x, current.y);
                    
                    if (neighbors.length > 0) {
                        const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                        
                        // Remove wall between current and next
                        if (next.x > current.x) {
                            this.maze[current.y][current.x].walls.right = false;
                            this.maze[next.y][next.x].walls.left = false;
                        } else if (next.x < current.x) {
                            this.maze[current.y][current.x].walls.left = false;
                            this.maze[next.y][next.x].walls.right = false;
                        } else if (next.y > current.y) {
                            this.maze[current.y][current.x].walls.bottom = false;
                            this.maze[next.y][next.x].walls.top = false;
                        } else if (next.y < current.y) {
                            this.maze[current.y][current.x].walls.top = false;
                            this.maze[next.y][next.x].walls.bottom = false;
                        }
                        
                        this.maze[next.y][next.x].visited = true;
                        stack.push(next);
                    } else {
                        stack.pop();
                    }
                }
                
                // Set start and end
                this.maze[1][1].walls.left = false;  // Entrance
                this.maze[this.size-2][this.size-2].walls.right = false; // Exit
            }
            
            getUnvisitedNeighbors(x, y) {
                const neighbors = [];
                const dirs = [
                    { x: 0, y: -2 }, // up
                    { x: 2, y: 0 },  // right
                    { x: 0, y: 2 },  // down
                    { x: -2, y: 0 }  // left
                ];
                
                for (const dir of dirs) {
                    const nx = x + dir.x;
                    const ny = y + dir.y;
                    if (nx > 0 && nx < this.size-1 && ny > 0 && ny < this.size-1 && 
                        !this.maze[ny][nx].visited) {
                        neighbors.push({ x: nx, y: ny });
                    }
                }
                return neighbors;
            }
            
            // === Draw the maze ===
            drawMaze() {
                this.svg.clear();
                
                // Background
                this.svg.rect('100%', '100%').fill('#f0f8ff');
                
                const offsetX = (900 - this.size * this.cellSize) / 2;
                const offsetY = (700 - this.size * this.cellSize) / 2;
                
                // Draw walls
                for (let y = 0; y < this.size; y++) {
                    for (let x = 0; x < this.size; x++) {
                        const cell = this.maze[y][x];
                        const px = offsetX + x * this.cellSize;
                        const py = offsetY + y * this.cellSize;
                        
                        if (cell.walls.top) {
                            this.svg.line(px, py, px + this.cellSize, py)
                                .stroke({ color: '#4a5568', width: 4 });
                        }
                        if (cell.walls.right) {
                            this.svg.line(px + this.cellSize, py, px + this.cellSize, py + this.cellSize)
                                .stroke({ color: '#4a5568', width: 4 });
                        }
                        if (cell.walls.bottom) {
                            this.svg.line(px, py + this.cellSize, px + this.cellSize, py + this.cellSize)
                                .stroke({ color: '#4a5568', width: 4 });
                        }
                        if (cell.walls.left) {
                            this.svg.line(px, py, px, py + this.cellSize)
                                .stroke({ color: '#4a5568', width: 4 });
                        }
                    }
                }
                
                // Entrance and exit
                this.svg.circle(offsetX + this.cellSize/2, offsetY + this.cellSize/2, this.cellSize/3)
                    .fill('#90ee90');
                this.svg.circle(offsetX + (this.size-1)*this.cellSize + this.cellSize/2, 
                              offsetY + (this.size-2)*this.cellSize + this.cellSize/2, this.cellSize/3)
                    .fill('#ffd700');
            }
            
            // === Player ===
            drawPlayer() {
                if (this.playerElement) this.playerElement.remove();
                if (this.trailGroup) this.trailGroup.remove();
                
                const offsetX = (900 - this.size * this.cellSize) / 2;
                const offsetY = (700 - this.size * this.cellSize) / 2;
                
                const px = offsetX + this.player.x * this.cellSize + this.cellSize/2;
                const py = offsetY + this.player.y * this.cellSize + this.cellSize/2;
                
                // Trail group
                this.trailGroup = this.svg.group();
                
                // Player - cute character
                this.playerElement = this.svg.group();
                
                // Body
                this.playerElement.circle(this.cellSize * 0.6)
                    .center(px, py)
                    .fill('#ff6b6b');
                
                // Face
                this.playerElement.circle(this.cellSize * 0.3)
                    .center(px, py - this.cellSize * 0.1)
                    .fill('#fff5e6');
                
                // Eyes
                this.playerElement.circle(6).center(px - 8, py - this.cellSize * 0.12).fill('#333');
                this.playerElement.circle(6).center(px + 8, py - this.cellSize * 0.12).fill('#333');
                
                // Smile
                this.playerElement.path('M' + (px-10) + ',' + (py + 2) + ' Q' + px + ',' + (py + 10) + ' ' + (px+10) + ',' + (py + 2))
                    .fill('none')
                    .stroke({ color: '#333', width: 3 });
            }
            
            // === Monsters ===
            spawnMonsters() {
                this.monsters = [];
                const monsterPositions = [
                    { x: 5, y: 5 },
                    { x: 10, y: 8 },
                    { x: 15, y: 12 },
                    { x: 8, y: 15 }
                ];
                
                monsterPositions.forEach(pos => {
                    if (pos.x !== this.player.x || pos.y !== this.player.y) {
                        this.monsters.push({
                            x: pos.x,
                            y: pos.y,
                            targetX: pos.x,
                            targetY: pos.y,
                            element: null
                        });
                    }
                });
                
                this.drawMonsters();
            }
            
            drawMonsters() {
                if (this.monsterGroup) this.monsterGroup.remove();
                this.monsterGroup = this.svg.group();
                
                const offsetX = (900 - this.size * this.cellSize) / 2;
                const offsetY = (700 - this.size * this.cellSize) / 2;
                
                this.monsters.forEach(monster => {
                    const mx = offsetX + monster.x * this.cellSize + this.cellSize/2;
                    const my = offsetY + monster.y * this.cellSize + this.cellSize/2;
                    
                    const mon = this.monsterGroup.group();
                    
                    // Body
                    mon.circle(this.cellSize * 0.7)
                        .center(mx, my)
                        .fill('#9c27b0');
                    
                    // Eyes
                    mon.circle(10).center(mx - 10, my - 8).fill('#fff');
                    mon.circle(10).center(mx + 10, my - 8).fill('#fff');
                    mon.circle(6).center(mx - 10, my - 8).fill('#000');
                    mon.circle(6).center(mx + 10, my - 8).fill('#000');
                    
                    // Mouth
                    mon.path('M' + (mx-15) + ',' + (my + 5) + ' Q' + mx + ',' + (my + 15) + ' ' + (mx+15) + ',' + (my + 5))
                        .fill('none')
                        .stroke({ color: '#fff', width: 4 });
                    
                    monster.element = mon;
                });
            }
            
            // === Player Movement ===
            movePlayer(dx, dy) {
                const newX = this.player.x + dx;
                const newY = this.player.y + dy;
                
                // Check boundaries
                if (newX < 1 || newX >= this.size-1 || newY < 1 || newY >= this.size-1) return;
                
                // Check walls
                if (dx === 1 && this.maze[this.player.y][this.player.x].walls.right) return;
                if (dx === -1 && this.maze[this.player.y][this.player.x].walls.left) return;
                if (dy === 1 && this.maze[this.player.y][this.player.x].walls.bottom) return;
                if (dy === -1 && this.maze[this.player.y][this.player.x].walls.top) return;
                
                // Move player
                this.player.x = newX;
                this.player.y = newY;
                
                // Leave trail
                this.trail.push({ x: this.player.x, y: this.player.y, age: 0 });
                if (this.trail.length > 50) {
                    this.trail.shift();
                }
                
                // Draw player and trail
                this.drawPlayer();
                this.drawTrail();
                
                // Check win
                if (this.player.x === this.size-2 && this.player.y === this.size-2) {
                    this.win();
                }
                
                // Check monster collision
                this.checkMonsterCollision();
            }
            
            drawTrail() {
                if (this.trailGroup) this.trailGroup.clear();
                
                const offsetX = (900 - this.size * this.cellSize) / 2;
                const offsetY = (700 - this.size * this.cellSize) / 2;
                
                this.trail.forEach((point, i) => {
                    const px = offsetX + point.x * this.cellSize + this.cellSize/2;
                    const py = offsetY + point.y * this.cellSize + this.cellSize/2;
                    const opacity = (i + 1) / this.trail.length;
                    
                    this.trailGroup.circle(8)
                        .center(px, py)
                        .fill(`rgba(255, 107, 107, ${opacity})`);
                });
            }
            
            // === Monster AI - Simple random movement ===
            moveMonsters() {
                this.monsters.forEach(monster => {
                    // Move randomly every few frames
                    if (Math.random() < 0.02) {
                        const directions = [
                            { dx: 0, dy: -1 },
                            { dx: 1, dy: 0 },
                            { dx: 0, dy: 1 },
                            { dx: -1, dy: 0 }
                        ];
                        
                        const validMoves = directions.filter(dir => {
                            const nx = monster.x + dir.dx;
                            const ny = monster.y + dir.dy;
                            
                            if (nx < 1 || nx >= this.size-1 || ny < 1 || ny >= this.size-1) return false;
                            
                            // Check if path is open
                            if (dir.dx === 1 && this.maze[monster.y][monster.x].walls.right) return false;
                            if (dir.dx === -1 && this.maze[monster.y][monster.x].walls.left) return false;
                            if (dir.dy === 1 && this.maze[monster.y][monster.x].walls.bottom) return false;
                            if (dir.dy === -1 && this.maze[monster.y][monster.x].walls.top) return false;
                            
                            return true;
                        });
                        
                        if (validMoves.length > 0) {
                            const move = validMoves[Math.floor(Math.random() * validMoves.length)];
                            monster.x += move.dx;
                            monster.y += move.dy;
                        }
                    }
                });
                
                this.drawMonsters();
                this.checkMonsterCollision();
            }
            
            checkMonsterCollision() {
                for (const monster of this.monsters) {
                    if (monster.x === this.player.x && monster.y === this.player.y) {
                        this.gameOver();
                    }
                }
            }
            
            // === Solution Path ===
            showSolutionPath() {
                if (this.solutionGroup) this.solutionGroup.remove();
                this.solutionGroup = this.svg.group();
                
                // Simple BFS to find solution
                const queue = [{ x: 1, y: 1, path: [] }];
                const visited = new Set();
                visited.add('1,1');
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    
                    if (current.x === this.size-2 && current.y === this.size-2) {
                        this.solutionPath = current.path.concat([{ x: current.x, y: current.y }]);
                        break;
                    }
                    
                    const neighbors = [
                        { x: current.x + 1, y: current.y },
                        { x: current.x - 1, y: current.y },
                        { x: current.x, y: current.y + 1 },
                        { x: current.x, y: current.y - 1 }
                    ];
                    
                    for (const neighbor of neighbors) {
                        if (neighbor.x < 1 || neighbor.x >= this.size-1 || 
                            neighbor.y < 1 || neighbor.y >= this.size-1) continue;
                        
                        const key = `${neighbor.x},${neighbor.y}`;
                        if (visited.has(key)) continue;
                        
                        // Check if path is open
                        let canMove = true;
                        if (neighbor.x > current.x && this.maze[current.y][current.x].walls.right) canMove = false;
                        if (neighbor.x < current.x && this.maze[current.y][current.x].walls.left) canMove = false;
                        if (neighbor.y > current.y && this.maze[current.y][current.x].walls.bottom) canMove = false;
                        if (neighbor.y < current.y && this.maze[current.y][current.x].walls.top) canMove = false;
                        
                        if (canMove) {
                            visited.add(key);
                            queue.push({ 
                                x: neighbor.x, 
                                y: neighbor.y, 
                                path: current.path.concat([{ x: current.x, y: current.y }])
                            });
                        }
                    }
                }
                
                // Draw solution path
                const offsetX = (900 - this.size * this.cellSize) / 2;
                const offsetY = (700 - this.size * this.cellSize) / 2;
                
                this.solutionPath.forEach((point, i) => {
                    if (i < this.solutionPath.length - 1) {
                        const next = this.solutionPath[i + 1];
                        const x1 = offsetX + point.x * this.cellSize + this.cellSize/2;
                        const y1 = offsetY + point.y * this.cellSize + this.cellSize/2;
                        const x2 = offsetX + next.x * this.cellSize + this.cellSize/2;
                        const y2 = offsetY + next.y * this.cellSize + this.cellSize/2;
                        
                        this.solutionGroup.line(x1, y1, x2, y2)
                            .stroke({ color: '#ffd700', width: 6, opacity: 0.7 })
                            .animate(1000).stroke({ opacity: 1 });
                    }
                });
            }
            
            // === Game States ===
            win() {
                document.getElementById('winMessage').classList.add('show');
                setTimeout(() => {
                    document.getElementById('winMessage').classList.remove('show');
                    this.newMaze();
                }, 4000);
            }
            
            gameOver() {
                alert('Oh no! The monster caught you!\nTry again!');
                this.newMaze();
            }
            
            newMaze() {
                this.init();
            }
            
            // === Controls ===
            setupControls() {
                document.getElementById('showSolution').addEventListener('click', () => {
                    if (!this.showSolution) {
                        this.showSolutionPath();
                        this.showSolution = true;
                    }
                });
                
                document.getElementById('newMaze').addEventListener('click', () => {
                    this.newMaze();
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    switch(e.key) {
                        case 'ArrowUp':
                        case 'w':
                            this.movePlayer(0, -1);
                            break;
                        case 'ArrowDown':
                        case 's':
                            this.movePlayer(0, 1);
                            break;
                        case 'ArrowLeft':
                        case 'a':
                            this.movePlayer(-1, 0);
                            break;
                        case 'ArrowRight':
                        case 'd':
                            this.movePlayer(1, 0);
                            break;
                    }
                });
            }
            
            // === Game Loop ===
            gameLoop() {
                this.moveMonsters();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Start the game when page loads
        window.onload = () => {
            new MazeGame();
        };
    </script>
</body>
</html>