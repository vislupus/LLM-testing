<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cute Maze Adventure - Kindergarten Game</title>
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2.0/dist/svg.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Segoe UI', cursive, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .game-header {
            text-align: center;
            color: #5a67d8;
        }

        .game-title {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .game-instructions {
            font-size: 14px;
            color: #718096;
            margin-bottom: 10px;
        }

        #maze-svg {
            border: 4px solid #5a67d8;
            border-radius: 12px;
            background: linear-gradient(45deg, #fef5e7 0%, #fdebd0 100%);
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .game-btn {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(72, 187, 120, 0.3);
        }

        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(72, 187, 120, 0.4);
        }

        .game-btn.solution {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            box-shadow: 0 4px 15px rgba(66, 153, 225, 0.3);
        }

        .game-btn.solution:hover {
            box-shadow: 0 6px 20px rgba(66, 153, 225, 0.4);
        }

        .game-status {
            font-size: 18px;
            color: #2d3748;
            font-weight: bold;
            text-align: center;
            min-height: 30px;
        }

        .game-over-message {
            color: #e53e3e;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .legend {
            display: flex;
            gap: 20px;
            font-size: 14px;
            color: #4a5568;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">ðŸŒŸ Cute Maze Adventure ðŸŒŸ</h1>
            <p class="game-instructions">Use arrow keys to move the hero to the goal! Avoid the monsters!</p>
        </div>
        
        <svg id="maze-svg"></svg>
        
        <div class="game-status" id="game-status">Find your way to the rainbow star! ðŸŒˆ</div>
        
        <div class="controls">
            <button class="game-btn" onclick="game.newMaze()">ðŸŽ² New Maze</button>
            <button class="game-btn solution" onclick="game.showSolution()">ðŸ’¡ Show Solution</button>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-icon" style="background: #48bb78;"></div>
                <span>Hero (You)</span>
            </div>
            <div class="legend-item">
                <div class="legend-icon" style="background: #f56565;"></div>
                <span>Monsters</span>
            </div>
            <div class="legend-item">
                <div class="legend-icon" style="background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffeaa7);"></div>
                <span>Goal</span>
            </div>
        </div>
    </div>

    <script>
        // Maze Game for Kindergarten Children
        // This game creates a fun, educational maze experience with cute characters
        
        class MazeGame {
            constructor() {
                // Game configuration
                this.mazeSize = 20; // 20x20 maze
                this.cellSize = 25; // Size of each cell in pixels
                this.svg = null;
                this.maze = [];
                this.solution = [];
                
                // Hero properties
                this.hero = {
                    x: 0,
                    y: 0,
                    element: null,
                    trail: [] // Trail of circles left by hero
                };
                
                // Goal position
                this.goal = {
                    x: 19,
                    y: 19,
                    element: null
                };
                
                // Monsters array
                this.monsters = [];
                this.monsterMoveTimer = 0;
                
                // Game state
                this.gameOver = false;
                this.solutionVisible = false;
                this.trailTimer = 0;
                
                // Initialize the game
                this.init();
            }
            
            // Initialize the game
            init() {
                // Create SVG canvas
                this.svg = SVG('#maze-svg')
                    .size(this.mazeSize * this.cellSize, this.mazeSize * this.cellSize);
                
                // Generate maze and find solution
                this.generateMaze();
                this.findSolution();
                
                // Draw maze
                this.drawMaze();
                
                // Place game elements
                this.placeHero();
                this.placeGoal();
                this.placeMonsters();
                
                // Setup keyboard controls
                this.setupControls();
                
                // Start game loop
                this.startGameLoop();
            }
            
            // Generate maze using recursive backtracking algorithm
            generateMaze() {
                // Initialize maze with all walls
                this.maze = [];
                for (let y = 0; y < this.mazeSize; y++) {
                    this.maze[y] = [];
                    for (let x = 0; x < this.mazeSize; x++) {
                        this.maze[y][x] = {
                            x: x,
                            y: y,
                            walls: { top: true, right: true, bottom: true, left: true },
                            visited: false
                        };
                    }
                }
                
                // Recursive backtracking to create maze
                const stack = [];
                const start = this.maze[0][0];
                start.visited = true;
                stack.push(start);
                
                while (stack.length > 0) {
                    const current = stack[stack.length - 1];
                    const neighbors = this.getUnvisitedNeighbors(current);
                    
                    if (neighbors.length > 0) {
                        // Choose random neighbor
                        const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                        
                        // Remove wall between current and next
                        this.removeWall(current, next);
                        
                        // Mark next as visited and add to stack
                        next.visited = true;
                        stack.push(next);
                    } else {
                        // Backtrack
                        stack.pop();
                    }
                }
                
                // Clear visited flags
                for (let y = 0; y < this.mazeSize; y++) {
                    for (let x = 0; x < this.mazeSize; x++) {
                        this.maze[y][x].visited = false;
                    }
                }
            }
            
            // Get unvisited neighbors for maze generation
            getUnvisitedNeighbors(cell) {
                const neighbors = [];
                const { x, y } = cell;
                
                // Check all four directions
                if (y > 0 && !this.maze[y - 1][x].visited) {
                    neighbors.push(this.maze[y - 1][x]);
                }
                if (x < this.mazeSize - 1 && !this.maze[y][x + 1].visited) {
                    neighbors.push(this.maze[y][x + 1]);
                }
                if (y < this.mazeSize - 1 && !this.maze[y + 1][x].visited) {
                    neighbors.push(this.maze[y + 1][x]);
                }
                if (x > 0 && !this.maze[y][x - 1].visited) {
                    neighbors.push(this.maze[y][x - 1]);
                }
                
                return neighbors;
            }
            
            // Remove wall between two cells
            removeWall(cell1, cell2) {
                const dx = cell1.x - cell2.x;
                const dy = cell1.y - cell2.y;
                
                if (dx === 1) {
                    cell1.walls.left = false;
                    cell2.walls.right = false;
                } else if (dx === -1) {
                    cell1.walls.right = false;
                    cell2.walls.left = false;
                } else if (dy === 1) {
                    cell1.walls.top = false;
                    cell2.walls.bottom = false;
                } else if (dy === -1) {
                    cell1.walls.bottom = false;
                    cell2.walls.top = false;
                }
            }
            
            // Draw the maze walls
            drawMaze() {
                for (let y = 0; y < this.mazeSize; y++) {
                    for (let x = 0; x < this.mazeSize; x++) {
                        const cell = this.maze[y][x];
                        const px = x * this.cellSize;
                        const py = y * this.cellSize;
                        
                        // Draw walls
                        if (cell.walls.top) {
                            this.svg.line(px, py, px + this.cellSize, py)
                                .stroke({ color: '#5a67d8', width: 3 });
                        }
                        if (cell.walls.right) {
                            this.svg.line(px + this.cellSize, py, px + this.cellSize, py + this.cellSize)
                                .stroke({ color: '#5a67d8', width: 3 });
                        }
                        if (cell.walls.bottom) {
                            this.svg.line(px, py + this.cellSize, px + this.cellSize, py + this.cellSize)
                                .stroke({ color: '#5a67d8', width: 3 });
                        }
                        if (cell.walls.left) {
                            this.svg.line(px, py, px, py + this.cellSize)
                                .stroke({ color: '#5a67d8', width: 3 });
                        }
                    }
                }
            }
            
            // Place hero at starting position
            placeHero() {
                const x = this.hero.x * this.cellSize + this.cellSize / 2;
                const y = this.hero.y * this.cellSize + this.cellSize / 2;
                
                // Create cute hero (green circle with smiley face)
                this.hero.element = this.svg.group();
                
                // Hero body
                const body = this.svg.circle(x, y, this.cellSize * 0.35)
                    .fill('#48bb78')
                    .stroke('#2f855a')
                    .strokeWidth(2);
                
                // Hero eyes
                const leftEye = this.svg.circle(x - 4, y - 2, 3)
                    .fill('white');
                const rightEye = this.svg.circle(x + 4, y - 2, 3)
                    .fill('white');
                const leftPupil = this.svg.circle(x - 4, y - 2, 1.5)
                    .fill('black');
                const rightPupil = this.svg.circle(x + 4, y - 2, 1.5)
                    .fill('black');
                
                // Hero smile
                const smile = this.svg.path(`M ${x - 5},${y + 3} Q ${x},${y + 6} ${x + 5},${y + 3}`)
                    .fill('none')
                    .stroke('#2f855a')
                    .strokeWidth(1.5);
                
                this.hero.element.add(body);
                this.hero.element.add(leftEye);
                this.hero.element.add(rightEye);
                this.hero.element.add(leftPupil);
                this.hero.element.add(rightPupil);
                this.hero.element.add(smile);
            }
            
            // Place goal at end position
            placeGoal() {
                const x = this.goal.x * this.cellSize + this.cellSize / 2;
                const y = this.goal.y * this.cellSize + this.cellSize / 2;
                
                // Create rainbow star goal
                this.goal.element = this.svg.group();
                
                // Star shape
                const star = this.svg.polygon(this.getStarPoints(x, y, this.cellSize * 0.4))
                    .fill('url(#rainbow)')
                    .stroke('#fbbf24')
                    .strokeWidth(2);
                
                // Add gradient definition
                const defs = this.svg.defs();
                const gradient = this.svg.gradient('linear', function(add) {
                    add.stop(0, '#ff6b6b');
                    add.stop(0.2, '#4ecdc4');
                    add.stop(0.4, '#45b7d1');
                    add.stop(0.6, '#96ceb4');
                    add.stop(0.8, '#ffeaa7');
                    add.stop(1, '#ff6b6b');
                });
                gradient.attr('id', 'rainbow');
                
                this.goal.element.add(star);
            }
            
            // Get star points for drawing
            getStarPoints(cx, cy, radius) {
                const points = [];
                const spikes = 5;
                const step = Math.PI / spikes;
                
                for (let i = 0; i < spikes * 2; i++) {
                    const angle = i * step - Math.PI / 2;
                    const r = i % 2 === 0 ? radius : radius * 0.5;
                    const x = cx + Math.cos(angle) * r;
                    const y = cy + Math.sin(angle) * r;
                    points.push(`${x},${y}`);
                }
                
                return points.join(' ');
            }
            
            // Place monsters in the maze
            placeMonsters() {
                const monsterCount = 3; // Number of monsters
                
                for (let i = 0; i < monsterCount; i++) {
                    // Find random empty position
                    let x, y;
                    do {
                        x = Math.floor(Math.random() * this.mazeSize);
                        y = Math.floor(Math.random() * this.mazeSize);
                    } while (
                        (x === this.hero.x && y === this.hero.y) ||
                        (x === this.goal.x && y === this.goal.y) ||
                        (x === 0 && y === 0) // Avoid start
                    );
                    
                    const px = x * this.cellSize + this.cellSize / 2;
                    const py = y * this.cellSize + this.cellSize / 2;
                    
                    // Create cute monster (red circle with grumpy face)
                    const monster = {
                        x: x,
                        y: y,
                        element: null,
                        direction: Math.floor(Math.random() * 4) // 0: up, 1: right, 2: down, 3: left
                    };
                    
                    const monsterGroup = this.svg.group();
                    
                    // Monster body
                    const body = this.svg.circle(px, py, this.cellSize * 0.35)
                        .fill('#f56565')
                        .stroke('#c53030')
                        .strokeWidth(2);
                    
                    // Monster eyes (angry)
                    const leftEye = this.svg.circle(px - 4, py - 2, 3)
                        .fill('white');
                    const rightEye = this.svg.circle(px + 4, py - 2, 3)
                        .fill('white');
                    const leftPupil = this.svg.circle(px - 4, y - 2, 1.5)
                        .fill('black');
                    const rightPupil = this.svg.circle(px + 4, y - 2, 1.5)
                        .fill('black');
                    
                    // Angry eyebrows
                    const leftBrow = this.svg.line(px - 6, py - 5, px - 2, py - 3)
                        .stroke('#c53030')
                        .strokeWidth(2);
                    const rightBrow = this.svg.line(px + 6, py - 5, px + 2, py - 3)
                        .stroke('#c53030')
                        .strokeWidth(2);
                    
                    // Frown
                    const frown = this.svg.path(`M ${x - 5},${y + 5} Q ${x},${y + 2} ${x + 5},${y + 5}`)
                        .fill('none')
                        .stroke('#c53030')
                        .strokeWidth(1.5);
                    
                    monsterGroup.add(body);
                    monsterGroup.add(leftEye);
                    monsterGroup.add(rightEye);
                    monsterGroup.add(leftPupil);
                    monsterGroup.add(rightPupil);
                    monsterGroup.add(leftBrow);
                    monsterGroup.add(rightBrow);
                    monsterGroup.add(frown);
                    
                    monster.element = monsterGroup;
                    this.monsters.push(monster);
                }
            }
            
            // Setup keyboard controls
            setupControls() {
                document.addEventListener('keydown', (e) => {
                    if (this.gameOver) return;
                    
                    let newX = this.hero.x;
                    let newY = this.hero.y;
                    
                    // Handle arrow keys
                    switch(e.key) {
                        case 'ArrowUp':
                            newY--;
                            e.preventDefault();
                            break;
                        case 'ArrowDown':
                            newY++;
                            e.preventDefault();
                            break;
                        case 'ArrowLeft':
                            newX--;
                            e.preventDefault();
                            break;
                        case 'ArrowRight':
                            newX++;
                            e.preventDefault();
                            break;
                        default:
                            return;
                    }
                    
                    // Check if move is valid
                    if (this.canMove(this.hero.x, this.hero.y, newX, newY)) {
                        this.moveHero(newX, newY);
                    }
                });
            }
            
            // Check if hero can move to new position
            canMove(fromX, fromY, toX, toY) {
                // Check boundaries
                if (toX < 0 || toX >= this.mazeSize || toY < 0 || toY >= this.mazeSize) {
                    return false;
                }
                
                // Check walls
                const currentCell = this.maze[fromY][fromX];
                
                if (toX > fromX && currentCell.walls.right) return false;
                if (toX < fromX && currentCell.walls.left) return false;
                if (toY > fromY && currentCell.walls.bottom) return false;
                if (toY < fromY && currentCell.walls.top) return false;
                
                return true;
            }
            
            // Move hero to new position
            moveHero(newX, newY) {
                this.hero.x = newX;
                this.hero.y = newY;
                
                // Update hero position
                const px = newX * this.cellSize + this.cellSize / 2;
                const py = newY * this.cellSize + this.cellSize / 2;
                this.hero.element.animate(200).move(px, py);
                
                // Check if hero reached goal
                if (newX === this.goal.x && newY === this.goal.y) {
                    this.win();
                }
                
                // Check if hero caught by monster
                for (const monster of this.monsters) {
                    if (monster.x === newX && monster.y === newY) {
                        this.lose();
                        return;
                    }
                }
            }
            
            // Leave trail of circles
            leaveTrail() {
                const px = this.hero.x * this.cellSize + this.cellSize / 2;
                const py = this.hero.y * this.cellSize + this.cellSize / 2;
                
                // Create small circle trail
                const trail = this.svg.circle(px, py, 3)
                    .fill('#68d391')
                    .opacity(0.6);
                
                this.hero.trail.push(trail);
                
                // Fade and remove old trails
                if (this.hero.trail.length > 10) {
                    const oldTrail = this.hero.trail.shift();
                    oldTrail.animate(1000).opacity(0).after(() => oldTrail.remove());
                }
            }
            
            // Move monsters
            moveMonsters() {
                for (const monster of this.monsters) {
                    // Try to move in current direction
                    let newX = monster.x;
                    let newY = monster.y;
                    
                    switch(monster.direction) {
                        case 0: newY--; break; // up
                        case 1: newX++; break; // right
                        case 2: newY++; break; // down
                        case 3: newX--; break; // left
                    }
                    
                    // Check if move is valid
                    if (this.canMove(monster.x, monster.y, newX, newY)) {
                        monster.x = newX;
                        monster.y = newY;
                        
                        // Update monster position
                        const px = newX * this.cellSize + this.cellSize / 2;
                        const py = newY * this.cellSize + this.cellSize / 2;
                        monster.element.animate(300).move(px, py);
                        
                        // Check if monster caught hero
                        if (monster.x === this.hero.x && monster.y === this.hero.y) {
                            this.lose();
                            return;
                        }
                    } else {
                        // Change direction if can't move
                        monster.direction = Math.floor(Math.random() * 4);
                    }
                }
            }
            
            // Find solution using BFS (Breadth-First Search)
            findSolution() {
                const start = { x: 0, y: 0 };
                const end = { x: this.goal.x, y: this.goal.y };
                const queue = [start];
                const visited = new Set();
                const parent = new Map();
                
                visited.add(`${start.x},${start.y}`);
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    
                    if (current.x === end.x && current.y === end.y) {
                        // Reconstruct path
                        const path = [];
                        let node = end;
                        
                        while (parent.has(`${node.x},${node.y}`)) {
                            path.unshift(node);
                            node = parent.get(`${node.x},${node.y}`);
                        }
                        
                        this.solution = path;
                        return;
                    }
                    
                    // Check all neighbors
                    const neighbors = [
                        { x: current.x, y: current.y - 1 },
                        { x: current.x + 1, y: current.y },
                        { x: current.x, y: current.y + 1 },
                        { x: current.x - 1, y: current.y }
                    ];
                    
                    for (const neighbor of neighbors) {
                        const key = `${neighbor.x},${neighbor.y}`;
                        
                        if (!visited.has(key) && 
                            neighbor.x >= 0 && neighbor.x < this.mazeSize &&
                            neighbor.y >= 0 && neighbor.y < this.mazeSize &&
                            this.canMove(current.x, current.y, neighbor.x, neighbor.y)) {
                            
                            visited.add(key);
                            parent.set(key, current);
                            queue.push(neighbor);
                        }
                    }
                }
            }
            
            // Show solution path
            showSolution() {
                if (this.solutionVisible) {
                    this.hideSolution();
                    return;
                }
                
                this.solutionVisible = true;
                
                // Draw solution path
                for (let i = 0; i < this.solution.length; i++) {
                    const cell = this.solution[i];
                    const px = cell.x * this.cellSize + this.cellSize / 2;
                    const py = cell.y * this.cellSize + this.cellSize / 2;
                    
                    setTimeout(() => {
                        const dot = this.svg.circle(px, py, 5)
                            .fill('#fbbf24')
                            .opacity(0.8);
                        
                        if (i > 0) {
                            const prevCell = this.solution[i - 1];
                            const prevX = prevCell.x * this.cellSize + this.cellSize / 2;
                            const prevY = prevCell.y * this.cellSize + this.cellSize / 2;
                            
                            this.svg.line(prevX, prevY, px, py)
                                .stroke('#fbbf24')
                                .strokeWidth(3)
                                .opacity(0.6);
                        }
                    }, i * 50);
                }
            }
            
            // Hide solution path
            hideSolution() {
                this.solutionVisible = false;
                // Redraw maze to clear solution
                this.svg.clear();
                this.drawMaze();
                this.placeHero();
                this.placeGoal();
                this.placeMonsters();
            }
            
            // Handle win condition
            win() {
                this.gameOver = true;
                document.getElementById('game-status').innerHTML = 
                    'ðŸŽ‰ Congratulations! You found the rainbow star! ðŸŒˆ';
                document.getElementById('game-status').className = 'game-status';
            }
            
            // Handle lose condition
            lose() {
                this.gameOver = true;
                document.getElementById('game-status').innerHTML = 
                    'ðŸ˜¢ Oh no! A monster caught you! Try again!';
                document.getElementById('game-status').className = 'game-status game-over-message';
            }
            
            // Start game loop for animations and monster movement
            startGameLoop() {
                setInterval(() => {
                    if (!this.gameOver) {
                        // Move monsters every 500ms
                        this.monsterMoveTimer++;
                        if (this.monsterMoveTimer >= 5) {
                            this.moveMonsters();
                            this.monsterMoveTimer = 0;
                        }
                        
                        // Leave trail every 200ms
                        this.trailTimer++;
                        if (this.trailTimer >= 2) {
                            this.leaveTrail();
                            this.trailTimer = 0;
                        }
                    }
                }, 100);
            }
            
            // Create new maze
            newMaze() {
                // Clear SVG
                this.svg.clear();
                
                // Reset game state
                this.hero.x = 0;
                this.hero.y = 0;
                this.hero.trail = [];
                this.monsters = [];
                this.gameOver = false;
                this.solutionVisible = false;
                this.monsterMoveTimer = 0;
                this.trailTimer = 0;
                
                // Reset status
                document.getElementById('game-status').innerHTML = 
                    'Find your way to the rainbow star! ðŸŒˆ';
                document.getElementById('game-status').className = 'game-status';
                
                // Generate new maze
                this.generateMaze();
                this.findSolution();
                this.drawMaze();
                this.placeHero();
                this.placeGoal();
                this.placeMonsters();
            }
        }
        
        // Create game instance when page loads
        let game;
        
        window.addEventListener('DOMContentLoaded', () => {
            game = new MazeGame();
        });
    </script>
</body>
</html>