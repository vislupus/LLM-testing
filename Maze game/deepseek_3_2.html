<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kindergarten Maze Adventure</title>
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2.2/dist/svg.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #ffccd5 0%, #c9e4ff 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 800px;
        }

        h1 {
            font-size: 2.8rem;
            color: #ff6b6b;
            margin-bottom: 10px;
            text-shadow: 3px 3px 0 #ffd166;
            letter-spacing: 1px;
        }

        .subtitle {
            font-size: 1.3rem;
            color: #06d6a0;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 900px;
        }

        .maze-container {
            position: relative;
            background-color: #ffebee;
            border-radius: 20px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border: 8px solid #ffd166;
        }

        #maze-svg {
            width: 600px;
            height: 600px;
            border-radius: 10px;
            background-color: #f8f9fa;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            width: 100%;
            max-width: 800px;
        }

        .btn {
            padding: 15px 25px;
            font-size: 1.2rem;
            font-weight: bold;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
        }

        .btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        #show-solution-btn {
            background: linear-gradient(135deg, #06d6a0, #118ab2);
        }

        #restart-btn {
            background: linear-gradient(135deg, #ffd166, #ff9e6d);
        }

        #new-maze-btn {
            background: linear-gradient(135deg, #ff6b6b, #ef476f);
        }

        .instructions {
            background-color: white;
            border-radius: 20px;
            padding: 20px;
            width: 100%;
            max-width: 800px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            border: 5px solid #ffd166;
        }

        .instructions h2 {
            color: #118ab2;
            margin-bottom: 15px;
            font-size: 1.8rem;
        }

        .instructions-content {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .instruction-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 10px;
        }

        .instruction-icon {
            font-size: 2rem;
            min-width: 50px;
            text-align: center;
        }

        .instruction-text {
            color: #333;
            font-size: 1.1rem;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px;
            padding: 15px;
            background-color: white;
            border-radius: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            border: 5px solid #ffd166;
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            font-size: 1.2rem;
            color: #118ab2;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 2rem;
            color: #ff6b6b;
            font-weight: bold;
        }

        .keyboard-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 10px;
            width: 200px;
            height: 200px;
            margin: 20px auto;
        }

        .key {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #118ab2;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 15px;
            box-shadow: 0 4px 0 #0a5a7a;
            user-select: none;
        }

        .key.up {
            grid-column: 2;
            grid-row: 1;
        }

        .key.left {
            grid-column: 1;
            grid-row: 2;
        }

        .key.right {
            grid-column: 3;
            grid-row: 2;
        }

        .key.down {
            grid-column: 2;
            grid-row: 3;
        }

        .key.center {
            grid-column: 2;
            grid-row: 2;
            background-color: #06d6a0;
            box-shadow: 0 4px 0 #049c75;
        }

        .game-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 30px;
            text-align: center;
            z-index: 1000;
            border: 8px solid #ffd166;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.3);
            display: none;
            max-width: 500px;
            width: 90%;
        }

        .message-title {
            font-size: 3rem;
            color: #ff6b6b;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0 #ffd166;
        }

        .message-text {
            font-size: 1.5rem;
            margin-bottom: 30px;
            color: #333;
            line-height: 1.5;
        }

        .celebration {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 500;
            display: none;
        }

        @media (max-width: 700px) {
            #maze-svg {
                width: 95vw;
                height: 95vw;
                max-width: 500px;
                max-height: 500px;
            }
            
            .instructions-content {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2.2rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Kindergarten Maze Adventure</h1>
        <p class="subtitle">Help the friendly hero find the treasure while avoiding the silly monsters!</p>
    </div>

    <div class="game-container">
        <div class="game-info">
            <div class="info-item">
                <div class="info-label">Steps Taken</div>
                <div class="info-value" id="steps-count">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">Monsters</div>
                <div class="info-value" id="monsters-count">3</div>
            </div>
            <div class="info-item">
                <div class="info-label">Trail Length</div>
                <div class="info-value" id="trail-count">0</div>
            </div>
        </div>

        <div class="maze-container">
            <div id="maze-svg"></div>
        </div>

        <div class="controls">
            <button id="show-solution-btn" class="btn">
                <span style="font-size: 1.5rem;">üîç</span> Show Solution Path
            </button>
            <button id="restart-btn" class="btn">
                <span style="font-size: 1.5rem;">üîÑ</span> Restart Game
            </button>
            <button id="new-maze-btn" class="btn">
                <span style="font-size: 1.5rem;">üé≤</span> New Maze
            </button>
        </div>

        <div class="instructions">
            <h2>How to Play</h2>
            <div class="instructions-content">
                <div class="instruction-item">
                    <div class="instruction-icon">üèÉ</div>
                    <div class="instruction-text">Use arrow keys to move the hero</div>
                </div>
                <div class="instruction-item">
                    <div class="instruction-icon">üéØ</div>
                    <div class="instruction-text">Find the treasure at the exit</div>
                </div>
                <div class="instruction-item">
                    <div class="instruction-icon">üëæ</div>
                    <div class="instruction-text">Avoid the silly monsters</div>
                </div>
                <div class="instruction-item">
                    <div class="instruction-icon">üîÑ</div>
                    <div class="instruction-text">Hero leaves a colorful trail</div>
                </div>
            </div>
        </div>

        <div class="instructions">
            <h2>Keyboard Controls</h2>
            <div class="keyboard-controls">
                <div class="key up">‚Üë</div>
                <div class="key left">‚Üê</div>
                <div class="key center">üèÉ</div>
                <div class="key right">‚Üí</div>
                <div class="key down">‚Üì</div>
            </div>
        </div>
    </div>

    <div class="game-message" id="win-message">
        <div class="message-title">You Win! üéâ</div>
        <div class="message-text">You found the treasure! Great job navigating the maze!</div>
        <button id="play-again-btn" class="btn" style="background: linear-gradient(135deg, #06d6a0, #118ab2);">
            <span style="font-size: 1.5rem;">‚ú®</span> Play Again
        </button>
    </div>

    <div class="game-message" id="lose-message">
        <div class="message-title">Oh No! üëæ</div>
        <div class="message-text">A silly monster caught you! Try again to find the treasure!</div>
        <button id="try-again-btn" class="btn" style="background: linear-gradient(135deg, #ff6b6b, #ef476f);">
            <span style="font-size: 1.5rem;">üîÑ</span> Try Again
        </button>
    </div>

    <div class="celebration" id="celebration"></div>

    <script>
        // Game State
        const gameState = {
            maze: null,
            hero: null,
            monsters: [],
            trail: [],
            treasures: [],
            solutionPath: [],
            cells: [],
            heroPosition: { x: 0, y: 0 },
            exitPosition: { x: 0, y: 0 },
            isGameActive: true,
            steps: 0,
            trailInterval: null,
            monsterInterval: null,
            cellSize: 0,
            mazeSize: 20, // 20x20 maze
            numMonsters: 3,
            showSolution: false
        };

        // Colors for child-friendly design
        const colors = {
            wall: '#ff9e6d',
            path: '#f8f9fa',
            hero: '#ff6b6b',
            monster: '#118ab2',
            treasure: '#ffd166',
            trail: ['#06d6a0', '#ff9e6d', '#ff6b6b', '#118ab2', '#9d4edd'],
            solution: 'rgba(255, 107, 107, 0.3)'
        };

        // Initialize the game
        function initGame() {
            // Create SVG drawing area
            const mazeSvg = SVG().addTo('#maze-svg').size('100%', '100%');
            gameState.maze = mazeSvg;
            
            // Calculate cell size based on maze size
            gameState.cellSize = Math.min(600, window.innerWidth * 0.8) / gameState.mazeSize;
            
            // Generate a random maze
            generateMaze();
            
            // Place hero at start (top-left)
            gameState.heroPosition = { x: 0, y: 0 };
            createHero();
            
            // Place exit at bottom-right
            gameState.exitPosition = { x: gameState.mazeSize - 1, y: gameState.mazeSize - 1 };
            createTreasure();
            
            // Create monsters
            createMonsters();
            
            // Start trail dropping
            startTrail();
            
            // Start monster movement
            startMonsterMovement();
            
            // Set up event listeners
            setupEventListeners();
            
            // Update UI
            updateUI();
            
            // Focus on window for keyboard events
            window.focus();
        }

        // Generate a random 20x20 maze using Recursive Backtracking algorithm
        function generateMaze() {
            // Initialize all cells as walls
            gameState.cells = [];
            for (let y = 0; y < gameState.mazeSize; y++) {
                gameState.cells[y] = [];
                for (let x = 0; x < gameState.mazeSize; x++) {
                    gameState.cells[y][x] = {
                        x: x,
                        y: y,
                        walls: { top: true, right: true, bottom: true, left: true },
                        visited: false
                    };
                }
            }
            
            // Start from top-left corner
            const startCell = gameState.cells[0][0];
            startCell.visited = true;
            
            // Use stack for backtracking
            const stack = [startCell];
            
            // Directions: up, right, down, left
            const directions = [
                { dx: 0, dy: -1, wall: 'top', opposite: 'bottom' },
                { dx: 1, dy: 0, wall: 'right', opposite: 'left' },
                { dx: 0, dy: 1, wall: 'bottom', opposite: 'top' },
                { dx: -1, dy: 0, wall: 'left', opposite: 'right' }
            ];
            
            // Generate maze paths
            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                
                // Find unvisited neighbors
                const neighbors = [];
                for (const dir of directions) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    
                    if (nx >= 0 && nx < gameState.mazeSize && ny >= 0 && ny < gameState.mazeSize) {
                        const neighbor = gameState.cells[ny][nx];
                        if (!neighbor.visited) {
                            neighbors.push({ neighbor, dir });
                        }
                    }
                }
                
                if (neighbors.length > 0) {
                    // Choose a random neighbor
                    const { neighbor, dir } = neighbors[Math.floor(Math.random() * neighbors.length)];
                    
                    // Remove walls between current and neighbor
                    current.walls[dir.wall] = false;
                    neighbor.walls[dir.opposite] = false;
                    
                    // Mark neighbor as visited
                    neighbor.visited = true;
                    
                    // Add to stack
                    stack.push(neighbor);
                } else {
                    // Backtrack
                    stack.pop();
                }
            }
            
            // Ensure there's a path to the exit (bottom-right)
            // We'll use BFS to find a path and break walls if needed
            ensurePathToExit();
            
            // Draw the maze
            drawMaze();
            
            // Calculate solution path using BFS
            calculateSolutionPath();
        }

        // Ensure there's a valid path from start to exit using BFS
        function ensurePathToExit() {
            // Reset visited status
            for (let y = 0; y < gameState.mazeSize; y++) {
                for (let x = 0; x < gameState.mazeSize; x++) {
                    gameState.cells[y][x].visited = false;
                }
            }
            
            // BFS to find path
            const queue = [{ x: 0, y: 0, path: [] }];
            gameState.cells[0][0].visited = true;
            
            const dirs = [
                { dx: 0, dy: -1, wall: 'top' },
                { dx: 1, dy: 0, wall: 'right' },
                { dx: 0, dy: 1, wall: 'bottom' },
                { dx: -1, dy: 0, wall: 'left' }
            ];
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                // Check if we reached the exit
                if (current.x === gameState.mazeSize - 1 && current.y === gameState.mazeSize - 1) {
                    // Path exists, no need to break walls
                    return;
                }
                
                // Check all directions
                for (const dir of dirs) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    
                    // Check bounds
                    if (nx >= 0 && nx < gameState.mazeSize && ny >= 0 && ny < gameState.mazeSize) {
                        // Check if there's no wall in this direction
                        const cell = gameState.cells[current.y][current.x];
                        if (!cell.walls[dir.wall]) {
                            const neighbor = gameState.cells[ny][nx];
                            if (!neighbor.visited) {
                                neighbor.visited = true;
                                queue.push({ x: nx, y: ny, path: [...current.path, { x: nx, y: ny }] });
                            }
                        }
                    }
                }
            }
            
            // If we get here, there's no path to exit
            // Break a wall to create a path (break wall between last cell and exit)
            const lastCell = gameState.cells[gameState.mazeSize - 2][gameState.mazeSize - 1];
            lastCell.walls.bottom = false;
            
            const exitCell = gameState.cells[gameState.mazeSize - 1][gameState.mazeSize - 1];
            exitCell.walls.top = false;
        }

        // Draw the maze
        function drawMaze() {
            // Clear the maze
            gameState.maze.clear();
            
            // Draw each cell
            for (let y = 0; y < gameState.mazeSize; y++) {
                for (let x = 0; x < gameState.mazeSize; x++) {
                    const cell = gameState.cells[y][x];
                    const cellX = x * gameState.cellSize;
                    const cellY = y * gameState.cellSize;
                    
                    // Draw cell background (path)
                    gameState.maze.rect(gameState.cellSize, gameState.cellSize)
                        .move(cellX, cellY)
                        .fill(colors.path)
                        .stroke({ width: 0 });
                    
                    // Draw walls
                    if (cell.walls.top) {
                        gameState.maze.line(cellX, cellY, cellX + gameState.cellSize, cellY)
                            .stroke({ width: 4, color: colors.wall });
                    }
                    
                    if (cell.walls.right) {
                        gameState.maze.line(cellX + gameState.cellSize, cellY, cellX + gameState.cellSize, cellY + gameState.cellSize)
                            .stroke({ width: 4, color: colors.wall });
                    }
                    
                    if (cell.walls.bottom) {
                        gameState.maze.line(cellX, cellY + gameState.cellSize, cellX + gameState.cellSize, cellY + gameState.cellSize)
                            .stroke({ width: 4, color: colors.wall });
                    }
                    
                    if (cell.walls.left) {
                        gameState.maze.line(cellX, cellY, cellX, cellY + gameState.cellSize)
                            .stroke({ width: 4, color: colors.wall });
                    }
                }
            }
            
            // Draw start and end markers
            const startX = 0;
            const startY = 0;
            const endX = (gameState.mazeSize - 1) * gameState.cellSize;
            const endY = (gameState.mazeSize - 1) * gameState.cellSize;
            
            // Start marker (green circle)
            gameState.maze.circle(gameState.cellSize * 0.6)
                .center(startX + gameState.cellSize / 2, startY + gameState.cellSize / 2)
                .fill('#06d6a0')
                .stroke({ width: 3, color: '#049c75' });
            
            gameState.maze.text('START')
                .center(startX + gameState.cellSize / 2, startY + gameState.cellSize / 2)
                .font({ size: gameState.cellSize / 6, fill: 'white', weight: 'bold' });
        }

        // Calculate solution path using BFS
        function calculateSolutionPath() {
            // Reset visited status
            for (let y = 0; y < gameState.mazeSize; y++) {
                for (let x = 0; x < gameState.mazeSize; x++) {
                    gameState.cells[y][x].visited = false;
                }
            }
            
            // BFS to find shortest path
            const queue = [{ x: 0, y: 0, path: [{ x: 0, y: 0 }] }];
            gameState.cells[0][0].visited = true;
            
            const dirs = [
                { dx: 0, dy: -1, wall: 'top' },
                { dx: 1, dy: 0, wall: 'right' },
                { dx: 0, dy: 1, wall: 'bottom' },
                { dx: -1, dy: 0, wall: 'left' }
            ];
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                // Check if we reached the exit
                if (current.x === gameState.mazeSize - 1 && current.y === gameState.mazeSize - 1) {
                    gameState.solutionPath = current.path;
                    return;
                }
                
                // Check all directions
                for (const dir of dirs) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    
                    // Check bounds
                    if (nx >= 0 && nx < gameState.mazeSize && ny >= 0 && ny < gameState.mazeSize) {
                        // Check if there's no wall in this direction
                        const cell = gameState.cells[current.y][current.x];
                        if (!cell.walls[dir.wall]) {
                            const neighbor = gameState.cells[ny][nx];
                            if (!neighbor.visited) {
                                neighbor.visited = true;
                                queue.push({ 
                                    x: nx, 
                                    y: ny, 
                                    path: [...current.path, { x: nx, y: ny }] 
                                });
                            }
                        }
                    }
                }
            }
            
            // If we get here, there's no solution (shouldn't happen)
            gameState.solutionPath = [];
        }

        // Show solution path
        function showSolution() {
            // Remove any existing solution display
            gameState.maze.find('path.solution-path').forEach(p => p.remove());
            
            if (!gameState.showSolution) {
                gameState.showSolution = true;
                
                // Create path for solution
                const pathData = gameState.solutionPath.map((point, index) => {
                    const x = point.x * gameState.cellSize + gameState.cellSize / 2;
                    const y = point.y * gameState.cellSize + gameState.cellSize / 2;
                    return `${index === 0 ? 'M' : 'L'} ${x} ${y}`;
                }).join(' ');
                
                // Draw solution path
                gameState.maze.path(pathData)
                    .fill('none')
                    .stroke({ width: gameState.cellSize / 4, color: colors.solution })
                    .addClass('solution-path');
                
                // Update button text
                document.getElementById('show-solution-btn').innerHTML = '<span style="font-size: 1.5rem;">üëÅÔ∏è</span> Hide Solution Path';
            } else {
                gameState.showSolution = false;
                // Update button text
                document.getElementById('show-solution-btn').innerHTML = '<span style="font-size: 1.5rem;">üîç</span> Show Solution Path';
            }
        }

        // Create the hero character
        function createHero() {
            // Remove existing hero
            gameState.maze.find('g.hero').forEach(g => g.remove());
            
            const x = gameState.heroPosition.x * gameState.cellSize + gameState.cellSize / 2;
            const y = gameState.heroPosition.y * gameState.cellSize + gameState.cellSize / 2;
            
            // Create hero group
            const heroGroup = gameState.maze.group().addClass('hero');
            
            // Hero body (circle)
            const body = heroGroup.circle(gameState.cellSize * 0.6)
                .center(x, y)
                .fill(colors.hero)
                .stroke({ width: 3, color: '#d64545' });
            
            // Hero face (smiley)
            const eyeSize = gameState.cellSize * 0.1;
            const eyeOffset = gameState.cellSize * 0.15;
            
            // Left eye
            heroGroup.circle(eyeSize)
                .center(x - eyeOffset, y - eyeOffset)
                .fill('white')
                .stroke({ width: 2, color: '#333' });
            
            heroGroup.circle(eyeSize / 2)
                .center(x - eyeOffset, y - eyeOffset)
                .fill('#333');
            
            // Right eye
            heroGroup.circle(eyeSize)
                .center(x + eyeOffset, y - eyeOffset)
                .fill('white')
                .stroke({ width: 2, color: '#333' });
            
            heroGroup.circle(eyeSize / 2)
                .center(x + eyeOffset, y - eyeOffset)
                .fill('#333');
            
            // Smile
            const smileRadius = gameState.cellSize * 0.15;
            heroGroup.path(`M ${x - smileRadius} ${y + smileRadius/2} Q ${x} ${y + smileRadius*1.5} ${x + smileRadius} ${y + smileRadius/2}`)
                .fill('none')
                .stroke({ width: 3, color: '#333' });
            
            // Hero hat
            heroGroup.rect(gameState.cellSize * 0.8, gameState.cellSize * 0.2)
                .center(x, y - gameState.cellSize * 0.25)
                .fill('#118ab2')
                .radius(5);
            
            gameState.hero = heroGroup;
        }

        // Create treasure at exit
        function createTreasure() {
            // Remove existing treasure
            gameState.maze.find('g.treasure').forEach(g => g.remove());
            
            const x = gameState.exitPosition.x * gameState.cellSize + gameState.cellSize / 2;
            const y = gameState.exitPosition.y * gameState.cellSize + gameState.cellSize / 2;
            
            // Create treasure group
            const treasureGroup = gameState.maze.group().addClass('treasure');
            
            // Treasure chest
            const chestWidth = gameState.cellSize * 0.7;
            const chestHeight = gameState.cellSize * 0.5;
            
            // Chest base
            treasureGroup.rect(chestWidth, chestHeight)
                .center(x, y)
                .fill('#ffd166')
                .stroke({ width: 3, color: '#e6b850' });
            
            // Chest lid
            treasureGroup.rect(chestWidth, chestHeight * 0.3)
                .center(x, y - chestHeight * 0.35)
                .fill('#ffb347')
                .stroke({ width: 3, color: '#e6b850' });
            
            // Chest lock
            treasureGroup.circle(gameState.cellSize * 0.15)
                .center(x, y - chestHeight * 0.1)
                .fill('#333');
            
            // Sparkle effect
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const sparkleX = x + Math.cos(angle) * gameState.cellSize * 0.4;
                const sparkleY = y + Math.sin(angle) * gameState.cellSize * 0.4;
                
                treasureGroup.polygon(`${sparkleX},${sparkleY} ${sparkleX+5},${sparkleY+10} ${sparkleX+10},${sparkleY}`)
                    .fill('#fff')
                    .opacity(0.7);
            }
            
            // Treasure text
            treasureGroup.text('TREASURE')
                .center(x, y + gameState.cellSize * 0.3)
                .font({ size: gameState.cellSize / 6, fill: '#ff6b6b', weight: 'bold' });
            
            gameState.treasure = treasureGroup;
        }

        // Create monsters
        function createMonsters() {
            // Remove existing monsters
            gameState.maze.find('g.monster').forEach(g => g.remove());
            gameState.monsters = [];
            
            // Create monsters at random positions (not at start or exit)
            for (let i = 0; i < gameState.numMonsters; i++) {
                let x, y;
                let attempts = 0;
                
                // Keep trying until we find a valid position
                do {
                    x = Math.floor(Math.random() * (gameState.mazeSize - 2)) + 1;
                    y = Math.floor(Math.random() * (gameState.mazeSize - 2)) + 1;
                    attempts++;
                    
                    // Break if we can't find a good position after many attempts
                    if (attempts > 100) {
                        x = 5 + i * 3;
                        y = 5 + i * 3;
                        break;
                    }
                } while (
                    (x === 0 && y === 0) || // Start position
                    (x === gameState.mazeSize - 1 && y === gameState.mazeSize - 1) || // Exit position
                    gameState.monsters.some(m => m.x === x && m.y === y) // Another monster position
                );
                
                createMonster(x, y, i);
            }
        }

        // Create a single monster
        function createMonster(x, y, index) {
            const centerX = x * gameState.cellSize + gameState.cellSize / 2;
            const centerY = y * gameState.cellSize + gameState.cellSize / 2;
            
            // Create monster group
            const monsterGroup = gameState.maze.group().addClass('monster');
            
            // Monster body (irregular shape for friendly look)
            const body = monsterGroup.polygon(`
                ${centerX},${centerY - gameState.cellSize * 0.25}
                ${centerX + gameState.cellSize * 0.3},${centerY}
                ${centerX},${centerY + gameState.cellSize * 0.25}
                ${centerX - gameState.cellSize * 0.3},${centerY}
            `).fill(colors.monster).stroke({ width: 3, color: '#0a5a7a' });
            
            // Monster eyes
            const eyeSize = gameState.cellSize * 0.08;
            const eyeOffset = gameState.cellSize * 0.15;
            
            // Left eye
            monsterGroup.circle(eyeSize * 2)
                .center(centerX - eyeOffset, centerY - eyeOffset/2)
                .fill('white');
            
            monsterGroup.circle(eyeSize)
                .center(centerX - eyeOffset, centerY - eyeOffset/2)
                .fill('#333');
            
            // Right eye
            monsterGroup.circle(eyeSize * 2)
                .center(centerX + eyeOffset, centerY - eyeOffset/2)
                .fill('white');
            
            monsterGroup.circle(eyeSize)
                .center(centerX + eyeOffset, centerY - eyeOffset/2)
                .fill('#333');
            
            // Monster mouth (friendly smile)
            monsterGroup.path(`M ${centerX - eyeOffset} ${centerY + eyeOffset/2} Q ${centerX} ${centerY + eyeOffset} ${centerX + eyeOffset} ${centerY + eyeOffset/2}`)
                .fill('none')
                .stroke({ width: 3, color: '#333' });
            
            // Monster horns/ears
            monsterGroup.circle(eyeSize * 1.5)
                .center(centerX - eyeOffset, centerY - eyeOffset * 1.5)
                .fill('#ff9e6d');
            
            monsterGroup.circle(eyeSize * 1.5)
                .center(centerX + eyeOffset, centerY - eyeOffset * 1.5)
                .fill('#ff9e6d');
            
            // Store monster data
            gameState.monsters.push({
                x: x,
                y: y,
                element: monsterGroup,
                direction: Math.floor(Math.random() * 4) // 0: up, 1: right, 2: down, 3: left
            });
        }

        // Move hero in direction
        function moveHero(dx, dy) {
            if (!gameState.isGameActive) return;
            
            const newX = gameState.heroPosition.x + dx;
            const newY = gameState.heroPosition.y + dy;
            
            // Check bounds
            if (newX < 0 || newX >= gameState.mazeSize || newY < 0 || newY >= gameState.mazeSize) {
                return;
            }
            
            // Check if there's a wall in the direction we want to move
            const currentCell = gameState.cells[gameState.heroPosition.y][gameState.heroPosition.x];
            let canMove = false;
            
            if (dx === -1 && dy === 0) canMove = !currentCell.walls.left; // Left
            if (dx === 1 && dy === 0) canMove = !currentCell.walls.right; // Right
            if (dx === 0 && dy === -1) canMove = !currentCell.walls.top; // Up
            if (dx === 0 && dy === 1) canMove = !currentCell.walls.bottom; // Down
            
            if (canMove) {
                // Update hero position
                gameState.heroPosition.x = newX;
                gameState.heroPosition.y = newY;
                
                // Update steps count
                gameState.steps++;
                document.getElementById('steps-count').textContent = gameState.steps;
                
                // Update hero visual position
                const x = newX * gameState.cellSize + gameState.cellSize / 2;
                const y = newY * gameState.cellSize + gameState.cellSize / 2;
                gameState.hero.animate(200).center(x, y);
                
                // Check if hero reached treasure
                if (newX === gameState.exitPosition.x && newY === gameState.exitPosition.y) {
                    winGame();
                    return;
                }
                
                // Check for monster collision
                checkMonsterCollision();
            }
        }

        // Start dropping trail
        function startTrail() {
            // Clear any existing interval
            if (gameState.trailInterval) clearInterval(gameState.trailInterval);
            
            // Drop trail every 300ms while moving
            gameState.trailInterval = setInterval(() => {
                if (!gameState.isGameActive) return;
                
                // Don't drop trail if hero hasn't moved recently
                if (gameState.steps === 0) return;
                
                dropTrail();
            }, 300);
        }

        // Drop a trail circle
        function dropTrail() {
            const x = gameState.heroPosition.x * gameState.cellSize + gameState.cellSize / 2;
            const y = gameState.heroPosition.y * gameState.cellSize + gameState.cellSize / 2;
            
            // Random color from trail colors
            const colorIndex = Math.floor(Math.random() * colors.trail.length);
            const color = colors.trail[colorIndex];
            
            // Create trail circle
            const trailCircle = gameState.maze.circle(gameState.cellSize * 0.15)
                .center(x, y)
                .fill(color)
                .stroke({ width: 2, color: 'white' })
                .opacity(0.8);
            
            // Add to trail array
            gameState.trail.push(trailCircle);
            
            // Update trail count
            document.getElementById('trail-count').textContent = gameState.trail.length;
            
            // Fade out and remove trail after 5 seconds
            setTimeout(() => {
                trailCircle.animate(1000).opacity(0).after(() => {
                    trailCircle.remove();
                    // Remove from trail array
                    const index = gameState.trail.indexOf(trailCircle);
                    if (index > -1) {
                        gameState.trail.splice(index, 1);
                        document.getElementById('trail-count').textContent = gameState.trail.length;
                    }
                });
            }, 5000);
        }

        // Start monster movement
        function startMonsterMovement() {
            // Clear any existing interval
            if (gameState.monsterInterval) clearInterval(gameState.monsterInterval);
            
            // Move monsters every 800ms
            gameState.monsterInterval = setInterval(() => {
                if (!gameState.isGameActive) return;
                
                moveMonsters();
            }, 800);
        }

        // Move all monsters
        function moveMonsters() {
            gameState.monsters.forEach(monster => {
                // Try to move in current direction
                let newX = monster.x;
                let newY = monster.y;
                
                switch(monster.direction) {
                    case 0: newY--; break; // Up
                    case 1: newX++; break; // Right
                    case 2: newY++; break; // Down
                    case 3: newX--; break; // Left
                }
                
                // Check if move is valid (within bounds and no wall)
                const cell = gameState.cells[monster.y][monster.x];
                let canMove = false;
                
                if (monster.direction === 0) canMove = !cell.walls.top;
                if (monster.direction === 1) canMove = !cell.walls.right;
                if (monster.direction === 2) canMove = !cell.walls.bottom;
                if (monster.direction === 3) canMove = !cell.walls.left;
                
                // Also check bounds
                if (newX < 0 || newX >= gameState.mazeSize || newY < 0 || newY >= gameState.mazeSize) {
                    canMove = false;
                }
                
                if (canMove) {
                    // Update monster position
                    monster.x = newX;
                    monster.y = newY;
                    
                    // Update monster visual position
                    const x = newX * gameState.cellSize + gameState.cellSize / 2;
                    const y = newY * gameState.cellSize + gameState.cellSize / 2;
                    monster.element.animate(500).center(x, y);
                } else {
                    // Change direction randomly
                    monster.direction = Math.floor(Math.random() * 4);
                }
                
                // Check for collision with hero
                checkMonsterCollision();
            });
        }

        // Check if any monster collided with hero
        function checkMonsterCollision() {
            for (const monster of gameState.monsters) {
                if (monster.x === gameState.heroPosition.x && monster.y === gameState.heroPosition.y) {
                    loseGame();
                    return;
                }
            }
        }

        // Win the game
        function winGame() {
            gameState.isGameActive = false;
            
            // Stop intervals
            clearInterval(gameState.trailInterval);
            clearInterval(gameState.monsterInterval);
            
            // Show celebration
            showCelebration();
            
            // Show win message after a short delay
            setTimeout(() => {
                document.getElementById('win-message').style.display = 'block';
            }, 1000);
        }

        // Lose the game
        function loseGame() {
            gameState.isGameActive = false;
            
            // Stop intervals
            clearInterval(gameState.trailInterval);
            clearInterval(gameState.monsterInterval);
            
            // Make hero look sad
            const heroGroup = gameState.hero;
            const x = gameState.heroPosition.x * gameState.cellSize + gameState.cellSize / 2;
            const y = gameState.heroPosition.y * gameState.cellSize + gameState.cellSize / 2;
            
            // Remove smile and add frown
            heroGroup.find('path').forEach(p => p.remove());
            
            // Add frown
            const frownRadius = gameState.cellSize * 0.15;
            heroGroup.path(`M ${x - frownRadius} ${y + frownRadius} Q ${x} ${y + frownRadius/2} ${x + frownRadius} ${y + frownRadius}`)
                .fill('none')
                .stroke({ width: 3, color: '#333' });
            
            // Show lose message after a short delay
            setTimeout(() => {
                document.getElementById('lose-message').style.display = 'block';
            }, 800);
        }

        // Show celebration animation
        function showCelebration() {
            const celebration = document.getElementById('celebration');
            celebration.style.display = 'block';
            
            // Create celebration elements
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.style.position = 'absolute';
                confetti.style.width = Math.random() * 20 + 10 + 'px';
                confetti.style.height = Math.random() * 20 + 10 + 'px';
                confetti.style.backgroundColor = colors.trail[Math.floor(Math.random() * colors.trail.length)];
                confetti.style.borderRadius = '50%';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.top = '-20px';
                confetti.style.opacity = '0.8';
                celebration.appendChild(confetti);
                
                // Animate confetti falling
                const animation = confetti.animate([
                    { transform: `translateY(0) rotate(0deg)`, opacity: 1 },
                    { transform: `translateY(${window.innerHeight + 20}px) rotate(${Math.random() * 360}deg)`, opacity: 0 }
                ], {
                    duration: Math.random() * 2000 + 2000,
                    easing: 'cubic-bezier(0.215, 0.610, 0.355, 1)'
                });
                
                // Remove confetti after animation
                animation.onfinish = () => confetti.remove();
            }
        }

        // Restart the game
        function restartGame() {
            // Clear intervals
            clearInterval(gameState.trailInterval);
            clearInterval(gameState.monsterInterval);
            
            // Reset game state
            gameState.isGameActive = true;
            gameState.steps = 0;
            gameState.trail = [];
            gameState.showSolution = false;
            
            // Clear trail
            gameState.trail.forEach(circle => circle.remove());
            gameState.trail = [];
            
            // Update UI
            document.getElementById('steps-count').textContent = '0';
            document.getElementById('trail-count').textContent = '0';
            
            // Hide messages
            document.getElementById('win-message').style.display = 'none';
            document.getElementById('lose-message').style.display = 'none';
            document.getElementById('celebration').style.display = 'none';
            document.getElementById('celebration').innerHTML = '';
            
            // Reset hero position
            gameState.heroPosition = { x: 0, y: 0 };
            
            // Recreate hero
            createHero();
            
            // Recreate monsters
            createMonsters();
            
            // Start intervals again
            startTrail();
            startMonsterMovement();
            
            // Update solution button text
            document.getElementById('show-solution-btn').innerHTML = '<span style="font-size: 1.5rem;">üîç</span> Show Solution Path';
            
            // Remove solution path if shown
            gameState.maze.find('path.solution-path').forEach(p => p.remove());
            gameState.showSolution = false;
        }

        // Generate a new maze
        function newMaze() {
            // Clear intervals
            clearInterval(gameState.trailInterval);
            clearInterval(gameState.monsterInterval);
            
            // Reset game state
            gameState.isGameActive = true;
            gameState.steps = 0;
            gameState.trail = [];
            gameState.showSolution = false;
            
            // Update UI
            document.getElementById('steps-count').textContent = '0';
            document.getElementById('trail-count').textContent = '0';
            
            // Hide messages
            document.getElementById('win-message').style.display = 'none';
            document.getElementById('lose-message').style.display = 'none';
            document.getElementById('celebration').style.display = 'none';
            document.getElementById('celebration').innerHTML = '';
            
            // Generate new maze
            generateMaze();
            
            // Reset hero position
            gameState.heroPosition = { x: 0, y: 0 };
            
            // Recreate hero
            createHero();
            
            // Recreate treasure
            createTreasure();
            
            // Recreate monsters
            createMonsters();
            
            // Start intervals again
            startTrail();
            startMonsterMovement();
            
            // Update solution button text
            document.getElementById('show-solution-btn').innerHTML = '<span style="font-size: 1.5rem;">üîç</span> Show Solution Path';
        }

        // Update UI
        function updateUI() {
            document.getElementById('steps-count').textContent = gameState.steps;
            document.getElementById('trail-count').textContent = gameState.trail.length;
            document.getElementById('monsters-count').textContent = gameState.numMonsters;
        }

        // Set up event listeners
        function setupEventListeners() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (!gameState.isGameActive) return;
                
                switch(e.key) {
                    case 'ArrowUp':
                        moveHero(0, -1);
                        break;
                    case 'ArrowDown':
                        moveHero(0, 1);
                        break;
                    case 'ArrowLeft':
                        moveHero(-1, 0);
                        break;
                    case 'ArrowRight':
                        moveHero(1, 0);
                        break;
                }
            });
            
            // Button event listeners
            document.getElementById('show-solution-btn').addEventListener('click', showSolution);
            document.getElementById('restart-btn').addEventListener('click', restartGame);
            document.getElementById('new-maze-btn').addEventListener('click', newMaze);
            document.getElementById('play-again-btn').addEventListener('click', restartGame);
            document.getElementById('try-again-btn').addEventListener('click', restartGame);
            
            // Touch controls for mobile
            let touchStartX = 0;
            let touchStartY = 0;
            
            document.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                e.preventDefault();
            });
            
            document.addEventListener('touchend', (e) => {
                if (!gameState.isGameActive) return;
                
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                
                const dx = touchEndX - touchStartX;
                const dy = touchEndY - touchStartY;
                
                // Determine swipe direction
                if (Math.abs(dx) > Math.abs(dy)) {
                    // Horizontal swipe
                    if (dx > 30) moveHero(1, 0);  // Right
                    if (dx < -30) moveHero(-1, 0); // Left
                } else {
                    // Vertical swipe
                    if (dy > 30) moveHero(0, 1);   // Down
                    if (dy < -30) moveHero(0, -1); // Up
                }
                
                e.preventDefault();
            });
        }

        // Initialize the game when page loads
        window.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>