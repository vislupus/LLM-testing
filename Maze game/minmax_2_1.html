<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Adventure - Fun Maze Game for Kids!</title>

    <!-- Include svg.js library from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.1.2/svg.min.js"></script>

    <style>
        /* ========================================
           Child-Friendly Colorful Styles
           ======================================== */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Chalkboard', cursive, sans-serif;
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        /* Title styling with fun colors */
        h1 {
            font-size: 2.5em;
            color: #e74c3c;
            text-shadow: 3px 3px 0px #f39c12;
            margin-bottom: 10px;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Game container with colorful border */
        #game-container {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border: 5px solid #3498db;
        }

        /* Maze SVG styling */
        #maze-svg {
            border-radius: 10px;
            display: block;
        }

        /* Control buttons with fun colors */
        .control-btn {
            font-family: inherit;
            font-size: 1.2em;
            padding: 15px 30px;
            margin: 10px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        /* Show Solution button - green */
        #show-solution {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: white;
            box-shadow: 0 5px 0 #1e8449;
        }

        #show-solution:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 0 #1e8449;
        }

        #show-solution:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #1e8449;
        }

        /* New Game button - blue */
        #new-game {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            box-shadow: 0 5px 0 #1f618d;
        }

        #new-game:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 0 #1f618d;
        }

        #new-game:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #1f618d;
        }

        /* Instructions styling */
        .instructions {
            background: rgba(255,255,255,0.9);
            padding: 15px 25px;
            border-radius: 15px;
            margin: 15px 0;
            text-align: center;
            color: #2c3e50;
            font-size: 1.1em;
        }

        .instructions span {
            color: #e74c3c;
            font-weight: bold;
        }

        /* Win message overlay */
        #win-message {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #f1c40f, #e67e22);
            padding: 40px 60px;
            border-radius: 30px;
            font-size: 2em;
            color: white;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            z-index: 1000;
            animation: celebrate 0.5s ease-out;
        }

        @keyframes celebrate {
            0% { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        /* Lose message overlay */
        #lose-message {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            padding: 40px 60px;
            border-radius: 30px;
            font-size: 2em;
            color: white;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            z-index: 1000;
        }

        /* Button container */
        .button-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Legend for the game */
        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1em;
            color: #2c3e50;
        }

        .legend-color {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            border: 2px solid #2c3e50;
        }
    </style>
</head>
<body>

    <!-- Main Title -->
    <h1>üéÆ Maze Adventure! üéÆ</h1>

    <!-- Game Instructions -->
    <div class="instructions">
        Use <span>Arrow Keys</span> to move the hero to the star!
        Avoid the <span>fun monsters</span> - they'll catch you! ‚≠ê
    </div>

    <!-- Game Container -->
    <div id="game-container">
        <div id="maze-svg"></div>
    </div>

    <!-- Legend -->
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #3498db;"></div>
            <span>Hero (You)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #f1c40f;"></div>
            <span>Goal (Star)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #e74c3c; border-radius: 5px;"></div>
            <span>Monster</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #9b59b6;"></div>
            <span>Your Trail</span>
        </div>
    </div>

    <!-- Control Buttons -->
    <div class="button-container">
        <button id="show-solution" class="control-btn" onclick="showSolution()">üí° Show Solution</button>
        <button id="new-game" class="control-btn" onclick="startNewGame()">üéÆ New Maze</button>
    </div>

    <!-- Win Message Overlay -->
    <div id="win-message">
        üéâ You Won! üéâ<br>
        <span style="font-size: 0.6em;">Great job, little hero!</span><br>
        <button class="control-btn" onclick="startNewGame(); hideWinMessage();" style="margin-top: 20px;">Play Again!</button>
    </div>

    <!-- Lose Message Overlay -->
    <div id="lose-message">
        üò¢ Oh no!<br>
        <span style="font-size: 0.6em;">The monster caught you!</span><br>
        <button class="control-btn" onclick="startNewGame(); hideLoseMessage();" style="margin-top: 20px;">Try Again!</button>
    </div>

    <script>
        /* ========================================
           MAZE GAME FOR KINDERGARTEN CHILDREN
           Made with SVG.js
           ======================================== */

        // ========================================
        // GAME CONFIGURATION
        // ========================================

        // Maze dimensions (20x20 grid)
        const MAZE_SIZE = 20;

        // Cell size in pixels for the maze
        const CELL_SIZE = 30;

        // Calculate maze dimensions
        const MAZE_WIDTH = MAZE_SIZE * CELL_SIZE;
        const MAZE_HEIGHT = MAZE_SIZE * CELL_SIZE;

        // Game state variables
        let draw = null;           // SVG.js drawing object
        let maze = [];             // 2D array representing the maze
        let hero = null;           // Hero character SVG group
        let heroX = 0;             // Hero's current X position
        let heroY = 0;             // Hero's current Y position
        let goalX = 0;             // Goal X position
        let goalY = 0;             // Goal Y position
        let monsters = [];         // Array of monster objects
        let trailCircles = [];     // Array of trail circles
        let gameRunning = false;   // Is the game currently running?
        let solutionPath = [];     // Array of solution path coordinates
        let solutionShown = false; // Is the solution currently shown?
        let trailTimer = null;     // Timer for creating trail circles

        // ========================================
        // MAZE GENERATION (Recursive Backtracking)
        // ========================================

        /**
         * Generates a random maze using recursive backtracking algorithm.
         * This ensures there is always exactly one valid path from start to end.
         */
        function generateMaze() {
            // Initialize maze with all walls (1 = wall, 0 = path)
            maze = [];
            for (let y = 0; y < MAZE_SIZE; y++) {
                maze[y] = [];
                for (let x = 0; x < MAZE_SIZE; x++) {
                    maze[y][x] = 1; // All cells start as walls
                }
            }

            // Start generating from position (1, 1)
            // We use (1,1) to leave a border around the maze
            generatePath(1, 1);

            // Set start position (top-left area)
            heroX = 1;
            heroY = 1;

            // Set goal position (bottom-right area)
            goalX = MAZE_SIZE - 2;
            goalY = MAZE_SIZE - 2;

            // Make sure goal is accessible (remove wall if needed)
            maze[goalY][goalX] = 0;
            maze[goalY][goalX - 1] = 0;

            // Calculate solution path using BFS
            calculateSolutionPath();
        }

        /**
         * Recursive function to carve paths through the maze.
         * Uses depth-first search with backtracking.
         */
        function generatePath(x, y) {
            // Mark current cell as path
            maze[y][x] = 0;

            // Randomize directions: up, right, down, left
            const directions = [
                { dx: 0, dy: -2 },  // Up
                { dx: 2, dy: 0 },   // Right
                { dx: 0, dy: 2 },   // Down
                { dx: -2, dy: 0 }   // Left
            ];

            // Shuffle directions for randomness
            shuffleArray(directions);

            // Try each direction
            for (let dir of directions) {
                const newX = x + dir.dx;
                const newY = y + dir.dy;

                // Check if new position is within bounds and is a wall
                if (newX > 0 && newX < MAZE_SIZE - 1 &&
                    newY > 0 && newY < MAZE_SIZE - 1 &&
                    maze[newY][newX] === 1) {

                    // Remove wall between current and new cell
                    maze[y + dir.dy / 2][x + dir.dx / 2] = 0;

                    // Recursively generate path from new position
                    generatePath(newX, newY);
                }
            }
        }

        /**
         * Calculates the solution path from hero to goal using BFS.
         * This is used to show the correct solution when requested.
         */
        function calculateSolutionPath() {
            // BFS to find shortest path
            const queue = [{ x: heroX, y: heroY, path: [{ x: heroX, y: heroY }] }];
            const visited = new Set();
            visited.add(`${heroX},${heroY}`);

            const directions = [
                { dx: 0, dy: -1 },  // Up
                { dx: 1, dy: 0 },   // Right
                { dx: 0, dy: 1 },   // Down
                { dx: -1, dy: 0 }   // Left
            ];

            while (queue.length > 0) {
                const current = queue.shift();

                // Check if we reached the goal
                if (current.x === goalX && current.y === goalY) {
                    solutionPath = current.path;
                    return;
                }

                // Try all directions
                for (let dir of directions) {
                    const newX = current.x + dir.dx;
                    const newY = current.y + dir.dy;
                    const key = `${newX},${newY}`;

                    // Check if move is valid (not a wall and not visited)
                    if (newX >= 0 && newX < MAZE_SIZE &&
                        newY >= 0 && newY < MAZE_SIZE &&
                        maze[newY][newX] === 0 &&
                        !visited.has(key)) {

                        visited.add(key);
                        queue.push({
                            x: newX,
                            y: newY,
                            path: [...current.path, { x: newX, y: newY }]
                        });
                    }
                }
            }

            // If no path found (shouldn't happen), use empty path
            solutionPath = [];
        }

        /**
         * Fisher-Yates shuffle algorithm for randomizing arrays.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // ========================================
        // MAZE DRAWING WITH SVG.JS
        // ========================================

        /**
         * Draws the entire maze using SVG.js.
         */
        function drawMaze() {
            // Clear any existing drawing
            document.getElementById('maze-svg').innerHTML = '';

            // Create new SVG drawing
            draw = SVG().addTo('#maze-svg').size(MAZE_WIDTH, MAZE_HEIGHT);

            // Draw the maze background (grass green)
            draw.rect(MAZE_WIDTH, MAZE_HEIGHT).fill('#a8e6cf');

            // Draw each cell
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    const cellX = x * CELL_SIZE;
                    const cellY = y * CELL_SIZE;

                    if (maze[y][x] === 1) {
                        // Draw wall as a colorful brick
                        const wall = draw.rect(CELL_SIZE - 2, CELL_SIZE - 2)
                            .move(cellX + 1, cellY + 1)
                            .fill('#5d4e6d')
                            .radius(3);

                        // Add brick pattern
                        draw.line(cellX + 1, cellY + CELL_SIZE/2, cellX + CELL_SIZE - 2, cellY + CELL_SIZE/2)
                            .stroke({ color: '#4a3f5a', width: 1 });
                    } else {
                        // Draw path as light grass
                        draw.rect(CELL_SIZE - 2, CELL_SIZE - 2)
                            .move(cellX + 1, cellY + 1)
                            .fill('#c8e6c9')
                            .radius(2);
                    }
                }
            }

            // Draw border around maze
            draw.rect(MAZE_WIDTH, MAZE_HEIGHT)
                .fill('none')
                .stroke({ color: '#3498db', width: 4 })
                .radius(10);
        }

        // ========================================
        // HERO CHARACTER (Cute Animated)
        // ========================================

        /**
         * Creates the hero character using SVG.js.
         * A cute blue character with friendly appearance.
         */
        function createHero() {
            // Remove existing hero if any
            if (hero) {
                hero.remove();
            }

            const centerX = heroX * CELL_SIZE + CELL_SIZE / 2;
            const centerY = heroY * CELL_SIZE + CELL_SIZE / 2;

            // Create hero as a group
            hero = draw.group();

            // Hero body (blue circle)
            const body = hero.circle(24)
                .center(centerX, centerY)
                .fill('#3498db')
                .stroke({ color: '#2980b9', width: 2 });

            // Hero face (white area)
            hero.circle(18)
                .center(centerX, centerY - 2)
                .fill('white');

            // Left eye
            const leftEye = hero.circle(6)
                .center(centerX - 5, centerY - 4)
                .fill('#2c3e50');

            // Right eye
            const rightEye = hero.circle(6)
                .center(centerX + 5, centerY - 4)
                .fill('#2c3e50');

            // Eye highlights (cute sparkle)
            hero.circle(2)
                .center(centerX - 4, centerY - 5)
                .fill('white');

            hero.circle(2)
                .center(centerX + 6, centerY - 5)
                .fill('white');

            // Smile (cute curve)
            hero.path(`M ${centerX - 4} ${centerY + 2} Q ${centerX} ${centerY + 7} ${centerX + 4} ${centerY + 2}`)
                .fill('none')
                .stroke({ color: '#e74c3c', width: 2, linecap: 'round' });

            // Add animation to hero (subtle bouncing)
            animateHero();
        }

        /**
         * Adds continuous bouncing animation to the hero.
         */
        function animateHero() {
            if (!hero || !gameRunning) return;

            hero.animate(300, '<>')
                .transform({ scale: 1.1 })
                .animate(300, '<>')
                .transform({ scale: 1 })
                .after(() => animateHero());
        }

        /**
         * Updates hero position on the screen.
         */
        function updateHeroPosition() {
            if (!hero) return;

            const centerX = heroX * CELL_SIZE + CELL_SIZE / 2;
            const centerY = heroY * CELL_SIZE + CELL_SIZE / 2;

            // Animate movement to new position
            hero.animate(100, '<>')
                .center(centerX, centerY);
        }

        // ========================================
        // GOAL (Star)
        // ========================================

        /**
         * Draws the goal (golden star) at the end position.
         */
        function drawGoal() {
            const centerX = goalX * CELL_SIZE + CELL_SIZE / 2;
            const centerY = goalY * CELL_SIZE + CELL_SIZE / 2;

            // Create star shape
            const starSize = 12;
            const points = [];

            // Create 5-pointed star
            for (let i = 0; i < 10; i++) {
                const angle = (i * 36 - 90) * Math.PI / 180;
                const radius = i % 2 === 0 ? starSize : starSize / 2;
                points.push(centerX + Math.cos(angle) * radius);
                points.push(centerY + Math.sin(angle) * radius);
            }

            // Draw star
            const star = draw.polygon(points)
                .fill('#f1c40f')
                .stroke({ color: '#f39c12', width: 2 });

            // Add glowing animation
            function animateStar() {
                if (!gameRunning) return;

                star.animate(500, '<>')
                    .transform({ scale: 1.2 })
                    .animate(500, '<>')
                    .transform({ scale: 1 })
                    .after(animateStar);
            }

            animateStar();
        }

        // ========================================
        // TRAIL SYSTEM
        // ========================================

        /**
         * Creates a trail circle at the hero's current position.
         */
        function createTrail() {
            if (!gameRunning || !hero) return;

            const centerX = heroX * CELL_SIZE + CELL_SIZE / 2;
            const centerY = heroY * CELL_SIZE + CELL_SIZE / 2;

            // Create small purple circle for trail
            const trail = draw.circle(8)
                .center(centerX, centerY)
                .fill('#9b59b6')
                .opacity(0.7);

            trailCircles.push(trail);

            // Fade out and remove after 3 seconds
            trail.animate(2000, '<>')
                .opacity(0)
                .after(() => {
                    trail.remove();
                    const index = trailCircles.indexOf(trail);
                    if (index > -1) {
                        trailCircles.splice(index, 1);
                    }
                });
        }

        /**
         * Starts the trail timer when hero moves.
         */
        let lastTrailTime = 0;

        function checkTrailTime() {
            const now = Date.now();
            if (now - lastTrailTime > 500) { // Every 500ms
                createTrail();
                lastTrailTime = now;
            }
        }

        // ========================================
        // MONSTERS (Friendly-looking)
        // ========================================

        /**
         * Creates friendly monster characters.
         * They move around the maze and catch the hero.
         */
        function createMonsters() {
            // Remove existing monsters
            monsters.forEach(m => m.group.remove());
            monsters = [];

            // Create 3-5 friendly monsters
            const numMonsters = 3 + Math.floor(Math.random() * 3);

            for (let i = 0; i < numMonsters; i++) {
                createMonster(i);
            }
        }

        /**
         * Creates a single monster at a random position.
         */
        function createMonster(index) {
            // Find a valid random position (not wall, not near hero)
            let x, y;
            do {
                x = Math.floor(Math.random() * MAZE_SIZE);
                y = Math.floor(Math.random() * MAZE_SIZE);
            } while (maze[y][x] === 1 ||
                     (Math.abs(x - heroX) < 5 && Math.abs(y - heroY) < 5) ||
                     (x === goalX && y === goalY));

            const centerX = x * CELL_SIZE + CELL_SIZE / 2;
            const centerY = y * CELL_SIZE + CELL_SIZE / 2;

            // Create monster group
            const monsterGroup = draw.group();

            // Monster colors (fun friendly colors)
            const colors = ['#e74c3c', '#e67e22', '#9b59b6'];
            const color = colors[index % colors.length];

            // Monster body (rounded rectangle)
            const body = monsterGroup.rect(22, 18)
                .center(centerX, centerY)
                .fill(color)
                .radius(5)
                .stroke({ color: '#c0392b', width: 1 });

            // Monster eyes (big and friendly)
            const eye1 = monsterGroup.circle(6)
                .center(centerX - 4, centerY - 2)
                .fill('white');

            const eye2 = monsterGroup.circle(6)
                .center(centerX + 4, centerY - 2)
                .fill('white');

            // Monster pupils
            monsterGroup.circle(3)
                .center(centerX - 4, centerY - 1)
                .fill('#2c3e50');

            monsterGroup.circle(3)
                .center(centerX + 4, centerY - 1)
                .fill('#2c3e50');

            // Friendly smile
            monsterGroup.path(`M ${centerX - 4} ${centerY + 3} Q ${centerX} ${centerY + 7} ${centerX + 4} ${centerY + 3}`)
                .fill('none')
                .stroke({ color: '#2c3e50', width: 1.5, linecap: 'round' });

            // Store monster data
            const monster = {
                group: monsterGroup,
                x: x,
                y: y,
                moveTimer: null,
                color: color
            };

            monsters.push(monster);

            // Start monster movement
            startMonsterMovement(monster);
        }

        /**
         * Starts a monster's movement timer.
         */
        function startMonsterMovement(monster) {
            // Move every 800ms to 1500ms (random interval)
            const moveInterval = 800 + Math.random() * 700;

            monster.moveTimer = setTimeout(() => {
                if (gameRunning) {
                    moveMonster(monster);
                    startMonsterMovement(monster);
                }
            }, moveInterval);
        }

        /**
         * Moves a monster randomly to an adjacent cell.
         */
        function moveMonster(monster) {
            // Get valid neighbors
            const directions = [
                { dx: 0, dy: -1 },  // Up
                { dx: 1, dy: 0 },   // Right
                { dx: 0, dy: 1 },   // Down
                { dx: -1, dy: 0 }   // Left
            ];

            // Shuffle directions for random movement
            shuffleArray(directions);

            for (let dir of directions) {
                const newX = monster.x + dir.dx;
                const newY = monster.y + dir.dy;

                // Check if move is valid
                if (newX >= 0 && newX < MAZE_SIZE &&
                    newY >= 0 && newY < MAZE_SIZE &&
                    maze[newY][newX] === 0) {

                    // Move monster
                    monster.x = newX;
                    monster.y = newY;

                    // Animate to new position
                    const centerX = newX * CELL_SIZE + CELL_SIZE / 2;
                    const centerY = newY * CELL_SIZE + CELL_SIZE / 2;

                    monster.group.animate(300, '<>')
                        .center(centerX, centerY);

                    // Check if monster caught hero
                    checkMonsterCollision(monster);

                    break;
                }
            }
        }

        /**
         * Checks if a monster has caught the hero.
         */
        function checkMonsterCollision(monster) {
            if (monster.x === heroX && monster.y === heroY) {
                gameOver(false);
            }
        }

        // ========================================
        // HERO MOVEMENT
        // ========================================

        /**
         * Handles keyboard input for hero movement.
         */
        document.addEventListener('keydown', function(event) {
            if (!gameRunning) return;

            let newX = heroX;
            let newY = heroY;

            // Arrow keys for movement
            switch (event.key) {
                case 'ArrowUp':
                    newY--;
                    event.preventDefault();
                    break;
                case 'ArrowDown':
                    newY++;
                    event.preventDefault();
                    break;
                case 'ArrowLeft':
                    newX--;
                    event.preventDefault();
                    break;
                case 'ArrowRight':
                    newX++;
                    event.preventDefault();
                    break;
                default:
                    return;
            }

            // Check if new position is valid (not a wall)
            if (newX >= 0 && newX < MAZE_SIZE &&
                newY >= 0 && newY < MAZE_SIZE &&
                maze[newY][newX] === 0) {

                // Update hero position
                heroX = newX;
                heroY = newY;

                // Update visual position
                updateHeroPosition();

                // Check trail timing
                checkTrailTime();

                // Check for win
                if (heroX === goalX && heroY === goalY) {
                    gameOver(true);
                }

                // Check monster collisions after move
                monsters.forEach(m => checkMonsterCollision(m));
            }
        });

        // ========================================
        // GAME CONTROL
        // ========================================

        /**
         * Starts a new game with a fresh maze.
         */
        function startNewGame() {
            // Stop any existing game
            stopGame();

            // Clear solution if shown
            hideSolution();

            // Generate new maze
            generateMaze();

            // Draw the maze
            drawMaze();

            // Draw goal
            drawGoal();

            // Create hero
            createHero();

            // Create monsters
            createMonsters();

            // Clear trail circles
            trailCircles.forEach(t => t.remove());
            trailCircles = [];

            // Start game
            gameRunning = true;
            lastTrailTime = Date.now();
        }

        /**
         * Stops the current game.
         */
        function stopGame() {
            gameRunning = false;

            // Clear monster timers
            monsters.forEach(m => {
                if (m.moveTimer) {
                    clearTimeout(m.moveTimer);
                }
            });

            // Clear trail timer
            if (trailTimer) {
                clearTimeout(trailTimer);
            }

            // Hide messages
            hideWinMessage();
            hideLoseMessage();
        }

        /**
         * Handles game over (win or lose).
         */
        function gameOver(won) {
            gameRunning = false;

            // Clear monster timers
            monsters.forEach(m => {
                if (m.moveTimer) {
                    clearTimeout(m.moveTimer);
                }
            });

            if (won) {
                // Show win message
                document.getElementById('win-message').style.display = 'block';
            } else {
                // Show lose message
                document.getElementById('lose-message').style.display = 'block';
            }
        }

        /**
         * Hides the win message overlay.
         */
        function hideWinMessage() {
            document.getElementById('win-message').style.display = 'none';
        }

        /**
         * Hides the lose message overlay.
         */
        function hideLoseMessage() {
            document.getElementById('lose-message').style.display = 'none';
        }

        // ========================================
        // SOLUTION PATH DISPLAY
        // ========================================

        /**
         * Shows the solution path on the maze.
         */
        let solutionMarkers = [];

        function showSolution() {
            if (!gameRunning || solutionShown) return;

            // Draw solution path
            solutionPath.forEach((point, index) => {
                // Skip start position (hero is there)
                if (index === 0) return;

                const centerX = point.x * CELL_SIZE + CELL_SIZE / 2;
                const centerY = point.y * CELL_SIZE + CELL_SIZE / 2;

                // Create glowing path marker
                const marker = draw.circle(10)
                    .center(centerX, centerY)
                    .fill('#3498db')
                    .opacity(0.5);

                solutionMarkers.push(marker);
            });

            solutionShown = true;

            // Auto-hide after 5 seconds
            setTimeout(hideSolution, 5000);
        }

        /**
         * Hides the solution path.
         */
        function hideSolution() {
            solutionMarkers.forEach(m => m.remove());
            solutionMarkers = [];
            solutionShown = false;
        }

        // ========================================
        // INITIALIZE GAME
        // ========================================

        // Start the game when the page loads
        window.onload = startNewGame;

    </script>
</body>
</html>