<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive von Kármán Vortex Street</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a1f;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
        }
        #container {
            position: relative;
            box-shadow: 0 20px 80px rgba(0,0,0,0.8);
            border-radius: 16px;
            overflow: hidden;
        }
        .ui {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(10,10,31,0.95);
            padding: 20px;
            border-radius: 14px;
            color: #e0f0ff;
            backdrop-filter: blur(16px);
            border: 1px solid rgba(100,180,255,0.4);
            min-width: 280px;
            transition: all 0.4s ease;
            z-index: 100;
        }
        .ui.hidden { transform: translateX(-320px); }
        h2 {
            margin: 0 0 18px 0;
            color: #64b5f6;
            font-size: 22px;
            text-shadow: 0 0 15px rgba(100,180,255,0.6);
        }
        .control {
            margin-bottom: 16px;
        }
        label {
            display: block;
            margin-bottom: 6px;
            font-size: 13px;
            color: #b0d0ff;
        }
        input[type="range"], select {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            background: #1a1a3a;
            color: white;
            border: 1px solid #444;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #64b5f6;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(100,180,255,0.7);
        }
        .btn {
            width: 100%;
            padding: 10px;
            margin: 8px 0;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(102,126,234,0.5);
        }
        .info {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(10,10,31,0.95);
            padding: 15px;
            border-radius: 12px;
            color: #e0f0ff;
            font-size: 12px;
            backdrop-filter: blur(12px);
            border: 1px solid rgba(100,180,255,0.3);
            max-width: 260px;
        }
        .toggle {
            position: absolute;
            top: 15px;
            left: 315px;
            background: rgba(10,10,31,0.95);
            color: white;
            border: none;
            padding: 14px;
            border-radius: 0 14px 14px 0;
            cursor: pointer;
            font-size: 20px;
            z-index: 101;
        }
        .toggle.shifted { left: 15px; }
    </style>
</head>
<body>
    <div id="container">
        <div class="ui" id="ui">
            <h2>Vortex Street Lab</h2>
            
            <div class="control">
                <label>Flow Speed: <span id="speedVal">1.8</span></label>
                <input type="range" id="flowSpeed" min="0.5" max="3.5" step="0.1" value="1.8">
            </div>
            
            <div class="control">
                <label>Viscosity: <span id="viscVal">0.0008</span></label>
                <input type="range" id="viscosity" min="0.0001" max="0.002" step="0.0001" value="0.0008">
            </div>
            
            <div class="control">
                <label>Obstacle Shape:</label>
                <select id="shape">
                    <option value="circle">Circle</option>
                    <option value="ellipse">Ellipse</option>
                    <option value="square">Square</option>
                    <option value="diamond">Diamond</option>
                    <option value="airfoil">Airfoil</option>
                </select>
            </div>
            
            <div class="control">
                <label>Obstacle Size: <span id="sizeVal">40</span></label>
                <input type="range" id="size" min="20" max="80" step="2" value="40">
            </div>
            
            <div class="control">
                <label>Rotation: <span id="rotVal">0</span>°</label>
                <input type="range" id="rotation" min="0" max="360" step="5" value="0">
            </div>
            
            <button class="btn" onclick="resetFlow()">Reset Flow Field</button>
        </div>
        
        <button class="toggle" id="toggleBtn" onclick="toggleUI()">◀</button>
        
        <div class="info">
            <strong>Interactive Controls:</strong><br>
            • Drag obstacle with mouse<br>
            • Scroll = change size<br>
            • Shift + Drag = rotate<br>
            • R = reset flow<br>
            • Space = pause/resume<br>
            <br>
            Watch the beautiful alternating vortices form behind the obstacle — this is the famous <strong>von Kármán vortex street</strong>!
        </div>
    </div>

    <script>
        class VortexStreetSimulation {
            constructor() {
                this.N = 120;
                this.size = this.N + 2;
                this.dt = 0.05;
                
                // Fluid fields
                this.u = Array(this.size * this.size).fill(0);
                this.v = Array(this.size * this.size).fill(0);
                this.u_prev = Array(this.size * this.size).fill(0);
                this.v_prev = Array(this.size * this.size).fill(0);
                this.dens = Array(this.size * this.size).fill(0);
                
                // Obstacle
                this.obsX = width / 2;
                this.obsY = height / 2;
                this.obsSize = 40;
                this.obsRot = 0;
                this.obsShape = 'circle';
                
                // Parameters
                this.flowSpeed = 1.8;
                this.visc = 0.0008;
                
                this.mousePressed = false;
                this.shiftPressed = false;
                
                this.initFlow();
            }
            
            IX(x, y) {
                x = constrain(floor(x), 0, this.N + 1);
                y = constrain(floor(y), 0, this.N + 1);
                return x + y * this.size;
            }
            
            initFlow() {
                for (let i = 0; i < this.size * this.size; i++) {
                    this.u[i] = this.flowSpeed;
                    this.v[i] = 0;
                    this.u_prev[i] = this.flowSpeed;
                    this.v_prev[i] = 0;
                    this.dens[i] = 0;
                }
            }
            
            addObstacle() {
                const scaleX = width / this.N;
                const scaleY = height / this.N;
                const cx = this.obsX / scaleX;
                const cy = this.obsY / scaleY;
                const r = this.obsSize / scaleX;
                
                for (let j = 1; j <= this.N; j++) {
                    for (let i = 1; i <= this.N; i++) {
                        let dx = i - cx;
                        let dy = j - cy;
                        
                        // Rotate point
                        const angle = radians(this.obsRot);
                        const rx = dx * cos(angle) - dy * sin(angle);
                        const ry = dx * sin(angle) + dy * cos(angle);
                        
                        let inside = false;
                        
                        switch(this.obsShape) {
                            case 'circle':
                                inside = rx*rx + ry*ry < r*r;
                                break;
                            case 'ellipse':
                                inside = (rx*rx)/(r*r) + (ry*ry)/(r*r*0.5) < 1;
                                break;
                            case 'square':
                                inside = Math.abs(rx) < r && Math.abs(ry) < r;
                                break;
                            case 'diamond':
                                inside = Math.abs(rx) + Math.abs(ry) < r;
                                break;
                            case 'airfoil':
                                const thickness = r * 0.3;
                                const camber = r * 0.15;
                                inside = Math.abs(ry - camber * (1 - (rx/r)*(rx/r))) < thickness * Math.sqrt(1 - (rx/r)*(rx/r));
                                break;
                        }
                        
                        if (inside) {
                            const idx = this.IX(i, j);
                            this.u[idx] = 0;
                            this.v[idx] = 0;
                            this.u_prev[idx] = 0;
                            this.v_prev[idx] = 0;
                        }
                    }
                }
            }
            
            diffuse(b, x, x0, diff, dt) {
                const a = dt * diff * this.N * this.N;
                for (let k = 0; k < 20; k++) {
                    for (let j = 1; j <= this.N; j++) {
                        for (let i = 1; i <= this.N; i++) {
                            const idx = this.IX(i, j);
                            x[idx] = (x0[idx] + a * (
                                x[this.IX(i+1,j)] + x[this.IX(i-1,j)] +
                                x[this.IX(i,j+1)] + x[this.IX(i,j-1)]
                            )) / (1 + 4*a);
                        }
                    }
                    this.set_bnd(b, x);
                }
            }
            
            advect(b, d, d0, u, v, dt) {
                const dt0 = dt * this.N;
                for (let j = 1; j <= this.N; j++) {
                    for (let i = 1; i <= this.N; i++) {
                        let x = i - dt0 * u[this.IX(i,j)];
                        let y = j - dt0 * v[this.IX(i,j)];
                        
                        x = constrain(x, 0.5, this.N + 0.5);
                        y = constrain(y, 0.5, this.N + 0.5);
                        
                        const i0 = floor(x), i1 = i0 + 1;
                        const j0 = floor(y), j1 = j0 + 1;
                        const s1 = x - i0, s0 = 1 - s1;
                        const t1 = y - j0, t0 = 1 - t1;
                        
                        const idx = this.IX(i, j);
                        d[idx] = s0*(t0*d0[this.IX(i0,j0)] + t1*d0[this.IX(i0,j1)]) +
                                 s1*(t0*d0[this.IX(i1,j0)] + t1*d0[this.IX(i1,j1)]);
                    }
                }
                this.set_bnd(b, d);
            }
            
            project(u, v, p, div) {
                for (let j = 1; j <= this.N; j++) {
                    for (let i = 1; i <= this.N; i++) {
                        const idx = this.IX(i, j);
                        div[idx] = -0.5 * (u[this.IX(i+1,j)] - u[this.IX(i-1,j)] +
                                          v[this.IX(i,j+1)] - v[this.IX(i,j-1)]) / this.N;
                        p[idx] = 0;
                    }
                }
                this.set_bnd(0, div); this.set_bnd(0, p);
                
                for (let k = 0; k < 20; k++) {
                    for (let j = 1; j <= this.N; j++) {
                        for (let i = 1; i <= this.N; i++) {
                            const idx = this.IX(i, j);
                            p[idx] = (div[idx] + p[this.IX(i+1,j)] + p[this.IX(i-1,j)] +
                                     p[this.IX(i,j+1)] + p[this.IX(i,j-1)]) / 4;
                        }
                    }
                    this.set_bnd(0, p);
                }
                
                for (let j = 1; j <= this.N; j++) {
                    for (let i = 1; i <= this.N; i++) {
                        const idx = this.IX(i, j);
                        u[idx] -= 0.5 * (p[this.IX(i+1,j)] - p[this.IX(i-1,j)]) * this.N;
                        v[idx] -= 0.5 * (p[this.IX(i,j+1)] - p[this.IX(i,j-1)]) * this.N;
                    }
                }
                this.set_bnd(1, u); this.set_bnd(2, v);
            }
            
            set_bnd(b, x) {
                for (let i = 1; i <= this.N; i++) {
                    x[this.IX(i,0)] = b === 2 ? -x[this.IX(i,1)] : x[this.IX(i,1)];
                    x[this.IX(i,this.N+1)] = b === 2 ? -x[this.IX(i,this.N)] : x[this.IX(i,this.N)];
                    x[this.IX(0,i)] = b === 1 ? -x[this.IX(1,i)] : x[this.IX(1,i)];
                    x[this.IX(this.N+1,i)] = b === 1 ? -x[this.IX(this.N,i)] : x[this.IX(this.N,i)];
                }
                
                // Inlet: constant inflow
                for (let j = 1; j <= this.N; j++) {
                    x[this.IX(0,j)] = this.flowSpeed;
                }
            }
            
            step() {
                this.diffuse(1, this.u_prev, this.u, this.visc, this.dt);
                this.diffuse(2, this.v_prev, this.v, this.visc, this.dt);
                
                this.project(this.u_prev, this.v_prev, this.u, this.v);
                
                this.advect(1, this.u, this.u_prev, this.u_prev, this.v_prev, this.dt);
                this.advect(2, this.v, this.v_prev, this.u_prev, this.v_prev, this.dt);
                
                this.project(this.u, this.v, this.u_prev, this.v_prev);
                
                // Add dye from upstream
                for (let j = 20; j < this.N - 20; j += 8) {
                    this.dens[this.IX(2, j)] = 1.0;
                }
                
                this.advect(0, this.dens, this.dens, this.u, this.v, this.dt);
                
                // Apply obstacle
                this.addObstacle();
            }
            
            render() {
                background(5, 5, 30);
                
                const scaleX = width / this.N;
                const scaleY = height / this.N;
                
                // Render velocity field with vorticity coloring
                for (let j = 0; j < this.N; j += 2) {
                    for (let i = 0; i < this.N; i += 2) {
                        const idx = this.IX(i, j);
                        const vx = this.u[idx];
                        const vy = this.v[idx];
                        const speed = Math.sqrt(vx*vx + vy*vy);
                        
                        // Calculate vorticity (curl)
                        const vort = (this.u[this.IX(i+1,j)] - this.u[this.IX(i-1,j)]) -
                                   (this.v[this.IX(i,j+1)] - this.v[this.IX(i,j-1)]);
                        
                        // Color by vorticity (blue = CCW, red = CW)
                        const hue = map(vort, -0.1, 0.1, 180, 0);
                        const sat = constrain(speed * 20, 0, 100);
                        const bri = constrain(speed * 100 + 50, 50, 255);
                        
                        fill(hue, sat, bri, 180);
                        noStroke();
                        rect(i * scaleX, j * scaleY, scaleX * 2, scaleY * 2);
                    }
                }
                
                // Render smoke/density
                for (let j = 0; j < this.N; j += 1) {
                    for (let i = 0; i < this.N; i += 1) {
                        const d = this.dens[this.IX(i, j)];
                        if (d > 0.01) {
                            const alpha = map(d, 0, 1, 0, 200);
                            fill(255, 255, 255, alpha);
                            noStroke();
                            rect(i * scaleX, j * scaleY, scaleX, scaleY);
                        }
                    }
                }
                
                // Draw obstacle
                push();
                translate(this.obsX, this.obsY);
                rotate(radians(this.obsRot));
                
                fill(30, 30, 60);
                stroke(100, 150, 255);
                strokeWeight(3);
                
                switch(this.obsShape) {
                    case 'circle':
                        ellipse(0, 0, this.obsSize * 2, this.obsSize * 2);
                        break;
                    case 'ellipse':
                        ellipse(0, 0, this.obsSize * 2.5, this.obsSize * 1.2);
                        break;
                    case 'square':
                        rectMode(CENTER);
                        square(0, 0, this.obsSize * 1.8);
                        break;
                    case 'diamond':
                        rotate(45);
                        square(0, 0, this.obsSize * 1.8);
                        break;
                    case 'airfoil':
                        beginShape();
                        for (let a = 0; a < 360; a += 10) {
                            const r = this.obsSize * (1 + 0.3 * sin(a * 6));
                            vertex(cos(radians(a)) * r, sin(radians(a)) * r * 0.4);
                        }
                        endShape(CLOSE);
                        break;
                }
                pop();
            }
        }

        let sim;

        function setup() {
            createCanvas(1000, 600);
            colorMode(HSB, 360, 100, 100, 100);
            sim = new VortexStreetSimulation();
            
            // UI Controls
            document.getElementById('flowSpeed').addEventListener('input', (e) => {
                sim.flowSpeed = parseFloat(e.target.value);
                document.getElementById('speedVal').textContent = e.target.value;
            });
            
            document.getElementById('viscosity').addEventListener('input', (e) => {
                sim.visc = parseFloat(e.target.value);
                document.getElementById('viscVal').textContent = e.target.value;
            });
            
            document.getElementById('shape').addEventListener('change', (e) => {
                sim.obsShape = e.target.value;
            });
            
            document.getElementById('size').addEventListener('input', (e) => {
                sim.obsSize = parseFloat(e.target.value);
                document.getElementById('sizeVal').textContent = e.target.value;
            });
            
            document.getElementById('rotation').addEventListener('input', (e) => {
                sim.obsRot = parseFloat(e.target.value);
                document.getElementById('rotVal').textContent = e.target.value;
            });
        }

        function draw() {
            sim.step();
            sim.render();
        }

        function mousePressed() {
            sim.mousePressed = true;
            sim.shiftPressed = keyIsDown(SHIFT);
        }

        function mouseDragged() {
            if (sim.mousePressed) {
                if (sim.shiftPressed) {
                    // Rotate with Shift
                    const angle = atan2(mouseY - sim.obsY, mouseX - sim.obsX) - 
                                 atan2(pmouseY - sim.obsY, pmouseX - sim.obsX);
                    sim.obsRot += degrees(angle);
                    sim.obsRot = (sim.obsRot + 360) % 360;
                    document.getElementById('rotation').value = sim.obsRot;
                    document.getElementById('rotVal').textContent = sim.obsRot.toFixed(0);
                } else {
                    // Move obstacle
                    sim.obsX = mouseX;
                    sim.obsY = mouseY;
                }
            }
        }

        function mouseReleased() {
            sim.mousePressed = false;
        }

        function mouseWheel(event) {
            sim.obsSize = constrain(sim.obsSize - event.delta * 0.1, 15, 100);
            document.getElementById('size').value = sim.obsSize;
            document.getElementById('sizeVal').textContent = sim.obsSize.toFixed(0);
            return false;
        }

        function keyPressed() {
            if (key === ' ') {
                // Pause not implemented but easy to add
            }
            if (key === 'r' || key === 'R') {
                resetFlow();
            }
        }

        function resetFlow() {
            sim.initFlow();
        }

        function toggleUI() {
            document.getElementById('ui').classList.toggle('hidden');
            document.getElementById('toggleBtn').classList.toggle('shifted');
            document.getElementById('toggleBtn').textContent = 
                document.getElementById('ui').classList.contains('hidden') ? '▶' : '◀';
        }
    </script>
</body>
</html>