<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EcoBalance - The Ecosystem Building Game</title>
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2/dist/svg.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background: linear-gradient(135deg, #1a3a1a 0%, #0d2818 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            color: #fff;
        }
        
        h1 {
            color: #7bed9f;
            font-size: 28px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(123, 237, 159, 0.4);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #main-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1400px;
        }
        
        #game-board {
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            background: linear-gradient(145deg, #0f2419, #1a3a2a);
            border: 3px solid rgba(123, 237, 159, 0.3);
        }
        
        #side-panel {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 320px;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 18px;
            border-radius: 14px;
            border: 1px solid rgba(123, 237, 159, 0.2);
        }
        
        .panel h3 {
            color: #7bed9f;
            font-size: 14px;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .organism-palette {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .organism-btn {
            padding: 12px;
            border: 2px solid transparent;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            transition: all 0.3s;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .organism-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }
        
        .organism-btn.selected {
            border-color: #7bed9f;
            background: rgba(123, 237, 159, 0.2);
        }
        
        .organism-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .organism-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        .organism-btn span {
            font-size: 11px;
            color: #aaa;
        }
        
        .organism-btn .cost {
            font-size: 10px;
            color: #ffd93d;
        }
        
        .producer .organism-icon { background: linear-gradient(135deg, #26de81, #20bf6b); }
        .herbivore .organism-icon { background: linear-gradient(135deg, #45aaf2, #2d98da); }
        .carnivore .organism-icon { background: linear-gradient(135deg, #fc5c65, #eb3b5a); }
        .decomposer .organism-icon { background: linear-gradient(135deg, #a55eea, #8854d0); }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-box .value {
            font-size: 24px;
            font-weight: 700;
            font-family: 'Consolas', monospace;
        }
        
        .stat-box .label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            margin-top: 4px;
        }
        
        .stat-box.energy .value { color: #ffd93d; }
        .stat-box.biodiversity .value { color: #7bed9f; }
        .stat-box.balance .value { color: #45aaf2; }
        .stat-box.turn .value { color: #fc5c65; }
        
        .balance-bar {
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
            display: flex;
        }
        
        .balance-segment {
            height: 100%;
            transition: width 0.5s;
        }
        
        .balance-segment.producers { background: #26de81; }
        .balance-segment.herbivores { background: #45aaf2; }
        .balance-segment.carnivores { background: #fc5c65; }
        .balance-segment.decomposers { background: #a55eea; }
        
        .button-row {
            display: flex;
            gap: 10px;
        }
        
        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }
        
        .btn-green { background: linear-gradient(135deg, #26de81, #20bf6b); color: #000; }
        .btn-blue { background: linear-gradient(135deg, #45aaf2, #2d98da); color: #fff; }
        .btn-red { background: linear-gradient(135deg, #fc5c65, #eb3b5a); color: #fff; }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }
        
        #event-log {
            max-height: 120px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
        }
        
        .log-entry {
            font-size: 11px;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: #aaa;
        }
        
        .log-entry:last-child { border-bottom: none; }
        .log-entry.positive { color: #7bed9f; }
        .log-entry.negative { color: #fc5c65; }
        .log-entry.event { color: #ffd93d; }
        
        #tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            padding: 12px 16px;
            border-radius: 10px;
            font-size: 12px;
            max-width: 250px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            border: 1px solid rgba(123, 237, 159, 0.3);
        }
        
        #tooltip.visible { opacity: 1; }
        #tooltip h4 { color: #7bed9f; margin-bottom: 6px; }
        #tooltip p { color: #ccc; line-height: 1.5; }
        
        .info-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 10px;
            font-size: 11px;
            color: #888;
            line-height: 1.6;
        }
        
        .info-box strong { color: #7bed9f; }
        
        #game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        #game-over-modal.visible { display: flex; }
        
        .modal-content {
            background: linear-gradient(145deg, #1a3a2a, #0f2419);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 2px solid rgba(123, 237, 159, 0.3);
            max-width: 400px;
        }
        
        .modal-content h2 {
            color: #7bed9f;
            font-size: 28px;
            margin-bottom: 20px;
        }
        
        .modal-content p {
            color: #aaa;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        .final-score {
            font-size: 48px;
            color: #ffd93d;
            font-weight: 700;
            margin-bottom: 20px;
        }
        
        .grade {
            font-size: 72px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <h1>üåø EcoBalance - The Ecosystem Building Game</h1>
    
    <div id="main-container">
        <div id="game-board"></div>
        
        <div id="side-panel">
            <div class="panel">
                <h3>üìä Ecosystem Status</h3>
                <div class="stats-grid">
                    <div class="stat-box energy">
                        <div class="value" id="energyDisplay">100</div>
                        <div class="label">Energy ‚òÄÔ∏è</div>
                    </div>
                    <div class="stat-box biodiversity">
                        <div class="value" id="biodiversityDisplay">0</div>
                        <div class="label">Biodiversity üß¨</div>
                    </div>
                    <div class="stat-box balance">
                        <div class="value" id="balanceDisplay">0%</div>
                        <div class="label">Balance ‚öñÔ∏è</div>
                    </div>
                    <div class="stat-box turn">
                        <div class="value" id="turnDisplay">1</div>
                        <div class="label">Turn / 20</div>
                    </div>
                </div>
                <div class="balance-bar">
                    <div class="balance-segment producers" id="prodBar" style="width: 25%"></div>
                    <div class="balance-segment herbivores" id="herbBar" style="width: 25%"></div>
                    <div class="balance-segment carnivores" id="carnBar" style="width: 25%"></div>
                    <div class="balance-segment decomposers" id="decompBar" style="width: 25%"></div>
                </div>
            </div>
            
            <div class="panel">
                <h3>ü¶é Place Organism</h3>
                <div class="organism-palette">
                    <div class="organism-btn producer" data-type="producer" onclick="selectOrganism('producer')">
                        <div class="organism-icon">üå±</div>
                        <span>Producer</span>
                        <span class="cost">-5 Energy</span>
                    </div>
                    <div class="organism-btn herbivore" data-type="herbivore" onclick="selectOrganism('herbivore')">
                        <div class="organism-icon">üê∞</div>
                        <span>Herbivore</span>
                        <span class="cost">-10 Energy</span>
                    </div>
                    <div class="organism-btn carnivore" data-type="carnivore" onclick="selectOrganism('carnivore')">
                        <div class="organism-icon">ü¶ä</div>
                        <span>Carnivore</span>
                        <span class="cost">-15 Energy</span>
                    </div>
                    <div class="organism-btn decomposer" data-type="decomposer" onclick="selectOrganism('decomposer')">
                        <div class="organism-icon">üçÑ</div>
                        <span>Decomposer</span>
                        <span class="cost">-8 Energy</span>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h3>üéÆ Controls</h3>
                <div class="button-row">
                    <button class="btn-green" onclick="endTurn()">End Turn</button>
                    <button class="btn-blue" onclick="showRules()">Rules</button>
                    <button class="btn-red" onclick="restartGame()">Restart</button>
                </div>
            </div>
            
            <div class="panel">
                <h3>üìú Event Log</h3>
                <div id="event-log"></div>
            </div>
            
            <div class="panel">
                <div class="info-box">
                    <strong>üéØ Goal:</strong> Build a balanced ecosystem! 
                    Producers feed herbivores, herbivores feed carnivores, 
                    decomposers recycle energy. Keep balance for bonus points!
                </div>
            </div>
        </div>
    </div>
    
    <div id="tooltip">
        <h4 id="tooltip-title"></h4>
        <p id="tooltip-text"></p>
    </div>
    
    <div id="game-over-modal">
        <div class="modal-content">
            <h2>üåç Ecosystem Complete!</h2>
            <div class="grade" id="finalGrade">üåü</div>
            <div class="final-score" id="finalScore">0</div>
            <p id="finalMessage">Your ecosystem assessment...</p>
            <button class="btn-green" onclick="restartGame()" style="width: 100%;">Play Again</button>
        </div>
    </div>

    <script>
        // ==================== GAME CONFIGURATION ====================
        const BOARD_SIZE = 600;
        const HEX_RADIUS = 45;
        const GRID_RINGS = 3;
        const MAX_TURNS = 20;
        
        // Organism costs and properties
        const ORGANISMS = {
            producer: {
                name: 'Producer',
                emoji: 'üå±',
                cost: 5,
                color: '#26de81',
                energyGain: 3,
                description: 'Plants and algae that convert sunlight to energy. Foundation of food chains.',
                foodSource: null,
                predators: ['herbivore']
            },
            herbivore: {
                name: 'Herbivore',
                emoji: 'üê∞',
                cost: 10,
                color: '#45aaf2',
                energyGain: 2,
                description: 'Animals that eat plants. They need producers nearby to survive.',
                foodSource: 'producer',
                predators: ['carnivore']
            },
            carnivore: {
                name: 'Carnivore',
                emoji: 'ü¶ä',
                cost: 15,
                color: '#fc5c65',
                energyGain: 1,
                description: 'Predators that eat herbivores. Top of the food chain.',
                foodSource: 'herbivore',
                predators: []
            },
            decomposer: {
                name: 'Decomposer',
                emoji: 'üçÑ',
                cost: 8,
                color: '#a55eea',
                energyGain: 2,
                description: 'Fungi and bacteria that recycle nutrients. Essential for ecosystem health.',
                foodSource: null,
                predators: []
            }
        };
        
        // Biome types
        const BIOMES = {
            forest: { name: 'Forest', color: '#1a472a', bonus: 'producer' },
            grassland: { name: 'Grassland', color: '#3d5c2f', bonus: 'herbivore' },
            wetland: { name: 'Wetland', color: '#1a3a4a', bonus: 'decomposer' },
            rocky: { name: 'Rocky', color: '#4a3a2a', bonus: 'carnivore' }
        };
        
        // Random events
        const EVENTS = [
            { name: 'Drought', effect: 'producers', change: -1, message: '‚òÄÔ∏è Drought! Some plants withered.' },
            { name: 'Disease', effect: 'herbivores', change: -1, message: 'ü¶† Disease spread among herbivores!' },
            { name: 'Abundant Rain', effect: 'producers', change: 1, message: 'üåßÔ∏è Rain! Plants flourish!' },
            { name: 'Migration', effect: 'herbivores', change: 1, message: 'ü¶å New herbivores migrated in!' },
            { name: 'Predator Boom', effect: 'carnivores', change: 1, message: 'üê∫ Carnivore population growing!' },
            { name: 'Fungal Bloom', effect: 'decomposers', change: 1, message: 'üçÑ Decomposers thriving!' }
        ];
        
        // ==================== GAME STATE ====================
        let draw;
        let hexCells = [];
        let selectedOrganism = null;
        let energy = 100;
        let turn = 1;
        let gameOver = false;
        
        let organisms = {
            producer: 0,
            herbivore: 0,
            carnivore: 0,
            decomposer: 0
        };
        
        // ==================== SVG.JS SETUP ====================
        function initBoard() {
            draw = SVG().addTo('#game-board').size(BOARD_SIZE, BOARD_SIZE);
            
            // Background gradient
            const gradient = draw.gradient('radial', function(add) {
                add.stop(0, '#1a3a2a');
                add.stop(1, '#0d1f14');
            });
            draw.rect(BOARD_SIZE, BOARD_SIZE).fill(gradient);
            
            // Create hexagonal grid
            createHexGrid();
            
            // Add decorative elements
            addDecorations();
        }
        
        function createHexGrid() {
            const centerX = BOARD_SIZE / 2;
            const centerY = BOARD_SIZE / 2;
            
            // Cube coordinates for hex grid
            const directions = [
                [1, -1, 0], [1, 0, -1], [0, 1, -1],
                [-1, 1, 0], [-1, 0, 1], [0, -1, 1]
            ];
            
            function cubeToPixel(q, r) {
                const x = HEX_RADIUS * (3/2 * q);
                const y = HEX_RADIUS * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
                return { x: centerX + x, y: centerY + y };
            }
            
            function getHexPoints(cx, cy, radius) {
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i - Math.PI / 6;
                    points.push([
                        cx + radius * Math.cos(angle),
                        cy + radius * Math.sin(angle)
                    ]);
                }
                return points;
            }
            
            // Generate all hex positions
            const hexPositions = [[0, 0]];
            
            for (let ring = 1; ring <= GRID_RINGS; ring++) {
                let q = ring, r = -ring, s = 0;
                
                for (let dir = 0; dir < 6; dir++) {
                    for (let step = 0; step < ring; step++) {
                        hexPositions.push([q, r]);
                        q += directions[dir][0];
                        r += directions[dir][1];
                        s += directions[dir][2];
                    }
                }
            }
            
            // Create hex cells
            const biomeTypes = Object.keys(BIOMES);
            
            hexPositions.forEach((pos, index) => {
                const pixel = cubeToPixel(pos[0], pos[1]);
                const points = getHexPoints(pixel.x, pixel.y, HEX_RADIUS - 2);
                
                const biomeType = biomeTypes[index % biomeTypes.length];
                const biome = BIOMES[biomeType];
                
                // Create hex group
                const hexGroup = draw.group();
                
                // Hex background
                const hex = hexGroup.polygon(points.flat())
                    .fill(biome.color)
                    .stroke({ color: '#2a5a3a', width: 2 })
                    .attr('cursor', 'pointer');
                
                // Subtle pattern
                const innerHex = hexGroup.polygon(getHexPoints(pixel.x, pixel.y, HEX_RADIUS - 15).flat())
                    .fill('none')
                    .stroke({ color: 'rgba(255,255,255,0.1)', width: 1 });
                
                // Organism placeholder
                const organismGroup = hexGroup.group();
                
                const cellData = {
                    group: hexGroup,
                    hex: hex,
                    organismGroup: organismGroup,
                    x: pixel.x,
                    y: pixel.y,
                    q: pos[0],
                    r: pos[1],
                    biome: biomeType,
                    organism: null,
                    organisms: []
                };
                
                // Click handler
                hex.click(() => placeOrganism(cellData));
                
                // Hover effects
                hex.mouseover(() => {
                    if (!cellData.organism || selectedOrganism) {
                        hex.fill({ color: lightenColor(biome.color, 20) });
                    }
                    showTooltip(cellData);
                });
                
                hex.mouseout(() => {
                    hex.fill(biome.color);
                    hideTooltip();
                });
                
                hexCells.push(cellData);
            });
        }
        
        function addDecorations() {
            // Title ring
            const ring = draw.circle(BOARD_SIZE - 40)
                .center(BOARD_SIZE / 2, BOARD_SIZE / 2)
                .fill('none')
                .stroke({ color: 'rgba(123, 237, 159, 0.2)', width: 2, dasharray: '10,5' });
            
            // Animate ring
            ring.animate(20000, '<>').ease('<>').rotate(360).loop();
        }
        
        function lightenColor(hex, percent) {
            const num = parseInt(hex.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return `rgb(${R},${G},${B})`;
        }
        
        // ==================== GAME LOGIC ====================
        function selectOrganism(type) {
            if (gameOver) return;
            
            const cost = ORGANISMS[type].cost;
            if (energy < cost) {
                addLogEntry(`Not enough energy for ${ORGANISMS[type].name}!`, 'negative');
                return;
            }
            
            selectedOrganism = type;
            
            // Update UI
            document.querySelectorAll('.organism-btn').forEach(btn => {
                btn.classList.remove('selected');
                if (btn.dataset.type === type) {
                    btn.classList.add('selected');
                }
            });
        }
        
        function placeOrganism(cell) {
            if (gameOver || !selectedOrganism) return;
            
            const orgData = ORGANISMS[selectedOrganism];
            
            // Check if cell already has max organisms (3)
            if (cell.organisms.length >= 3) {
                addLogEntry('This habitat is full!', 'negative');
                return;
            }
            
            // Check food chain requirements
            if (selectedOrganism === 'herbivore') {
                const hasProducerNearby = checkNearbyOrganism(cell, 'producer');
                if (!hasProducerNearby && organisms.producer < 2) {
                    addLogEntry('Herbivores need producers nearby!', 'negative');
                    return;
                }
            }
            
            if (selectedOrganism === 'carnivore') {
                const hasHerbivoreNearby = checkNearbyOrganism(cell, 'herbivore');
                if (!hasHerbivoreNearby && organisms.herbivore < 2) {
                    addLogEntry('Carnivores need herbivores nearby!', 'negative');
                    return;
                }
            }
            
            // Deduct energy
            energy -= orgData.cost;
            
            // Add organism to cell
            cell.organisms.push(selectedOrganism);
            organisms[selectedOrganism]++;
            
            // Draw organism
            drawOrganism(cell, selectedOrganism);
            
            // Check for biome bonus
            const biome = BIOMES[cell.biome];
            if (biome.bonus === selectedOrganism) {
                energy += 3;
                addLogEntry(`üéÅ Biome bonus! +3 energy`, 'positive');
            }
            
            addLogEntry(`Placed ${orgData.emoji} ${orgData.name}`, 'positive');
            
            // Update display
            updateDisplay();
            
            // Clear selection
            selectedOrganism = null;
            document.querySelectorAll('.organism-btn').forEach(btn => btn.classList.remove('selected'));
        }
        
        function drawOrganism(cell, type) {
            const orgData = ORGANISMS[type];
            const count = cell.organisms.length;
            
            // Position offset based on count
            const offsets = [
                { x: 0, y: 0 },
                { x: -12, y: 8 },
                { x: 12, y: 8 }
            ];
            
            const offset = offsets[count - 1];
            
            // Create organism group
            const orgGroup = cell.organismGroup.group();
            
            // Background circle
            const bg = orgGroup.circle(28)
                .center(cell.x + offset.x, cell.y + offset.y)
                .fill(orgData.color)
                .stroke({ color: '#fff', width: 2 });
            
            // Emoji
            const emoji = orgGroup.text(orgData.emoji)
                .font({ size: 16, anchor: 'middle' })
                .center(cell.x + offset.x, cell.y + offset.y);
            
            // Animate appearance
            orgGroup.scale(0).animate(300).scale(1);
            bg.animate(2000, '<>').attr({ opacity: 0.8 }).animate(2000, '<>').attr({ opacity: 1 }).loop();
        }
        
        function checkNearbyOrganism(cell, type) {
            const directions = [
                [1, 0], [0, 1], [-1, 1],
                [-1, 0], [0, -1], [1, -1]
            ];
            
            for (let dir of directions) {
                const neighbor = hexCells.find(c => 
                    c.q === cell.q + dir[0] && c.r === cell.r + dir[1]
                );
                
                if (neighbor && neighbor.organisms.includes(type)) {
                    return true;
                }
            }
            
            // Also check the cell itself
            return cell.organisms.includes(type);
        }
        
        function endTurn() {
            if (gameOver) return;
            
            // Process ecosystem
            processEcosystem();
            
            // Random event (30% chance)
            if (Math.random() < 0.3) {
                triggerRandomEvent();
            }
            
            // Gain energy from organisms
            let energyGain = 0;
            for (let type in organisms) {
                energyGain += organisms[type] * ORGANISMS[type].energyGain;
            }
            
            // Balance bonus
            const balance = calculateBalance();
            if (balance > 70) {
                energyGain += Math.floor(balance / 20);
                addLogEntry(`‚öñÔ∏è Balance bonus! +${Math.floor(balance / 20)} energy`, 'positive');
            }
            
            energy += energyGain;
            energy = Math.min(energy, 200); // Cap energy
            
            addLogEntry(`Turn ${turn} ended. +${energyGain} energy`, 'positive');
            
            turn++;
            
            if (turn > MAX_TURNS) {
                endGame();
            }
            
            updateDisplay();
        }
        
        function processEcosystem() {
            // Check for starvation
            hexCells.forEach(cell => {
                cell.organisms.forEach((org, index) => {
                    if (org === 'herbivore' && organisms.producer < organisms.herbivore / 2) {
                        // Herbivore might starve
                        if (Math.random() < 0.3) {
                            removeOrganism(cell, index);
                            addLogEntry('üê∞ A herbivore starved!', 'negative');
                        }
                    }
                    if (org === 'carnivore' && organisms.herbivore < organisms.carnivore) {
                        // Carnivore might starve
                        if (Math.random() < 0.3) {
                            removeOrganism(cell, index);
                            addLogEntry('ü¶ä A carnivore starved!', 'negative');
                        }
                    }
                });
            });
            
            // Decomposers recycle
            if (organisms.decomposer > 0 && Math.random() < 0.3) {
                energy += organisms.decomposer;
                addLogEntry(`üçÑ Decomposers recycled +${organisms.decomposer} energy`, 'positive');
            }
        }
        
        function removeOrganism(cell, index) {
            const type = cell.organisms[index];
            cell.organisms.splice(index, 1);
            organisms[type]--;
            
            // Redraw cell
            cell.organismGroup.clear();
            cell.organisms.forEach((org, i) => {
                // Recreate remaining organisms
                const tempOrg = cell.organisms[i];
                cell.organisms = cell.organisms.slice(0, i);
                cell.organisms.push(tempOrg);
                // Note: simplified - in production would need proper redraw
            });
        }
        
        function triggerRandomEvent() {
            const event = EVENTS[Math.floor(Math.random() * EVENTS.length)];
            addLogEntry(event.message, 'event');
            
            // Apply effect
            if (event.change > 0 && organisms[event.effect.slice(0, -1)] > 0) {
                // Positive effect - add organism to random cell
                const emptyCells = hexCells.filter(c => c.organisms.length < 3);
                if (emptyCells.length > 0) {
                    const cell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    const type = event.effect.slice(0, -1); // Remove 's'
                    cell.organisms.push(type);
                    organisms[type]++;
                    drawOrganism(cell, type);
                }
            } else if (event.change < 0) {
                // Negative effect - remove organism
                const type = event.effect.slice(0, -1);
                for (let cell of hexCells) {
                    const idx = cell.organisms.indexOf(type);
                    if (idx !== -1) {
                        cell.organisms.splice(idx, 1);
                        organisms[type]--;
                        cell.organismGroup.clear();
                        // Redraw remaining
                        const remaining = [...cell.organisms];
                        cell.organisms = [];
                        remaining.forEach(org => {
                            cell.organisms.push(org);
                            drawOrganism(cell, org);
                        });
                        break;
                    }
                }
            }
            
            updateDisplay();
        }
        
        function calculateBalance() {
            const total = Object.values(organisms).reduce((a, b) => a + b, 0);
            if (total === 0) return 0;
            
            // Ideal ratio: 40% producers, 30% herbivores, 20% carnivores, 10% decomposers
            const ideal = {
                producer: 0.4,
                herbivore: 0.3,
                carnivore: 0.2,
                decomposer: 0.1
            };
            
            let score = 100;
            for (let type in organisms) {
                const actual = organisms[type] / total;
                const diff = Math.abs(ideal[type] - actual);
                score -= diff * 100;
            }
            
            return Math.max(0, Math.min(100, score));
        }
        
        function calculateBiodiversity() {
            let diversity = 0;
            const typesPresent = Object.values(organisms).filter(n => n > 0).length;
            
            // Base points for variety
            diversity += typesPresent * 10;
            
            // Points for total organisms
            const total = Object.values(organisms).reduce((a, b) => a + b, 0);
            diversity += total * 2;
            
            // Bonus for balance
            diversity += calculateBalance() / 5;
            
            return Math.floor(diversity);
        }
        
        // ==================== UI FUNCTIONS ====================
        function updateDisplay() {
            document.getElementById('energyDisplay').textContent = energy;
            document.getElementById('turnDisplay').textContent = turn;
            document.getElementById('biodiversityDisplay').textContent = calculateBiodiversity();
            document.getElementById('balanceDisplay').textContent = Math.floor(calculateBalance()) + '%';
            
            // Update balance bar
            const total = Object.values(organisms).reduce((a, b) => a + b, 0) || 1;
            document.getElementById('prodBar').style.width = (organisms.producer / total * 100) + '%';
            document.getElementById('herbBar').style.width = (organisms.herbivore / total * 100) + '%';
            document.getElementById('carnBar').style.width = (organisms.carnivore / total * 100) + '%';
            document.getElementById('decompBar').style.width = (organisms.decomposer / total * 100) + '%';
            
            // Update organism buttons
            document.querySelectorAll('.organism-btn').forEach(btn => {
                const type = btn.dataset.type;
                const cost = ORGANISMS[type].cost;
                btn.classList.toggle('disabled', energy < cost);
            });
        }
        
        function addLogEntry(message, type = '') {
            const log = document.getElementById('event-log');
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.textContent = `[${turn}] ${message}`;
            log.insertBefore(entry, log.firstChild);
            
            // Keep only last 20 entries
            while (log.children.length > 20) {
                log.removeChild(log.lastChild);
            }
        }
        
        function showTooltip(cell) {
            const tooltip = document.getElementById('tooltip');
            const biome = BIOMES[cell.biome];
            
            let content = `<strong>Biome:</strong> ${biome.name}<br>`;
            content += `<strong>Bonus:</strong> +3 energy for ${ORGANISMS[biome.bonus].name}<br>`;
            
            if (cell.organisms.length > 0) {
                content += `<strong>Organisms:</strong> `;
                content += cell.organisms.map(o => ORGANISMS[o].emoji).join(' ');
            } else {
                content += '<em>Empty - click to place organism</em>';
            }
            
            document.getElementById('tooltip-title').textContent = biome.name + ' Habitat';
            document.getElementById('tooltip-text').innerHTML = content;
            
            tooltip.classList.add('visible');
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }
        
        document.addEventListener('mousemove', (e) => {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.left = (e.clientX + 15) + 'px';
            tooltip.style.top = (e.clientY + 15) + 'px';
        });
        
        function showRules() {
            alert(`üåø EcoBalance Rules üåø

üéØ GOAL: Build a balanced, diverse ecosystem in 20 turns!

üìã ORGANISMS:
üå± Producers (5‚ö°) - Plants that create energy
üê∞ Herbivores (10‚ö°) - Eat producers, need them nearby
ü¶ä Carnivores (15‚ö°) - Eat herbivores, need them nearby  
üçÑ Decomposers (8‚ö°) - Recycle energy each turn

‚öñÔ∏è BALANCE:
‚Ä¢ Ideal ratio: 40% producers, 30% herbivores, 20% carnivores, 10% decomposers
‚Ä¢ Good balance = bonus energy!
‚Ä¢ Poor balance = organisms may starve!

üéÅ BIOME BONUSES:
‚Ä¢ Placing the right organism in matching biome = +3 energy

üé≤ RANDOM EVENTS:
‚Ä¢ Each turn may trigger weather, disease, or migration!

Score = Biodiversity √ó Balance √ó Survival Bonus`);
        }
        
        function endGame() {
            gameOver = true;
            
            const biodiversity = calculateBiodiversity();
            const balance = calculateBalance();
            const total = Object.values(organisms).reduce((a, b) => a + b, 0);
            
            const score = Math.floor(biodiversity * (balance / 50) * (1 + total / 20));
            
            let grade, message;
            if (score >= 150) {
                grade = 'üèÜ';
                message = 'Master Ecologist! Your ecosystem is thriving and perfectly balanced!';
            } else if (score >= 100) {
                grade = 'üåü';
                message = 'Great job! Your ecosystem is healthy and sustainable!';
            } else if (score >= 60) {
                grade = 'üå±';
                message = 'Good effort! Your ecosystem needs some balance adjustments.';
            } else {
                grade = 'üçÇ';
                message = 'Keep learning! Remember: balance is key to ecosystem health.';
            }
            
            document.getElementById('finalGrade').textContent = grade;
            document.getElementById('finalScore').textContent = score + ' pts';
            document.getElementById('finalMessage').textContent = message;
            document.getElementById('game-over-modal').classList.add('visible');
        }
        
        function restartGame() {
            // Clear board
            if (draw) draw.clear();
            hexCells = [];
            selectedOrganism = null;
            energy = 100;
            turn = 1;
            gameOver = false;
            organisms = { producer: 0, herbivore: 0, carnivore: 0, decomposer: 0 };
            
            document.getElementById('event-log').innerHTML = '';
            document.getElementById('game-over-modal').classList.remove('visible');
            
            // Reinitialize
            initBoard();
            updateDisplay();
            addLogEntry('üåç New ecosystem started!', 'positive');
        }
        
        // ==================== INITIALIZATION ====================
        window.onload = function() {
            initBoard();
            updateDisplay();
            addLogEntry('üåç Welcome to EcoBalance!', 'positive');
            addLogEntry('Select an organism and click a tile to place it.', '');
        };
    </script>
</body>
</html>