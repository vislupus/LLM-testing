<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pirate Island Defense - Babylon.js Prototype</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at top, #3a6ea5 0, #020817 60%);
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    color: #f9fafb;
  }
  #renderCanvas {
    width: 100%;
    height: 100%;
    touch-action: none;
    display: block;
  }
  #uiRoot {
    position: fixed;
    inset: 0;
    pointer-events: none;
  }
  .panel {
    pointer-events: auto;
    background: rgba(15, 23, 42, 0.85);
    border-radius: 8px;
    padding: 8px 12px;
    border: 1px solid rgba(148, 163, 184, 0.5);
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    backdrop-filter: blur(8px);
    color: #e5e7eb;
    font-size: 13px;
  }
  #topPanel {
    position: absolute;
    top: 10px;
    left: 10px;
    display: flex;
    gap: 12px;
    align-items: center;
  }
  #topPanel span.label {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: #9ca3af;
    margin-right: 4px;
  }
  #topPanel span.value {
    font-weight: 600;
    color: #f9fafb;
  }
  #shipPanel {
    position: absolute;
    bottom: 10px;
    left: 10px;
    min-width: 260px;
  }
  #shipPanel h3 {
    margin: 0 0 4px;
    font-size: 13px;
    color: #fbbf24;
  }
  #shipPanel small {
    color: #9ca3af;
  }
  #shipStats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 4px;
    margin-top: 6px;
    margin-bottom: 6px;
  }
  #shipStats div {
    font-size: 11px;
  }
  .upgrade-buttons {
    display: grid;
    grid-template-columns: 1fr;
    gap: 4px;
    margin-top: 4px;
  }
  button.upgrade {
    width: 100%;
    padding: 4px 8px;
    background: #1d4ed8;
    border-radius: 4px;
    border: 1px solid #2563eb;
    color: #e5e7eb;
    font-size: 11px;
    cursor: pointer;
    text-align: left;
  }
  button.upgrade span.cost {
    float: right;
    color: #facc15;
  }
  button.upgrade:disabled {
    background: #111827;
    border-color: #374151;
    color: #6b7280;
    cursor: default;
  }
  #wavePanel {
    position: absolute;
    top: 10px;
    right: 10px;
    min-width: 220px;
    text-align: center;
  }
  #wavePanel h3 {
    margin: 0 0 4px;
    font-size: 13px;
    color: #a5b4fc;
  }
  #waveInfo {
    font-size: 12px;
    margin-bottom: 6px;
    color: #d1d5db;
  }
  #nextWaveBtn {
    padding: 6px 12px;
    border-radius: 999px;
    border: 1px solid #22c55e;
    background: #16a34a;
    color: #ecfdf5;
    font-size: 12px;
    cursor: pointer;
    font-weight: 600;
  }
  #nextWaveBtn:disabled {
    background: #064e3b;
    border-color: #064e3b;
    color: #6ee7b7;
    opacity: 0.6;
    cursor: default;
  }
  #hint {
    font-size: 11px;
    color: #9ca3af;
    margin-top: 4px;
  }
  #gameOverOverlay {
    position: absolute;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: radial-gradient(circle at top, rgba(15,23,42,0.9), rgba(15,23,42,0.98));
    pointer-events: auto;
    z-index: 10;
  }
  #gameOverOverlay.active {
    display: flex;
  }
  #gameOverCard {
    background: rgba(15, 23, 42, 0.95);
    border-radius: 12px;
    padding: 20px 24px;
    border: 1px solid rgba(148, 163, 184, 0.6);
    text-align: center;
    max-width: 340px;
  }
  #gameOverCard h2 {
    margin: 0 0 6px;
    font-size: 22px;
    color: #fecaca;
  }
  #gameOverCard p {
    margin: 4px 0;
    font-size: 13px;
    color: #e5e7eb;
  }
  #restartBtn {
    margin-top: 12px;
    padding: 8px 18px;
    border-radius: 999px;
    border: 1px solid #f97316;
    background: #f97316;
    color: #111827;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
  }
  #restartBtn:hover {
    filter: brightness(1.1);
  }
  #controlsHelp {
    position: absolute;
    bottom: 10px;
    right: 10px;
    font-size: 11px;
    color: #9ca3af;
    background: rgba(15,23,42,0.7);
    border-radius: 8px;
    padding: 6px 8px;
    border: 1px solid rgba(55,65,81,0.8);
    pointer-events: none;
  }
  #controlsHelp div {
    margin-bottom: 2px;
  }
  #controlsHelp span.key {
    display: inline-block;
    padding: 1px 5px;
    margin-right: 2px;
    border-radius: 3px;
    background: rgba(31,41,55,0.9);
    border: 1px solid rgba(75,85,99,0.8);
    color: #e5e7eb;
    font-size: 10px;
  }
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<div id="uiRoot">
  <div id="topPanel" class="panel">
    <div><span class="label">Gold</span><span class="value" id="goldText">0</span></div>
    <div><span class="label">Wave</span><span class="value" id="waveText">0</span></div>
    <div><span class="label">Island HP</span><span class="value" id="hpText">100</span></div>
  </div>

  <div id="shipPanel" class="panel">
    <h3>Selected Ship: <span id="selectedShipName">None</span></h3>
    <small>Press 1â€“3 to select a ship. Use A/D + W/S to steer.</small>
    <div id="shipStats">
      <div>DMG: <span id="statDamage">-</span></div>
      <div>Fire/s: <span id="statFireRate">-</span></div>
      <div>Speed: <span id="statSpeed">-</span></div>
    </div>
    <div class="upgrade-buttons">
      <button class="upgrade" id="upgradeDamageBtn">
        Upgrade Damage <span class="cost" id="costDamage">50g</span>
      </button>
      <button class="upgrade" id="upgradeFireRateBtn">
        Upgrade Fire Rate <span class="cost" id="costFireRate">60g</span>
      </button>
      <button class="upgrade" id="upgradeSpeedBtn">
        Upgrade Speed <span class="cost" id="costSpeed">40g</span>
      </button>
    </div>
  </div>

  <div id="wavePanel" class="panel">
    <h3>Waves</h3>
    <div id="waveInfo">Press "Start Wave" to begin.</div>
    <button id="nextWaveBtn">Start Wave</button>
    <div id="hint">Earn gold by sinking enemy ships.<br>Upgrade between waves.</div>
  </div>

  <div id="controlsHelp">
    <div><span class="key">1</span><span class="key">2</span><span class="key">3</span> select ships</div>
    <div><span class="key">W/S</span> move, <span class="key">A/D</span> turn</div>
    <div><span class="key">Space</span> manual fire, <span class="key">C</span> toggle auto</div>
    <div><span class="key">Mouse</span> orbit camera</div>
  </div>

  <div id="gameOverOverlay">
    <div id="gameOverCard">
      <h2>Island Lost</h2>
      <p>Your brave pirate crews fought well, but the island has fallen.</p>
      <p>Final Wave: <span id="finalWaveText">0</span> &nbsp; | &nbsp; Gold: <span id="finalGoldText">0</span></p>
      <button id="restartBtn">Restart Defense</button>
    </div>
  </div>
</div>

<!-- Babylon.js from CDN (no other external assets needed) -->
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script>
(function () {
  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

  // UI elements
  const goldText = document.getElementById("goldText");
  const waveText = document.getElementById("waveText");
  const hpText   = document.getElementById("hpText");
  const selectedShipName = document.getElementById("selectedShipName");
  const statDamage = document.getElementById("statDamage");
  const statFireRate = document.getElementById("statFireRate");
  const statSpeed = document.getElementById("statSpeed");
  const nextWaveBtn = document.getElementById("nextWaveBtn");
  const waveInfo = document.getElementById("waveInfo");
  const costDamageText = document.getElementById("costDamage");
  const costFireRateText = document.getElementById("costFireRate");
  const costSpeedText = document.getElementById("costSpeed");
  const upgradeDamageBtn = document.getElementById("upgradeDamageBtn");
  const upgradeFireRateBtn = document.getElementById("upgradeFireRateBtn");
  const upgradeSpeedBtn = document.getElementById("upgradeSpeedBtn");
  const gameOverOverlay = document.getElementById("gameOverOverlay");
  const finalWaveText = document.getElementById("finalWaveText");
  const finalGoldText = document.getElementById("finalGoldText");
  const restartBtn = document.getElementById("restartBtn");

  // Game state
  let scene;
  let islandMesh;
  let islandRadius = 10;
  let islandMaxHP = 100;
  let islandHP = islandMaxHP;

  const friendlyShips = [];
  const enemyShips = [];
  const projectiles = [];

  let selectedShipIndex = -1;

  let gold = 0;
  let wave = 0;
  let waveInProgress = false;
  let enemiesToSpawn = 0;
  let enemiesSpawned = 0;
  let spawnInterval = 2500; // ms
  let spawnTimer = 0;
  let baseEnemyHP = 20;
  let baseEnemySpeed = 3;
  let baseEnemyDamage = 8;

  let autoFireEnabled = true;

  // Movement input
  const inputState = {
    forward: 0,
    turn: 0,
    manualFire: false
  };

  const baseShipStats = {
    damage: 10,
    fireRate: 1.2, // shots per second
    moveSpeed: 6,
    range: 40
  };

  const upgradeCosts = {
    damage: 50,
    fireRate: 60,
    speed: 40
  };

  function createScene() {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.02, 0.06, 0.18, 1);

    const camera = new BABYLON.ArcRotateCamera(
      "camera",
      Math.PI * 1.1,
      1.0,
      50,
      new BABYLON.Vector3(0, 3, 0),
      scene
    );
    camera.lowerBetaLimit = 0.3;
    camera.upperBetaLimit = 1.3;
    camera.lowerRadiusLimit = 25;
    camera.upperRadiusLimit = 80;
    camera.wheelDeltaPercentage = 0.01;
    camera.panningSensibility = 0;
    camera.attachControl(canvas, true);

    const light = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0.3, 1, 0.2), scene);
    light.intensity = 0.85;
    light.groundColor = new BABYLON.Color3(0.02, 0.02, 0.04);

    // Directional light for highlights
    const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-0.5, -1, -0.25), scene);
    dirLight.position = new BABYLON.Vector3(40, 40, 20);
    dirLight.intensity = 0.4;

    // Stylized water plane
    const water = BABYLON.MeshBuilder.CreateGround("water", {
      width: 400,
      height: 400,
      subdivisions: 100
    }, scene);
    water.position.y = 0;
    const waterMat = new BABYLON.StandardMaterial("waterMat", scene);
    waterMat.diffuseColor = new BABYLON.Color3(0.03, 0.35, 0.6);
    waterMat.specularColor = new BABYLON.Color3(0.8, 0.9, 1.0);
    waterMat.emissiveColor = new BABYLON.Color3(0.0, 0.1, 0.2);
    waterMat.backFaceCulling = false;
    water.material = waterMat;

    const waterPositions = water.getVerticesData(BABYLON.VertexBuffer.PositionKind);
    const baseWaterPositions = waterPositions.slice();

    // Island ground
    islandMesh = BABYLON.MeshBuilder.CreateGround("island", {
      width: 30,
      height: 30,
      subdivisions: 50
    }, scene);
    islandMesh.position.y = 0.5;
    const islandPositions = islandMesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);

    for (let i = 0; i < islandPositions.length; i += 3) {
      const x = islandPositions[i];
      const z = islandPositions[i + 2];
      const dist = Math.sqrt(x * x + z * z);
      const maxRadius = 11;
      let y;
      if (dist < maxRadius) {
        const t = dist / maxRadius;
        y = Math.cos(t * Math.PI * 0.5) * 4 - 0.3;
      } else {
        y = -1.5; // under water
      }
      islandPositions[i + 1] = y;
    }
    islandMesh.updateVerticesData(BABYLON.VertexBuffer.PositionKind, islandPositions);
    const islandMat = new BABYLON.StandardMaterial("islandMat", scene);
    islandMat.diffuseColor = new BABYLON.Color3(0.1, 0.6, 0.25);
    islandMat.specularColor = new BABYLON.Color3(0.02, 0.1, 0.02);
    islandMesh.material = islandMat;
    islandRadius = 9.5;

    // Simple "beach" ring via decal-like disc
    const beach = BABYLON.MeshBuilder.CreateDisc("beach", {
      radius: islandRadius + 0.7,
      tessellation: 48
    }, scene);
    beach.position.y = 0.25;
    beach.rotation.x = Math.PI / 2;
    const beachMat = new BABYLON.StandardMaterial("beachMat", scene);
    beachMat.diffuseColor = new BABYLON.Color3(0.92, 0.8, 0.55);
    beachMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
    beachMat.alpha = 0.9;
    beach.material = beachMat;

    // Palms and rocks
    const palmTrunkMat = new BABYLON.StandardMaterial("palmTrunkMat", scene);
    palmTrunkMat.diffuseColor = new BABYLON.Color3(0.36, 0.21, 0.1);

    const palmLeafMat = new BABYLON.StandardMaterial("palmLeafMat", scene);
    palmLeafMat.diffuseColor = new BABYLON.Color3(0.13, 0.7, 0.35);
    palmLeafMat.backFaceCulling = false;

    for (let i = 0; i < 4; i++) {
      const angle = Math.PI * 0.5 * i + Math.PI / 6;
      const r = 4 + Math.random() * 2;
      const px = Math.cos(angle) * r;
      const pz = Math.sin(angle) * r;

      const trunk = BABYLON.MeshBuilder.CreateCylinder("palmTrunk" + i, {
        height: 5 + Math.random() * 1,
        diameterTop: 0.25,
        diameterBottom: 0.4
      }, scene);
      trunk.position.set(px, 1.8, pz);
      trunk.rotation.z = (Math.random() - 0.5) * 0.3;
      trunk.material = palmTrunkMat;

      for (let j = 0; j < 4; j++) {
        const leaf = BABYLON.MeshBuilder.CreatePlane("leaf" + i + "_" + j, { size: 3 }, scene);
        leaf.position = trunk.position.add(new BABYLON.Vector3(0, 2.5, 0));
        leaf.rotation.y = (Math.PI / 2) * j + Math.random() * 0.5;
        leaf.rotation.x = -Math.PI / 3;
        leaf.material = palmLeafMat;
      }
    }

    const rockMat = new BABYLON.StandardMaterial("rockMat", scene);
    rockMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.45);
    rockMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
    for (let i = 0; i < 5; i++) {
      const angle = Math.random() * Math.PI * 2;
      const r = 1.5 + Math.random() * 2.5;
      const px = Math.cos(angle) * r;
      const pz = Math.sin(angle) * r;
      const rock = BABYLON.MeshBuilder.CreateSphere("rock" + i, { diameter: 1 + Math.random() }, scene);
      rock.position.set(px, 0.5 + Math.random() * 0.3, pz);
      rock.scaling.y = 0.6 + Math.random() * 0.4;
      rock.material = rockMat;
    }

    // Ship materials
    const friendlyMat = new BABYLON.StandardMaterial("friendlyMat", scene);
    friendlyMat.diffuseColor = new BABYLON.Color3(0.83, 0.7, 0.5);

    const enemyMat = new BABYLON.StandardMaterial("enemyMat", scene);
    enemyMat.diffuseColor = new BABYLON.Color3(0.7, 0.15, 0.15);

    // Create friendly ships in a ring around island
    const radius = islandRadius + 9;
    const angles = [0, (2 * Math.PI) / 3, (4 * Math.PI) / 3];
    for (let i = 0; i < 3; i++) {
      const angle = angles[i];
      const ship = createShipMesh("friendly" + (i + 1), friendlyMat, scene);
      ship.root.position.set(
        Math.cos(angle) * radius,
        0.3,
        Math.sin(angle) * radius
      );
      ship.root.rotation.y = angle + Math.PI; // face center
      ship.isFriendly = true;
      ship.stats = {
        damage: baseShipStats.damage,
        fireRate: baseShipStats.fireRate,
        moveSpeed: baseShipStats.moveSpeed,
        range: baseShipStats.range
      };
      ship.fireCooldown = 0;
      ship.id = i + 1;
      friendlyShips.push(ship);
    }

    // Projectile material
    const cannonMat = new BABYLON.StandardMaterial("cannonMat", scene);
    cannonMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
    cannonMat.specularColor = new BABYLON.Color3(0.8, 0.8, 0.8);

    // Animated water
    scene.registerBeforeRender(function () {
      const t = performance.now() * 0.001;
      for (let i = 0; i < waterPositions.length; i += 3) {
        const x = baseWaterPositions[i];
        const z = baseWaterPositions[i + 2];
        const wave = Math.sin(x * 0.12 + t * 1.2) * 0.25 +
                     Math.cos(z * 0.18 + t * 0.8) * 0.18;
        waterPositions[i] = x;
        waterPositions[i + 1] = wave;
        waterPositions[i + 2] = z;
      }
      water.updateVerticesData(BABYLON.VertexBuffer.PositionKind, waterPositions, false, true);
    });

    // Main update loop
    scene.onBeforeRenderObservable.add(function () {
      const dt = engine.getDeltaTime() / 1000;

      // Waves & spawning
      if (waveInProgress) {
        spawnTimer += dt * 1000;
        if (enemiesSpawned < enemiesToSpawn && spawnTimer >= spawnInterval) {
          spawnTimer = 0;
          spawnEnemy(scene, enemyMat);
        }
        if (enemiesSpawned >= enemiesToSpawn && enemyShips.length === 0) {
          waveInProgress = false;
          const bonus = 20 + wave * 10;
          gold += bonus;
          updateUI();
          waveInfo.textContent = "Wave " + wave + " cleared! +" + bonus + " gold. Prepare and upgrade.";
          nextWaveBtn.disabled = false;
        }
      }

      // Friendly ship control
      handleShipControl(dt);

      // Enemies movement
      updateEnemies(dt);

      // Firing logic
      updateFiring(dt, cannonMat, scene);

      // Projectiles
      updateProjectiles(dt);

      // Check game over
      if (islandHP <= 0 && !gameOverOverlay.classList.contains("active")) {
        showGameOver();
      }

      updateUpgradeButtons();
    });

    return scene;
  }

  function createShipMesh(name, hullMaterial, scene) {
    const root = new BABYLON.TransformNode(name + "_root", scene);

    const hull = BABYLON.MeshBuilder.CreateBox(name + "_hull", {
      width: 2,
      height: 0.6,
      depth: 4
    }, scene);
    hull.position.y = 0.3;
    hull.material = hullMaterial;
    hull.parent = root;

    // Slightly pointy bow
    const bow = BABYLON.MeshBuilder.CreateBox(name + "_bow", {
      width: 1.4,
      height: 0.5,
      depth: 1.4
    }, scene);
    bow.position.y = 0.35;
    bow.position.z = -2.4;
    bow.scaling.z = 0.7;
    bow.scaling.x = 0.8;
    bow.material = hullMaterial;
    bow.parent = root;

    const mast = BABYLON.MeshBuilder.CreateCylinder(name + "_mast", {
      height: 3.5,
      diameter: 0.15
    }, scene);
    mast.position.y = 2;
    mast.position.z = 0;
    mast.material = new BABYLON.StandardMaterial(name + "_mastMat", scene);
    mast.material.diffuseColor = new BABYLON.Color3(0.5, 0.35, 0.2);
    mast.parent = root;

    const sail = BABYLON.MeshBuilder.CreatePlane(name + "_sail", {
      width: 1.8,
      height: 2.5
    }, scene);
    sail.position.y = 2.1;
    sail.position.z = 0.2;
    sail.rotation.y = Math.PI;
    const sailMat = new BABYLON.StandardMaterial(name + "_sailMat", scene);
    sailMat.diffuseColor = new BABYLON.Color3(0.95, 0.95, 0.9);
    sailMat.backFaceCulling = false;
    sail.material = sailMat;
    sail.parent = root;

    // Simple "highlight" ring
    const ring = BABYLON.MeshBuilder.CreateTorus(name + "_ring", {
      diameter: 3.2,
      thickness: 0.05
    }, scene);
    ring.rotation.x = Math.PI / 2;
    ring.position.y = 0.02;
    const ringMat = new BABYLON.StandardMaterial(name + "_ringMat", scene);
    ringMat.diffuseColor = new BABYLON.Color3(0.2, 0.7, 1.0);
    ringMat.alpha = 0.0; // hidden by default
    ring.material = ringMat;
    ring.parent = root;

    return {
      root,
      hull,
      ring,
      mast,
      sail,
      hullMaterial
    };
  }

  function spawnEnemy(scene, enemyMat) {
    enemiesSpawned++;
    const radius = 120;
    const angle = Math.random() * Math.PI * 2;
    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;

    const ship = createShipMesh("enemy" + enemiesSpawned, enemyMat, scene);
    ship.root.position.set(x, 0.3, z);

    // Face towards island center
    const dir = new BABYLON.Vector3(0, 0, 0).subtract(ship.root.position);
    ship.root.rotation.y = Math.atan2(dir.x, dir.z);

    ship.isFriendly = false;
    ship.hp = baseEnemyHP + wave * 8;
    ship.speed = baseEnemySpeed + wave * 0.4;
    ship.damage = baseEnemyDamage + wave * 2;

    enemyShips.push(ship);
  }

  function handleShipControl(dt) {
    if (selectedShipIndex < 0 || selectedShipIndex >= friendlyShips.length) return;
    const ship = friendlyShips[selectedShipIndex];
    const root = ship.root;

    // Turning
    if (inputState.turn !== 0) {
      const turnSpeed = 1.6; // rad/s
      root.rotation.y += inputState.turn * turnSpeed * dt;
    }

    // Forward/backward
    if (inputState.forward !== 0) {
      const dir = new BABYLON.Vector3(
        Math.sin(root.rotation.y),
        0,
        Math.cos(root.rotation.y)
      );
      const speed = ship.stats.moveSpeed * inputState.forward;
      const delta = dir.scale(speed * dt);

      const newPos = root.position.add(delta);

      // Keep mostly around island, limit too far or too close
      const dist = Math.sqrt(newPos.x * newPos.x + newPos.z * newPos.z);
      const minR = islandRadius + 3;
      const maxR = islandRadius + 35;
      if (dist > minR && dist < maxR) {
        root.position = newPos;
      }
    }
  }

  function updateEnemies(dt) {
    // Move enemies towards island center; if reach, damage island
    for (let i = enemyShips.length - 1; i >= 0; i--) {
      const enemy = enemyShips[i];
      const root = enemy.root;
      const target = new BABYLON.Vector3(0, root.position.y, 0);
      const dir = target.subtract(root.position);
      const dist = dir.length();

      if (dist > 0.001) {
        dir.normalize();
        root.position.addInPlace(dir.scale(enemy.speed * dt));
        root.rotation.y = Math.atan2(dir.x, dir.z);
      }

      const groundDist = Math.sqrt(root.position.x * root.position.x + root.position.z * root.position.z);
      if (groundDist <= islandRadius + 0.2) {
        // Reached island
        islandHP -= enemy.damage;
        if (islandHP < 0) islandHP = 0;
        updateUI();
        // Dispose enemy
        disposeShip(enemy);
        enemyShips.splice(i, 1);
      }
    }
  }

  function updateFiring(dt, cannonMat, scene) {
    // Manual fire
    if (inputState.manualFire && selectedShipIndex >= 0 && enemyShips.length > 0) {
      const ship = friendlyShips[selectedShipIndex];
      if (ship.fireCooldown <= 0) {
        const target = findNearestEnemy(ship.root.position, ship.stats.range);
        if (target) {
          fireCannon(ship, target, cannonMat, scene);
          ship.fireCooldown = 1 / ship.stats.fireRate;
        }
      }
      inputState.manualFire = false;
    }

    // Auto fire
    if (autoFireEnabled) {
      for (const ship of friendlyShips) {
        ship.fireCooldown -= dt;
        if (ship.fireCooldown <= 0 && enemyShips.length > 0) {
          const target = findNearestEnemy(ship.root.position, ship.stats.range);
          if (target) {
            fireCannon(ship, target, cannonMat, scene);
            ship.fireCooldown = 1 / ship.stats.fireRate;
          }
        }
      }
    }
  }

  function findNearestEnemy(fromPos, maxRange) {
    let best = null;
    let bestDist = Infinity;
    for (const enemy of enemyShips) {
      const d = BABYLON.Vector3.Distance(fromPos, enemy.root.position);
      if (d < bestDist && d <= maxRange) {
        bestDist = d;
        best = enemy;
      }
    }
    return best;
  }

  function fireCannon(ship, target, cannonMat, scene) {
    const muzzleOffset = new BABYLON.Vector3(
      Math.sin(ship.root.rotation.y) * 2.2,
      0.8,
      Math.cos(ship.root.rotation.y) * 2.2
    );
    const startPos = ship.root.position.add(muzzleOffset);
    const dir = target.root.position.add(new BABYLON.Vector3(0, 0.3, 0)).subtract(startPos).normalize();

    const ball = BABYLON.MeshBuilder.CreateSphere("ball", { diameter: 0.5, segments: 8 }, scene);
    ball.position = startPos.scale(1);
    ball.material = cannonMat;

    const speed = 32;
    const proj = {
      mesh: ball,
      velocity: dir.scale(speed),
      damage: ship.stats.damage,
      life: 4
    };
    projectiles.push(proj);

    // Simple muzzle flash
    const flash = BABYLON.MeshBuilder.CreateSphere("flash", { diameter: 0.9 }, scene);
    flash.position = startPos;
    const flashMat = new BABYLON.StandardMaterial("flashMat", scene);
    flashMat.emissiveColor = new BABYLON.Color3(1, 0.85, 0.4);
    flashMat.diffuseColor = new BABYLON.Color3(1, 0.7, 0.2);
    flash.material = flashMat;
    flash.parent = ship.root;
    flash.scaling.setAll(0.8);
    setTimeout(() => flash.dispose(), 120);
  }

  function updateProjectiles(dt) {
    for (let i = projectiles.length - 1; i >= 0; i--) {
      const p = projectiles[i];
      p.life -= dt;
      if (p.life <= 0) {
        p.mesh.dispose();
        projectiles.splice(i, 1);
        continue;
      }
      p.mesh.position.addInPlace(p.velocity.scale(dt));

      // Hit detection: check against all enemies
      let hit = false;
      for (let j = enemyShips.length - 1; j >= 0; j--) {
        const enemy = enemyShips[j];
        const d = BABYLON.Vector3.Distance(p.mesh.position, enemy.root.position.add(new BABYLON.Vector3(0, 0.5, 0)));
        if (d < 1.3) {
          enemy.hp -= p.damage;
          if (enemy.hp <= 0) {
            gold += 15 + Math.floor(5 * Math.random());
            updateUI();
            createExplosion(enemy.root.position);
            disposeShip(enemy);
            enemyShips.splice(j, 1);
          } else {
            createHitSpark(p.mesh.position);
          }
          hit = true;
          break;
        }
      }
      if (hit) {
        p.mesh.dispose();
        projectiles.splice(i, 1);
      }
    }
  }

  function createExplosion(pos) {
    const scene = engine.scenes[0];
    const sphere = BABYLON.MeshBuilder.CreateSphere("expl", { diameter: 2, segments: 6 }, scene);
    sphere.position = pos.add(new BABYLON.Vector3(0, 0.5, 0));
    const mat = new BABYLON.StandardMaterial("explMat", scene);
    mat.emissiveColor = new BABYLON.Color3(1.0, 0.7, 0.3);
    mat.diffuseColor = new BABYLON.Color3(1.0, 0.5, 0.0);
    sphere.material = mat;
    sphere.scaling.setAll(0.5);
    let t = 0;
    const obs = scene.onBeforeRenderObservable.add(function () {
      const dt = engine.getDeltaTime() / 1000;
      t += dt;
      sphere.scaling.addInPlace(new BABYLON.Vector3(1.5 * dt, 1.5 * dt, 1.5 * dt));
      mat.alpha = Math.max(0, 1 - t * 2.5);
      if (t > 0.6) {
        scene.onBeforeRenderObservable.remove(obs);
        sphere.dispose();
      }
    });
  }

  function createHitSpark(pos) {
    const scene = engine.scenes[0];
    const spark = BABYLON.MeshBuilder.CreateSphere("spark", { diameter: 0.7, segments: 4 }, scene);
    spark.position = pos;
    const mat = new BABYLON.StandardMaterial("sparkMat", scene);
    mat.emissiveColor = new BABYLON.Color3(1.0, 1.0, 0.8);
    mat.diffuseColor = new BABYLON.Color3(1.0, 0.9, 0.6);
    spark.material = mat;
    let t = 0;
    const obs = scene.onBeforeRenderObservable.add(function () {
      const dt = engine.getDeltaTime() / 1000;
      t += dt;
      mat.alpha = Math.max(0, 1 - t * 4);
      if (t > 0.3) {
        scene.onBeforeRenderObservable.remove(obs);
        spark.dispose();
      }
    });
  }

  function disposeShip(ship) {
    ship.root.getChildMeshes().forEach(m => m.dispose());
    ship.root.dispose();
  }

  // UI helper
  function updateUI() {
    goldText.textContent = gold;
    waveText.textContent = wave;
    hpText.textContent = islandHP + " / " + islandMaxHP;
    if (islandHP <= islandMaxHP * 0.3) {
      hpText.style.color = "#f97316";
    } else {
      hpText.style.color = "#f9fafb";
    }
    updateSelectedShipStats();
  }

  function updateSelectedShipStats() {
    if (selectedShipIndex < 0 || selectedShipIndex >= friendlyShips.length) {
      selectedShipName.textContent = "None";
      statDamage.textContent = "-";
      statFireRate.textContent = "-";
      statSpeed.textContent = "-";
      return;
    }
    const ship = friendlyShips[selectedShipIndex];
    selectedShipName.textContent = "Ship " + ship.id;
    statDamage.textContent = ship.stats.damage.toFixed(0);
    statFireRate.textContent = ship.stats.fireRate.toFixed(2);
    statSpeed.textContent = ship.stats.moveSpeed.toFixed(1);
  }

  function updateUpgradeButtons() {
    const hasShip = selectedShipIndex >= 0 && selectedShipIndex < friendlyShips.length;
    upgradeDamageBtn.disabled = !hasShip || gold < upgradeCosts.damage || waveInProgress;
    upgradeFireRateBtn.disabled = !hasShip || gold < upgradeCosts.fireRate || waveInProgress;
    upgradeSpeedBtn.disabled = !hasShip || gold < upgradeCosts.speed || waveInProgress;
  }

  function selectShip(index) {
    if (index < 0 || index >= friendlyShips.length) {
      selectedShipIndex = -1;
      friendlyShips.forEach(s => {
        s.ring.material.alpha = 0.0;
        s.hullMaterial.emissiveColor = BABYLON.Color3.Black();
      });
      updateSelectedShipStats();
      return;
    }
    selectedShipIndex = index;
    friendlyShips.forEach((s, i) => {
      if (i === index) {
        s.ring.material.alpha = 0.9;
        s.hullMaterial.emissiveColor = new BABYLON.Color3(0.6, 0.85, 1.0);
      } else {
        s.ring.material.alpha = 0.0;
        s.hullMaterial.emissiveColor = BABYLON.Color3.Black();
      }
    });
    updateSelectedShipStats();
  }

  function startNextWave() {
    if (waveInProgress || islandHP <= 0) return;
    wave++;
    enemiesSpawned = 0;
    enemiesToSpawn = 3 + wave * 2;
    spawnInterval = Math.max(800, 2500 - wave * 100);
    baseEnemyHP = 20 + wave * 8;
    baseEnemySpeed = 3 + wave * 0.4;
    baseEnemyDamage = 8 + wave * 2;
    spawnTimer = 0;
    waveInProgress = true;
    waveInfo.textContent = "Wave " + wave + " underway! " + enemiesToSpawn + " enemy ships inbound.";
    nextWaveBtn.disabled = true;
    updateUI();
  }

  function resetGame() {
    // Clear enemies and projectiles
    for (const e of enemyShips) {
      disposeShip(e);
    }
    enemyShips.length = 0;
    for (const p of projectiles) {
      p.mesh.dispose();
    }
    projectiles.length = 0;

    // Reset friendly ships
    const radius = islandRadius + 9;
    const angles = [0, (2 * Math.PI) / 3, (4 * Math.PI) / 3];
    friendlyShips.forEach((ship, i) => {
      const angle = angles[i];
      ship.root.position.set(
        Math.cos(angle) * radius,
        0.3,
        Math.sin(angle) * radius
      );
      ship.root.rotation.y = angle + Math.PI;
      ship.stats = {
        damage: baseShipStats.damage,
        fireRate: baseShipStats.fireRate,
        moveSpeed: baseShipStats.moveSpeed,
        range: baseShipStats.range
      };
      ship.fireCooldown = 0;
    });

    gold = 80;
    wave = 0;
    islandHP = islandMaxHP;
    waveInProgress = false;
    enemiesToSpawn = 0;
    enemiesSpawned = 0;
    spawnTimer = 0;

    selectShip(0);
    waveInfo.textContent = 'Press "Start Wave" to begin.';
    nextWaveBtn.disabled = false;

    costDamageText.textContent = upgradeCosts.damage + "g";
    costFireRateText.textContent = upgradeCosts.fireRate + "g";
    costSpeedText.textContent = upgradeCosts.speed + "g";

    updateUI();
  }

  function showGameOver() {
    finalWaveText.textContent = wave;
    finalGoldText.textContent = gold;
    gameOverOverlay.classList.add("active");
  }

  // Input
  window.addEventListener("keydown", function (e) {
    if (e.repeat) return;
    switch (e.key) {
      case "1":
        selectShip(0);
        break;
      case "2":
        selectShip(1);
        break;
      case "3":
        selectShip(2);
        break;
      case "w":
      case "W":
        inputState.forward = 1;
        break;
      case "s":
      case "S":
        inputState.forward = -1;
        break;
      case "a":
      case "A":
        inputState.turn = -1;
        break;
      case "d":
      case "D":
        inputState.turn = 1;
        break;
      case " ":
        e.preventDefault();
        inputState.manualFire = true;
        break;
      case "c":
      case "C":
        autoFireEnabled = !autoFireEnabled;
        break;
    }
  });

  window.addEventListener("keyup", function (e) {
    switch (e.key) {
      case "w":
      case "W":
        if (inputState.forward === 1) inputState.forward = 0;
        break;
      case "s":
      case "S":
        if (inputState.forward === -1) inputState.forward = 0;
        break;
      case "a":
      case "A":
        if (inputState.turn === -1) inputState.turn = 0;
        break;
      case "d":
      case "D":
        if (inputState.turn === 1) inputState.turn = 0;
        break;
    }
  });

  // Upgrade buttons
  upgradeDamageBtn.addEventListener("click", function () {
    if (selectedShipIndex < 0) return;
    if (gold < upgradeCosts.damage || waveInProgress) return;
    const ship = friendlyShips[selectedShipIndex];
    ship.stats.damage += 5;
    gold -= upgradeCosts.damage;
    upgradeCosts.damage = Math.floor(upgradeCosts.damage * 1.25);
    costDamageText.textContent = upgradeCosts.damage + "g";
    updateUI();
  });

  upgradeFireRateBtn.addEventListener("click", function () {
    if (selectedShipIndex < 0) return;
    if (gold < upgradeCosts.fireRate || waveInProgress) return;
    const ship = friendlyShips[selectedShipIndex];
    ship.stats.fireRate *= 1.15;
    gold -= upgradeCosts.fireRate;
    upgradeCosts.fireRate = Math.floor(upgradeCosts.fireRate * 1.3);
    costFireRateText.textContent = upgradeCosts.fireRate + "g";
    updateUI();
  });

  upgradeSpeedBtn.addEventListener("click", function () {
    if (selectedShipIndex < 0) return;
    if (gold < upgradeCosts.speed || waveInProgress) return;
    const ship = friendlyShips[selectedShipIndex];
    ship.stats.moveSpeed += 0.8;
    gold -= upgradeCosts.speed;
    upgradeCosts.speed = Math.floor(upgradeCosts.speed * 1.25);
    costSpeedText.textContent = upgradeCosts.speed + "g";
    updateUI();
  });

  nextWaveBtn.addEventListener("click", startNextWave);
  restartBtn.addEventListener("click", function () {
    gameOverOverlay.classList.remove("active");
    resetGame();
  });

  // Start everything
  scene = createScene();
  resetGame();

  engine.runRenderLoop(function () {
    if (scene) scene.render();
  });

  window.addEventListener("resize", function () {
    engine.resize();
  });
})();
</script>
</body>
</html>