<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Pirate Island Defense - Babylon.js Prototype</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
    body { margin:0; overflow:hidden; background:#000; font-family:Arial, sans-serif; }
    canvas { width:100%; height:100%; display:block; }
    #ui {
        position:absolute; top:10px; left:10px; color:#fff; background:rgba(0,0,0,0.6); padding:15px; border-radius:8px; min-width:250px;
        box-shadow:0 0 20px rgba(0,200,255,0.5);
    }
    button { margin:5px; padding:8px 12px; background:#00aaff; color:white; border:none; border-radius:4px; cursor:pointer; }
    button:hover { background:#0088cc; }
    button:disabled { background:#555; cursor:not-allowed; }
    #gameOver, #victory { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:48px; color:#ff0000; background:rgba(0,0,0,0.8); padding:30px; border-radius:15px; display:none; }
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<div id="ui">
    Gold: <span id="gold">150</span>  Wave: <span id="wave">1</span>  Island HP: <span id="islandHP">200</span>/200<br><br>
    Selected: <span id="selected">None (press 1-3)</span><br><br>
    <div id="upgrades" style="display:none;">
        <strong>Upgrades (selected ship)</strong><br>
        Damage lvl <span id="dmgLvl">0</span> → <button onclick="upgrade('damage')">+Damage (cost <span id="dmgCost">50</span>)</button><br>
        Fire Rate lvl <span id="rateLvl">0</span> → <button onclick="upgrade('rate')">+Fire Rate (cost <span id="rateCost">60</span>)</button><br>
        Speed lvl <span id="speedLvl">0</span> → <button onclick="upgrade('speed')">+Speed (cost <span id="speedCost">70</span>)</button><br>
    </div>
    <div id="nextWaveBtn" style="margin-top:15px;"><button onclick="startNextWave()" style="padding:12px 20px; font-size:18px;">Start Next Wave</button></div>
</div>

<div id="gameOver">GAME OVER<br><small>Island destroyed</small></div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script>
// ================ Babylon.js Setup ================
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);

// Camera - free orbit above the scene
const camera = new BABYLON.ArcRotateCamera("cam", Math.PI / 2, Math.PI / 3.5, 120, BABYLON.Vector3.Zero(), scene);
camera.lowerRadiusLimit = 40;
camera.upperRadiusLimit = 250;
camera.lowerBetaLimit = 0.1;
camera.upperBetaLimit = Math.PI / 2.1;
camera.attachControl(canvas, true);

// Lighting
new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

// Skybox
const skybox = BABYLON.MeshBuilder.CreateBox("skybox", {size:2000}, scene);
const skyboxMat = new BABYLON.StandardMaterial("skybox", scene);
skyboxMat.backFaceCulling = false;
skyboxMat.reflectionTexture = new BABYLON.CubeTexture("https://playground.babylonjs.com/textures/skybox", scene);
skyboxMat.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
skyboxMat.diffuseColor = BABYLON.Color3.Black();
skyboxMat.specularColor = BABYLON.Color3.Black();
skybox.material = skyboxMat;

// Water
const waterMesh = BABYLON.MeshBuilder.CreateGround("water", {width:2048, height:2048, subdivisions:256}, scene);
waterMesh.position.y = -2;
const water = new BABYLON.WaterMaterial("water", scene);
water.bumpTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/waterbump.png", scene);
water.windForce = 45;
water.waveHeight = 1.2;
water.bumpHeight = 0.3;
water.windDirection = new BABYLON.Vector2(1, 1);
water.waterColor = new BABYLON.Color2(0.05, 0.25, 0.4);
water.colorBlendFactor = 0.25;
water.addToRenderList(skybox);
waterMesh.material = water;

// Island
const island = BABYLON.MeshBuilder.CreateCylinder("island", {height:12, diameterTop:38, diameterBottom:55, tessellation:64}, scene);
island.position.y = 5;
const islandMat = new BABYLON.StandardMaterial("islandMat", scene);
islandMat.diffuseColor = new BABYLON.Color3(0.15, 0.75, 0.15);
island.material = islandMat;
water.addToRenderList(island);

// Simple palms & rocks
function createPalm(x, z) {
    const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk", {height:12, diameter:1.5}, scene);
    trunk.position.set(x, 6, z);
    trunk.material = new BABYLON.StandardMaterial("", scene);
    trunk.material.diffuseColor = new BABYLON.Color3(0.45, 0.3, 0.15);
    const leaves = BABYLON.MeshBuilder.CreateSphere("leaves", {diameter:9}, scene);
    leaves.position.set(x, 14, z);
    leaves.material = new BABYLON.StandardMaterial("", scene);
    leaves.material.diffuseColor = new BABYLON.Color3(0.05, 0.65, 0.05);
    water.addToRenderList(trunk);
    water.addToRenderList(leaves);
}
function createRock(x, z, scale=1) {
    const rock = BABYLON.MeshBuilder.CreateSphere("rock", {diameter:4*scale, segments:10}, scene);
    rock.position.set(x, 1.5*scale, z);
    rock.material = new BABYLON.StandardMaterial("", scene);
    rock.material.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.45);
    water.addToRenderList(rock);
}
createPalm(8, 10); createPalm(-12, -6); createPalm(5, -14);
createRock(15, 5, 1.4); createRock(-10, 12, 1.2); createRock(0, -16, 1.6);

// ================ Ship Creation ================
function createShipMesh(isFriendly = true) {
    const root = new BABYLON.TransformNode("shipRoot", scene);
    
    // Hull
    const hull = BABYLON.MeshBuilder.CreateBox("hull", {width:8, height:5, depth:28}, scene);
    hull.parent = root;
    hull.position.y = 2.5;
    const wood = new BABYLON.StandardMaterial("wood", scene);
    wood.diffuseColor = new BABYLON.Color3(0.6, 0.4, 0.2);
    hull.material = wood;
    
    // Mast & Sail
    const mast = BABYLON.MeshBuilder.CreateCylinder("mast", {height:24, diameter:1}, scene);
    mast.parent = root;
    mast.position.y = 14;
    mast.material = wood;
    
    const sail = BABYLON.MeshBuilder.CreatePlane("sail", {width:16, height:20}, scene);
    sail.parent = root;
    sail.position.y = 18;
    const sailMat = new BABYLON.StandardMaterial("sail", scene);
    sailMat.diffuseColor = isFriendly ? BABYLON.Color3.White() : new BABYLON.Color3(0.9, 0, 0);
    sailMat.backFaceCulling = false;
    sail.material = sailMat;
    
    water.addToRenderList(root);
    return root;
}

// ================ Game State ================
let gold = 150;
let wave = 0;
let islandHP = 200;
let selectedShip = null;
let gameOver = false;

class PirateShip {
    constructor(position, rotationY) {
        this.mesh = createShipMesh(true);
        this.mesh.position = position;
        this.mesh.rotation.y = rotationY;
        this.mesh.position.y = 2;
        
        this.levels = {damage:0, rate:0, speed:0};
        this.damage = 15;
        this.fireRate = 0.9;      // shots/sec
        this.speed = 14;
        this.turnSpeed = Math.PI * 0.9;
        this.range = 85;
        this.cooldown = 0;
        this.lastCannonSide = 1;
    }
    upgrade(stat) {
        const cost = (this.levels[stat] + 1) * (stat === "damage" ? 50 : stat === "rate" ? 60 : 70);
        if (gold >= cost) {
            gold -= cost;
            this.levels[stat]++;
            if (stat === "damage") this.damage = 15 + this.levels.damage * 12;
            if (stat === "rate") this.fireRate = 0.9 + this.levels.rate * 0.6;
            if (stat === "speed") { this.speed = 14 + this.levels.speed * 6; this.turnSpeed += 0.4; }
            updateUI();
        }
    }
    fireAt(target) {
        if (this.cooldown > 0) return;
        const right = this.mesh.getDirection(BABYLON.Vector3.Right());
        const startPos = this.mesh.position.clone();
        startPos.addInPlace(right.scale(this.lastCannonSide * 6));
        startPos.y += 4;
        
        const cannonball = BABYLON.MeshBuilder.CreateSphere("cb", {diameter:1.6}, scene);
        cannonball.position = startPos;
        const cbMat = new BABYLON.StandardMaterial("cbMat", scene);
        cbMat.diffuseColor = BABYLON.Color3.Black();
        cannonball.material = cbMat;
        
        const dir = target.mesh.position.subtract(startPos).normalize();
        cannonballs.push({
            mesh: cannonball,
            vel: dir.scale(110),
            damage: this.damage
        });
        
        this.cooldown = 1 / this.fireRate;
        this.lastCannonSide *= -1;
    }
}

// Create 3 friendly ships
const friendlyShips = [];
for (let i = 0; i < 3; i++) {
    const angle = i * Math.PI * 2 / 3 + Math.PI / 6;
    const pos = new BABYLON.Vector3(Math.sin(angle) * 80, 2, Math.cos(angle) * 80);
    friendlyShips.push(new PirateShip(pos, angle + Math.PI));
}

// Enemies & cannonballs
let enemies = [];
let cannonballs = [];

// Input
const input = {};
window.addEventListener("keydown", e => input[e.key.toLowerCase()] = true);
window.addEventListener("keyup", e => input[e.key.toLowerCase()] = false);
scene.onKeyboardObservable.add((kb) => {
    if (kb.type === BABYLON.KeyboardEventTypes.KEYDOWN) {
        if (kb.event.key === "1") { selectedShip = friendlyShips[0]; updateUI(); }
        if (kb.event.key === "2") { selectedShip = friendlyShips[1]; updateUI(); }
        if (kb.event.key === "3") { selectedShip = friendlyShips[2]; updateUI(); }
    }
});

// Wave system
let spawning = false;
let enemiesThisWave = 0;
function startNextWave() {
    if (gameOver) return;
    wave++;
    enemiesThisWave = wave * 4 + 3;
    spawning = true;
    document.getElementById("nextWaveBtn").style.display = "none";
    document.getElementById("upgrades").style.display = "none";
    updateUI();
}
let spawnTimer = 0;

// ================ Game Loop ================
scene.registerBeforeRender(() => {
    if (gameOver) return;
    const dt = engine.getDeltaTime() / 1000;
    
    // Player ship control
    if (selectedShip) {
        if (input["a"] || input["arrowleft"]) selectedShip.mesh.rotation.y += selectedShip.turnSpeed * dt;
        if (input["d"] || input["arrowright"]) selectedShip.mesh.rotation.y -= selectedShip.turnSpeed * dt;
        if (input["w"] || input["arrowup"]) selectedShip.mesh.position.addInPlace(selectedShip.mesh.forward.scale(selectedShip.speed * dt));
        if (input["s"] || input["arrowdown"]) selectedShip.mesh.position.addInPlace(selectedShip.mesh.forward.scale(-selectedShip.speed * dt * 0.6));
    }
    
    // Auto-fire for all friendly ships
    friendlyShips.forEach(ship => {
        ship.cooldown = Math.max(0, ship.cooldown - dt);
        let closest = null;
        let bestDist = ship.range;
        enemies.forEach(e => {
            const d = BABYLON.Vector3.Distance(ship.mesh.position, e.mesh.position);
            if (d < bestDist) { bestDist = d; closest = e; }
        });
        if (closest) ship.fireAt(closest);
    });
    
    // Spawn enemies
    if (spawning) {
        spawnTimer -= dt;
        if (spawnTimer <= 0 && enemiesThisWave > 0) {
            const angle = Math.random() * Math.PI * 2;
            const pos = new BABYLON.Vector3(Math.sin(angle) * 320, 2, Math.cos(angle) * 320);
            const enemy = { mesh: createShipMesh(false), hp: 40 + wave * 25, speed: 9 + wave * 1.2 };
            enemy.mesh.position = pos;
            enemy.mesh.rotation.y = angle + Math.PI;
            enemies.push(enemy);
            enemiesThisWave--;
            spawnTimer = 2.5;
        }
    }
    
    // Enemy movement
    enemies = enemies.filter(e => {
        const toIsland = BABYLON.Vector3.Zero().subtract(e.mesh.position);
        const dist = toIsland.length();
        if (dist < 28) {
            islandHP -= 25;
            e.mesh.dispose();
            updateUI();
            if (islandHP <= 0) { gameOver = true; document.getElementById("gameOver").style.display = "block"; }
            return false;
        }
        const dir = toIsland.normalize();
        e.mesh.position.addInPlace(dir.scale(e.speed * dt));
        const targetAngle = Math.atan2(dir.x, dir.z);
        e.mesh.rotation.y = BABYLON.Scalar.LerpAngle(e.mesh.rotation.y, targetAngle, 0.08);
        return true;
    });
    
    // Cannonballs
    cannonballs = cannonballs.filter(cb => {
        cb.mesh.position.addInPlace(cb.vel.scale(dt));
        let hit = false;
        enemies.forEach((e, i) => {
            if (BABYLON.Vector3.Distance(cb.mesh.position, e.mesh.position) < 12) {
                e.hp -= cb.damage;
                if (e.hp <= 0) {
                    e.mesh.dispose();
                    enemies.splice(i, 1);
                    gold += 15 + wave * 3;
                    updateUI();
                }
                hit = true;
            }
        });
        if (hit || cb.mesh.position.y < -20) {
            cb.mesh.dispose();
            return false;
        }
        return true;
    });
    
    // Wave end → upgrade phase
    if (spawning && enemies.length === 0 && enemiesThisWave === 0) {
        spawning = false;
        document.getElementById("nextWaveBtn").style.display = "block";
        if (selectedShip) document.getElementById("upgrades").style.display = "block";
    }
});

// UI
function updateUI() {
    document.getElementById("gold").innerText = gold;
    document.getElementById("wave").innerText = wave;
    document.getElementById("islandHP").innerText = Math.max(0, islandHP);
    if (selectedShip) {
        const s = selectedShip;
        document.getElementById("selected").innerText = friendlyShips.indexOf(s) + 1;
        document.getElementById("dmgLvl").innerText = s.levels.damage;
        document.getElementById("rateLvl").innerText = s.levels.rate;
        document.getElementById("speedLvl").innerText = s.levels.speed;
        document.getElementById("dmgCost").innerText = (s.levels.damage + 1) * 50;
        document.getElementById("rateCost").innerText = (s.levels.rate + 1) * 60;
        document.getElementById("speedCost").innerText = (s.levels.speed + 1) * 70;
    }
}
function upgrade(type) {
    if (selectedShip) selectedShip.upgrade(type);
}

// Start first wave after 2 seconds
setTimeout(() => {
    document.getElementById("nextWaveBtn").style.display = "block";
}, 2000);

// Run
engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());
updateUI();
</script>
</body>
</html>