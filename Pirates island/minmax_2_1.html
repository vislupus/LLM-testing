<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pirate Island Defense - 3D Browser Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
        }

        #renderCanvas {
            width: 100%;
            height: 100vh;
            display: block;
            touch-action: none;
        }

        /* UI Overlay */
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* Top HUD */
        .hud-top {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 30px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 50px;
            pointer-events: auto;
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #fff;
            font-size: 1.1rem;
        }

        .hud-icon {
            font-size: 1.5rem;
        }

        .hud-value {
            font-weight: bold;
            color: #ffd700;
            min-width: 60px;
        }

        .island-hp {
            color: #ff6b6b !important;
        }

        .wave-value {
            color: #4ecdc4 !important;
        }

        /* Ship Selection HUD */
        .ship-hud {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }

        .ship-card {
            width: 120px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
        }

        .ship-card:hover {
            transform: translateY(-5px);
            background: rgba(30, 30, 50, 0.9);
        }

        .ship-card.selected {
            border-color: #4ecdc4;
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }

        .ship-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .ship-number {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 5px;
        }

        .ship-name {
            font-weight: bold;
            color: #fff;
            font-size: 0.95rem;
            margin-bottom: 8px;
        }

        .ship-stats {
            font-size: 0.75rem;
            color: #aaa;
            line-height: 1.4;
        }

        .ship-health {
            margin-top: 8px;
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
        }

        .ship-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ee5a5a);
            transition: width 0.3s ease;
        }

        /* Upgrade Panel */
        .upgrade-panel {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            border-radius: 20px;
            padding: 20px;
            pointer-events: auto;
            min-width: 200px;
        }

        .upgrade-title {
            color: #fff;
            font-size: 1.1rem;
            margin-bottom: 15px;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .upgrade-btn {
            width: 100%;
            padding: 12px 15px;
            margin-bottom: 10px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .upgrade-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .upgrade-damage {
            background: linear-gradient(135deg, #e94560, #d63447);
            color: white;
        }

        .upgrade-damage:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(233, 69, 96, 0.4);
        }

        .upgrade-fireRate {
            background: linear-gradient(135deg, #f7b731, #f39c12);
            color: #1a1a2e;
        }

        .upgrade-fireRate:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(247, 183, 49, 0.4);
        }

        .upgrade-speed {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .upgrade-speed:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(52, 152, 219, 0.4);
        }

        .upgrade-cost {
            font-size: 0.75rem;
            opacity: 0.9;
        }

        /* Controls Help */
        .controls-help {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 15px 20px;
            color: #fff;
            font-size: 0.85rem;
            pointer-events: auto;
        }

        .controls-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #4ecdc4;
        }

        .control-item {
            margin-bottom: 8px;
            display: flex;
            gap: 10px;
        }

        .key {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
        }

        /* Game Over Screen */
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
            pointer-events: auto;
        }

        .game-over.active {
            display: flex;
        }

        .game-over-content {
            text-align: center;
            color: #fff;
        }

        .game-over-title {
            font-size: 3rem;
            margin-bottom: 20px;
            color: #e94560;
        }

        .game-over-stats {
            font-size: 1.2rem;
            margin-bottom: 30px;
            color: #aaa;
        }

        .restart-btn {
            padding: 15px 40px;
            font-size: 1.2rem;
            border: none;
            border-radius: 30px;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .restart-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 30px rgba(78, 205, 196, 0.4);
        }

        /* Wave Announcement */
        .wave-announce {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 30px rgba(233, 69, 96, 0.8);
            pointer-events: none;
            opacity: 0;
            z-index: 150;
        }

        .wave-announce.show {
            animation: waveAnnounceAnim 2s ease forwards;
        }

        @keyframes waveAnnounceAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        /* Mini-map */
        .minimap {
            position: absolute;
            bottom: 140px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            overflow: hidden;
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>

    <!-- UI Overlay -->
    <div class="ui-overlay">
        <!-- Top HUD -->
        <div class="hud-top">
            <div class="hud-item">
                <span class="hud-icon">üí∞</span>
                <span class="hud-value" id="gold-display">100</span>
            </div>
            <div class="hud-item">
                <span class="hud-icon">üåä</span>
                <span class="hud-value wave-value" id="wave-display">1</span>
            </div>
            <div class="hud-item">
                <span class="hud-icon">üèùÔ∏è</span>
                <span class="hud-value island-hp" id="island-hp">1000</span>
            </div>
        </div>

        <!-- Controls Help -->
        <div class="controls-help">
            <div class="controls-title">‚öîÔ∏è Controls</div>
            <div class="control-item"><span class="key">1, 2, 3</span><span>Select Ship</span></div>
            <div class="control-item"><span class="key">WASD</span><span>Move Ship</span></div>
            <div class="control-item"><span class="key">Mouse</span><span>Camera</span></div>
            <div class="control-item"><span class="key">Space</span><span>Fire</span></div>
        </div>

        <!-- Upgrade Panel -->
        <div class="upgrade-panel">
            <div class="upgrade-title">‚ö° Ship Upgrades</div>
            <button class="upgrade-btn upgrade-damage" id="btn-damage">
                <span>Damage +10</span>
                <span class="upgrade-cost">üí∞50</span>
            </button>
            <button class="upgrade-btn upgrade-fireRate" id="btn-fireRate">
                <span>Fire Rate +15%</span>
                <span class="upgrade-cost">üí∞75</span>
            </button>
            <button class="upgrade-btn upgrade-speed" id="btn-speed">
                <span>Speed +10%</span>
                <span class="upgrade-cost">üí∞40</span>
            </button>
        </div>

        <!-- Ship Selection HUD -->
        <div class="ship-hud" id="ship-hud"></div>

        <!-- Wave Announcement -->
        <div class="wave-announce" id="wave-announce">Wave 1</div>
    </div>

    <!-- Game Over Screen -->
    <div class="game-over" id="game-over">
        <div class="game-over-content">
            <div class="game-over-title">üíÄ Game Over</div>
            <div class="game-over-stats" id="game-over-stats">
                Waves Survived: 5<br>
                Enemies Defeated: 23<br>
                Gold Earned: 450
            </div>
            <button class="restart-btn" onclick="location.reload()">Play Again</button>
        </div>
    </div>

    <!-- Babylon.js -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <script>
        // ==================== GAME CONFIGURATION ====================
        const CONFIG = {
            // Island settings
            island: {
                radius: 15,
                health: 1000,
                maxHealth: 1000
            },

            // Friendly ships
            friendlyShips: [
                { id: 0, name: "Sea Serpent", position: new BABYLON.Vector3(25, 0, 0), color: "#4ecdc4", health: 100, maxHealth: 100 },
                { id: 1, name: "Crimson Wave", position: new BABYLON.Vector3(-12.5, 0, 21.65), color: "#e94560", health: 100, maxHealth: 100 },
                { id: 2, name: "Golden Dawn", position: new BABYLON.Vector3(-12.5, 0, -21.65), color: "#f7b731", health: 100, maxHealth: 100 }
            ],

            // Ship stats
            shipStats: {
                damage: 25,
                fireRate: 2000, // ms between shots
                speed: 0.15,
                cannonballSpeed: 0.8,
                range: 50
            },

            // Enemy settings
            enemySpawn: {
                initialInterval: 5000,
                minInterval: 1500,
                spawnDistance: 80
            },

            // Upgrade costs
            upgrades: {
                damage: { cost: 50, increment: 10 },
                fireRate: { cost: 75, increment: 300 }, // reduce interval
                speed: { cost: 40, increment: 0.02 }
            },

            // Wave configuration
            waves: {
                baseEnemies: 3,
                enemiesPerWave: 2,
                enemyHealthMultiplier: 1.2,
                enemyDamageMultiplier: 1.1
            }
        };

        // ==================== GAME STATE ====================
        let gameState = {
            gold: 100,
            wave: 1,
            islandHealth: CONFIG.island.health,
            selectedShip: 0,
            isGameOver: false,
            lastFireTime: [0, 0, 0],
            enemiesDefeated: 0,
            upgradeLevels: {
                damage: [1, 1, 1],
                fireRate: [1, 1, 1],
                speed: [1, 1, 1]
            }
        };

        // ==================== BABYLON SETUP ====================
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

        // Game objects
        let scene, camera;
        let friendlyShips = [];
        let enemyShips = [];
        let cannonballs = [];
        let island;
        let waterMaterial;

        // Input state
        let inputState = {
            w: false, a: false, s: false, d: false,
            space: false
        };

        // ==================== CREATE SCENE ====================
        const createScene = () => {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.5, 0.7, 0.9, 1);

            // Camera
            camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 4, 100, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 30;
            camera.upperRadiusLimit = 200;
            camera.lowerBetaLimit = 0.1;
            camera.upperBetaLimit = Math.PI / 2.2;

            // Lighting
            const hemisphericLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
            hemisphericLight.intensity = 0.6;
            hemisphericLight.diffuse = new BABYLON.Color3(1, 0.95, 0.9);
            hemisphericLight.groundColor = new BABYLON.Color3(0.2, 0.4, 0.3);

            const directionalLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
            directionalLight.position = new BABYLON.Vector3(50, 100, 50);
            directionalLight.intensity = 0.8;

            // Shadows
            const shadowGenerator = new BABYLON.ShadowGenerator(2048, directionalLight);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;

            // Create environment
            createWater();
            createIsland(shadowGenerator);
            createProps(shadowGenerator);
            createFriendlyShips(shadowGenerator);
            createSkybox();

            return scene;
        };

        // ==================== WATER ====================
        function createWater() {
            const waterMesh = BABYLON.MeshBuilder.CreateGround("water", { width: 300, height: 300, subdivisions: 64 }, scene);

            waterMaterial = new BABYLON.StandardMaterial("waterMat", scene);
            waterMaterial.diffuseColor = new BABYLON.Color3(0.1, 0.4, 0.6);
            waterMaterial.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            waterMaterial.specularPower = 64;
            waterMaterial.alpha = 0.85;

            // Simple wave animation
            let time = 0;
            scene.registerBeforeRender(() => {
                time += 0.01;
                const positions = waterMesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] = Math.sin(positions[i] * 0.1 + time) * 0.3 +
                                       Math.cos(positions[i + 2] * 0.1 + time * 0.8) * 0.2;
                }
                waterMesh.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
            });

            waterMesh.material = waterMaterial;
            waterMesh.receiveShadows = true;
        }

        // ==================== ISLAND ====================
        function createIsland(shadowGenerator) {
            // Main island
            island = BABYLON.MeshBuilder.CreateCylinder("island", {
                height: 3,
                diameterTop: CONFIG.island.radius * 2,
                diameterBottom: CONFIG.island.radius * 2.5,
                tessellation: 32
            }, scene);
            island.position.y = 1;

            const islandMat = new BABYLON.StandardMaterial("islandMat", scene);
            islandMat.diffuseColor = new BABYLON.Color3(0.3, 0.6, 0.2);
            islandMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            island.material = islandMat;
            island.receiveShadows = true;
            shadowGenerator.addShadowCaster(island);

            // Beach ring
            const beach = BABYLON.MeshBuilder.CreateTorus("beach", {
                diameter: CONFIG.island.radius * 2.8,
                thickness: 3,
                tessellation: 32
            }, scene);
            beach.position.y = 0.5;
            const beachMat = new BABYLON.StandardMaterial("beachMat", scene);
            beachMat.diffuseColor = new BABYLON.Color3(0.95, 0.85, 0.6);
            beach.material = beachMat;
        }

        // ==================== PROPS ====================
        function createProps(shadowGenerator) {
            // Palm trees
            const palmPositions = [
                new BABYLON.Vector3(5, 0, 3),
                new BABYLON.Vector3(-4, 0, 6),
                new BABYLON.Vector3(-7, 0, -2),
                new BABYLON.Vector3(3, 0, -7),
                new BABYLON.Vector3(8, 0, -5)
            ];

            palmPositions.forEach((pos, i) => {
                createPalmTree(pos, shadowGenerator);
            });

            // Rocks
            const rockPositions = [
                new BABYLON.Vector3(6, 0.5, -2),
                new BABYLON.Vector3(-3, 0.3, 4),
                new BABYLON.Vector3(-5, 0.4, -5),
                new BABYLON.Vector3(2, 0.6, 7)
            ];

            rockPositions.forEach(pos => {
                createRock(pos, shadowGenerator);
            });

            // Treasure chest (decorative)
            createTreasureChest(new BABYLON.Vector3(0, 1, 0), shadowGenerator);
        }

        function createPalmTree(position, shadowGenerator) {
            const tree = new BABYLON.TransformNode("palm", scene);

            // Trunk
            const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk", {
                height: 8,
                diameterTop: 0.3,
                diameterBottom: 0.6,
                tessellation: 8
            }, scene);
            trunk.position.y = 4;
            trunk.rotation.z = Math.random() * 0.3 - 0.15;

            const trunkMat = new BABYLON.StandardMaterial("trunkMat", scene);
            trunkMat.diffuseColor = new BABYLON.Color3(0.5, 0.35, 0.2);
            trunk.material = trunkMat;
            trunk.parent = tree;
            shadowGenerator.addShadowCaster(trunk);

            // Leaves
            const leaves = BABYLON.MeshBuilder.CreateCylinder("leaves", {
                height: 0.1,
                diameterTop: 0,
                diameterBottom: 5,
                tessellation: 6
            }, scene);
            leaves.position.y = 8;
            const leavesMat = new BABYLON.StandardMaterial("leavesMat", scene);
            leavesMat.diffuseColor = new BABYLON.Color3(0.2, 0.5, 0.15);
            leaves.material = leavesMat;
            leaves.parent = tree;
            shadowGenerator.addShadowCaster(leaves);

            tree.position = position;
        }

        function createRock(position, shadowGenerator) {
            const rock = BABYLON.MeshBuilder.CreateSphere("rock", {
                diameter: 1.5 + Math.random(),
                segments: 6
            }, scene);

            const rockMat = new BABYLON.StandardMaterial("rockMat", scene);
            rockMat.diffuseColor = new BABYLON.Color3(0.4, 0.38, 0.35);
            rock.material = rockMat;
            rock.position = position;
            rock.scaling = new BABYLON.Vector3(1 + Math.random(), 0.6 + Math.random() * 0.4, 1 + Math.random());
            rock.rotation = new BABYLON.Vector3(Math.random(), Math.random(), Math.random());
            rock.receiveShadows = true;
            shadowGenerator.addShadowCaster(rock);
        }

        function createTreasureChest(position, shadowGenerator) {
            const chest = BABYLON.MeshBuilder.CreateBox("chest", { width: 2, height: 1.5, depth: 1.5 }, scene);
            chest.position = position;

            const chestMat = new BABYLON.StandardMaterial("chestMat", scene);
            chestMat.diffuseColor = new BABYLON.Color3(0.6, 0.4, 0.2);
            chest.material = chestMat;
            shadowGenerator.addShadowCaster(chest);
        }

        // ==================== FRIENDLY SHIPS ====================
        function createFriendlyShips(shadowGenerator) {
            CONFIG.friendlyShips.forEach((config, index) => {
                const ship = createShipMesh(config.color, shadowGenerator);
                ship.position = config.position.clone();
                ship.rotation.y = Math.atan2(-config.position.x, -config.position.z);

                friendlyShips.push({
                    mesh: ship,
                    config: config,
                    velocity: new BABYLON.Vector3(0, 0, 0)
                });
            });

            updateShipHUD();
        }

        function createShipMesh(color, shadowGenerator) {
            const ship = new BABYLON.TransformNode("friendlyShip", scene);

            // Hull
            const hull = BABYLON.MeshBuilder.CreateCylinder("hull", {
                height: 6,
                diameterTop: 1.5,
                diameterBottom: 3,
                tessellation: 8
            }, scene);
            hull.rotation.z = Math.PI / 2;
            hull.position.y = 0.5;

            const hullMat = new BABYLON.StandardMaterial("hullMat", scene);
            hullMat.diffuseColor = BABYLON.Color3.FromHexString(color);
            hull.material = hullMat;
            hull.parent = ship;
            shadowGenerator.addShadowCaster(hull);

            // Deck
            const deck = BABYLON.MeshBuilder.CreateBox("deck", { width: 4, height: 0.3, depth: 1.5 }, scene);
            deck.position.y = 1.5;
            const deckMat = new BABYLON.StandardMaterial("deckMat", scene);
            deckMat.diffuseColor = new BABYLON.Color3(0.6, 0.5, 0.35);
            deck.material = deckMat;
            deck.parent = ship;

            // Mast
            const mast = BABYLON.MeshBuilder.CreateCylinder("mast", { height: 5, diameter: 0.3 }, scene);
            mast.position.y = 4;
            mast.material = hullMat;
            mast.parent = ship;
            shadowGenerator.addShadowCaster(mast);

            // Sail
            const sail = BABYLON.MeshBuilder.CreatePlane("sail", { width: 3, height: 3.5 }, scene);
            sail.position.y = 4;
            sail.position.z = 0.3;
            const sailMat = new BABYLON.StandardMaterial("sailMat", scene);
            sailMat.diffuseColor = new BABYLON.Color3(0.95, 0.95, 0.9);
            sailMat.backFaceCulling = false;
            sail.material = sailMat;
            sail.parent = ship;

            // Cannon indicators
            for (let i = 0; i < 2; i++) {
                const cannon = BABYLON.MeshBuilder.CreateCylinder("cannon" + i, { height: 0.8, diameter: 0.2 }, scene);
                cannon.rotation.x = Math.PI / 2;
                cannon.position = new BABYLON.Vector3(1.5 - i * 3, 0.5, 0);
                const cannonMat = new BABYLON.StandardMaterial("cannonMat", scene);
                cannonMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                cannon.material = cannonMat;
                cannon.parent = ship;
            }

            // Selection ring
            const ring = BABYLON.MeshBuilder.CreateTorus("ring", { diameter: 5, thickness: 0.2 }, scene);
            ring.position.y = 0.1;
            const ringMat = new BABYLON.StandardMaterial("ringMat", scene);
            ringMat.diffuseColor = new BABYLON.Color3(0.3, 0.8, 0.7);
            ringMat.emissiveColor = new BABYLON.Color3(0.1, 0.3, 0.25);
            ring.material = ringMat;
            ring.parent = ship;
            ring.visibility = 0.3;

            return ship;
        }

        // ==================== ENEMY SHIPS ====================
        function spawnEnemy() {
            if (gameState.isGameOver) return;

            // Calculate spawn position at horizon
            const angle = Math.random() * Math.PI * 2;
            const distance = CONFIG.enemySpawn.spawnDistance;
            const spawnPos = new BABYLON.Vector3(
                Math.cos(angle) * distance,
                0.5,
                Math.sin(angle) * distance
            );

            const enemy = createEnemyMesh(spawnPos);
            enemyShips.push({
                mesh: enemy,
                health: 50 * Math.pow(CONFIG.waves.enemyHealthMultiplier, gameState.wave - 1),
                maxHealth: 50 * Math.pow(CONFIG.waves.enemyHealthMultiplier, gameState.wave - 1),
                damage: 10 * CONFIG.waves.enemyDamageMultiplier,
                speed: 0.05 + gameState.wave * 0.005
            });
        }

        function createEnemyMesh(position) {
            const ship = new BABYLON.TransformNode("enemyShip", scene);

            // Dark hull
            const hull = BABYLON.MeshBuilder.CreateCylinder("hull", {
                height: 5,
                diameterTop: 1.2,
                diameterBottom: 2.5,
                tessellation: 8
            }, scene);
            hull.rotation.z = Math.PI / 2;
            hull.position.y = 0.5;

            const hullMat = new BABYLON.StandardMaterial("enemyHullMat", scene);
            hullMat.diffuseColor = new BABYLON.Color3(0.2, 0.15, 0.15);
            hull.material = hullMat;
            hull.parent = ship;

            // Dark sail
            const sail = BABYLON.MeshBuilder.CreatePlane("enemySail", { width: 2.5, height: 3 }, scene);
            sail.position.y = 3.5;
            const sailMat = new BABYLON.StandardMaterial("enemySailMat", scene);
            sailMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            sailMat.backFaceCulling = false;
            sail.material = sailMat;
            sail.parent = ship;

            // Skull decoration
            const skull = BABYLON.MeshBuilder.CreateSphere("skull", { diameter: 0.5 }, scene);
            skull.position.y = 3.5;
            skull.position.z = 0.4;
            skull.scaling = new BABYLON.Vector3(0.8, 1, 0.6);
            const skullMat = new BABYLON.StandardMaterial("skullMat", scene);
            skullMat.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.85);
            skull.material = skullMat;
            skull.parent = ship;

            ship.position = position;

            // Face island
            ship.lookAt(BABYLON.Vector3.Zero());

            return ship;
        }

        // ==================== CANNONBALLS ====================
        function fireCannonball(shipIndex) {
            const now = Date.now();
            const fireRate = CONFIG.shipStats.fireRate - (gameState.upgradeLevels.fireRate[shipIndex] - 1) * CONFIG.upgrades.fireRate.increment;

            if (now - gameState.lastFireTime[shipIndex] < fireRate) return;
            gameState.lastFireTime[shipIndex] = now;

            const ship = friendlyShips[shipIndex];
            if (!ship || gameState.isGameOver) return;

            // Find nearest enemy
            let nearestEnemy = null;
            let nearestDist = CONFIG.shipStats.range;

            enemyShips.forEach(enemy => {
                const dist = BABYLON.Vector3.Distance(ship.mesh.position, enemy.mesh.position);
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestEnemy = enemy;
                }
            });

            if (!nearestEnemy) return;

            // Create cannonball
            const cannonball = BABYLON.MeshBuilder.CreateSphere("cannonball", { diameter: 0.5 }, scene);
            const startPos = ship.mesh.position.clone();
            startPos.y = 1.5;
            cannonball.position = startPos;

            const cannonballMat = new BABYLON.StandardMaterial("cannonMat", scene);
            cannonballMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            cannonball.material = cannonballMat;

            // Calculate direction
            const direction = nearestEnemy.mesh.position.subtract(startPos).normalize();

            cannonballs.push({
                mesh: cannonball,
                direction: direction,
                speed: CONFIG.shipStats.cannonballSpeed,
                damage: CONFIG.shipStats.damage + (gameState.upgradeLevels.damage[shipIndex] - 1) * CONFIG.upgrades.damage.increment,
                lifetime: 0
            });
        }

        // ==================== SKYBOX ====================
        function createSkybox() {
            const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 500 }, scene);
            const skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
            skyboxMaterial.backFaceCulling = false;
            skyboxMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.7, 0.9);
            skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            skybox.material = skyboxMaterial;
        }

        // ==================== UPDATE FUNCTIONS ====================
        function updateGame() {
            if (gameState.isGameOver) return;

            const dt = engine.getDeltaTime() / 1000;

            // Update friendly ships
            friendlyShips.forEach((ship, index) => {
                if (!ship) return;

                const speed = CONFIG.shipStats.speed + (gameState.upgradeLevels.speed[index] - 1) * CONFIG.upgrades.speed.increment;

                // Movement
                if (index === gameState.selectedShip) {
                    const moveDir = new BABYLON.Vector3(0, 0, 0);
                    if (inputState.w) moveDir.z = 1;
                    if (inputState.s) moveDir.z = -1;
                    if (inputState.a) moveDir.x = -1;
                    if (inputState.d) moveDir.x = 1;

                    if (moveDir.length() > 0) {
                        moveDir.normalize();
                        const worldMove = moveDir.applyRotationQuaternion(camera.rotationQuaternion || BABYLON.Quaternion.Identity());
                        worldMove.y = 0;
                        ship.mesh.position.addInPlace(worldMove.scale(speed));
                    }

                    // Auto-fire at nearest enemy
                    if (inputState.space || true) {
                        fireCannonball(index);
                    }
                }

                // Keep ship in bounds
                const maxDist = 70;
                if (ship.mesh.position.length() > maxDist) {
                    ship.mesh.position.normalize().scaleInPlace(maxDist);
                }

                // Gentle bobbing
                ship.mesh.position.y = 0.5 + Math.sin(Date.now() * 0.002 + index) * 0.1;
            });

            // Update enemy ships
            enemyShips.forEach((enemy, index) => {
                if (!enemy) return;

                // Move towards island
                const direction = BABYLON.Vector3.Zero().subtract(enemy.mesh.position).normalize();
                direction.y = 0;
                enemy.mesh.position.addInPlace(direction.scale(enemy.speed));

                // Face direction of movement
                enemy.mesh.lookAt(enemy.mesh.position.add(direction));

                // Check if reached island
                if (enemy.mesh.position.length() < CONFIG.island.radius + 3) {
                    // Damage island
                    gameState.islandHealth -= enemy.damage;
                    updateUI();

                    // Remove enemy
                    enemy.mesh.dispose();
                    enemyShips.splice(index, 1);

                    // Check game over
                    if (gameState.islandHealth <= 0) {
                        gameOver();
                    }
                }
            });

            // Update cannonballs
            cannonballs.forEach((ball, index) => {
                if (!ball) return;

                ball.mesh.position.addInPlace(ball.direction.scale(ball.speed));
                ball.lifetime += dt;

                // Check collision with enemies
                enemyShips.forEach((enemy, enemyIndex) => {
                    if (!enemy) return;
                    const dist = BABYLON.Vector3.Distance(ball.mesh.position, enemy.mesh.position);
                    if (dist < 2) {
                        // Hit!
                        enemy.health -= ball.damage;
                        ball.mesh.dispose();
                        cannonballs.splice(index, 1);

                        // Check enemy death
                        if (enemy.health <= 0) {
                            enemy.mesh.dispose();
                            enemyShips.splice(enemyIndex, 1);
                            gameState.gold += 15;
                            gameState.enemiesDefeated++;
                            updateUI();
                        }
                        return;
                    }
                });

                // Remove if too old or too far
                if (ball.lifetime > 5 || ball.mesh.position.length() > 100) {
                    ball.mesh.dispose();
                    cannonballs.splice(index, 1);
                }
            });

            // Update selection ring visibility
            friendlyShips.forEach((ship, index) => {
                if (!ship) return;
                const ring = ship.mesh.getChildMeshes().find(m => m.name === "ring");
                if (ring) {
                    ring.visibility = index === gameState.selectedShip ? 1 : 0.3;
                }
            });
        }

        // ==================== WAVE SYSTEM ====================
        let waveSpawnInterval;
        let enemiesToSpawn = 0;

        function startWave() {
            const waveNum = gameState.wave;
            enemiesToSpawn = CONFIG.waves.baseEnemies + (waveNum - 1) * CONFIG.waves.enemiesPerWave;

            // Show wave announcement
            const announce = document.getElementById('wave-announce');
            announce.textContent = `Wave ${waveNum}`;
            announce.classList.add('show');
            setTimeout(() => announce.classList.remove('show'), 2000);

            // Start spawning enemies
            const spawnInterval = Math.max(
                CONFIG.enemySpawn.minInterval,
                CONFIG.enemySpawn.initialInterval - waveNum * 300
            );

            waveSpawnInterval = setInterval(() => {
                if (enemiesToSpawn > 0 && !gameState.isGameOver) {
                    spawnEnemy();
                    enemiesToSpawn--;
                } else if (enemiesToSpawn <= 0) {
                    clearInterval(waveSpawnInterval);
                }
            }, spawnInterval);
        }

        function checkWaveComplete() {
            if (enemiesToSpawn <= 0 && enemyShips.length === 0 && !gameState.isGameOver) {
                gameState.wave++;
                gameState.gold += 50 + gameState.wave * 10;
                updateUI();
                setTimeout(startWave, 3000);
            }
        }

        // ==================== UI FUNCTIONS ====================
        function updateUI() {
            document.getElementById('gold-display').textContent = gameState.gold;
            document.getElementById('wave-display').textContent = gameState.wave;
            document.getElementById('island-hp').textContent = Math.max(0, Math.floor(gameState.islandHealth));

            updateShipHUD();
            updateUpgradeButtons();
        }

        function updateShipHUD() {
            const hud = document.getElementById('ship-hud');
            hud.innerHTML = '';

            friendlyShips.forEach((ship, index) => {
                const config = CONFIG.friendlyShips[index];
                const card = document.createElement('div');
                card.className = `ship-card ${index === gameState.selectedShip ? 'selected' : ''}`;
                card.innerHTML = `
                    <div class="ship-number">Press ${index + 1}</div>
                    <div class="ship-name">${config.name}</div>
                    <div class="ship-stats">
                        DMG: ${CONFIG.shipStats.damage + (gameState.upgradeLevels.damage[index] - 1) * CONFIG.upgrades.damage.increment}<br>
                        SPD: ${(CONFIG.shipStats.speed + (gameState.upgradeLevels.speed[index] - 1) * CONFIG.upgrades.speed.increment).toFixed(2)}
                    </div>
                    <div class="ship-health">
                        <div class="ship-health-fill" style="width: ${(config.health / config.maxHealth) * 100}%"></div>
                    </div>
                `;
                card.onclick = () => selectShip(index);
                hud.appendChild(card);
            });
        }

        function updateUpgradeButtons() {
            const shipIdx = gameState.selectedShip;
            const damageCost = CONFIG.upgrades.damage.cost * gameState.upgradeLevels.damage[shipIdx];
            const fireRateCost = CONFIG.upgrades.fireRate.cost * gameState.upgradeLevels.fireRate[shipIdx];
            const speedCost = CONFIG.upgrades.speed.cost * gameState.upgradeLevels.speed[shipIdx];

            document.getElementById('btn-damage').disabled = gameState.gold < damageCost;
            document.getElementById('btn-damage').innerHTML = `<span>Damage +${CONFIG.upgrades.damage.increment}</span><span class="upgrade-cost">üí∞${damageCost}</span>`;

            document.getElementById('btn-fireRate').disabled = gameState.gold < fireRateCost;
            document.getElementById('btn-fireRate').innerHTML = `<span>Fire Rate +15%</span><span class="upgrade-cost">üí∞${fireRateCost}</span>`;

            document.getElementById('btn-speed').disabled = gameState.gold < speedCost;
            document.getElementById('btn-speed').innerHTML = `<span>Speed +10%</span><span class="upgrade-cost">üí∞${speedCost}</span>`;
        }

        function selectShip(index) {
            gameState.selectedShip = index;
            updateShipHUD();
            updateUpgradeButtons();
        }

        function purchaseUpgrade(type) {
            const shipIdx = gameState.selectedShip;
            let cost;

            switch (type) {
                case 'damage':
                    cost = CONFIG.upgrades.damage.cost * gameState.upgradeLevels.damage[shipIdx];
                    if (gameState.gold >= cost) {
                        gameState.gold -= cost;
                        gameState.upgradeLevels.damage[shipIdx]++;
                    }
                    break;
                case 'fireRate':
                    cost = CONFIG.upgrades.fireRate.cost * gameState.upgradeLevels.fireRate[shipIdx];
                    if (gameState.gold >= cost) {
                        gameState.gold -= cost;
                        gameState.upgradeLevels.fireRate[shipIdx]++;
                    }
                    break;
                case 'speed':
                    cost = CONFIG.upgrades.speed.cost * gameState.upgradeLevels.speed[shipIdx];
                    if (gameState.gold >= cost) {
                        gameState.gold -= cost;
                        gameState.upgradeLevels.speed[shipIdx]++;
                    }
                    break;
            }

            updateUI();
        }

        function gameOver() {
            gameState.isGameOver = true;
            clearInterval(waveSpawnInterval);

            document.getElementById('game-over-stats').innerHTML = `
                Waves Survived: ${gameState.wave}<br>
                Enemies Defeated: ${gameState.enemiesDefeated}<br>
                Gold Earned: ${gameState.gold}
            `;
            document.getElementById('game-over').classList.add('active');
        }

        // ==================== INPUT HANDLING ====================
        function setupInput() {
            // Keyboard
            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (key === 'w') inputState.w = true;
                if (key === 'a') inputState.a = true;
                if (key === 's') inputState.s = true;
                if (key === 'd') inputState.d = true;
                if (key === ' ') { inputState.space = true; e.preventDefault(); }

                // Ship selection
                if (key >= '1' && key <= '3') {
                    selectShip(parseInt(key) - 1);
                }
            });

            window.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (key === 'w') inputState.w = false;
                if (key === 'a') inputState.a = false;
                if (key === 's') inputState.s = false;
                if (key === 'd') inputState.d = false;
                if (key === ' ') inputState.space = false;
            });

            // Upgrade buttons
            document.getElementById('btn-damage').onclick = () => purchaseUpgrade('damage');
            document.getElementById('btn-fireRate').onclick = () => purchaseUpgrade('fireRate');
            document.getElementById('btn-speed').onclick = () => purchaseUpgrade('speed');
        }

        // ==================== GAME LOOP ====================
        function gameLoop() {
            updateGame();

            // Check wave completion
            if (enemiesToSpawn <= 0 && enemyShips.length === 0 && !gameState.isGameOver) {
                checkWaveComplete();
            }
        }

        // ==================== INITIALIZATION ====================
        const scene = createScene();

        setupInput();
        updateUI();
        startWave();

        engine.runRenderLoop(() => {
            gameLoop();
            scene.render();
        });

        window.addEventListener('resize', () => {
            engine.resize();
        });

        console.log('Pirate Island Defense loaded successfully!');
    </script>
</body>
</html>
