<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Photoshop-like Editor (Single HTML)</title>
  <style>
    :root {
      --bg-dark: #020617;
      --bg-mid: #0b1120;
      --bg-top: #111827;
      --border-subtle: #1f2937;
      --accent: #2563eb;
      --accent-soft: rgba(37, 99, 235, 0.2);
      --text: #e5e7eb;
      --text-soft: #9ca3af;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-user-select: none;
      user-select: none;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: var(--text);
    }

    body {
      display: flex;
      flex-direction: column;
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    /* Top bar */

    #top-bar {
      height: 48px;
      background: var(--bg-top);
      border-bottom: 1px solid var(--border-subtle);
      display: flex;
      align-items: center;
      padding: 0 10px;
      gap: 14px;
      flex-shrink: 0;
    }

    .top-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .top-logo {
      background: #0284c7;
      padding: 4px 8px;
      border-radius: 4px;
      font-weight: 700;
      font-size: 14px;
      letter-spacing: 0.06em;
    }

    .menu-label {
      font-size: 13px;
      color: var(--text-soft);
      cursor: default;
    }

    .top-center {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 16px;
      min-width: 0;
      font-size: 12px;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 6px;
      color: var(--text-soft);
      white-space: nowrap;
    }

    .control-group label {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    input[type="color"] {
      width: 32px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid #4b5563;
      background: #111827;
      padding: 0;
      cursor: pointer;
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 4px;
      border-radius: 999px;
      background: #1f2937;
      outline: none;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      margin-top: -4px;
    }

    input[type="range"]::-moz-range-thumb {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
    }

    select {
      border-radius: 4px;
      border: 1px solid #374151;
      background: #020617;
      color: var(--text);
      padding: 2px 4px;
      font-size: 12px;
    }

    .top-right {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .top-btn {
      border-radius: 4px;
      border: 1px solid #374151;
      background: #020617;
      color: var(--text);
      padding: 4px 6px;
      cursor: pointer;
      font-size: 14px;
      min-width: 28px;
    }

    .top-btn:hover:not(:disabled) {
      background: #1f2937;
    }

    .top-btn:disabled {
      opacity: 0.3;
      cursor: default;
    }

    /* Workspace */

    #workspace {
      flex: 1;
      display: flex;
      min-height: 0;
    }

    /* Toolbar */

    #toolbar {
      width: 56px;
      background: var(--bg-dark);
      border-right: 1px solid var(--border-subtle);
      padding: 6px 4px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      flex-shrink: 0;
    }

    .tool-btn {
      width: 40px;
      height: 40px;
      border-radius: 6px;
      border: none;
      background: #111827;
      color: var(--text);
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .tool-btn:hover {
      background: #1f2937;
    }

    .tool-btn.active {
      background: var(--accent);
    }

    /* Canvas area */

    #canvas-panel {
      flex: 1;
      background: #020617;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: auto;
      padding: 10px;
    }

    #canvas-wrapper {
      background-image:
        linear-gradient(45deg, #e5e7eb 25%, #d1d5db 25%, #d1d5db 50%, #e5e7eb 50%, #e5e7eb 75%, #d1d5db 75%, #d1d5db 100%);
      background-size: 16px 16px;
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.9);
    }

    #main-canvas {
      display: block;
      background: transparent;
      border-radius: 4px;
      border: 1px solid #030712;
      cursor: crosshair;
    }

    /* Side panels */

    #sidepanels {
      width: 270px;
      background: var(--bg-dark);
      border-left: 1px solid var(--border-subtle);
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex-shrink: 0;
      min-height: 0;
    }

    .panel {
      background: #020617;
      border-radius: 8px;
      border: 1px solid var(--border-subtle);
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-height: 0;
    }

    .panel-header {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-soft);
    }

    #layers-list {
      flex: 1;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .layer-item {
      background: #030712;
      border-radius: 6px;
      border: 1px solid transparent;
      padding: 4px 6px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      cursor: pointer;
    }

    .layer-item.active {
      background: #0b1120;
      border-color: var(--accent);
    }

    .layer-main {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .layer-eye {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: none;
      background: transparent;
      color: var(--text-soft);
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      flex-shrink: 0;
    }

    .layer-name {
      font-size: 12px;
      flex: 1;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    .layer-controls {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .layer-opacity {
      flex: 1;
    }

    .layer-blend {
      border-radius: 4px;
      border: 1px solid #374151;
      background: #020617;
      color: var(--text);
      font-size: 11px;
      padding: 2px 4px;
      max-width: 110px;
    }

    #layers-actions,
    #layers-actions-2 {
      display: flex;
      gap: 4px;
    }

    .layers-btn {
      flex: 1;
      border-radius: 4px;
      border: 1px solid #374151;
      background: #020617;
      color: var(--text);
      font-size: 11px;
      padding: 4px;
      cursor: pointer;
    }

    .layers-btn:hover {
      background: #111827;
    }

    #history-list {
      flex: 1;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: 11px;
    }

    .history-item {
      padding: 3px 5px;
      border-radius: 4px;
      cursor: pointer;
      color: var(--text-soft);
    }

    .history-item.active {
      background: #111827;
      color: var(--text);
    }

    .history-item:hover {
      background: #0b1120;
    }

    /* Scrollbars */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: #4b5563;
      border-radius: 999px;
    }

    @media (max-width: 900px) {
      #sidepanels {
        width: 220px;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Top bar -->
    <div id="top-bar">
      <div class="top-left">
        <div class="top-logo">Ps</div>
        <div class="menu-label">File</div>
        <div class="menu-label">Edit</div>
        <div class="menu-label">Image</div>
        <div class="menu-label">Filter</div>
      </div>

      <div class="top-center">
        <div class="control-group">
          <label>
            Color
            <input type="color" id="color-picker" value="#000000" />
          </label>
        </div>

        <div class="control-group">
          <label>
            Size
            <input type="range" id="size-range" min="1" max="60" value="8" />
            <span id="size-label">8</span>
          </label>
        </div>

        <div class="control-group">
          <label>
            Opacity
            <input type="range" id="opacity-range" min="10" max="100" value="100" />
            <span id="opacity-label">100%</span>
          </label>
        </div>

        <div class="control-group">
          <label>
            Filter
            <select id="filter-select">
              <option value="none">None</option>
              <option value="grayscale">Grayscale</option>
              <option value="invert">Invert</option>
              <option value="brightness">Brightness+</option>
              <option value="contrast">Contrast+</option>
              <option value="blur">Blur</option>
            </select>
          </label>
          <button class="top-btn" id="apply-filter">Apply</button>
        </div>
      </div>

      <div class="top-right">
        <button class="top-btn" id="undo-btn" title="Undo">â†¶</button>
        <button class="top-btn" id="redo-btn" title="Redo">â†·</button>
      </div>
    </div>

    <!-- Workspace -->
    <div id="workspace">
      <!-- Toolbar -->
      <div id="toolbar">
        <button class="tool-btn active" data-tool="brush" title="Brush">ðŸ–Œ</button>
        <button class="tool-btn" data-tool="eraser" title="Eraser">ðŸ©¹</button>
        <button class="tool-btn" data-tool="fill" title="Fill (whole layer)">ðŸª£</button>
      </div>

      <!-- Canvas panel -->
      <div id="canvas-panel">
        <div id="canvas-wrapper">
          <canvas id="main-canvas" width="900" height="600"></canvas>
        </div>
      </div>

      <!-- Side panels -->
      <div id="sidepanels">
        <!-- Layers -->
        <div class="panel" id="layers-panel">
          <div class="panel-header">Layers</div>
          <div id="layers-list"></div>
          <div id="layers-actions">
            <button class="layers-btn" id="add-layer-btn">+ Layer</button>
            <button class="layers-btn" id="delete-layer-btn">Delete</button>
          </div>
          <div id="layers-actions-2">
            <button class="layers-btn" id="layer-up-btn">Move Up</button>
            <button class="layers-btn" id="layer-down-btn">Move Down</button>
            <button class="layers-btn" id="layer-dup-btn">Duplicate</button>
          </div>
        </div>

        <!-- History -->
        <div class="panel" id="history-panel">
          <div class="panel-header">History</div>
          <div id="history-list"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (function () {
      'use strict';

      const canvas = document.getElementById('main-canvas');
      const ctx = canvas.getContext('2d');

      const state = {
        canvasWidth: canvas.width,
        canvasHeight: canvas.height,
        layers: [],
        activeLayerIndex: 0,
        tool: 'brush',
        brushColor: '#000000',
        brushSize: 8,
        brushOpacity: 1,
        isDrawing: false,
        lastX: 0,
        lastY: 0,
        history: [],
        historyIndex: -1,
        isRestoringHistory: false
      };

      const BLEND_MODES = {
        normal: 'source-over',
        multiply: 'multiply',
        screen: 'screen',
        overlay: 'overlay',
        darken: 'darken',
        lighten: 'lighten'
      };

      const FILTER_LABELS = {
        grayscale: 'Grayscale',
        invert: 'Invert',
        brightness: 'Brightness+',
        contrast: 'Contrast+',
        blur: 'Blur'
      };

      function init() {
        createInitialDocument();
        attachUI();
        renderLayers();
        saveHistory('Initial document');
      }

      function createLayer(name) {
        const offCanvas = document.createElement('canvas');
        offCanvas.width = state.canvasWidth;
        offCanvas.height = state.canvasHeight;
        const offCtx = offCanvas.getContext('2d');
        offCtx.clearRect(0, 0, offCanvas.width, offCanvas.height);
        return {
          id: Date.now() + Math.random(),
          name,
          visible: true,
          opacity: 1,
          blendMode: BLEND_MODES.normal,
          canvas: offCanvas,
          ctx: offCtx
        };
      }

      function createInitialDocument() {
        state.layers = [];

        const background = createLayer('Background');
        background.ctx.fillStyle = '#ffffff';
        background.ctx.fillRect(0, 0, state.canvasWidth, state.canvasHeight);
        state.layers.push(background);

        const layer1 = createLayer('Layer 1');
        state.layers.push(layer1);

        state.activeLayerIndex = 1;

        state.history = [];
        state.historyIndex = -1;
        refreshLayersUI();
        refreshHistoryUI();
        updateUndoRedoButtons();
      }

      function getActiveLayer() {
        return state.layers[state.activeLayerIndex] || null;
      }

      function renderLayers() {
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);

        for (let i = 0; i < state.layers.length; i++) {
          const layer = state.layers[i];
          if (!layer.visible) continue;
          ctx.globalAlpha = layer.opacity;
          ctx.globalCompositeOperation = layer.blendMode || 'source-over';
          ctx.drawImage(layer.canvas, 0, 0);
        }

        ctx.restore();
      }

      function getLayerSnapshot(layer) {
        const img = layer.ctx.getImageData(0, 0, state.canvasWidth, state.canvasHeight);
        const clone = new ImageData(
          new Uint8ClampedArray(img.data),
          img.width,
          img.height
        );
        return {
          name: layer.name,
          visible: layer.visible,
          opacity: layer.opacity,
          blendMode: layer.blendMode,
          imageData: clone
        };
      }

      function saveHistory(label) {
        if (state.isRestoringHistory) return;

        const snapshotLayers = state.layers.map(getLayerSnapshot);
        state.history = state.history.slice(0, state.historyIndex + 1);
        state.history.push({
          label: label,
          layers: snapshotLayers
        });

        const MAX_HISTORY = 30;
        if (state.history.length > MAX_HISTORY) {
          state.history.shift();
          state.historyIndex = state.history.length - 1;
        } else {
          state.historyIndex = state.history.length - 1;
        }

        refreshHistoryUI();
        updateUndoRedoButtons();
      }

      function loadHistory(index) {
        const snap = state.history[index];
        if (!snap) return;

        state.isRestoringHistory = true;
        state.layers = snap.layers.map(lsnap => {
          const layer = createLayer(lsnap.name);
          layer.visible = lsnap.visible;
          layer.opacity = lsnap.opacity;
          layer.blendMode = lsnap.blendMode;
          layer.ctx.putImageData(lsnap.imageData, 0, 0);
          return layer;
        });

        state.activeLayerIndex = Math.min(state.layers.length - 1, state.activeLayerIndex);
        state.historyIndex = index;
        state.isRestoringHistory = false;

        renderLayers();
        refreshLayersUI();
        refreshHistoryUI();
        updateUndoRedoButtons();
      }

      function undo() {
        if (state.historyIndex <= 0) return;
        loadHistory(state.historyIndex - 1);
      }

      function redo() {
        if (state.historyIndex >= state.history.length - 1) return;
        loadHistory(state.historyIndex + 1);
      }

      function updateUndoRedoButtons() {
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        undoBtn.disabled = state.historyIndex <= 0;
        redoBtn.disabled = state.historyIndex >= state.history.length - 1;
      }

      function refreshHistoryUI() {
        const list = document.getElementById('history-list');
        list.innerHTML = '';
        state.history.forEach((entry, index) => {
          const item = document.createElement('div');
          item.className = 'history-item';
          if (index === state.historyIndex) item.classList.add('active');
          item.textContent = (index + 1) + '. ' + entry.label;
          item.dataset.index = index;
          item.addEventListener('click', () => {
            loadHistory(index);
          });
          list.appendChild(item);
        });
      }

      function refreshLayersUI() {
        const list = document.getElementById('layers-list');
        list.innerHTML = '';

        for (let i = state.layers.length - 1; i >= 0; i--) {
          const layer = state.layers[i];
          const item = document.createElement('div');
          item.className = 'layer-item';
          if (i === state.activeLayerIndex) item.classList.add('active');
          item.dataset.index = i;

          const mainRow = document.createElement('div');
          mainRow.className = 'layer-main';

          const eyeBtn = document.createElement('button');
          eyeBtn.className = 'layer-eye';
          eyeBtn.textContent = layer.visible ? 'ðŸ‘' : 'ðŸš«';
          mainRow.appendChild(eyeBtn);

          const nameSpan = document.createElement('span');
          nameSpan.className = 'layer-name';
          nameSpan.textContent = layer.name;
          mainRow.appendChild(nameSpan);

          item.appendChild(mainRow);

          const controlsRow = document.createElement('div');
          controlsRow.className = 'layer-controls';

          const opRange = document.createElement('input');
          opRange.type = 'range';
          opRange.min = '0';
          opRange.max = '100';
          opRange.value = String(Math.round(layer.opacity * 100));
          opRange.className = 'layer-opacity';

          const blendSelect = document.createElement('select');
          blendSelect.className = 'layer-blend';

          const blendOptions = [
            ['normal', 'Normal'],
            ['multiply', 'Multiply'],
            ['screen', 'Screen'],
            ['overlay', 'Overlay'],
            ['darken', 'Darken'],
            ['lighten', 'Lighten']
          ];

          blendOptions.forEach(([val, label]) => {
            const opt = document.createElement('option');
            opt.value = val;
            opt.textContent = label;
            if (BLEND_MODES[val] === layer.blendMode) opt.selected = true;
            blendSelect.appendChild(opt);
          });

          controlsRow.appendChild(opRange);
          controlsRow.appendChild(blendSelect);
          item.appendChild(controlsRow);

          // Events
          item.addEventListener('click', (e) => {
            if (e.target === eyeBtn || e.target === opRange || e.target === blendSelect) return;
            state.activeLayerIndex = i;
            refreshLayersUI();
          });

          eyeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            layer.visible = !layer.visible;
            renderLayers();
            refreshLayersUI();
            saveHistory('Toggle visibility: ' + layer.name);
          });

          opRange.addEventListener('input', () => {
            layer.opacity = Number(opRange.value) / 100;
            renderLayers();
          });

          opRange.addEventListener('change', () => {
            saveHistory('Change opacity: ' + layer.name);
          });

          blendSelect.addEventListener('change', () => {
            const val = blendSelect.value;
            layer.blendMode = BLEND_MODES[val] || BLEND_MODES.normal;
            renderLayers();
            saveHistory('Blend mode: ' + layer.name);
          });

          list.appendChild(item);
        }
      }

      function attachUI() {
        // Tools
        document.querySelectorAll('.tool-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            state.tool = btn.dataset.tool || 'brush';
            canvas.style.cursor = (state.tool === 'fill') ? 'pointer' : 'crosshair';
          });
        });

        // Brush controls
        const colorPicker = document.getElementById('color-picker');
        const sizeRange = document.getElementById('size-range');
        const sizeLabel = document.getElementById('size-label');
        const opacityRange = document.getElementById('opacity-range');
        const opacityLabel = document.getElementById('opacity-label');

        colorPicker.addEventListener('input', () => {
          state.brushColor = colorPicker.value;
        });

        sizeRange.addEventListener('input', () => {
          state.brushSize = Number(sizeRange.value);
          sizeLabel.textContent = sizeRange.value;
        });

        opacityRange.addEventListener('input', () => {
          state.brushOpacity = Number(opacityRange.value) / 100;
          opacityLabel.textContent = opacityRange.value + '%';
        });

        // Undo/redo
        document.getElementById('undo-btn').addEventListener('click', undo);
        document.getElementById('redo-btn').addEventListener('click', redo);

        // Filters
        document.getElementById('apply-filter').addEventListener('click', () => {
          const sel = document.getElementById('filter-select');
          const type = sel.value;
          if (type === 'none') return;
          applyFilter(type);
        });

        // Layer actions
        document.getElementById('add-layer-btn').addEventListener('click', addLayer);
        document.getElementById('delete-layer-btn').addEventListener('click', deleteLayer);
        document.getElementById('layer-up-btn').addEventListener('click', () => moveLayer(1));
        document.getElementById('layer-down-btn').addEventListener('click', () => moveLayer(-1));
        document.getElementById('layer-dup-btn').addEventListener('click', duplicateLayer);

        // Canvas drawing
        canvas.addEventListener('pointerdown', onPointerDown);
        canvas.addEventListener('pointermove', onPointerMove);
        canvas.addEventListener('pointerup', onPointerUp);
        canvas.addEventListener('pointerleave', onPointerUp);
      }

      function getCanvasCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
          x: (e.clientX - rect.left) * scaleX,
          y: (e.clientY - rect.top) * scaleY
        };
      }

      function onPointerDown(e) {
        e.preventDefault();
        const pos = getCanvasCoords(e);
        if (state.tool === 'brush' || state.tool === 'eraser') {
          state.isDrawing = true;
          state.lastX = pos.x;
          state.lastY = pos.y;
        } else if (state.tool === 'fill') {
          applyFill();
        }
      }

      function onPointerMove(e) {
        if (!state.isDrawing) return;
        const pos = getCanvasCoords(e);
        drawStroke(state.lastX, state.lastY, pos.x, pos.y);
        state.lastX = pos.x;
        state.lastY = pos.y;
      }

      function onPointerUp() {
        if (!state.isDrawing) return;
        state.isDrawing = false;
        saveHistory('Brush stroke');
      }

      function drawStroke(x1, y1, x2, y2) {
        const layer = getActiveLayer();
        if (!layer) return;
        const lctx = layer.ctx;
        lctx.save();
        lctx.lineCap = 'round';
        lctx.lineJoin = 'round';
        lctx.lineWidth = state.brushSize;

        if (state.tool === 'brush') {
          lctx.globalCompositeOperation = 'source-over';
          lctx.strokeStyle = state.brushColor;
          lctx.globalAlpha = state.brushOpacity;
        } else if (state.tool === 'eraser') {
          lctx.globalCompositeOperation = 'destination-out';
          lctx.strokeStyle = 'rgba(0,0,0,1)';
          lctx.globalAlpha = 1;
        }

        lctx.beginPath();
        lctx.moveTo(x1, y1);
        lctx.lineTo(x2, y2);
        lctx.stroke();
        lctx.restore();

        renderLayers();
      }

      function applyFill() {
        const layer = getActiveLayer();
        if (!layer) return;
        const lctx = layer.ctx;
        lctx.save();
        lctx.globalCompositeOperation = 'source-over';
        lctx.globalAlpha = state.brushOpacity;
        lctx.fillStyle = state.brushColor;
        lctx.fillRect(0, 0, state.canvasWidth, state.canvasHeight);
        lctx.restore();
        renderLayers();
        saveHistory('Fill layer');
      }

      function addLayer() {
        const idx = state.activeLayerIndex;
        const newLayer = createLayer('Layer ' + state.layers.length);
        state.layers.splice(idx + 1, 0, newLayer);
        state.activeLayerIndex = idx + 1;
        renderLayers();
        refreshLayersUI();
        saveHistory('Add layer');
      }

      function deleteLayer() {
        if (state.layers.length <= 1) return;
        const idx = state.activeLayerIndex;
        if (idx === 0) {
          // Don't delete background; just ignore
          return;
        }
        const name = state.layers[idx].name;
        state.layers.splice(idx, 1);
        state.activeLayerIndex = Math.max(0, idx - 1);
        renderLayers();
        refreshLayersUI();
        saveHistory('Delete layer: ' + name);
      }

      function moveLayer(direction) {
        const idx = state.activeLayerIndex;
        const newIndex = idx + direction;
        if (newIndex < 0 || newIndex >= state.layers.length) return;
        const tmp = state.layers[idx];
        state.layers[idx] = state.layers[newIndex];
        state.layers[newIndex] = tmp;
        state.activeLayerIndex = newIndex;
        renderLayers();
        refreshLayersUI();
        saveHistory('Reorder layers');
      }

      function duplicateLayer() {
        const layer = getActiveLayer();
        if (!layer) return;
        const snapshot = getLayerSnapshot(layer);
        const newLayer = createLayer(layer.name + ' copy');
        newLayer.visible = snapshot.visible;
        newLayer.opacity = snapshot.opacity;
        newLayer.blendMode = snapshot.blendMode;
        newLayer.ctx.putImageData(snapshot.imageData, 0, 0);

        const idx = state.activeLayerIndex;
        state.layers.splice(idx + 1, 0, newLayer);
        state.activeLayerIndex = idx + 1;
        renderLayers();
        refreshLayersUI();
        saveHistory('Duplicate layer: ' + layer.name);
      }

      function applyFilter(type) {
        const layer = getActiveLayer();
        if (!layer) return;

        const img = layer.ctx.getImageData(0, 0, state.canvasWidth, state.canvasHeight);
        const data = img.data;
        const len = data.length;

        if (type === 'grayscale') {
          for (let i = 0; i < len; i += 4) {
            const r = data[i], g = data[i + 1], b = data[i + 2];
            const v = 0.3 * r + 0.59 * g + 0.11 * b;
            data[i] = data[i + 1] = data[i + 2] = v;
          }
        } else if (type === 'invert') {
          for (let i = 0; i < len; i += 4) {
            data[i] = 255 - data[i];
            data[i + 1] = 255 - data[i + 1];
            data[i + 2] = 255 - data[i + 2];
          }
        } else if (type === 'brightness') {
          const delta = 30;
          for (let i = 0; i < len; i += 4) {
            data[i] = Math.max(0, Math.min(255, data[i] + delta));
            data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + delta));
            data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + delta));
          }
        } else if (type === 'contrast') {
          const contrast = 40;
          const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
          for (let i = 0; i < len; i += 4) {
            data[i] = clampColor(factor * (data[i] - 128) + 128);
            data[i + 1] = clampColor(factor * (data[i + 1] - 128) + 128);
            data[i + 2] = clampColor(factor * (data[i + 2] - 128) + 128);
          }
        } else if (type === 'blur') {
          applyBoxBlur(img, layer.ctx);
          renderLayers();
          saveHistory('Filter: ' + (FILTER_LABELS[type] || type));
          return;
        }

        layer.ctx.putImageData(img, 0, 0);
        renderLayers();
        saveHistory('Filter: ' + (FILTER_LABELS[type] || type));
      }

      function clampColor(v) {
        return Math.max(0, Math.min(255, v));
      }

      function applyBoxBlur(img, lctx) {
        const w = img.width;
        const h = img.height;
        const src = img.data;
        const out = new Uint8ClampedArray(src.length);
        const kernelSize = 3;
        const half = Math.floor(kernelSize / 2);

        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            let r = 0, g = 0, b = 0, a = 0, count = 0;
            for (let ky = -half; ky <= half; ky++) {
              for (let kx = -half; kx <= half; kx++) {
                const nx = x + kx;
                const ny = y + ky;
                if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                  const idx = (ny * w + nx) * 4;
                  r += src[idx];
                  g += src[idx + 1];
                  b += src[idx + 2];
                  a += src[idx + 3];
                  count++;
                }
              }
            }
            const i = (y * w + x) * 4;
            out[i] = r / count;
            out[i + 1] = g / count;
            out[i + 2] = b / count;
            out[i + 3] = a / count;
          }
        }

        img.data.set(out);
        lctx.putImageData(img, 0, 0);
      }

      init();
    })();
  </script>
</body>
</html>
