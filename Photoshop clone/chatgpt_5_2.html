<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MiniShop (Photoshop-like) ‚Äî Single File</title>
  <style>
    :root{
      --bg:#0e0f12; --panel:#14161b; --panel2:#101218; --line:#252833;
      --text:#e7e9ee; --muted:#a9afbf; --acc:#5aa7ff; --good:#38d996; --bad:#ff5a77;
      --btn:#1b1f2a; --btn2:#23293a; --shadow: rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: var(--sans); }
    button, input, select { font: inherit; color: inherit; }
    a { color: var(--acc); }
    .app {
      display: grid;
      grid-template-rows: 46px 1fr;
      height: 100%;
    }
    .topbar {
      display: flex; align-items: center; gap: 10px;
      padding: 8px 10px;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(180deg, #141722, #10121a);
      box-shadow: 0 2px 10px var(--shadow);
      user-select: none;
    }
    .brand { font-weight: 700; letter-spacing: .2px; }
    .brand small { font-weight: 500; color: var(--muted); margin-left: 6px; }
    .pill {
      padding: 4px 8px; border: 1px solid var(--line); border-radius: 999px;
      background: rgba(255,255,255,.03); color: var(--muted);
      font-size: 12px;
    }
    .spacer { flex: 1; }
    .btn {
      background: var(--btn); border: 1px solid var(--line); border-radius: 10px;
      padding: 7px 10px; cursor: pointer;
      display: inline-flex; align-items: center; gap: 8px;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
    }
    .btn:hover { background: var(--btn2); border-color: #2f3550; }
    .btn:active { transform: translateY(1px); }
    .btn.primary { border-color: rgba(90,167,255,.4); box-shadow: 0 0 0 2px rgba(90,167,255,.08) inset; }
    .btn.danger { border-color: rgba(255,90,119,.4); }
    .btn .k { font-family: var(--mono); font-size: 11px; color: var(--muted); padding: 1px 6px; border: 1px solid var(--line); border-radius: 999px; }
    .main {
      display: grid;
      grid-template-columns: 260px 1fr 330px;
      min-height: 0;
    }
    .left, .right {
      min-height: 0;
      border-right: 1px solid var(--line);
      background: var(--panel);
    }
    .right { border-right: none; border-left: 1px solid var(--line); }
    .panel {
      display: flex; flex-direction: column;
      min-height: 0;
      height: 100%;
    }
    .panel h3 {
      margin: 0;
      padding: 10px 12px;
      font-size: 12px;
      letter-spacing: .8px;
      text-transform: uppercase;
      color: var(--muted);
      border-bottom: 1px solid var(--line);
      background: var(--panel2);
    }
    .section { padding: 10px 12px; border-bottom: 1px solid var(--line); }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
    .label { font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    .ctrl {
      width: 100%;
      background: var(--btn);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      outline: none;
    }
    .ctrl:focus { border-color: rgba(90,167,255,.6); box-shadow: 0 0 0 3px rgba(90,167,255,.12); }
    .toolgrid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }
    .toolbtn {
      padding: 10px 8px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: var(--btn);
      cursor: pointer;
      display: grid;
      place-items: center;
      gap: 4px;
      user-select: none;
    }
    .toolbtn:hover { background: var(--btn2); }
    .toolbtn.active { border-color: rgba(90,167,255,.6); box-shadow: 0 0 0 3px rgba(90,167,255,.12); }
    .toolbtn .i { font-size: 16px; line-height: 1; }
    .toolbtn .t { font-size: 11px; color: var(--muted); }
    .canvasWrap {
      position: relative;
      min-width: 0; min-height: 0;
      background:
        linear-gradient(45deg, rgba(255,255,255,.04) 25%, transparent 25%, transparent 75%, rgba(255,255,255,.04) 75%, rgba(255,255,255,.04)),
        linear-gradient(45deg, rgba(255,255,255,.04) 25%, transparent 25%, transparent 75%, rgba(255,255,255,.04) 75%, rgba(255,255,255,.04));
      background-position: 0 0, 12px 12px;
      background-size: 24px 24px;
      overflow: hidden;
    }
    canvas { position: absolute; inset: 0; width: 100%; height: 100%; }
    .status {
      position: absolute; left: 10px; bottom: 10px;
      background: rgba(10,12,18,.72);
      border: 1px solid rgba(255,255,255,.08);
      padding: 6px 9px;
      border-radius: 10px;
      font-size: 12px;
      color: var(--muted);
      display: flex; gap: 10px; align-items: center;
      user-select: none;
      backdrop-filter: blur(10px);
    }
    .status strong { color: var(--text); font-weight: 650; }
    .hint {
      position: absolute; right: 10px; bottom: 10px;
      background: rgba(10,12,18,.72);
      border: 1px solid rgba(255,255,255,.08);
      padding: 8px 10px;
      border-radius: 12px;
      width: min(420px, 92%);
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
      user-select: none;
      backdrop-filter: blur(10px);
    }
    .hint code { font-family: var(--mono); font-size: 11px; color: var(--text); }
    .list {
      min-height: 0;
      overflow: auto;
      padding: 8px;
    }
    .item {
      border: 1px solid var(--line);
      background: rgba(255,255,255,.03);
      border-radius: 12px;
      padding: 8px 10px;
      margin-bottom: 8px;
      cursor: pointer;
      user-select: none;
    }
    .item:hover { border-color: #313857; }
    .item.active { border-color: rgba(90,167,255,.6); box-shadow: 0 0 0 3px rgba(90,167,255,.10); }
    .item .top {
      display: flex; align-items: center; gap: 8px;
    }
    .badge {
      font-size: 11px;
      padding: 2px 7px;
      border-radius: 999px;
      border: 1px solid var(--line);
      color: var(--muted);
    }
    .eye { cursor: pointer; padding: 2px 6px; border-radius: 8px; border: 1px solid var(--line); background: rgba(255,255,255,.02); }
    .eye.off { opacity: .55; }
    .item .name { flex: 1; font-weight: 600; }
    .item .meta { font-size: 11px; color: var(--muted); margin-top: 6px; display:flex; gap:8px; flex-wrap: wrap; }
    .minirow { display:flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-top: 8px; }
    .minirow .ctrl { padding: 6px 8px; border-radius: 10px; }
    .hr { height: 1px; background: var(--line); margin: 10px 0; }
    .toast {
      position: absolute; top: 12px; left: 50%; transform: translateX(-50%);
      background: rgba(10,12,18,.85);
      border: 1px solid rgba(255,255,255,.12);
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 12px;
      color: var(--text);
      display: none;
      user-select: none;
      box-shadow: 0 10px 24px rgba(0,0,0,.35);
      backdrop-filter: blur(12px);
    }
    .toast.show { display: block; animation: pop .18s ease-out; }
    @keyframes pop { from { transform: translateX(-50%) translateY(-6px); opacity: .0; } to { transform: translateX(-50%) translateY(0); opacity: 1; } }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="brand">MiniShop <small>single-file ‚ÄúPhotoshop-ish‚Äù</small></div>
      <div id="docInfo" class="pill">Doc: ‚Äî</div>
      <div id="zoomInfo" class="pill">Zoom: ‚Äî</div>
      <div class="spacer"></div>

      <button class="btn" id="newBtn" title="New document"><span>üÜï</span><span>New</span></button>
      <button class="btn" id="openImgBtn" title="Place image as new layer"><span>üì∑</span><span>Open Image</span></button>
      <button class="btn" id="openProjBtn" title="Open .minishop project"><span>üìÇ</span><span>Open Project</span></button>
      <button class="btn" id="saveProjBtn" title="Save .minishop project"><span>üíæ</span><span>Save Project</span></button>
      <button class="btn primary" id="exportBtn" title="Export merged PNG"><span>üñºÔ∏è</span><span>Export PNG</span></button>

      <button class="btn" id="undoBtn" title="Undo (Ctrl/‚åò+Z)"><span>‚Ü∂</span><span>Undo</span><span class="k">Ctrl Z</span></button>
      <button class="btn" id="redoBtn" title="Redo (Ctrl/‚åò+Y or Ctrl/‚åò+Shift+Z)"><span>‚Ü∑</span><span>Redo</span><span class="k">Ctrl Y</span></button>

      <input id="fileImg" type="file" accept="image/*" hidden />
      <input id="fileProj" type="file" accept=".minishop,application/json" hidden />
    </div>

    <div class="main">
      <!-- LEFT: Tools -->
      <div class="left panel">
        <h3>Tools</h3>
        <div class="section">
          <div class="toolgrid">
            <div class="toolbtn active" data-tool="brush" title="Brush (B)">
              <div class="i">üñåÔ∏è</div><div class="t">Brush</div>
            </div>
            <div class="toolbtn" data-tool="eraser" title="Eraser (E)">
              <div class="i">üßΩ</div><div class="t">Eraser</div>
            </div>
            <div class="toolbtn" data-tool="move" title="Move Layer (V)">
              <div class="i">üß≤</div><div class="t">Move</div>
            </div>
            <div class="toolbtn" data-tool="marquee" title="Rect Select (M)">
              <div class="i">‚ñ≠</div><div class="t">Select</div>
            </div>
            <div class="toolbtn" data-tool="text" title="Text (T)">
              <div class="i">üî§</div><div class="t">Text</div>
            </div>
            <div class="toolbtn" data-tool="hand" title="Pan (Space)">
              <div class="i">‚úã</div><div class="t">Hand</div>
            </div>
          </div>
        </div>

        <h3>Brush</h3>
        <div class="section">
          <div class="row">
            <div>
              <div class="label">Color</div>
              <input class="ctrl" id="color" type="color" value="#5aa7ff" />
            </div>
            <div>
              <div class="label">Opacity</div>
              <input class="ctrl" id="brushOpacity" type="range" min="0" max="1" step="0.01" value="1" />
            </div>
          </div>
          <div class="hr"></div>
          <div class="row">
            <div>
              <div class="label">Size</div>
              <input class="ctrl" id="size" type="range" min="1" max="200" step="1" value="18" />
            </div>
            <div>
              <div class="label">Hardness</div>
              <input class="ctrl" id="hardness" type="range" min="0" max="1" step="0.01" value="0.65" />
            </div>
          </div>
          <div class="hr"></div>
          <div class="row3">
            <button class="btn" id="fillSelBtn" title="Fill selection with current color">ü™£ Fill</button>
            <button class="btn danger" id="clearSelBtn" title="Clear selection (Delete)">üßπ Clear</button>
            <button class="btn" id="deselectBtn" title="Deselect (Esc)">üö´ None</button>
          </div>
        </div>

        <h3>Filters</h3>
        <div class="section">
          <div class="row">
            <button class="btn" data-filter="grayscale">‚ö´ Grayscale</button>
            <button class="btn" data-filter="invert">üîÅ Invert</button>
            <button class="btn" data-filter="sepia">üü§ Sepia</button>
            <button class="btn" data-filter="blur">üå´Ô∏è Blur</button>
            <button class="btn" data-filter="sharpen">üó°Ô∏è Sharpen</button>
            <button class="btn" data-filter="edge">üßä Edge</button>
          </div>
          <div class="hr"></div>
          <button class="btn" id="bcBtn" title="Brightness/Contrast (applies to active layer)">üåó Brightness / Contrast</button>
        </div>

        <h3>Help</h3>
        <div class="section" style="font-size:12px;color:var(--muted);line-height:1.45">
          <div><b>Zoom:</b> Ctrl/‚åò + Mousewheel</div>
          <div><b>Pan:</b> Space-drag (or Hand tool)</div>
          <div><b>Undo/Redo:</b> Ctrl/‚åò+Z, Ctrl/‚åò+Y</div>
          <div style="margin-top:8px;font-family:var(--mono);font-size:11px;">
            B Brush ¬∑ E Eraser ¬∑ V Move ¬∑ M Select ¬∑ T Text ¬∑ Esc Deselect
          </div>
        </div>
      </div>

      <!-- CENTER: Canvas -->
      <div class="canvasWrap" id="canvasWrap">
        <canvas id="view"></canvas>
        <canvas id="overlay"></canvas>
        <div class="toast" id="toast"></div>
        <div class="status" id="status">
          <span>Tool: <strong id="toolName">Brush</strong></span>
          <span>Layer: <strong id="layerName">‚Äî</strong></span>
          <span>Pos: <strong id="pos">‚Äî</strong></span>
        </div>
        <div class="hint">
          <div><b>MiniShop</b> supports: brushes/eraser, layers (opacity + blend modes), move layer, selection + fill/clear, text, filters, and history.</div>
          <div style="margin-top:6px;">Tip: Use <code>Open Image</code> to add photos as new layers; <code>Save Project</code> keeps layers/editability.</div>
        </div>
      </div>

      <!-- RIGHT: Layers + History -->
      <div class="right panel">
        <h3>Layers</h3>
        <div class="section">
          <div class="row">
            <button class="btn" id="addLayerBtn">‚ûï Add</button>
            <button class="btn" id="dupLayerBtn">üìÑ Duplicate</button>
            <button class="btn danger" id="delLayerBtn">üóëÔ∏è Delete</button>
            <button class="btn" id="mergeDownBtn" title="Merge active down">‚¨áÔ∏è Merge</button>
          </div>
        </div>
        <div class="list" id="layersList"></div>

        <h3>History</h3>
        <div class="section">
          <div class="row">
            <button class="btn" id="snapBtn" title="Add a history snapshot">üìç Snapshot</button>
            <button class="btn danger" id="clearHistBtn" title="Clear history (keeps current state)">üßØ Clear</button>
          </div>
        </div>
        <div class="list" id="historyList"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Utilities =====
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const now = () => performance.now();

  function downloadBlob(blob, filename){
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
  }
  function downloadText(text, filename, type="application/json"){
    downloadBlob(new Blob([text], {type}), filename);
  }
  function hexToRgb(hex){
    const s = hex.replace('#','').trim();
    const v = s.length===3 ? s.split('').map(c=>c+c).join('') : s;
    const n = parseInt(v, 16);
    return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
  }

  // ===== DOM =====
  const view = document.getElementById('view');
  const overlay = document.getElementById('overlay');
  const wrap = document.getElementById('canvasWrap');
  const ctxV = view.getContext('2d');
  const ctxO = overlay.getContext('2d');

  const toolNameEl = document.getElementById('toolName');
  const layerNameEl = document.getElementById('layerName');
  const posEl = document.getElementById('pos');
  const docInfoEl = document.getElementById('docInfo');
  const zoomInfoEl = document.getElementById('zoomInfo');
  const toastEl = document.getElementById('toast');

  const layersList = document.getElementById('layersList');
  const historyList = document.getElementById('historyList');

  const colorEl = document.getElementById('color');
  const sizeEl = document.getElementById('size');
  const hardnessEl = document.getElementById('hardness');
  const brushOpacityEl = document.getElementById('brushOpacity');

  // Top buttons
  const newBtn = document.getElementById('newBtn');
  const openImgBtn = document.getElementById('openImgBtn');
  const openProjBtn = document.getElementById('openProjBtn');
  const saveProjBtn = document.getElementById('saveProjBtn');
  const exportBtn = document.getElementById('exportBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const fileImg = document.getElementById('fileImg');
  const fileProj = document.getElementById('fileProj');

  // Layer buttons
  const addLayerBtn = document.getElementById('addLayerBtn');
  const dupLayerBtn = document.getElementById('dupLayerBtn');
  const delLayerBtn = document.getElementById('delLayerBtn');
  const mergeDownBtn = document.getElementById('mergeDownBtn');

  // Selection buttons
  const fillSelBtn = document.getElementById('fillSelBtn');
  const clearSelBtn = document.getElementById('clearSelBtn');
  const deselectBtn = document.getElementById('deselectBtn');

  // History buttons
  const snapBtn = document.getElementById('snapBtn');
  const clearHistBtn = document.getElementById('clearHistBtn');

  const bcBtn = document.getElementById('bcBtn');

  // Filter buttons
  document.querySelectorAll('[data-filter]').forEach(btn => {
    btn.addEventListener('click', () => applyFilter(btn.dataset.filter));
  });

  // Tool buttons
  const toolButtons = [...document.querySelectorAll('.toolbtn')];

  // ===== App State =====
  const App = {
    docW: 1280,
    docH: 720,
    layers: [],
    activeLayer: 0,

    // view transform (CSS pixels)
    zoom: 1,
    panX: 0,
    panY: 0,

    // interaction
    tool: 'brush',
    pointerDown: false,
    lastPt: null,

    // selection
    selection: null, // {x,y,w,h} in doc coords
    selecting: false,
    selStart: null,

    // move tool
    moving: false,
    moveStart: null, // {x,y, ox, oy}

    // panning
    panning: false,
    panStart: null,

    // brush stamp cache
    stamp: { key:'', canvas:null },

    // render invalidation
    dirty: true,
    overlayDirty: true,

    // history
    history: [],
    histIdx: -1,
    maxHist: 30,

    // keyboard
    keys: new Set(),
  };

  function showToast(msg, ms=1400){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toastEl.classList.remove('show'), ms);
  }

  // ===== Canvas sizing =====
  function resizeCanvases(){
    const dpr = window.devicePixelRatio || 1;
    const rect = wrap.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width * dpr));
    const h = Math.max(1, Math.floor(rect.height * dpr));

    if (view.width !== w || view.height !== h){
      view.width = w; view.height = h;
      overlay.width = w; overlay.height = h;
      ctxV.imageSmoothingEnabled = true;
      ctxO.imageSmoothingEnabled = true;
      App.dirty = true;
      App.overlayDirty = true;
    }
  }
  window.addEventListener('resize', () => { resizeCanvases(); fitToScreen(false); });

  function fitToScreen(show=true){
    // Fit doc inside viewport with margin
    const rect = wrap.getBoundingClientRect();
    const margin = 40;
    const scaleX = (rect.width - margin) / App.docW;
    const scaleY = (rect.height - margin) / App.docH;
    App.zoom = clamp(Math.min(scaleX, scaleY), 0.05, 32);

    // center
    const cx = rect.width/2, cy = rect.height/2;
    App.panX = cx - (App.docW*App.zoom)/2;
    App.panY = cy - (App.docH*App.zoom)/2;

    App.dirty = true; App.overlayDirty = true;
    updateTopInfo();
    if (show) showToast('Fit to screen');
  }

  // ===== Layers =====
  function makeLayer(name){
    const c = document.createElement('canvas');
    c.width = App.docW; c.height = App.docH;
    const x = c.getContext('2d');
    x.imageSmoothingEnabled = true;
    return {
      id: crypto.randomUUID?.() ?? String(Math.random()).slice(2),
      name,
      canvas: c,
      ctx: x,
      visible: true,
      opacity: 1,
      blend: 'source-over', // canvas globalCompositeOperation
      offsetX: 0,
      offsetY: 0,
    };
  }

  function addLayer(name){
    const layer = makeLayer(name ?? `Layer ${App.layers.length+1}`);
    App.layers.push(layer);
    App.activeLayer = App.layers.length - 1;
    pushHistory('Add layer');
    refreshUI();
    App.dirty = true;
  }

  function duplicateLayer(){
    const src = App.layers[App.activeLayer];
    if (!src) return;
    const layer = makeLayer(`${src.name} copy`);
    layer.visible = src.visible;
    layer.opacity = src.opacity;
    layer.blend = src.blend;
    layer.offsetX = src.offsetX;
    layer.offsetY = src.offsetY;
    layer.ctx.drawImage(src.canvas, 0, 0);
    App.layers.splice(App.activeLayer+1, 0, layer);
    App.activeLayer += 1;
    pushHistory('Duplicate layer');
    refreshUI();
    App.dirty = true;
  }

  function deleteLayer(){
    if (App.layers.length <= 1){
      showToast('Need at least one layer');
      return;
    }
    const idx = App.activeLayer;
    App.layers.splice(idx, 1);
    App.activeLayer = clamp(idx-1, 0, App.layers.length-1);
    pushHistory('Delete layer');
    refreshUI();
    App.dirty = true;
  }

  function mergeDown(){
    const i = App.activeLayer;
    if (i <= 0) { showToast('No layer below to merge into'); return; }
    const top = App.layers[i];
    const bot = App.layers[i-1];

    // Merge by drawing top onto bottom using top's blend/opacity/offset
    bot.ctx.save();
    bot.ctx.globalAlpha = top.opacity;
    bot.ctx.globalCompositeOperation = top.blend;
    bot.ctx.drawImage(top.canvas, top.offsetX, top.offsetY);
    bot.ctx.restore();

    // Remove top
    App.layers.splice(i, 1);
    App.activeLayer = i-1;
    pushHistory('Merge down');
    refreshUI();
    App.dirty = true;
  }

  function placeImageAsLayer(img){
    const layer = makeLayer(`Image ${App.layers.length+1}`);
    // Fit image to doc with "contain"
    const sx = App.docW / img.width;
    const sy = App.docH / img.height;
    const s = Math.min(sx, sy);
    const w = img.width * s;
    const h = img.height * s;
    const x = (App.docW - w)/2;
    const y = (App.docH - h)/2;
    layer.ctx.drawImage(img, x, y, w, h);
    App.layers.push(layer);
    App.activeLayer = App.layers.length - 1;
    pushHistory('Place image');
    refreshUI();
    App.dirty = true;
  }

  // ===== History =====
  function cloneLayerPixels(layer){
    const img = layer.ctx.getImageData(0,0,App.docW,App.docH);
    // clone data
    const data = new Uint8ClampedArray(img.data);
    return {
      name: layer.name,
      visible: layer.visible,
      opacity: layer.opacity,
      blend: layer.blend,
      offsetX: layer.offsetX,
      offsetY: layer.offsetY,
      pixels: { w: img.width, h: img.height, data }
    };
  }

  function pushHistory(label){
    // drop redo states
    if (App.histIdx < App.history.length - 1){
      App.history.splice(App.histIdx + 1);
    }
    const entry = {
      t: Date.now(),
      label,
      docW: App.docW,
      docH: App.docH,
      activeLayer: App.activeLayer,
      selection: App.selection ? {...App.selection} : null,
      zoom: App.zoom,
      panX: App.panX,
      panY: App.panY,
      layers: App.layers.map(cloneLayerPixels),
    };
    App.history.push(entry);
    if (App.history.length > App.maxHist){
      App.history.shift();
    }
    App.histIdx = App.history.length - 1;
    refreshHistoryUI();
    updateUndoRedoButtons();
  }

  function restoreHistory(idx){
    idx = clamp(idx, 0, App.history.length-1);
    const entry = App.history[idx];
    if (!entry) return;

    // If doc size changed in history, rebuild layers
    App.docW = entry.docW;
    App.docH = entry.docH;
    App.layers = entry.layers.map(l => {
      const layer = makeLayer(l.name);
      layer.visible = l.visible;
      layer.opacity = l.opacity;
      layer.blend = l.blend;
      layer.offsetX = l.offsetX;
      layer.offsetY = l.offsetY;
      const img = new ImageData(new Uint8ClampedArray(l.pixels.data), l.pixels.w, l.pixels.h);
      layer.ctx.putImageData(img, 0, 0);
      return layer;
    });
    App.activeLayer = clamp(entry.activeLayer, 0, App.layers.length-1);
    App.selection = entry.selection ? {...entry.selection} : null;

    App.zoom = entry.zoom; App.panX = entry.panX; App.panY = entry.panY;

    App.histIdx = idx;
    refreshUI();
    App.dirty = true; App.overlayDirty = true;
    updateUndoRedoButtons();
  }

  function undo(){
    if (App.histIdx > 0) restoreHistory(App.histIdx - 1);
  }
  function redo(){
    if (App.histIdx < App.history.length - 1) restoreHistory(App.histIdx + 1);
  }
  function updateUndoRedoButtons(){
    undoBtn.disabled = !(App.histIdx > 0);
    redoBtn.disabled = !(App.histIdx < App.history.length - 1);
    undoBtn.style.opacity = undoBtn.disabled ? .5 : 1;
    redoBtn.style.opacity = redoBtn.disabled ? .5 : 1;
  }

  // ===== Rendering =====
  function updateTopInfo(){
    docInfoEl.textContent = `Doc: ${App.docW}√ó${App.docH}`;
    zoomInfoEl.textContent = `Zoom: ${Math.round(App.zoom*100)}%`;
  }

  function setTransforms(ctx){
    const dpr = window.devicePixelRatio || 1;
    ctx.setTransform(App.zoom*dpr, 0, 0, App.zoom*dpr, App.panX*dpr, App.panY*dpr);
  }

  function render(){
    resizeCanvases();

    if (App.dirty){
      // clear
      ctxV.setTransform(1,0,0,1,0,0);
      ctxV.clearRect(0,0,view.width,view.height);

      // draw layers
      setTransforms(ctxV);
      ctxV.imageSmoothingEnabled = true;

      for (let i=0;i<App.layers.length;i++){
        const L = App.layers[i];
        if (!L.visible) continue;
        ctxV.save();
        ctxV.globalAlpha = L.opacity;
        ctxV.globalCompositeOperation = L.blend || 'source-over';
        ctxV.drawImage(L.canvas, L.offsetX, L.offsetY);
        ctxV.restore();
      }

      // reset
      ctxV.setTransform(1,0,0,1,0,0);
      App.dirty = false;
    }

    if (App.overlayDirty){
      ctxO.setTransform(1,0,0,1,0,0);
      ctxO.clearRect(0,0,overlay.width,overlay.height);

      if (App.selection){
        setTransforms(ctxO);
        ctxO.save();
        ctxO.lineWidth = 1 / (App.zoom * (window.devicePixelRatio||1));
        ctxO.setLineDash([6/(App.zoom*(window.devicePixelRatio||1)), 4/(App.zoom*(window.devicePixelRatio||1))]);
        ctxO.strokeStyle = 'rgba(90,167,255,.95)';
        ctxO.fillStyle = 'rgba(90,167,255,.08)';
        ctxO.strokeRect(App.selection.x, App.selection.y, App.selection.w, App.selection.h);
        ctxO.fillRect(App.selection.x, App.selection.y, App.selection.w, App.selection.h);
        ctxO.restore();
      }

      ctxO.setTransform(1,0,0,1,0,0);
      App.overlayDirty = false;
    }

    requestAnimationFrame(render);
  }

  // ===== Coordinate mapping =====
  function screenToDoc(clientX, clientY){
    const rect = wrap.getBoundingClientRect();
    const x = (clientX - rect.left - App.panX) / App.zoom;
    const y = (clientY - rect.top  - App.panY) / App.zoom;
    return { x, y };
  }

  function docToLayer(docPt, layer){
    // layer is drawn at offset; so draw into layer canvas at (doc - offset)
    return { x: docPt.x - layer.offsetX, y: docPt.y - layer.offsetY };
  }

  function updateStatus(ptDoc){
    const L = App.layers[App.activeLayer];
    toolNameEl.textContent = toolLabel(App.tool);
    layerNameEl.textContent = L ? L.name : '‚Äî';
    if (ptDoc){
      posEl.textContent = `${Math.round(ptDoc.x)}, ${Math.round(ptDoc.y)}`;
    }
    updateTopInfo();
  }

  function toolLabel(tool){
    switch(tool){
      case 'brush': return 'Brush';
      case 'eraser': return 'Eraser';
      case 'move': return 'Move';
      case 'marquee': return 'Select';
      case 'text': return 'Text';
      case 'hand': return 'Hand';
      default: return tool;
    }
  }

  // ===== Brush stamping =====
  function getBrushStamp(size, hardness, colorHex, opacity){
    // Cache by key
    const key = `${size}|${hardness}|${colorHex}|${opacity}`;
    if (App.stamp.key === key && App.stamp.canvas) return App.stamp.canvas;

    const dpr = 1; // stamp in doc pixels
    const s = Math.max(1, Math.round(size * dpr));
    const c = document.createElement('canvas');
    c.width = c.height = s*2+2;
    const g = c.getContext('2d');
    g.clearRect(0,0,c.width,c.height);

    const {r,g:gg,b} = hexToRgb(colorHex);
    const cx = c.width/2, cy = c.height/2;
    const rad = s;

    // Hardness: inner radius stays solid, outer fades.
    const inner = rad * hardness;
    const grd = g.createRadialGradient(cx,cy, inner, cx,cy, rad);
    grd.addColorStop(0, `rgba(${r},${gg},${b},${opacity})`);
    grd.addColorStop(1, `rgba(${r},${gg},${b},0)`);
    g.fillStyle = grd;
    g.beginPath();
    g.arc(cx,cy,rad,0,Math.PI*2);
    g.fill();

    App.stamp.key = key;
    App.stamp.canvas = c;
    return c;
  }

  function stampAlongPath(layer, from, to, mode){
    // mode: 'paint' or 'erase'
    const size = +sizeEl.value;
    const hardness = +hardnessEl.value;
    const opacity = +brushOpacityEl.value;
    const color = colorEl.value;

    const stamp = getBrushStamp(size, hardness, color, opacity);
    const step = Math.max(1, size * 0.35);

    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const dist = Math.hypot(dx,dy);
    const n = Math.max(1, Math.floor(dist / step));

    layer.ctx.save();
    if (mode === 'erase'){
      layer.ctx.globalCompositeOperation = 'destination-out';
      layer.ctx.globalAlpha = 1;
    } else {
      layer.ctx.globalCompositeOperation = 'source-over';
      layer.ctx.globalAlpha = 1;
    }

    for (let i=0;i<=n;i++){
      const t = i/n;
      const x = from.x + dx*t;
      const y = from.y + dy*t;
      layer.ctx.drawImage(stamp, x - stamp.width/2, y - stamp.height/2);
    }
    layer.ctx.restore();
  }

  // ===== Selection ops =====
  function normalizeRect(a, b){
    const x1 = Math.min(a.x, b.x);
    const y1 = Math.min(a.y, b.y);
    const x2 = Math.max(a.x, b.x);
    const y2 = Math.max(a.y, b.y);
    return { x: x1, y: y1, w: x2-x1, h: y2-y1 };
  }

  function fillSelection(){
    if (!App.selection){ showToast('No selection'); return; }
    const L = App.layers[App.activeLayer]; if (!L) return;
    const rgb = hexToRgb(colorEl.value);
    L.ctx.save();
    L.ctx.globalCompositeOperation = 'source-over';
    L.ctx.globalAlpha = +brushOpacityEl.value;
    L.ctx.fillStyle = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
    const r = App.selection;
    // selection is in doc coords; convert to layer coords:
    const p = docToLayer({x:r.x, y:r.y}, L);
    L.ctx.fillRect(p.x, p.y, r.w, r.h);
    L.ctx.restore();
    pushHistory('Fill selection');
    App.dirty = true;
  }

  function clearSelectionPixels(){
    if (!App.selection){ showToast('No selection'); return; }
    const L = App.layers[App.activeLayer]; if (!L) return;
    const r = App.selection;
    const p = docToLayer({x:r.x, y:r.y}, L);
    L.ctx.save();
    L.ctx.globalCompositeOperation = 'destination-out';
    L.ctx.fillStyle = 'rgba(0,0,0,1)';
    L.ctx.fillRect(p.x, p.y, r.w, r.h);
    L.ctx.restore();
    pushHistory('Clear selection');
    App.dirty = true;
  }

  function deselect(){
    App.selection = null;
    App.overlayDirty = true;
  }

  // ===== Filters =====
  function applyFilter(type){
    const L = App.layers[App.activeLayer];
    if (!L) return;

    // If selection exists, filter only within selection (simple: crop region)
    const r = App.selection ? {...App.selection} : {x:0,y:0,w:App.docW,h:App.docH};
    // convert to layer coords
    const p = docToLayer({x:r.x,y:r.y}, L);
    const rx = Math.round(p.x), ry = Math.round(p.y), rw = Math.round(r.w), rh = Math.round(r.h);
    const x0 = clamp(rx, 0, App.docW);
    const y0 = clamp(ry, 0, App.docH);
    const x1 = clamp(rx+rw, 0, App.docW);
    const y1 = clamp(ry+rh, 0, App.docH);
    const w = Math.max(0, x1-x0);
    const h = Math.max(0, y1-y0);
    if (w===0 || h===0){ showToast('Selection outside layer'); return; }

    const img = L.ctx.getImageData(x0,y0,w,h);
    const d = img.data;

    const doConvolve = (kernel, div=1, bias=0) => {
      const out = new Uint8ClampedArray(d.length);
      const kw = Math.sqrt(kernel.length) | 0;
      const kh = kw;
      const half = (kw/2) | 0;
      for (let y=0;y<h;y++){
        for (let x=0;x<w;x++){
          let r=0,g=0,b=0,a=0;
          for (let ky=0;ky<kh;ky++){
            for (let kx=0;kx<kw;kx++){
              const ix = clamp(x + kx - half, 0, w-1);
              const iy = clamp(y + ky - half, 0, h-1);
              const si = (iy*w + ix)*4;
              const k = kernel[ky*kw + kx];
              r += d[si]*k;
              g += d[si+1]*k;
              b += d[si+2]*k;
              a += d[si+3]*k;
            }
          }
          const di = (y*w + x)*4;
          out[di]   = clamp(r/div + bias, 0, 255);
          out[di+1] = clamp(g/div + bias, 0, 255);
          out[di+2] = clamp(b/div + bias, 0, 255);
          out[di+3] = clamp(a/div, 0, 255);
        }
      }
      img.data.set(out);
    };

    if (type === 'grayscale'){
      for (let i=0;i<d.length;i+=4){
        const v = (0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2])|0;
        d[i]=d[i+1]=d[i+2]=v;
      }
    } else if (type === 'invert'){
      for (let i=0;i<d.length;i+=4){
        d[i]=255-d[i]; d[i+1]=255-d[i+1]; d[i+2]=255-d[i+2];
      }
    } else if (type === 'sepia'){
      for (let i=0;i<d.length;i+=4){
        const r=d[i], g=d[i+1], b=d[i+2];
        d[i]   = clamp(0.393*r + 0.769*g + 0.189*b, 0, 255);
        d[i+1] = clamp(0.349*r + 0.686*g + 0.168*b, 0, 255);
        d[i+2] = clamp(0.272*r + 0.534*g + 0.131*b, 0, 255);
      }
    } else if (type === 'blur'){
      // simple box blur-ish convolution
      doConvolve([
        1,1,1,
        1,1,1,
        1,1,1
      ], 9, 0);
    } else if (type === 'sharpen'){
      doConvolve([
         0,-1, 0,
        -1, 5,-1,
         0,-1, 0
      ], 1, 0);
    } else if (type === 'edge'){
      doConvolve([
        -1,-1,-1,
        -1, 8,-1,
        -1,-1,-1
      ], 1, 0);
    } else {
      showToast('Unknown filter');
      return;
    }

    L.ctx.putImageData(img, x0,y0);
    pushHistory(`Filter: ${type}`);
    App.dirty = true;
  }

  function brightnessContrast(){
    const L = App.layers[App.activeLayer];
    if (!L) return;
    const b = prompt('Brightness (-100..100)', '0');
    if (b === null) return;
    const c = prompt('Contrast (-100..100)', '0');
    if (c === null) return;

    const bright = clamp(parseFloat(b)||0, -100, 100);
    const cont = clamp(parseFloat(c)||0, -100, 100);

    const img = L.ctx.getImageData(0,0,App.docW,App.docH);
    const d = img.data;

    // Contrast formula: factor = (259*(c+255))/(255*(259-c))
    const cf = (259*(cont+255)) / (255*(259-cont));

    for (let i=0;i<d.length;i+=4){
      for (let k=0;k<3;k++){
        let v = d[i+k];
        // brightness
        v = v + (bright * 2.55);
        // contrast around 128
        v = cf*(v-128) + 128;
        d[i+k] = clamp(v, 0, 255);
      }
    }
    L.ctx.putImageData(img, 0,0);
    pushHistory('Brightness/Contrast');
    App.dirty = true;
  }

  // ===== UI refresh =====
  function refreshLayersUI(){
    layersList.innerHTML = '';
    for (let i=App.layers.length-1; i>=0; i--){
      const L = App.layers[i];
      const item = document.createElement('div');
      item.className = 'item' + (i===App.activeLayer ? ' active' : '');
      item.dataset.idx = i;

      const top = document.createElement('div');
      top.className = 'top';

      const eye = document.createElement('div');
      eye.className = 'eye' + (L.visible ? '' : ' off');
      eye.textContent = L.visible ? 'üëÅÔ∏è' : 'üö´';
      eye.title = 'Toggle visibility';
      eye.addEventListener('click', (e) => {
        e.stopPropagation();
        L.visible = !L.visible;
        pushHistory(L.visible ? 'Show layer' : 'Hide layer');
        refreshUI();
        App.dirty = true;
      });

      const name = document.createElement('div');
      name.className = 'name';
      name.textContent = L.name;

      const badge = document.createElement('div');
      badge.className = 'badge';
      badge.textContent = i===0 ? 'BG' : `#${i}`;

      top.appendChild(eye);
      top.appendChild(name);
      top.appendChild(badge);

      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.textContent = `Opacity ${Math.round(L.opacity*100)}% ¬∑ ${blendLabel(L.blend)} ¬∑ Offset ${Math.round(L.offsetX)},${Math.round(L.offsetY)}`;

      const mini = document.createElement('div');
      mini.className = 'minirow';

      const op = document.createElement('input');
      op.type = 'range';
      op.min = 0; op.max = 1; op.step = 0.01;
      op.value = L.opacity;
      op.className = 'ctrl';
      op.title = 'Opacity';
      op.addEventListener('input', () => {
        L.opacity = parseFloat(op.value);
        meta.textContent = `Opacity ${Math.round(L.opacity*100)}% ¬∑ ${blendLabel(L.blend)} ¬∑ Offset ${Math.round(L.offsetX)},${Math.round(L.offsetY)}`;
        App.dirty = true;
      });
      op.addEventListener('change', () => pushHistory('Change opacity'));

      const blend = document.createElement('select');
      blend.className = 'ctrl';
      blend.title = 'Blend mode';
      const modes = [
        ['source-over','Normal'],
        ['multiply','Multiply'],
        ['screen','Screen'],
        ['overlay','Overlay'],
        ['darken','Darken'],
        ['lighten','Lighten'],
        ['color-dodge','Color Dodge'],
        ['color-burn','Color Burn'],
        ['hard-light','Hard Light'],
        ['soft-light','Soft Light'],
        ['difference','Difference'],
        ['exclusion','Exclusion'],
        ['hue','Hue'],
        ['saturation','Saturation'],
        ['color','Color'],
        ['luminosity','Luminosity'],
      ];
      for (const [v, t] of modes){
        const opt = document.createElement('option');
        opt.value = v; opt.textContent = t;
        if (v === L.blend) opt.selected = true;
        blend.appendChild(opt);
      }
      blend.addEventListener('change', () => {
        L.blend = blend.value;
        meta.textContent = `Opacity ${Math.round(L.opacity*100)}% ¬∑ ${blendLabel(L.blend)} ¬∑ Offset ${Math.round(L.offsetX)},${Math.round(L.offsetY)}`;
        pushHistory('Change blend mode');
        App.dirty = true;
      });

      const rename = document.createElement('button');
      rename.className = 'btn';
      rename.style.padding = '6px 8px';
      rename.textContent = '‚úèÔ∏è';
      rename.title = 'Rename';
      rename.addEventListener('click', (e) => {
        e.stopPropagation();
        const n = prompt('Layer name:', L.name);
        if (n && n.trim()){
          L.name = n.trim();
          pushHistory('Rename layer');
          refreshUI();
        }
      });

      const up = document.createElement('button');
      up.className = 'btn';
      up.style.padding = '6px 8px';
      up.textContent = '‚¨ÜÔ∏è';
      up.title = 'Move up';
      up.addEventListener('click', (e)=>{
        e.stopPropagation();
        if (i < App.layers.length-1){
          const t = App.layers[i];
          App.layers[i] = App.layers[i+1];
          App.layers[i+1] = t;
          App.activeLayer = i+1;
          pushHistory('Reorder layer');
          refreshUI();
          App.dirty = true;
        }
      });

      const down = document.createElement('button');
      down.className = 'btn';
      down.style.padding = '6px 8px';
      down.textContent = '‚¨áÔ∏è';
      down.title = 'Move down';
      down.addEventListener('click', (e)=>{
        e.stopPropagation();
        if (i > 0){
          const t = App.layers[i];
          App.layers[i] = App.layers[i-1];
          App.layers[i-1] = t;
          App.activeLayer = i-1;
          pushHistory('Reorder layer');
          refreshUI();
          App.dirty = true;
        }
      });

      mini.appendChild(op);
      mini.appendChild(blend);
      mini.appendChild(rename);
      mini.appendChild(up);
      mini.appendChild(down);

      item.appendChild(top);
      item.appendChild(meta);
      item.appendChild(mini);

      item.addEventListener('click', () => {
        App.activeLayer = i;
        refreshUI();
      });

      layersList.appendChild(item);
    }
  }

  function blendLabel(blend){
    const m = {
      'source-over':'Normal',
      'multiply':'Multiply',
      'screen':'Screen',
      'overlay':'Overlay',
      'darken':'Darken',
      'lighten':'Lighten',
      'color-dodge':'Color Dodge',
      'color-burn':'Color Burn',
      'hard-light':'Hard Light',
      'soft-light':'Soft Light',
      'difference':'Difference',
      'exclusion':'Exclusion',
      'hue':'Hue',
      'saturation':'Saturation',
      'color':'Color',
      'luminosity':'Luminosity',
    };
    return m[blend] || blend || 'Normal';
  }

  function refreshHistoryUI(){
    historyList.innerHTML = '';
    for (let i=App.history.length-1;i>=0;i--){
      const H = App.history[i];
      const item = document.createElement('div');
      item.className = 'item' + (i===App.histIdx ? ' active' : '');
      const when = new Date(H.t);
      const time = when.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
      item.innerHTML = `
        <div class="top">
          <div class="name">${escapeHtml(H.label)}</div>
          <div class="badge">${time}</div>
        </div>
        <div class="meta">Step ${i+1} / ${App.history.length}</div>
      `;
      item.addEventListener('click', ()=> restoreHistory(i));
      historyList.appendChild(item);
    }
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function refreshUI(){
    refreshLayersUI();
    refreshHistoryUI();
    updateStatus();
    updateUndoRedoButtons();
    App.overlayDirty = true;
    App.dirty = true;
  }

  // ===== Tools switching =====
  function setTool(tool){
    App.tool = tool;
    toolButtons.forEach(b => b.classList.toggle('active', b.dataset.tool===tool));
    updateStatus();
    showToast(`${toolLabel(tool)} tool`);
  }
  toolButtons.forEach(btn => btn.addEventListener('click', ()=> setTool(btn.dataset.tool)));

  // ===== Pointer interaction =====
  function onPointerDown(e){
    wrap.setPointerCapture?.(e.pointerId);
    App.pointerDown = true;

    const ptDoc = screenToDoc(e.clientX, e.clientY);
    updateStatus(ptDoc);

    // Space acts like hand regardless of tool (common PS behavior)
    const spaceHand = App.keys.has(' ') || e.button===1;
    const tool = spaceHand ? 'hand' : App.tool;

    if (tool === 'hand'){
      App.panning = true;
      App.panStart = { x:e.clientX, y:e.clientY, panX:App.panX, panY:App.panY };
      return;
    }

    if (tool === 'move'){
      const L = App.layers[App.activeLayer];
      App.moving = true;
      App.moveStart = { x: ptDoc.x, y: ptDoc.y, ox: L.offsetX, oy: L.offsetY };
      return;
    }

    if (tool === 'marquee'){
      App.selecting = true;
      App.selStart = ptDoc;
      App.selection = { x: ptDoc.x, y: ptDoc.y, w: 0, h: 0 };
      App.overlayDirty = true;
      return;
    }

    if (tool === 'text'){
      const L = App.layers[App.activeLayer];
      const txt = prompt('Text:', 'Hello');
      if (!txt) { return; }
      const size = prompt('Font size (px):', '48');
      const px = clamp(parseFloat(size)||48, 6, 256);
      const layerPt = docToLayer(ptDoc, L);
      L.ctx.save();
      L.ctx.globalCompositeOperation = 'source-over';
      L.ctx.globalAlpha = +brushOpacityEl.value;
      L.ctx.fillStyle = colorEl.value;
      L.ctx.font = `${px}px ${getComputedStyle(document.body).fontFamily}`;
      L.ctx.textBaseline = 'top';
      L.ctx.fillText(txt, layerPt.x, layerPt.y);
      L.ctx.restore();
      pushHistory('Text');
      App.dirty = true;
      return;
    }

    // Brush/Eraser
    if (tool === 'brush' || tool === 'eraser'){
      const L = App.layers[App.activeLayer];
      App.lastPt = docToLayer(ptDoc, L);
      // stamp initial dot
      stampAlongPath(L, App.lastPt, App.lastPt, tool==='eraser' ? 'erase' : 'paint');
      App.dirty = true;
    }
  }

  function onPointerMove(e){
    const ptDoc = screenToDoc(e.clientX, e.clientY);
    updateStatus(ptDoc);

    if (!App.pointerDown) return;

    // Space acts like hand while dragging
    const spaceHand = App.keys.has(' ') || e.button===1;
    const tool = spaceHand ? 'hand' : App.tool;

    if (tool === 'hand' && App.panning){
      const s = App.panStart;
      App.panX = s.panX + (e.clientX - s.x);
      App.panY = s.panY + (e.clientY - s.y);
      App.dirty = true; App.overlayDirty = true;
      updateTopInfo();
      return;
    }

    if (tool === 'move' && App.moving){
      const L = App.layers[App.activeLayer];
      const s = App.moveStart;
      const dx = ptDoc.x - s.x;
      const dy = ptDoc.y - s.y;
      L.offsetX = s.ox + dx;
      L.offsetY = s.oy + dy;
      App.dirty = true; App.overlayDirty = true;
      refreshLayersUI();
      return;
    }

    if (tool === 'marquee' && App.selecting){
      const r = normalizeRect(App.selStart, ptDoc);
      // clamp to doc
      const x = clamp(r.x, 0, App.docW);
      const y = clamp(r.y, 0, App.docH);
      const w = clamp(r.w, 0, App.docW - x);
      const h = clamp(r.h, 0, App.docH - y);
      App.selection = { x, y, w, h };
      App.overlayDirty = true;
      return;
    }

    if (tool === 'brush' || tool === 'eraser'){
      const L = App.layers[App.activeLayer];
      const cur = docToLayer(ptDoc, L);
      if (App.lastPt){
        stampAlongPath(L, App.lastPt, cur, tool==='eraser' ? 'erase' : 'paint');
        App.lastPt = cur;
        App.dirty = true;
      }
    }
  }

  function onPointerUp(e){
    if (!App.pointerDown) return;
    App.pointerDown = false;

    const spaceHand = App.keys.has(' ') || e.button===1;
    const tool = spaceHand ? 'hand' : App.tool;

    if (tool === 'hand'){
      App.panning = false;
      return;
    }
    if (tool === 'move'){
      if (App.moving){
        App.moving = false;
        pushHistory('Move layer');
        refreshUI();
      }
      return;
    }
    if (tool === 'marquee'){
      if (App.selecting){
        App.selecting = false;
        App.overlayDirty = true;
        pushHistory('Selection');
        refreshHistoryUI();
        updateUndoRedoButtons();
      }
      return;
    }
    if (tool === 'brush' || tool === 'eraser'){
      App.lastPt = null;
      pushHistory(tool==='eraser' ? 'Erase' : 'Brush stroke');
      refreshHistoryUI();
      updateUndoRedoButtons();
    }
  }

  wrap.addEventListener('pointerdown', onPointerDown);
  wrap.addEventListener('pointermove', onPointerMove);
  wrap.addEventListener('pointerup', onPointerUp);
  wrap.addEventListener('pointercancel', onPointerUp);

  // Zoom/pan with wheel
  wrap.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = wrap.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    if (e.ctrlKey || e.metaKey){
      // zoom about mouse position
      const zoomFactor = Math.exp(-e.deltaY * 0.0015);
      const newZoom = clamp(App.zoom * zoomFactor, 0.05, 32);

      // keep doc point under mouse fixed
      const docX = (mx - App.panX) / App.zoom;
      const docY = (my - App.panY) / App.zoom;

      App.zoom = newZoom;
      App.panX = mx - docX * App.zoom;
      App.panY = my - docY * App.zoom;

      App.dirty = true; App.overlayDirty = true;
      updateTopInfo();
      return;
    } else {
      // pan
      App.panX -= e.deltaX;
      App.panY -= e.deltaY;
      App.dirty = true; App.overlayDirty = true;
      updateTopInfo();
    }
  }, { passive:false });

  // ===== Keyboard shortcuts =====
  window.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    App.keys.add(e.key);

    const mod = e.ctrlKey || e.metaKey;

    if (mod && e.key.toLowerCase()==='z'){
      e.preventDefault();
      if (e.shiftKey) redo();
      else undo();
      return;
    }
    if (mod && (e.key.toLowerCase()==='y')){
      e.preventDefault();
      redo();
      return;
    }

    const k = e.key.toLowerCase();
    if (k==='b') setTool('brush');
    else if (k==='e') setTool('eraser');
    else if (k==='v') setTool('move');
    else if (k==='m') setTool('marquee');
    else if (k==='t') setTool('text');
    else if (k==='escape') { deselect(); showToast('Deselect'); }
    else if (k==='delete' || k==='backspace') {
      if (App.selection){
        clearSelectionPixels();
      }
    }
  });
  window.addEventListener('keyup', (e) => { App.keys.delete(e.key); });

  // ===== Buttons wiring =====
  undoBtn.addEventListener('click', undo);
  redoBtn.addEventListener('click', redo);

  addLayerBtn.addEventListener('click', ()=> addLayer());
  dupLayerBtn.addEventListener('click', duplicateLayer);
  delLayerBtn.addEventListener('click', deleteLayer);
  mergeDownBtn.addEventListener('click', mergeDown);

  fillSelBtn.addEventListener('click', fillSelection);
  clearSelBtn.addEventListener('click', clearSelectionPixels);
  deselectBtn.addEventListener('click', ()=> { deselect(); showToast('Deselect'); });

  snapBtn.addEventListener('click', ()=> { pushHistory('Snapshot'); showToast('Snapshot saved'); });
  clearHistBtn.addEventListener('click', ()=>{
    // keep current state as the only history entry
    const cur = App.history[App.histIdx];
    App.history = cur ? [cur] : [];
    App.histIdx = App.history.length ? 0 : -1;
    refreshHistoryUI();
    updateUndoRedoButtons();
    showToast('History cleared');
  });

  bcBtn.addEventListener('click', brightnessContrast);

  newBtn.addEventListener('click', () => {
    const w = prompt('New document width (px):', String(App.docW));
    if (w === null) return;
    const h = prompt('New document height (px):', String(App.docH));
    if (h === null) return;
    const W = clamp(parseInt(w,10)||App.docW, 32, 8192);
    const H = clamp(parseInt(h,10)||App.docH, 32, 8192);
    newDocument(W,H);
  });

  openImgBtn.addEventListener('click', ()=> fileImg.click());
  fileImg.addEventListener('change', async () => {
    const f = fileImg.files?.[0];
    fileImg.value = '';
    if (!f) return;
    const img = await fileToImage(f);
    placeImageAsLayer(img);
    showToast('Image placed as new layer');
  });

  openProjBtn.addEventListener('click', ()=> fileProj.click());
  fileProj.addEventListener('change', async () => {
    const f = fileProj.files?.[0];
    fileProj.value = '';
    if (!f) return;
    const txt = await f.text();
    try{
      const obj = JSON.parse(txt);
      await loadProject(obj);
      showToast('Project loaded');
    }catch(err){
      console.error(err);
      showToast('Could not open project');
    }
  });

  saveProjBtn.addEventListener('click', async () => {
    const obj = await saveProject();
    const name = `minishop_${App.docW}x${App.docH}.minishop`;
    downloadText(JSON.stringify(obj), name, 'application/json');
    showToast('Project saved');
  });

  exportBtn.addEventListener('click', async () => {
    const blob = await exportPNG();
    const name = `export_${App.docW}x${App.docH}.png`;
    downloadBlob(blob, name);
    showToast('Exported PNG');
  });

  // ===== Project I/O =====
  async function fileToImage(file){
    const url = URL.createObjectURL(file);
    try{
      const img = new Image();
      img.decoding = 'async';
      await new Promise((res, rej)=>{
        img.onload = res;
        img.onerror = rej;
        img.src = url;
      });
      return img;
    } finally {
      URL.revokeObjectURL(url);
    }
  }

  async function saveProject(){
    // store layers as PNG dataURLs + metadata
    const layers = App.layers.map(L => ({
      name: L.name,
      visible: L.visible,
      opacity: L.opacity,
      blend: L.blend,
      offsetX: L.offsetX,
      offsetY: L.offsetY,
      png: L.canvas.toDataURL('image/png'),
    }));
    return {
      app: 'MiniShop',
      version: 1,
      docW: App.docW,
      docH: App.docH,
      activeLayer: App.activeLayer,
      zoom: App.zoom,
      panX: App.panX,
      panY: App.panY,
      selection: App.selection,
      layers
    };
  }

  async function loadProject(obj){
    if (!obj || obj.app !== 'MiniShop') throw new Error('Not a MiniShop project');
    App.docW = obj.docW|0;
    App.docH = obj.docH|0;
    App.layers = [];

    for (const L of obj.layers){
      const layer = makeLayer(L.name);
      layer.visible = !!L.visible;
      layer.opacity = clamp(+L.opacity, 0, 1);
      layer.blend = L.blend || 'source-over';
      layer.offsetX = +L.offsetX || 0;
      layer.offsetY = +L.offsetY || 0;

      // draw image
      const img = await dataUrlToImage(L.png);
      layer.ctx.clearRect(0,0,App.docW,App.docH);
      layer.ctx.drawImage(img, 0, 0);
      App.layers.push(layer);
    }

    App.activeLayer = clamp(obj.activeLayer|0, 0, App.layers.length-1);
    App.selection = obj.selection || null;
    App.zoom = clamp(+obj.zoom || 1, 0.05, 32);
    App.panX = +obj.panX || 0;
    App.panY = +obj.panY || 0;

    // reset history to one entry (loaded)
    App.history = [];
    App.histIdx = -1;
    pushHistory('Load project');
    refreshUI();
    App.dirty = true; App.overlayDirty = true;
  }

  async function dataUrlToImage(url){
    const img = new Image();
    img.decoding = 'async';
    await new Promise((res, rej) => {
      img.onload = res;
      img.onerror = rej;
      img.src = url;
    });
    return img;
  }

  async function exportPNG(){
    const out = document.createElement('canvas');
    out.width = App.docW; out.height = App.docH;
    const c = out.getContext('2d');
    c.clearRect(0,0,out.width,out.height);

    for (const L of App.layers){
      if (!L.visible) continue;
      c.save();
      c.globalAlpha = L.opacity;
      c.globalCompositeOperation = L.blend || 'source-over';
      c.drawImage(L.canvas, L.offsetX, L.offsetY);
      c.restore();
    }

    return await new Promise(res => out.toBlob(res, 'image/png'));
  }

  // ===== New doc =====
  function newDocument(W,H){
    App.docW = W; App.docH = H;
    App.layers = [makeLayer('Background')];
    App.layers[0].opacity = 1;
    App.layers[0].blend = 'source-over';
    App.activeLayer = 0;
    App.selection = null;

    // reset view
    resizeCanvases();
    fitToScreen(false);

    // reset history
    App.history = [];
    App.histIdx = -1;
    pushHistory('New document');
    refreshUI();
    showToast(`New doc ${W}√ó${H}`);
  }

  // ===== Initialize =====
  function init(){
    resizeCanvases();
    newDocument(App.docW, App.docH);

    // helpful initial layer
    addLayer('Paint');
    // tiny starter mark
    const L = App.layers[App.activeLayer];
    L.ctx.fillStyle = 'rgba(255,255,255,.0)';
    pushHistory('Init');
    refreshUI();
    fitToScreen(false);
    updateUndoRedoButtons();
    updateTopInfo();
    showToast('Ready');
    requestAnimationFrame(render);
  }

  init();
})();
</script>
</body>
</html>
