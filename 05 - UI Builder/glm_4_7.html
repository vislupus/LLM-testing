<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro UI Builder & Flowchart Designer</title>
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary: #4f46e5;
            --primary-hover: #4338ca;
            --bg-dark: #1e293b;
            --bg-panel: #0f172a;
            --bg-canvas: #e2e8f0;
            --border: #334155;
            --text: #f8fafc;
            --text-dim: #94a3b8;
            --grid-color: rgba(0,0,0,0.05);
            --grid-size: 20px;
            --guide-color: #3b82f6;
        }

        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- Header --- */
        header {
            height: 50px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }
        .logo { font-weight: 600; font-size: 16px; display: flex; align-items: center; gap: 10px; }
        .logo i { color: var(--primary); }
        .actions button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .actions button:hover { background: var(--primary-hover); }

        /* --- Main Layout --- */
        .workspace {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* --- Sidebar (Library) --- */
        .sidebar {
            width: 240px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }
        .sidebar-header { padding: 15px; font-size: 12px; text-transform: uppercase; color: var(--text-dim); letter-spacing: 1px; font-weight: 600; }
        .component-list { padding: 0 10px; overflow-y: auto; flex: 1; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        
        .comp-item {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 15px 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            cursor: grab;
            transition: all 0.2s;
            font-size: 11px;
            color: var(--text-dim);
        }
        .comp-item:hover { border-color: var(--primary); color: var(--text); transform: translateY(-2px); }
        .comp-item i { font-size: 18px; color: var(--text); }
        .comp-cat { grid-column: span 2; padding: 5px 0; font-size: 10px; color: var(--text-dim); font-weight: 600; margin-top: 5px; }

        /* --- Properties Panel --- */
        .properties {
            width: 260px;
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        .prop-group { padding: 15px; border-bottom: 1px solid var(--border); }
        .prop-label { display: block; font-size: 11px; color: var(--text-dim); margin-bottom: 8px; font-weight: 500; }
        .prop-row { display: flex; gap: 10px; margin-bottom: 10px; }
        
        input[type="text"], input[type="number"], select, textarea {
            width: 100%;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        input[type="color"] { width: 100%; height: 35px; border: none; cursor: pointer; padding: 0; background: none; }
        input:focus { border-color: var(--primary); outline: none; }
        
        .empty-state { text-align: center; color: var(--text-dim); padding: 40px 20px; font-size: 13px; }

        /* --- Canvas Area --- */
        .canvas-area {
            flex: 1;
            background: var(--bg-canvas);
            position: relative;
            overflow: hidden;
            /* Grid Pattern */
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: var(--grid-size) var(--grid-size);
            cursor: grab;
        }
        .canvas-area.panning { cursor: grabbing; }

        /* The Infinite Canvas Container */
        #canvas-wrapper {
            position: absolute;
            top: 0; left: 0;
            width: 5000px; height: 5000px;
            transform-origin: 0 0;
            transform: translate(0, 0);
        }

        /* Elements on Canvas */
        .canvas-el {
            position: absolute;
            min-width: 20px;
            min-height: 20px;
            cursor: pointer;
            user-select: none;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box; /* Include border in sizing */
        }
        
        /* Internal Component Styling */
        .comp-content {
            width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            pointer-events: none; /* Let parent div handle selection */
        }
        /* Allow pointer events on actual inputs */
        .comp-content input, .comp-content select, .comp-content button, .comp-content textarea {
            pointer-events: auto;
        }
        
        /* Selection State */
        .canvas-el.selected {
            outline: 2px solid var(--primary);
            z-index: 100;
        }

        /* Resize Handles */
        .resize-handle {
            width: 8px; height: 8px;
            background: white;
            border: 1px solid var(--primary);
            position: absolute;
            z-index: 101;
            display: none;
        }
        .canvas-el.selected .resize-handle { display: block; }
        .rh-n { top: -4px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .rh-e { top: 50%; right: -4px; transform: translateY(-50%); cursor: e-resize; }
        .rh-s { bottom: -4px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        .rh-w { top: 50%; left: -4px; transform: translateY(-50%); cursor: w-resize; }
        .rh-ne { top: -4px; right: -4px; cursor: ne-resize; }
        .rh-se { bottom: -4px; right: -4px; cursor: se-resize; }
        .rh-sw { bottom: -4px; left: -4px; cursor: sw-resize; }
        .rh-nw { top: -4px; left: -4px; cursor: nw-resize; }

        /* Connectors (Ports) */
        .connector-port {
            width: 10px; height: 10px;
            background: var(--text-dim);
            border-radius: 50%;
            position: absolute;
            top: 50%; transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 102;
            cursor: crosshair;
        }
        .canvas-el.selected .connector-port { opacity: 1; }
        .connector-port:hover { background: var(--primary); scale: 1.2; }
        .port-left { left: -5px; }
        .port-right { right: -5px; }

        /* Connections SVG Layer */
        #connections-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 50;
            overflow: visible;
        }
        path.connection-line {
            fill: none;
            stroke: #64748b;
            stroke-width: 2;
            pointer-events: visibleStroke; /* Allow selecting line */
            cursor: pointer;
        }
        path.connection-line:hover { stroke: var(--primary); stroke-width: 3; }
        path.connection-line.selected { stroke: var(--primary); stroke-width: 3; stroke-dasharray: 5; }

        /* Alignment Guides */
        #guides-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 200;
        }
        .guide-line {
            position: absolute;
            background: var(--guide-color);
        }
        .guide-h { height: 1px; left: 0; right: 0; }
        .guide-v { width: 1px; top: 0; bottom: 0; }

        /* --- Export Preview Styles (Injected) --- */
        .preview-btn {
            background: #10b981;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 11px;
            margin-top: 10px;
            cursor: pointer;
            width: 100%;
        }
    </style>
</head>
<body>

    <header>
        <div class="logo">
            <i class="fa-solid fa-layer-group"></i> UI Builder Pro
        </div>
        <div class="actions">
            <button onclick="builder.exportHTML()"><i class="fa-solid fa-download"></i> Export HTML</button>
        </div>
    </header>

    <div class="workspace">
        <!-- Sidebar Library -->
        <div class="sidebar">
            <div class="sidebar-header">Components</div>
            <div class="component-list" id="component-list">
                <!-- Populated by JS -->
            </div>
        </div>

        <!-- Canvas -->
        <div class="canvas-area" id="canvas-container">
            <div id="canvas-wrapper">
                <svg id="connections-layer"></svg>
                <div id="guides-layer"></div>
                <div id="elements-layer"></div>
            </div>
        </div>

        <!-- Properties Panel -->
        <div class="properties" id="properties-panel">
            <div class="sidebar-header">Properties</div>
            <div id="props-content">
                <div class="empty-state">Select an element to edit properties</div>
            </div>
        </div>
    </div>

<script>
    /**
     * UI Builder Core Logic
     */
    const COMPONENTS = [
        { type: 'button', icon: 'fa-square', label: 'Button', html: '<button>Button</button>', defaults: { w: 100, h: 40, bg: '#4f46e5', color: '#fff' } },
        { type: 'input', icon: 'fa-i-cursor', label: 'Input', html: '<input type="text" placeholder="Text...">', defaults: { w: 150, h: 40, bg: '#fff', color: '#333' } },
        { type: 'text', icon: 'fa-font', label: 'Text', html: '<h3>Heading</h3>', defaults: { w: 150, h: 40, bg: 'transparent', color: '#333' } },
        { type: 'checkbox', icon: 'fa-check-square', label: 'Checkbox', html: '<input type="checkbox"> Label', defaults: { w: 120, h: 30, bg: 'transparent', color: '#333' } },
        { type: 'dropdown', icon: 'fa-caret-down', label: 'Dropdown', html: '<select><option>Option 1</option></select>', defaults: { w: 140, h: 40, bg: '#fff', color: '#333' } },
        { type: 'slider', icon: 'fa-sliders-h', label: 'Slider', html: '<input type="range">', defaults: { w: 150, h: 30, bg: 'transparent', color: '#333' } },
        { type: 'stepper', icon: 'fa-plus-minus', label: 'Stepper', html: '<input type="number" value="1">', defaults: { w: 100, h: 40, bg: '#fff', color: '#333' } },
        { type: 'progress', icon: 'fa-bars-progress', label: 'Progress', html: '<progress value="50" max="100" style="width:100%">', defaults: { w: 150, h: 20, bg: 'transparent', color: '#333' } },
        { type: 'div', icon: 'fa-vector-square', label: 'Container', html: '', defaults: { w: 200, h: 100, bg: '#cbd5e1', color: '#333' } },
    ];

    const SHAPES = [
        { type: 'rect', icon: 'fa-square', label: 'Rectangle', html: '', defaults: { w: 100, h: 100, bg: '#94a3b8', radius: 0 } },
        { type: 'circle', icon: 'fa-circle', label: 'Circle', html: '', defaults: { w: 100, h: 100, bg: '#f472b6', radius: 50 } },
        { type: 'triangle', icon: 'fa-play', label: 'Triangle', html: '', defaults: { w: 100, h: 100, bg: '#fbbf24', radius: 0, clip: 'polygon(50% 0%, 0% 100%, 100% 100%)' } },
        { type: 'line', icon: 'fa-minus', label: 'Line', html: '', defaults: { w: 150, h: 5, bg: '#000', radius: 0 } }
    ];

    class Builder {
        constructor() {
            this.elCounter = 0;
            this.elements = {}; // ID -> Data
            this.connections = []; // { from, to }
            this.selectedId = null;
            this.isDragging = false;
            this.isResizing = false;
            this.resizeDir = null;
            this.dragOffset = { x: 0, y: 0 };
            this.startDims = { w: 0, h: 0, x: 0, y: 0 };
            this.isPanning = false;
            this.panOffset = { x: 0, y: 0 };
            this.isLinking = false;
            this.linkSource = null;

            this.initLibrary();
            this.initCanvasEvents();
            this.updatePropertiesPanel();
        }

        initLibrary() {
            const list = document.getElementById('component-list');
            const addCat = (name) => {
                const div = document.createElement('div');
                div.className = 'comp-cat';
                div.innerText = name;
                return div;
            };
            const addItem = (c) => {
                const div = document.createElement('div');
                div.className = 'comp-item';
                div.draggable = true;
                div.innerHTML = `<i class="fa-solid ${c.icon}"></i><span>${c.label}</span>`;
                div.ondragstart = (e) => {
                    e.dataTransfer.setData('type', c.type);
                    e.dataTransfer.setData('shape', c.type in SHAPES.map(s=>s.type) ? 'true' : 'false');
                };
                list.appendChild(div);
            };

            list.appendChild(addCat('UI Elements'));
            COMPONENTS.forEach(c => addItem(c));
            list.appendChild(addCat('Shapes'));
            SHAPES.forEach(c => addItem(c));
        }

        // --- Core Operations ---

        addElement(type, x, y, isShape = false) {
            const lib = isShape ? SHAPES.find(c => c.type === type) : COMPONENTS.find(c => c.type === type);
            const id = `el-${++this.elCounter}`;
            
            // Snap to grid
            x = Math.round(x / 20) * 20;
            y = Math.round(y / 20) * 20;

            this.elements[id] = {
                id, type,
                x, y, w: lib.defaults.w, h: lib.defaults.h,
                styles: {
                    bg: lib.defaults.bg || '#ffffff',
                    color: lib.defaults.color || '#000000',
                    radius: lib.defaults.radius || 0,
                    shadow: 'none',
                    padding: '0px',
                    clip: lib.defaults.clip || 'none',
                    border: 'none'
                },
                html: lib.html
            };

            this.renderElement(id);
            this.selectElement(id);
        }

        renderElement(id) {
            const data = this.elements[id];
            const el = document.createElement('div');
            el.id = id;
            el.className = 'canvas-el';
            
            // Styles
            el.style.left = data.x + 'px';
            el.style.top = data.y + 'px';
            el.style.width = data.w + 'px';
            el.style.height = data.h + 'px';
            el.style.backgroundColor = data.styles.bg;
            el.style.color = data.styles.color;
            el.style.borderRadius = data.styles.radius + 'px';
            el.style.boxShadow = data.styles.shadow;
            el.style.border = data.styles.border;
            el.style.clipPath = data.styles.clip;
            if(data.styles.padding) el.style.padding = data.styles.padding;

            // Content
            const content = document.createElement('div');
            content.className = 'comp-content';
            content.innerHTML = data.html;
            el.appendChild(content);

            // Resize Handles
            const dirs = ['n', 's', 'e', 'w', 'ne', 'se', 'sw', 'nw'];
            dirs.forEach(d => {
                const h = document.createElement('div');
                h.className = `resize-handle rh-${d}`;
                h.dataset.dir = d;
                el.appendChild(h);
            });

            // Connector Ports
            const p1 = document.createElement('div');
            p1.className = 'connector-port port-left';
            p1.title = 'Connect Output';
            p1.onmousedown = (e) => this.startLink(e, id, 'left');
            
            const p2 = document.createElement('div');
            p2.className = 'connector-port port-right';
            p2.title = 'Connect Input';
            p2.onmouseup = (e) => this.endLink(e, id, 'right');

            el.appendChild(p1);
            el.appendChild(p2);

            // Events
            el.onmousedown = (e) => {
                if(e.target.classList.contains('resize-handle')) return; // handled elsewhere
                if(e.target.classList.contains('connector-port')) return;
                if(e.shiftKey) return; // Ignore if shift key (reserved for future)
                this.selectElement(id);
                this.startDrag(e, id);
            };

            // Prevent content events from bubbling to drag
            el.ondblclick = (e) => {
                e.stopPropagation();
                this.makeEditable(content);
            };

            document.getElementById('elements-layer').appendChild(el);
        }

        updateElementVisuals(id) {
            const data = this.elements[id];
            const el = document.getElementById(id);
            if(!el) return;

            el.style.left = data.x + 'px';
            el.style.top = data.y + 'px';
            el.style.width = data.w + 'px';
            el.style.height = data.h + 'px';
            el.style.backgroundColor = data.styles.bg;
            el.style.color = data.styles.color;
            el.style.borderRadius = data.styles.radius + 'px';
            el.style.boxShadow = data.styles.shadow;
            el.style.border = data.styles.border;
            el.style.clipPath = data.styles.clip;
            el.style.padding = data.styles.padding;
        }

        // --- Interaction Logic ---

        initCanvasEvents() {
            const container = document.getElementById('canvas-container');
            const wrapper = document.getElementById('canvas-wrapper');

            // Drop from Library
            container.ondragover = (e) => e.preventDefault();
            container.ondrop = (e) => {
                e.preventDefault();
                const type = e.dataTransfer.getData('type');
                const isShape = e.dataTransfer.getData('shape') === 'true';
                if (type) {
                    const rect = wrapper.getBoundingClientRect();
                    const x = e.clientX - rect.left - this.panOffset.x; // Simple pan not impl for simplicity of drop
                    const y = e.clientY - rect.top - this.panOffset.y;
                    this.addElement(type, x, y, isShape);
                }
            };

            // Mouse Move (Global)
            window.addEventListener('mousemove', (e) => {
                if (this.isDragging) {
                    const dx = e.clientX - this.dragOffset.x;
                    const dy = e.clientY - this.dragOffset.y;
                    
                    let newX = this.startDims.x + dx;
                    let newY = this.startDims.y + dy;

                    // Snap
                    newX = Math.round(newX / 10) * 10;
                    newY = Math.round(newY / 10) * 10;

                    const elData = this.elements[this.selectedId];
                    elData.x = newX;
                    elData.y = newY;

                    this.updateElementVisuals(this.selectedId);
                    this.drawGuides(this.selectedId);
                    this.updateConnections();
                } else if (this.isResizing) {
                    this.handleResize(e);
                    this.updateConnections();
                } else if (this.isLinking) {
                    this.drawTempLine(e);
                } else if (this.isPanning) {
                    const dx = e.clientX - this.dragOffset.x;
                    const dy = e.clientY - this.dragOffset.y;
                    wrapper.style.transform = `translate(${this.panOffset.x + dx}px, ${this.panOffset.y + dy}px)`;
                }
            });

            window.addEventListener('mouseup', () => {
                if(this.isDragging || this.isResizing) {
                    this.drawGuides(null); // Clear guides
                }
                this.isDragging = false;
                this.isResizing = false;
                this.isPanning = false;
                if(this.isLinking) {
                    this.isLinking = false;
                    this.linkSource = null;
                    document.getElementById('temp-line')?.remove();
                }
            });

            // Clicking Background to deselect
            container.addEventListener('mousedown', (e) => {
                if(e.target === container || e.target === wrapper || e.target.id === 'elements-layer') {
                    if(e.button === 1 || e.altKey) { // Middle click or Alt+Click to pan
                        this.isPanning = true;
                        this.dragOffset = { x: e.clientX, y: e.clientY };
                        const transform = wrapper.style.transform;
                        const match = /translate\((.*?)px,\s*(.*?)px\)/.exec(transform);
                        if(match) {
                            this.panOffset = { x: parseFloat(match[1]), y: parseFloat(match[2]) };
                        }
                    } else {
                        this.selectElement(null);
                    }
                }
            });
        }

        startDrag(e, id) {
            this.isDragging = true;
            this.dragOffset = { x: e.clientX, y: e.clientY };
            const el = this.elements[id];
            this.startDims = { x: el.x, y: el.y };
        }

        handleResize(e) {
            const el = this.elements[this.selectedId];
            const dir = this.resizeDir;
            const dx = e.clientX - this.dragOffset.x;
            const dy = e.clientY - this.dragOffset.y;

            let newW = this.startDims.w;
            let newH = this.startDims.h;
            let newX = this.startDims.x;
            let newY = this.startDims.y;

            if (dir.includes('e')) newW = this.startDims.w + dx;
            if (dir.includes('w')) { newW = this.startDims.w - dx; newX = this.startDims.x + dx; }
            if (dir.includes('s')) newH = this.startDims.h + dy;
            if (dir.includes('n')) { newH = this.startDims.h - dy; newY = this.startDims.y + dy; }

            // Snap dimensions
            newW = Math.max(10, Math.round(newW / 10) * 10);
            newH = Math.max(10, Math.round(newH / 10) * 10);

            // Snap position
            newX = Math.round(newX / 10) * 10;
            newY = Math.round(newY / 10) * 10;

            el.w = newW; el.h = newH; el.x = newX; el.y = newY;
            this.updateElementVisuals(this.selectedId);
            this.drawGuides(this.selectedId);
        }

        selectElement(id) {
            // Clear previous
            if (this.selectedId) {
                const old = document.getElementById(this.selectedId);
                if(old) old.classList.remove('selected');
            }
            
            this.selectedId = id;
            if (id) {
                document.getElementById(id).classList.add('selected');
                // Setup Resize listeners
                const handles = document.querySelectorAll(`#${id} .resize-handle`);
                handles.forEach(h => {
                    h.onmousedown = (e) => {
                        e.stopPropagation();
                        this.isResizing = true;
                        this.resizeDir = h.dataset.dir;
                        this.dragOffset = { x: e.clientX, y: e.clientY };
                        const el = this.elements[id];
                        this.startDims = { w: el.w, h: el.h, x: el.x, y: el.y };
                    };
                });
            }
            this.updatePropertiesPanel();
        }

        // --- Alignment Guides ---
        drawGuides(activeId) {
            const layer = document.getElementById('guides-layer');
            layer.innerHTML = '';
            if(!activeId) return;
            
            const active = this.elements[activeId];
            const threshold = 5;

            Object.values(this.elements).forEach(other => {
                if (other.id === activeId) return;
                
                // Check Left Edges
                if (Math.abs(active.x - other.x) < threshold) createVGuide(active.x);
                // Check Right Edges
                if (Math.abs((active.x + active.w) - (other.x + other.w)) < threshold) createVGuide(active.x + active.w);
                // Check Horizontal Centers
                if (Math.abs((active.x + active.w/2) - (other.x + other.w/2)) < threshold) createVGuide(active.x + active.w/2);
                
                // Check Top Edges
                if (Math.abs(active.y - other.y) < threshold) createHGuide(active.y);
                // Check Bottom Edges
                if (Math.abs((active.y + active.h) - (other.y + other.h)) < threshold) createHGuide(active.y + active.h);
                // Check Vertical Centers
                if (Math.abs((active.y + active.h/2) - (other.y + other.h/2)) < threshold) createHGuide(active.y + active.h/2);
            });

            function createVGuide(x) { const g = document.createElement('div'); g.className='guide-line guide-v'; g.style.left=x+'px'; layer.appendChild(g); }
            function createHGuide(y) { const g = document.createElement('div'); g.className='guide-line guide-h'; g.style.top=y+'px'; layer.appendChild(g); }
        }

        // --- Properties Panel ---
        updatePropertiesPanel() {
            const panel = document.getElementById('props-content');
            if (!this.selectedId) {
                panel.innerHTML = '<div class="empty-state">Select an element to edit properties</div>';
                return;
            }

            const el = this.elements[this.selectedId];
            const s = el.styles;

            panel.innerHTML = `
                <div class="prop-group">
                    <label class="prop-label">Position & Size</label>
                    <div class="prop-row">
                        <input type="number" value="${Math.round(el.x)}" onchange="builder.updateProp('x', this.value)"> X
                        <input type="number" value="${Math.round(el.y)}" onchange="builder.updateProp('y', this.value)"> Y
                    </div>
                    <div class="prop-row">
                        <input type="number" value="${Math.round(el.w)}" onchange="builder.updateProp('w', this.value)"> W
                        <input type="number" value="${Math.round(el.h)}" onchange="builder.updateProp('h', this.value)"> H
                    </div>
                </div>
                <div class="prop-group">
                    <label class="prop-label">Appearance</label>
                    <div class="prop-row"><label>Bg</label><input type="color" value="${s.bg}" onchange="builder.updateStyle('bg', this.value)"></div>
                    <div class="prop-row"><label>Text</label><input type="color" value="${s.color}" onchange="builder.updateStyle('color', this.value)"></div>
                    <div class="prop-row"><label>Radius</label><input type="number" value="${s.radius}" onchange="builder.updateStyle('radius', this.value)"></div>
                    <div class="prop-row"><label>Padding</label><input type="text" value="${s.padding}" onchange="builder.updateStyle('padding', this.value)"></div>
                    <div class="prop-row"><label>Border</label><input type="text" value="${s.border}" onchange="builder.updateStyle('border', this.value)" placeholder="1px solid black"></div>
                    <div class="prop-row">
                        <label class="prop-label" style="margin-bottom:5px">Shadow</label>
                        <select onchange="builder.updateStyle('shadow', this.value)">
                            <option value="none" ${s.shadow==='none'?'selected':''}>None</option>
                            <option value="0 4px 6px rgba(0,0,0,0.1)" ${s.shadow.includes('0 4px 6px')?'selected':''}>Small</option>
                            <option value="0 10px 15px rgba(0,0,0,0.2)" ${s.shadow.includes('0 10px')?'selected':''}>Large</option>
                        </select>
                    </div>
                </div>
                <div class="prop-group">
                    <button class="preview-btn" onclick="builder.makeEditable(document.querySelector('#${this.selectedId} .comp-content'))">Edit Text</button>
                </div>
                <div class="prop-group">
                    <button class="preview-btn" style="background:#ef4444" onclick="builder.deleteElement('${this.selectedId}')">Delete Element</button>
                </div>
            `;
        }

        updateProp(key, val) {
            this.elements[this.selectedId][key] = parseFloat(val);
            this.updateElementVisuals(this.selectedId);
        }

        updateStyle(key, val) {
            this.elements[this.selectedId].styles[key] = val;
            this.updateElementVisuals(this.selectedId);
        }

        makeEditable(contentDiv) {
            contentDiv.contentEditable = true;
            contentDiv.focus();
            contentDiv.style.outline = "1px dashed #ccc";
            
            const save = () => {
                contentDiv.contentEditable = false;
                contentDiv.style.outline = "none";
                this.elements[this.selectedId].html = contentDiv.innerHTML;
                contentDiv.onblur = null;
                contentDiv.onkeydown = null;
            };

            contentDiv.onblur = save;
            contentDiv.onkeydown = (e) => { if(e.key === 'Enter') { e.preventDefault(); save(); }};
        }

        deleteElement(id) {
            delete this.elements[id];
            document.getElementById(id).remove();
            // Remove connections
            this.connections = this.connections.filter(c => c.from !== id && c.to !== id);
            this.updateConnections();
            this.selectElement(null);
        }

        // --- Connections (Flowchart) ---
        
        startLink(e, id, side) {
            e.stopPropagation();
            this.isLinking = true;
            this.linkSource = { id, side };
        }

        endLink(e, id, side) {
            e.stopPropagation();
            if(this.isLinking && this.linkSource && this.linkSource.id !== id) {
                // Check duplicate
                const exists = this.connections.find(c => c.from === this.linkSource.id && c.to === id);
                if(!exists) {
                    this.connections.push({ from: this.linkSource.id, to: id });
                    this.updateConnections();
                }
            }
        }

        drawTempLine(e) {
            const svg = document.getElementById('connections-layer');
            let line = document.getElementById('temp-line');
            const sourceEl = document.getElementById(this.linkSource.id);
            
            if(!line) {
                line = document.createElementNS("http://www.w3.org/2000/svg", "path");
                line.id = 'temp-line';
                line.setAttribute('stroke', '#3b82f6');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('fill', 'none');
                line.setAttribute('stroke-dasharray', '5');
                svg.appendChild(line);
            }

            const start = this.getPortCoords(sourceEl, this.linkSource.side);
            // Mouse relative to svg (wrapper)
            const wrapper = document.getElementById('canvas-wrapper');
            const rect = wrapper.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const endY = e.clientY - rect.top;

            const path = this.calculateBezier(start.x, start.y, endX, endY);
            line.setAttribute('d', path);
        }

        updateConnections() {
            const svg = document.getElementById('connections-layer');
            // Remove old persistent lines (keep temp line if exists)
            const lines = Array.from(svg.querySelectorAll('.connection-line'));
            lines.forEach(l => l.remove());

            this.connections.forEach((conn, idx) => {
                const el1 = document.getElementById(conn.from);
                const el2 = document.getElementById(conn.to);
                if(!el1 || !el2) return;

                const start = this.getPortCoords(el1, 'left');
                const end = this.getPortCoords(el2, 'right');

                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute('d', this.calculateBezier(start.x, start.y, end.x, end.y));
                path.setAttribute('class', 'connection-line');
                path.onclick = (e) => {
                    e.stopPropagation();
                    if(confirm('Delete connection?')) {
                        this.connections.splice(idx, 1);
                        this.updateConnections();
                    }
                };
                svg.appendChild(path);
            });
        }

        getPortCoords(el, side) {
            const rect = el.getBoundingClientRect();
            const wrapper = document.getElementById('canvas-wrapper').getBoundingClientRect();
            const top = rect.top - wrapper.top;
            const left = rect.left - wrapper.left;
            
            if(side === 'left') return { x: left, y: top + el.offsetHeight / 2 };
            return { x: left + el.offsetWidth, y: top + el.offsetHeight / 2 };
        }

        calculateBezier(x1, y1, x2, y2) {
            const cp1x = x1 - Math.abs(x2 - x1) * 0.5;
            const cp1y = y1;
            const cp2x = x2 + Math.abs(x2 - x1) * 0.5;
            const cp2y = y2;
            return `M ${x1} ${y1} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x2} ${y2}`;
        }

        // --- Export ---
        exportHTML() {
            const width = Math.max(...Object.values(this.elements).map(e => e.x + e.w + 100));
            const height = Math.max(...Object.values(this.elements).map(e => e.y + e.h + 100));

            let css = `
                <style>
                    body { margin:0; padding:0; font-family: 'Inter', sans-serif; background: #fff; height: 100vh; overflow: auto; }
                    .container { position: relative; width: ${width}px; height: ${height}px; }
                    .el { position: absolute; box-sizing: border-box; display: flex; align-items: center; justify-content: center; }
                </style>
            `;
            
            let html = `<div class="container">`;
            
            // Elements
            Object.values(this.elements).forEach(e => {
                html += `<div class="el" style="
                    left: ${e.x}px; top: ${e.y}px;
                    width: ${e.w}px; height: ${e.h}px;
                    background-color: ${e.styles.bg};
                    color: ${e.styles.color};
                    border-radius: ${e.styles.radius}px;
                    box-shadow: ${e.styles.shadow};
                    border: ${e.styles.border};
                    padding: ${e.styles.padding};
                    clip-path: ${e.styles.clip};
                ">${e.html}</div>`;
            });

            // SVG Layer (simplified)
            if(this.connections.length > 0) {
                html += `<svg style="position:absolute; top:0; left:0; width:100%; height:100%; overflow:visible; pointer-events:none; z-index:0;">`;
                this.connections.forEach(conn => {
                    const el1 = this.elements[conn.from];
                    const el2 = this.elements[conn.to];
                    const start = { x: el1.x, y: el1.y + el1.h/2 };
                    const end = { x: el2.x + el2.w, y: el2.y + el2.h/2 };
                    // Reuse bezier logic simplified for string generation
                    const cp1x = start.x - Math.abs(end.x - start.x) * 0.5;
                    const cp1y = start.y;
                    const cp2x = end.x + Math.abs(end.x - start.x) * 0.5;
                    const cp2y = end.y;
                    
                    html += `<path d="M ${start.x} ${start.y} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${end.x} ${end.y}" fill="none" stroke="#64748b" stroke-width="2" />`;
                });
                html += `</svg>`;
            }

            html += `</div>`;

            const fileContent = `<!DOCTYPE html><html><head><title>Exported Design</title><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">${css}</head><body>${html}</body></html>`;

            const blob = new Blob([fileContent], {type: 'text/html'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'exported-design.html';
            a.click();
        }
    }

    // Initialize
    const builder = new Builder();

</script>
</body>
</html>