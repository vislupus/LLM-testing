<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel Clone - Web Spreadsheet</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f8f9fa;
            overflow: hidden;
            user-select: none;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Toolbar */
        .toolbar {
            background: #ffffff;
            border-bottom: 1px solid #e0e0e0;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 16px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .toolbar-group {
            display: flex;
            gap: 4px;
            padding: 0 8px;
            border-right: 1px solid #e0e0e0;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar button {
            background: #ffffff;
            border: 1px solid #d0d0d0;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .toolbar button:hover {
            background: #f0f0f0;
            border-color: #b0b0b0;
        }

        .toolbar button.active {
            background: #e1f5fe;
            border-color: #0288d1;
            color: #0288d1;
        }

        .toolbar input[type="color"] {
            width: 36px;
            height: 32px;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Formula Bar */
        .formula-bar {
            background: #ffffff;
            border-bottom: 1px solid #e0e0e0;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .cell-address {
            min-width: 60px;
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .formula-input {
            flex: 1;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            padding: 6px 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            outline: none;
        }

        .formula-input:focus {
            border-color: #0288d1;
            box-shadow: 0 0 0 2px rgba(2, 136, 209, 0.2);
        }

        /* Spreadsheet Container */
        .spreadsheet-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #ffffff;
            overflow: hidden;
        }

        /* Column Headers */
        .column-headers {
            display: flex;
            background: #f5f5f5;
            border-bottom: 1px solid #d0d0d0;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .corner-cell {
            width: 40px;
            height: 24px;
            background: #e8e8e8;
            border-right: 1px solid #d0d0d0;
            border-bottom: 1px solid #d0d0d0;
        }

        .column-header {
            min-width: 80px;
            height: 24px;
            background: #f5f5f5;
            border-right: 1px solid #d0d0d0;
            border-bottom: 1px solid #d0d0d0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            color: #666;
            cursor: pointer;
            position: relative;
        }

        .column-header:hover {
            background: #e8e8e8;
        }

        .column-resizer {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            cursor: col-resize;
            background: transparent;
        }

        .column-resizer:hover {
            background: #0288d1;
        }

        /* Grid Container */
        .grid-container {
            flex: 1;
            overflow: auto;
            position: relative;
        }

        .grid {
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .row {
            display: flex;
            min-height: 24px;
        }

        .row-number {
            width: 40px;
            min-height: 24px;
            background: #f5f5f5;
            border-right: 1px solid #d0d0d0;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            color: #666;
            position: sticky;
            left: 0;
            z-index: 5;
        }

        .cell {
            min-width: 80px;
            min-height: 24px;
            border-right: 1px solid #e0e0e0;
            border-bottom: 1px solid #e0e0e0;
            padding: 4px 6px;
            font-size: 13px;
            position: relative;
            cursor: cell;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .cell:hover {
            background: #f8f9fa;
        }

        .cell.selected {
            background: #e3f2fd !important;
            border: 2px solid #0288d1;
            padding: 2px 4px;
        }

        .cell.range-selected {
            background: #bbdefb !important;
        }

        .cell.editing {
            outline: none;
            cursor: text;
        }

        .cell.bold {
            font-weight: 700;
        }

        .cell.italic {
            font-style: italic;
        }

        /* Sheet Tabs */
        .sheet-tabs {
            background: #f5f5f5;
            border-top: 1px solid #d0d0d0;
            padding: 0 16px;
            display: flex;
            align-items: center;
            gap: 4px;
            overflow-x: auto;
        }

        .sheet-tab {
            background: #ffffff;
            border: 1px solid #d0d0d0;
            border-bottom: none;
            padding: 6px 16px;
            cursor: pointer;
            font-size: 13px;
            border-radius: 4px 4px 0 0;
            position: relative;
            white-space: nowrap;
        }

        .sheet-tab.active {
            background: #ffffff;
            border-bottom: 1px solid #ffffff;
            margin-bottom: -1px;
            z-index: 10;
            font-weight: 600;
        }

        .sheet-tab:hover:not(.active) {
            background: #f0f0f0;
        }

        .sheet-tab-close {
            margin-left: 8px;
            cursor: pointer;
            color: #666;
            font-size: 16px;
            line-height: 1;
        }

        .sheet-tab-close:hover {
            color: #d32f2f;
        }

        .add-sheet-btn {
            background: transparent;
            border: 1px solid #d0d0d0;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 16px;
            border-radius: 4px;
        }

        .add-sheet-btn:hover {
            background: #f0f0f0;
        }

        /* Context Menu */
        .context-menu {
            position: absolute;
            background: #ffffff;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            display: none;
            z-index: 1000;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
        }

        .context-menu-item:hover {
            background: #f0f0f0;
        }

        /* File Input */
        .file-input {
            display: none;
        }

        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
            color: #666;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .toolbar {
                flex-wrap: wrap;
            }
            
            .column-header, .cell {
                min-width: 60px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Toolbar -->
        <div class="toolbar">
            <div class="toolbar-group">
                <button onclick="clearContents()" title="Clear">
                    <span>üóëÔ∏è</span> Clear
                </button>
                <button onclick="downloadCSV()" title="Download CSV">
                    <span>‚¨áÔ∏è</span> Download
                </button>
                <button onclick="document.getElementById('csvFile').click()" title="Upload CSV">
                    <span>‚¨ÜÔ∏è</span> Upload
                </button>
                <input type="file" id="csvFile" class="file-input" accept=".csv" onchange="uploadCSV(event)">
            </div>
            
            <div class="toolbar-group">
                <button id="boldBtn" onclick="toggleBold()" title="Bold">
                    <span><b>B</b></span>
                </button>
                <button id="italicBtn" onclick="toggleItalic()" title="Italic">
                    <span><i>I</i></span>
                </button>
            </div>
            
            <div class="toolbar-group">
                <label style="font-size: 14px;">Fill:</label>
                <input type="color" id="bgColor" onchange="changeBackgroundColor()" title="Background Color">
            </div>
        </div>

        <!-- Formula Bar -->
        <div class="formula-bar">
            <div class="cell-address" id="cellAddress">A1</div>
            <input type="text" class="formula-input" id="formulaInput" placeholder="Enter value or formula" onkeydown="handleFormulaKeydown(event)">
        </div>

        <!-- Spreadsheet Container -->
        <div class="spreadsheet-container">
            <!-- Column Headers -->
            <div class="column-headers" id="columnHeaders">
                <div class="corner-cell"></div>
            </div>

            <!-- Grid Container -->
            <div class="grid-container" id="gridContainer">
                <div class="grid" id="grid">
                    <!-- Grid will be generated dynamically -->
                </div>
            </div>

            <!-- Sheet Tabs -->
            <div class="sheet-tabs" id="sheetTabs">
                <!-- Sheet tabs will be generated dynamically -->
            </div>
        </div>

        <!-- Context Menu -->
        <div class="context-menu" id="contextMenu">
            <div class="context-menu-item" onclick="cut()">Cut</div>
            <div class="context-menu-item" onclick="copy()">Copy</div>
            <div class="context-menu-item" onclick="paste()">Paste</div>
            <div class="context-menu-item" onclick="clearContents()">Clear</div>
        </div>
    </div>

    <script>
        // Spreadsheet Engine
        class SpreadsheetEngine {
            constructor() {
                this.sheets = {};
                this.activeSheet = 'Sheet1';
                this.selectedCell = 'A1';
                this.selectedRange = null;
                this.isEditing = false;
                this.clipboard = null;
                this.columnWidths = {};
                this.dependencies = {};
                this.init();
            }

            init() {
                // Initialize with one sheet
                this.addSheet('Sheet1');
                this.render();
            }

            addSheet(name) {
                if (!this.sheets[name]) {
                    this.sheets[name] = {
                        cells: {},
                        styles: {},
                        name: name
                    };
                }
            }

            deleteSheet(name) {
                if (name !== 'Sheet1' && this.sheets[name]) {
                    delete this.sheets[name];
                    if (this.activeSheet === name) {
                        this.activeSheet = Object.keys(this.sheets)[0];
                    }
                }
            }

            renameSheet(oldName, newName) {
                if (this.sheets[oldName] && !this.sheets[newName]) {
                    this.sheets[newName] = this.sheets[oldName];
                    this.sheets[newName].name = newName;
                    delete this.sheets[oldName];
                    if (this.activeSheet === oldName) {
                        this.activeSheet = newName;
                    }
                }
            }

            getCell(col, row) {
                const sheet = this.sheets[this.activeSheet];
                const key = `${col}${row}`;
                return sheet.cells[key] || { value: '', formula: '' };
            }

            setCell(col, row, value, isFormula = false) {
                const sheet = this.sheets[this.activeSheet];
                const key = `${col}${row}`;
                
                // Clear old dependencies
                this.clearDependencies(key);
                
                if (isFormula || (value && value.startsWith('='))) {
                    const formula = value.startsWith('=') ? value : `=${value}`;
                    sheet.cells[key] = { value: '', formula };
                    this.parseDependencies(key, formula);
                } else {
                    sheet.cells[key] = { value, formula: '' };
                }
                
                // Recalculate dependent cells
                this.recalculateDependents(key);
            }

            clearDependencies(key) {
                if (this.dependencies[key]) {
                    this.dependencies[key].forEach(dep => {
                        const dependents = this.sheets[this.activeSheet].dependents?.[dep] || [];
                        const index = dependents.indexOf(key);
                        if (index > -1) {
                            dependents.splice(index, 1);
                        }
                    });
                    delete this.dependencies[key];
                }
            }

            parseDependencies(key, formula) {
                const refs = formula.match(/[A-Z]+\d+:[A-Z]+\d+|[A-Z]+\d+/g) || [];
                this.dependencies[key] = refs;
                
                refs.forEach(ref => {
                    if (!this.sheets[this.activeSheet].dependents) {
                        this.sheets[this.activeSheet].dependents = {};
                    }
                    if (!this.sheets[this.activeSheet].dependents[ref]) {
                        this.sheets[this.activeSheet].dependents[ref] = [];
                    }
                    this.sheets[this.activeSheet].dependents[ref].push(key);
                });
            }

            recalculateDependents(changedKey) {
                const dependents = this.sheets[this.activeSheet].dependents?.[changedKey] || [];
                dependents.forEach(dep => {
                    this.recalculateCell(dep);
                    this.recalculateDependents(dep);
                });
            }

            recalculateCell(key) {
                const sheet = this.sheets[this.activeSheet];
                const cell = sheet.cells[key];
                if (cell && cell.formula) {
                    try {
                        const result = this.evaluateFormula(cell.formula);
                        cell.value = result;
                    } catch (e) {
                        cell.value = '#ERROR';
                    }
                }
            }

            evaluateFormula(formula) {
                if (!formula || !formula.startsWith('=')) return formula;
                
                let expression = formula.substring(1);
                
                // Replace cell references with values
                expression = expression.replace(/[A-Z]+\d+:[A-Z]+\d+/g, (match) => {
                    const range = this.parseRange(match);
                    return `[${range.map(cell => this.getCellValue(cell)).join(',')}]`;
                });
                
                expression = expression.replace(/[A-Z]+\d+/g, (match) => {
                    return this.getCellValue(match);
                });
                
                // Replace functions
                expression = expression.replace(/SUM\((.*?)\)/g, (match, args) => {
                    const values = this.parseArray(args);
                    return values.reduce((sum, val) => sum + (parseFloat(val) || 0), 0);
                });
                
                expression = expression.replace(/AVERAGE\((.*?)\)/g, (match, args) => {
                    const values = this.parseArray(args);
                    const sum = values.reduce((s, v) => s + (parseFloat(v) || 0), 0);
                    return sum / values.length;
                });
                
                expression = expression.replace(/MIN\((.*?)\)/g, (match, args) => {
                    const values = this.parseArray(args);
                    return Math.min(...values.map(v => parseFloat(v) || 0));
                });
                
                expression = expression.replace(/MAX\((.*?)\)/g, (match, args) => {
                    const values = this.parseArray(args);
                    return Math.max(...values.map(v => parseFloat(v) || 0));
                });
                
                // Evaluate the expression
                try {
                    return eval(expression);
                } catch (e) {
                    return '#ERROR';
                }
            }

            parseArray(str) {
                if (str.startsWith('[') && str.endsWith(']')) {
                    return str.slice(1, -1).split(',').map(v => v.trim());
                }
                return [str];
            }

            parseRange(range) {
                const [start, end] = range.split(':');
                const cells = [];
                const startCol = this.columnToNumber(start.match(/[A-Z]+/)[0]);
                const startRow = parseInt(start.match(/\d+/)[0]);
                const endCol = this.columnToNumber(end.match(/[A-Z]+/)[0]);
                const endRow = parseInt(end.match(/\d+/)[0]);
                
                for (let col = startCol; col <= endCol; col++) {
                    for (let row = startRow; row <= endRow; row++) {
                        cells.push(`${this.numberToColumn(col)}${row}`);
                    }
                }
                return cells;
            }

            getCellValue(key) {
                const cell = this.getCell(key.match(/[A-Z]+/)[0], parseInt(key.match(/\d+/)[0]));
                return cell.value || '0';
            }

            columnToNumber(col) {
                let num = 0;
                for (let i = 0; i < col.length; i++) {
                    num = num * 26 + (col.charCodeAt(i) - 64);
                }
                return num;
            }

            numberToColumn(num) {
                let col = '';
                while (num > 0) {
                    num--;
                    col = String.fromCharCode(65 + (num % 26)) + col;
                    num = Math.floor(num / 26);
                }
                return col;
            }

            render() {
                this.renderColumnHeaders();
                this.renderGrid();
                this.renderSheetTabs();
                this.updateFormulaBar();
            }

            renderColumnHeaders() {
                const container = document.getElementById('columnHeaders');
                container.innerHTML = '<div class="corner-cell"></div>';
                
                for (let col = 1; col <= 26; col++) {
                    const header = document.createElement('div');
                    header.className = 'column-header';
                    header.textContent = this.numberToColumn(col);
                    
                    const width = this.columnWidths[col] || 80;
                    header.style.width = width + 'px';
                    
                    const resizer = document.createElement('div');
                    resizer.className = 'column-resizer';
                    resizer.onmousedown = (e) => this.startColumnResize(e, col);
                    header.appendChild(resizer);
                    
                    container.appendChild(header);
                }
            }

            renderGrid() {
                const container = document.getElementById('grid');
                container.innerHTML = '';
                
                for (let row = 1; row <= 100; row++) {
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'row';
                    
                    // Row number
                    const rowNum = document.createElement('div');
                    rowNum.className = 'row-number';
                    rowNum.textContent = row;
                    rowDiv.appendChild(rowNum);
                    
                    // Cells
                    for (let col = 1; col <= 26; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.col = this.numberToColumn(col);
                        cell.dataset.row = row;
                        
                        const width = this.columnWidths[col] || 80;
                        cell.style.width = width + 'px';
                        
                        const key = `${cell.dataset.col}${row}`;
                        const cellData = this.getCell(cell.dataset.col, row);
                        cell.textContent = cellData.value;
                        
                        // Apply styles
                        const styles = this.sheets[this.activeSheet].styles[key] || {};
                        if (styles.bold) cell.classList.add('bold');
                        if (styles.italic) cell.classList.add('italic');
                        if (styles.backgroundColor) {
                            cell.style.backgroundColor = styles.backgroundColor;
                        }
                        
                        // Event listeners
                        cell.onclick = (e) => this.selectCell(e, cell);
                        cell.ondblclick = (e) => this.editCell(e, cell);
                        cell.onmousedown = (e) => this.startRangeSelection(e, cell);
                        cell.oncontextmenu = (e) => this.showContextMenu(e, cell);
                        
                        rowDiv.appendChild(cell);
                    }
                    
                    container.appendChild(rowDiv);
                }
            }

            renderSheetTabs() {
                const container = document.getElementById('sheetTabs');
                container.innerHTML = '';
                
                Object.keys(this.sheets).forEach(name => {
                    const tab = document.createElement('div');
                    tab.className = 'sheet-tab';
                    if (name === this.activeSheet) {
                        tab.classList.add('active');
                    }
                    tab.textContent = name;
                    
                    if (Object.keys(this.sheets).length > 1) {
                        const close = document.createElement('span');
                        close.className = 'sheet-tab-close';
                        close.textContent = '√ó';
                        close.onclick = (e) => {
                            e.stopPropagation();
                            this.deleteSheet(name);
                            this.render();
                        };
                        tab.appendChild(close);
                    }
                    
                    tab.onclick = () => {
                        this.activeSheet = name;
                        this.render();
                    };
                    
                    tab.ondblclick = () => {
                        const newName = prompt('Enter sheet name:', name);
                        if (newName && newName !== name) {
                            this.renameSheet(name, newName);
                            this.render();
                        }
                    };
                    
                    container.appendChild(tab);
                });
                
                // Add sheet button
                const addBtn = document.createElement('button');
                addBtn.className = 'add-sheet-btn';
                addBtn.textContent = '+';
                addBtn.onclick = () => {
                    const name = `Sheet${Object.keys(this.sheets).length + 1}`;
                    this.addSheet(name);
                    this.activeSheet = name;
                    this.render();
                };
                container.appendChild(addBtn);
            }

            selectCell(e, cell) {
                if (this.isEditing) return;
                
                // Clear previous selection
                document.querySelectorAll('.cell.selected, .cell.range-selected').forEach(c => {
                    c.classList.remove('selected', 'range-selected');
                });
                
                cell.classList.add('selected');
                this.selectedCell = `${cell.dataset.col}${cell.dataset.row}`;
                this.selectedRange = null;
                this.updateFormulaBar();
            }

            startRangeSelection(e, cell) {
                if (e.shiftKey && this.selectedCell) {
                    this.selectRange(this.selectedCell, `${cell.dataset.col}${cell.dataset.row}`);
                }
            }

            selectRange(start, end) {
                const [startCol, startRow] = [this.columnToNumber(start.match(/[A-Z]+/)[0]), parseInt(start.match(/\d+/)[0])];
                const [endCol, endRow] = [this.columnToNumber(end.match(/[A-Z]+/)[0]), parseInt(end.match(/\d+/)[0])];
                
                const minCol = Math.min(startCol, endCol);
                const maxCol = Math.max(startCol, endCol);
                const minRow = Math.min(startRow, endRow);
                const maxRow = Math.max(startRow, endRow);
                
                document.querySelectorAll('.cell').forEach(c => {
                    c.classList.remove('selected', 'range-selected');
                });
                
                for (let col = minCol; col <= maxCol; col++) {
                    for (let row = minRow; row <= maxRow; row++) {
                        const cell = document.querySelector(`[data-col="${this.numberToColumn(col)}"][data-row="${row}"]`);
                        if (cell) {
                            cell.classList.add('range-selected');
                        }
                    }
                }
                
                this.selectedRange = `${this.numberToColumn(minCol)}${minRow}:${this.numberToColumn(maxCol)}${maxRow}`;
            }

            editCell(e, cell) {
                if (this.isEditing) return;
                
                this.isEditing = true;
                cell.contentEditable = true;
                cell.classList.add('editing');
                cell.focus();
                
                const key = `${cell.dataset.col}${cell.dataset.row}`;
                const cellData = this.getCell(cell.dataset.col, row);
                cell.textContent = cellData.formula || cellData.value;
                
                // Select all text
                const range = document.createRange();
                range.selectNodeContents(cell);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
                
                cell.onblur = () => {
                    this.isEditing = false;
                    cell.contentEditable = false;
                    cell.classList.remove('editing');
                    
                    const value = cell.textContent;
                    this.setCell(cell.dataset.col, cell.dataset.row, value, value.startsWith('='));
                    this.render();
                };
                
                cell.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        cell.blur();
                        this.moveCursor('down');
                    } else if (e.key === 'Tab') {
                        e.preventDefault();
                        cell.blur();
                        this.moveCursor('right');
                    }
                };
            }

            updateFormulaBar() {
                document.getElementById('cellAddress').textContent = this.selectedCell;
                const [col, row] = [this.selectedCell.match(/[A-Z]+/)[0], parseInt(this.selectedCell.match(/\d+/)[0])];
                const cell = this.getCell(col, row);
                const formulaInput = document.getElementById('formulaInput');
                
                if (this.isEditing) {
                    // Keep current input
                } else {
                    formulaInput.value = cell.formula || cell.value;
                }
            }

            moveCursor(direction) {
                const [col, row] = [this.selectedCell.match(/[A-Z]+/)[0], parseInt(this.selectedCell.match(/\d+/)[0])];
                let newCol = col;
                let newRow = row;
                
                switch(direction) {
                    case 'up': newRow = Math.max(1, row - 1); break;
                    case 'down': newRow = Math.min(100, row + 1); break;
                    case 'left': newCol = this.numberToColumn(Math.max(1, this.columnToNumber(col) - 1)); break;
                    case 'right': newCol = this.numberToColumn(Math.min(26, this.columnToNumber(col) + 1)); break;
                }
                
                const newCell = document.querySelector(`[data-col="${newCol}"][data-row="${newRow}"]`);
                if (newCell) {
                    this.selectCell(null, newCell);
                    newCell.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }

            startColumnResize(e, col) {
                e.preventDefault();
                const startX = e.clientX;
                const startWidth = this.columnWidths[col] || 80;
                
                const onMouseMove = (e) => {
                    const width = startWidth + (e.clientX - startX);
                    this.columnWidths[col] = Math.max(40, width);
                    
                    document.querySelector(`.column-header:nth-child(${col + 1})`).style.width = width + 'px';
                    document.querySelectorAll(`.cell[data-col="${this.numberToColumn(col)}"]`).forEach(cell => {
                        cell.style.width = width + 'px';
                    });
                };
                
                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }

            showContextMenu(e, cell) {
                e.preventDefault();
                const menu = document.getElementById('contextMenu');
                menu.style.display = 'block';
                menu.style.left = e.pageX + 'px';
                menu.style.top = e.pageY + 'px';
                
                document.addEventListener('click', () => {
                    menu.style.display = 'none';
                }, { once: true });
            }
        }

        // Initialize spreadsheet
        const spreadsheet = new SpreadsheetEngine();

        // Global functions
        function handleFormulaKeydown(e) {
            if (e.key === 'Enter') {
                const input = e.target;
                const value = input.value;
                const [col, row] = [spreadsheet.selectedCell.match(/[A-Z]+/)[0], parseInt(spreadsheet.selectedCell.match(/\d+/)[0])];
                spreadsheet.setCell(col, row, value, value.startsWith('='));
                spreadsheet.render();
            }
        }

        function toggleBold() {
            const btn = document.getElementById('boldBtn');
            btn.classList.toggle('active');
            applyStyle('bold', btn.classList.contains('active'));
        }

        function toggleItalic() {
            const btn = document.getElementById('italicBtn');
            btn.classList.toggle('active');
            applyStyle('italic', btn.classList.contains('active'));
        }

        function applyStyle(style, value) {
            if (spreadsheet.selectedRange) {
                // Apply to range
                const range = spreadsheet.parseRange(spreadsheet.selectedRange);
                range.forEach(key => {
                    if (!spreadsheet.sheets[spreadsheet.activeSheet].styles[key]) {
                        spreadsheet.sheets[spreadsheet.activeSheet].styles[key] = {};
                    }
                    spreadsheet.sheets[spreadsheet.activeSheet].styles[key][style] = value;
                });
            } else {
                // Apply to single cell
                if (!spreadsheet.sheets[spreadsheet.activeSheet].styles[spreadsheet.selectedCell]) {
                    spreadsheet.sheets[spreadsheet.activeSheet].styles[spreadsheet.selectedCell] = {};
                }
                spreadsheet.sheets[spreadsheet.activeSheet].styles[spreadsheet.selectedCell][style] = value;
            }
            spreadsheet.render();
        }

        function changeBackgroundColor() {
            const color = document.getElementById('bgColor').value;
            applyStyle('backgroundColor', color);
        }

        function clearContents() {
            if (spreadsheet.selectedRange) {
                const range = spreadsheet.parseRange(spreadsheet.selectedRange);
                range.forEach(key => {
                    const [col, row] = [key.match(/[A-Z]+/)[0], parseInt(key.match(/\d+/)[0])];
                    spreadsheet.setCell(col, row, '');
                });
            } else {
                const [col, row] = [spreadsheet.selectedCell.match(/[A-Z]+/)[0], parseInt(spreadsheet.selectedCell.match(/\d+/)[0])];
                spreadsheet.setCell(col, row, '');
            }
            spreadsheet.render();
        }

        function downloadCSV() {
            let csv = '';
            for (let row = 1; row <= 100; row++) {
                const rowData = [];
                for (let col = 1; col <= 26; col++) {
                    const cell = spreadsheet.getCell(spreadsheet.numberToColumn(col), row);
                    rowData.push(cell.value || '');
                }
                csv += rowData.join(',') + '\n';
            }
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${spreadsheet.activeSheet}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function uploadCSV(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                const csv = event.target.result;
                const lines = csv.split('\n');
                
                lines.forEach((line, rowIndex) => {
                    if (rowIndex >= 100) return;
                    const values = line.split(',');
                    values.forEach((value, colIndex) => {
                        if (colIndex >= 26) return;
                        const col = spreadsheet.numberToColumn(colIndex + 1);
                        const row = rowIndex + 1;
                        spreadsheet.setCell(col, row, value);
                    });
                });
                
                spreadsheet.render();
            };
            reader.readAsText(file);
        }

        function cut() {
            copy();
            clearContents();
        }

        function copy() {
            if (spreadsheet.selectedRange) {
                spreadsheet.clipboard = [];
                const range = spreadsheet.parseRange(spreadsheet.selectedRange);
                range.forEach(key => {
                    const [col, row] = [key.match(/[A-Z]+/)[0], parseInt(key.match(/\d+/)[0])];
                    const cell = spreadsheet.getCell(col, row);
                    spreadsheet.clipboard.push({ key, value: cell.value, formula: cell.formula });
                });
            } else {
                const [col, row] = [spreadsheet.selectedCell.match(/[A-Z]+/)[0], parseInt(spreadsheet.selectedCell.match(/\d+/)[0])];
                const cell = spreadsheet.getCell(col, row);
                spreadsheet.clipboard = [{ key: spreadsheet.selectedCell, value: cell.value, formula: cell.formula }];
            }
        }

        function paste() {
            if (!spreadsheet.clipboard) return;
            
            const [startCol, startRow] = [spreadsheet.selectedCell.match(/[A-Z]+/)[0], parseInt(spreadsheet.selectedCell.match(/\d+/)[0])];
            const startColNum = spreadsheet.columnToNumber(startCol);
            
            spreadsheet.clipboard.forEach((item, index) => {
                const offsetCol = index % 26;
                const offsetRow = Math.floor(index / 26);
                const newCol = spreadsheet.numberToColumn(startColNum + offsetCol);
                const newRow = startRow + offsetRow;
                
                if (newCol && newRow <= 100) {
                    spreadsheet.setCell(newCol, newRow, item.formula || item.value, !!item.formula);
                }
            });
            
            spreadsheet.render();
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (spreadsheet.isEditing) return;
            
            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    spreadsheet.moveCursor('up');
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    spreadsheet.moveCursor('down');
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    spreadsheet.moveCursor('left');
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    spreadsheet.moveCursor('right');
                    break;
                case 'Enter':
                    e.preventDefault();
                    spreadsheet.moveCursor('down');
                    break;
                case 'Tab':
                    e.preventDefault();
                    spreadsheet.moveCursor('right');
                    break;
                case 'Delete':
                case 'Backspace':
                    e.preventDefault();
                    clearContents();
                    break;
                case 'c':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        copy();
                    }
                    break;
                case 'v':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        paste();
                    }
                    break;
                case 'x':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        cut();
                    }
                    break;
            }
        });

        // Formula input focus handling
        document.getElementById('formulaInput').addEventListener('focus', () => {
            spreadsheet.isEditing = true;
        });

        document.getElementById('formulaInput').addEventListener('blur', () => {
            spreadsheet.isEditing = false;
        });

        // Cell selection in formula
        document.addEventListener('mousedown', (e) => {
            if (spreadsheet.isEditing && e.target.classList.contains('cell')) {
                e.preventDefault();
                const cell = e.target;
                const address = `${cell.dataset.col}${cell.dataset.row}`;
                const input = document.getElementById('formulaInput');
                
                if (e.shiftKey && spreadsheet.selectedCell) {
                    const range = `${spreadsheet.selectedCell}:${address}`;
                    input.value += range;
                } else {
                    input.value += address;
                }
                
                input.focus();
            }
        });
    </script>
</body>
</html>