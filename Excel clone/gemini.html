<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebExcel Clone</title>
    <style>
        :root {
            --primary: #107c41;
            --border: #d4d4d4;
            --header-bg: #f8f9fa;
            --select-border: #107c41;
            --select-bg: rgba(16, 124, 65, 0.1);
            --row-header-width: 40px;
            --default-col-width: 100px;
        }

        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 13px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- Toolbar --- */
        .toolbar {
            background: #f3f3f3;
            border-bottom: 1px solid var(--border);
            padding: 8px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn-group {
            display: flex;
            border-right: 1px solid #ccc;
            padding-right: 10px;
            gap: 5px;
        }

        button {
            border: 1px solid transparent;
            background: none;
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 3px;
        }
        button:hover { background: #e1e1e1; }
        button.active { background: #d1d1d1; border-color: #bbb; }

        input[type="color"] {
            width: 30px;
            height: 25px;
            border: none;
            padding: 0;
            cursor: pointer;
        }

        /* --- Formula Bar --- */
        .formula-bar {
            display: flex;
            align-items: center;
            padding: 5px;
            border-bottom: 1px solid var(--border);
            background: white;
        }

        #selected-cell-display {
            width: 40px;
            text-align: center;
            font-weight: bold;
            color: #555;
            border-right: 1px solid var(--border);
            margin-right: 10px;
        }

        #formula-input {
            flex-grow: 1;
            border: none;
            outline: none;
            font-family: monospace;
            font-size: 14px;
        }

        /* --- Main Grid Area --- */
        .spreadsheet-container {
            flex-grow: 1;
            overflow: auto;
            position: relative;
            background: white;
        }

        .grid {
            display: grid;
            /* Grid template columns set dynamically via JS */
        }

        /* Cells */
        .cell {
            border-right: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
            outline: none;
            padding: 2px 4px;
            white-space: nowrap;
            overflow: hidden;
            position: relative;
            cursor: cell;
            user-select: none;
        }

        .cell input {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            font-family: inherit;
            font-size: inherit;
            background: white;
            position: absolute;
            top: 0;
            left: 0;
            padding: 2px 4px;
        }

        /* Headers */
        .header-col {
            background: var(--header-bg);
            border-right: 1px solid #ccc;
            border-bottom: 1px solid #ccc;
            text-align: center;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        .resizer {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 5px;
            cursor: col-resize;
            z-index: 11;
        }
        .resizer:hover { background: var(--primary); }


        .header-row {
            background: var(--header-bg);
            border-right: 1px solid #ccc;
            border-bottom: 1px solid var(--border);
            text-align: center;
            position: sticky;
            left: 0;
            z-index: 10;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* The top-left corner cell */
        .header-corner {
            position: sticky;
            top: 0;
            left: 0;
            z-index: 20;
            background: var(--header-bg);
            border-right: 1px solid #ccc;
            border-bottom: 1px solid #ccc;
        }

        /* Selection Styles */
        .cell.selected {
            border: 2px solid var(--select-border);
            z-index: 5;
        }
        .cell.in-range {
            background-color: var(--select-bg);
        }

        /* --- Sheets Bar --- */
        .sheet-bar {
            background: #f3f3f3;
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            height: 35px;
            overflow-x: auto;
        }
        
        .sheet-tab {
            padding: 0 15px;
            height: 100%;
            display: flex;
            align-items: center;
            border-right: 1px solid var(--border);
            cursor: pointer;
            background: #e1e1e1;
            user-select: none;
            position: relative;
        }
        
        .sheet-tab.active {
            background: white;
            color: var(--primary);
            font-weight: bold;
            border-top: 2px solid var(--primary);
        }
        
        .sheet-tab:hover { background: #ededed; }

        .sheet-btn {
            width: 35px;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            color: #555;
        }
        .sheet-btn:hover { background: #ddd; color: black; }
    </style>
</head>
<body>

    <!-- Toolbar -->
    <div class="toolbar">
        <div class="btn-group">
            <button onclick="formatCell('bold')" title="Bold"><b>B</b></button>
            <button onclick="formatCell('italic')" title="Italic"><i>I</i></button>
            <input type="color" id="bg-color-picker" onchange="formatCell('bgColor', this.value)" title="Background Color">
        </div>
        <div class="btn-group">
            <button onclick="fileActions.downloadCSV()">Download CSV</button>
            <button onclick="document.getElementById('csv-upload').click()">Upload CSV</button>
            <input type="file" id="csv-upload" style="display:none" accept=".csv" onchange="fileActions.uploadCSV(this)">
        </div>
        <div class="btn-group">
            <button onclick="gridManager.clearSelection()">Clear Selection</button>
        </div>
    </div>

    <!-- Formula Bar -->
    <div class="formula-bar">
        <div id="selected-cell-display"></div>
        <input type="text" id="formula-input" placeholder="Enter value or formula (e.g., =SUM(A1:B2))">
    </div>

    <!-- Grid -->
    <div class="spreadsheet-container" id="scroller">
        <div id="grid" class="grid"></div>
    </div>

    <!-- Sheets -->
    <div class="sheet-bar" id="sheet-bar">
        <div class="sheet-btn" onclick="sheetManager.addSheet()">+</div>
        <!-- Tabs injected here -->
    </div>

<script>
/**
 * CONSTANTS & STATE
 */
const COLS = 26; // A-Z
const ROWS = 100;
const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

const state = {
    workbook: [], // Array of sheet objects
    activeSheetIndex: 0,
    selectedCell: null,
    selectionRange: null, // {start: "A1", end: "B2"}
    isDragging: false,
    columnWidths: {}, // Per sheet, default 100
};

// Core Cell Data Structure: { value: "", formula: "", style: {} }

/**
 * UTILITIES
 */
const utils = {
    toId: (col, row) => `${ALPHABET[col]}${row + 1}`,
    
    parseId: (id) => {
        const match = id.match(/([A-Z]+)([0-9]+)/);
        if (!match) return null;
        const colStr = match[1];
        const row = parseInt(match[2]) - 1;
        let col = 0;
        for (let i = 0; i < colStr.length; i++) {
            col = col * 26 + (colStr.charCodeAt(i) - 64);
        }
        return { col: col - 1, row };
    },

    getRangeCells: (startId, endId) => {
        const s = utils.parseId(startId);
        const e = utils.parseId(endId);
        if(!s || !e) return [];

        const startRow = Math.min(s.row, e.row);
        const endRow = Math.max(s.row, e.row);
        const startCol = Math.min(s.col, e.col);
        const endCol = Math.max(s.col, e.col);

        const ids = [];
        for (let r = startRow; r <= endRow; r++) {
            for (let c = startCol; c <= endCol; c++) {
                ids.push(utils.toId(c, r));
            }
        }
        return ids;
    }
};

/**
 * FORMULA ENGINE
 */
const engine = {
    // Allowed functions
    funcs: {
        SUM: (...args) => args.flat().reduce((a, b) => a + (Number(b) || 0), 0),
        AVERAGE: (...args) => {
            const flat = args.flat();
            const sum = flat.reduce((a, b) => a + (Number(b) || 0), 0);
            return flat.length ? sum / flat.length : 0;
        },
        MIN: (...args) => Math.min(...args.flat().map(n => Number(n) || Infinity)),
        MAX: (...args) => Math.max(...args.flat().map(n => Number(n) || -Infinity)),
        COUNT: (...args) => args.flat().filter(n => !isNaN(parseFloat(n)) && isFinite(n)).length,
    },

    evaluate: (formula, sheetData) => {
        if (!formula.startsWith('=')) return formula;

        const expression = formula.substring(1).toUpperCase();

        try {
            // 1. Resolve Ranges (e.g., A1:A3 -> "1, 2, 3")
            // Regex looks for A1:B2 pattern
            const rangeResolved = expression.replace(/([A-Z]+[0-9]+):([A-Z]+[0-9]+)/g, (match, start, end) => {
                const cells = utils.getRangeCells(start, end);
                const values = cells.map(id => {
                    const cell = sheetData[id];
                    const val = cell ? (cell.value || 0) : 0;
                    return isNaN(Number(val)) ? 0 : val;
                });
                return `[${values.join(',')}]`; // Return as array string
            });

            // 2. Resolve Single Cell References
            const cellResolved = rangeResolved.replace(/[A-Z]+[0-9]+/g, (match) => {
                // Check if it is a function name like SUM, if so skip
                if (Object.keys(engine.funcs).includes(match)) return match;
                
                const cell = sheetData[match];
                const val = cell ? cell.value : 0;
                return isNaN(Number(val)) ? `"${val}"` : val; 
            });

            // 3. Execute safely
            // Construct a function with access to math utils
            const funcKeys = Object.keys(engine.funcs);
            const funcVals = Object.values(engine.funcs);
            
            // Basic sanitation: allow math chars, function names, numbers, arrays
            // In a real app, use a tokenizer. This uses Function constructor which is safer than eval but still powerful.
            const fn = new Function(...funcKeys, `return ${cellResolved}`);
            const result = fn(...funcVals);
            
            return result;
        } catch (e) {
            return "#ERROR";
        }
    },

    recalculateAll: () => {
        const sheet = state.workbook[state.activeSheetIndex];
        const data = sheet.data;
        
        // Simple multi-pass approach to resolve dependencies
        // A real graph is better, but 2 passes works for simple A=B, B=C chains
        for (let pass = 0; pass < 2; pass++) {
            Object.keys(data).forEach(id => {
                const cell = data[id];
                if (cell.formula && cell.formula.startsWith('=')) {
                    cell.value = engine.evaluate(cell.formula, data);
                    gridManager.updateCellVisual(id);
                }
            });
        }
    }
};

/**
 * GRID & UI MANAGER
 */
const gridManager = {
    init: () => {
        sheetManager.addSheet("Sheet1");
        gridManager.render();
        
        // Global listeners
        document.addEventListener('keydown', gridManager.handleKeydown);
        document.getElementById('formula-input').addEventListener('keydown', (e) => {
            if(e.key === 'Enter') {
                gridManager.saveFormulaBar();
                document.getElementById('grid').focus();
            }
        });
    },

    render: () => {
        const gridEl = document.getElementById('grid');
        gridEl.innerHTML = '';
        
        const sheet = state.workbook[state.activeSheetIndex];
        const colWidths = sheet.colWidths || {};

        // Set CSS Grid Template
        let templateCols = '40px '; // Row header column
        for (let c = 0; c < COLS; c++) {
            const w = colWidths[c] || 100;
            templateCols += `${w}px `;
        }
        gridEl.style.gridTemplateColumns = templateCols;

        // 1. Top-Left Corner
        const corner = document.createElement('div');
        corner.className = 'header-corner';
        gridEl.appendChild(corner);

        // 2. Column Headers (A, B, C...)
        for (let c = 0; c < COLS; c++) {
            const header = document.createElement('div');
            header.className = 'header-col';
            header.innerText = ALPHABET[c];
            
            // Resizer handle
            const resizer = document.createElement('div');
            resizer.className = 'resizer';
            resizer.onmousedown = (e) => gridManager.initResize(e, c);
            header.appendChild(resizer);
            
            gridEl.appendChild(header);
        }

        // 3. Rows
        for (let r = 0; r < ROWS; r++) {
            // Row Header (1, 2, 3...)
            const rowHeader = document.createElement('div');
            rowHeader.className = 'header-row';
            rowHeader.innerText = r + 1;
            gridEl.appendChild(rowHeader);

            // Cells
            for (let c = 0; c < COLS; c++) {
                const id = utils.toId(c, r);
                const cellDiv = document.createElement('div');
                cellDiv.className = 'cell';
                cellDiv.dataset.id = id;
                
                // Event listeners
                cellDiv.onmousedown = (e) => gridManager.onCellMouseDown(e, id);
                cellDiv.onmouseenter = (e) => gridManager.onCellMouseEnter(e, id);
                cellDiv.ondblclick = () => gridManager.editCell(id);
                
                // Apply Data
                if (sheet.data[id]) {
                    const d = sheet.data[id];
                    cellDiv.innerText = d.value;
                    if (d.style) {
                        if (d.style.bold) cellDiv.style.fontWeight = 'bold';
                        if (d.style.italic) cellDiv.style.fontStyle = 'italic';
                        if (d.style.bgColor) cellDiv.style.backgroundColor = d.style.bgColor;
                    }
                }

                gridEl.appendChild(cellDiv);
            }
        }
    },

    updateCellVisual: (id) => {
        const cellEl = document.querySelector(`.cell[data-id="${id}"]`);
        const sheet = state.workbook[state.activeSheetIndex];
        if (cellEl && sheet.data[id]) {
            cellEl.innerText = sheet.data[id].value;
        }
    },

    onCellMouseDown: (e, id) => {
        state.isDragging = true;
        gridManager.selectCell(id, e.ctrlKey); // Ctrl for multiple selection not fully impl, resets here
        state.selectionRange = { start: id, end: id };
        gridManager.renderSelection();
        
        // Stop drag on mouseup
        const upHandler = () => {
            state.isDragging = false;
            document.removeEventListener('mouseup', upHandler);
        };
        document.addEventListener('mouseup', upHandler);
    },

    onCellMouseEnter: (e, id) => {
        if (state.isDragging) {
            state.selectionRange.end = id;
            gridManager.renderSelection();
        }
    },

    selectCell: (id) => {
        state.selectedCell = id;
        const sheet = state.workbook[state.activeSheetIndex];
        const data = sheet.data[id];

        // Update formula bar
        document.getElementById('selected-cell-display').innerText = id;
        document.getElementById('formula-input').value = data ? (data.formula || data.value) : "";
        
        gridManager.renderSelection();
    },

    renderSelection: () => {
        // Clear previous styles
        document.querySelectorAll('.selected, .in-range').forEach(el => {
            el.classList.remove('selected', 'in-range');
        });

        if (!state.selectedCell) return;

        // Highlight Primary Selection
        const primEl = document.querySelector(`.cell[data-id="${state.selectedCell}"]`);
        if (primEl) primEl.classList.add('selected');

        // Highlight Range
        if (state.selectionRange) {
            const cells = utils.getRangeCells(state.selectionRange.start, state.selectionRange.end);
            cells.forEach(cid => {
                const el = document.querySelector(`.cell[data-id="${cid}"]`);
                if (el) el.classList.add('in-range');
            });
        }
    },

    editCell: (id) => {
        const el = document.querySelector(`.cell[data-id="${id}"]`);
        if (el.querySelector('input')) return; // Already editing

        const sheet = state.workbook[state.activeSheetIndex];
        const cellData = sheet.data[id] || {};
        const rawValue = cellData.formula || cellData.value || "";

        const input = document.createElement('input');
        input.value = rawValue;
        
        // State flag to prevent recursive calls (Enter -> Blur)
        let isSaving = false;

        // Save on Blur or Enter
        const save = () => {
            if (isSaving) return; // Prevent double execution
            isSaving = true;

            const val = input.value;
            if (!sheet.data[id]) sheet.data[id] = {};
            
            // If starts with =, treat as formula
            sheet.data[id].formula = val.startsWith('=') ? val : "";
            sheet.data[id].value = val.startsWith('=') ? engine.evaluate(val, sheet.data) : val;

            // Clean up DOM
            if(el.contains(input)) el.removeChild(input);
            gridManager.updateCellVisual(id);
            
            // Trigger recalculation of dependencies
            engine.recalculateAll();
            
            // Update formula bar if still selected
            if(state.selectedCell === id) {
                document.getElementById('formula-input').value = val;
            }
        };

        input.onblur = save;
        input.onkeydown = (e) => {
            if (e.key === 'Enter') {
                save();
                gridManager.moveSelection(0, 1);
            }
        };

        el.innerText = ''; // Clear display text
        el.appendChild(input);
        input.focus();
    },

    saveFormulaBar: () => {
        if (!state.selectedCell) return;
        const val = document.getElementById('formula-input').value;
        const sheet = state.workbook[state.activeSheetIndex];
        const id = state.selectedCell;

        if (!sheet.data[id]) sheet.data[id] = {};
        sheet.data[id].formula = val.startsWith('=') ? val : "";
        sheet.data[id].value = val.startsWith('=') ? engine.evaluate(val, sheet.data) : val;
        
        gridManager.updateCellVisual(id);
        engine.recalculateAll();
    },

    handleKeydown: (e) => {
        // Don't capture if editing inside a cell
        if (e.target.tagName === 'INPUT' && e.target.id !== 'formula-input') return;

        if (e.key.startsWith('Arrow')) {
            e.preventDefault();
            const direction = { ArrowUp: [0, -1], ArrowDown: [0, 1], ArrowLeft: [-1, 0], ArrowRight: [1, 0] };
            const [dx, dy] = direction[e.key];
            gridManager.moveSelection(dx, dy);
        } else if (e.key === 'Enter') {
            e.preventDefault();
            gridManager.moveSelection(0, 1);
        } else if (e.key === 'Tab') {
            e.preventDefault();
            gridManager.moveSelection(1, 0);
        } else if (e.key === 'Delete' || e.key === 'Backspace') {
             if(state.selectionRange) {
                 gridManager.clearSelectionContent();
             }
        } else if (!e.ctrlKey && !e.altKey && !e.metaKey && e.key.length === 1) {
            // Start typing immediately
            if (state.selectedCell) {
                 gridManager.editCell(state.selectedCell);
            }
        }
    },

    moveSelection: (dx, dy) => {
        if (!state.selectedCell) return;
        const pos = utils.parseId(state.selectedCell);
        let newCol = pos.col + dx;
        let newRow = pos.row + dy;

        // Clamp
        if (newCol < 0) newCol = 0;
        if (newRow < 0) newRow = 0;
        if (newCol >= COLS) newCol = COLS - 1;
        if (newRow >= ROWS) newRow = ROWS - 1;

        const newId = utils.toId(newCol, newRow);
        gridManager.selectCell(newId);
        state.selectionRange = { start: newId, end: newId };
        gridManager.renderSelection();
        
        // Scroll into view logic could go here
    },

    initResize: (e, colIndex) => {
        e.stopPropagation();
        const startX = e.pageX;
        const sheet = state.workbook[state.activeSheetIndex];
        const startWidth = (sheet.colWidths && sheet.colWidths[colIndex]) ? sheet.colWidths[colIndex] : 100;

        const mouseMove = (moveEvent) => {
            const diff = moveEvent.pageX - startX;
            const newWidth = Math.max(20, startWidth + diff);
            if (!sheet.colWidths) sheet.colWidths = {};
            sheet.colWidths[colIndex] = newWidth;
            gridManager.render(); // Re-render grid columns
        };

        const mouseUp = () => {
            document.removeEventListener('mousemove', mouseMove);
            document.removeEventListener('mouseup', mouseUp);
        };

        document.addEventListener('mousemove', mouseMove);
        document.addEventListener('mouseup', mouseUp);
    },

    clearSelection: () => {
        state.selectedCell = null;
        state.selectionRange = null;
        gridManager.renderSelection();
        document.getElementById('selected-cell-display').innerText = '';
        document.getElementById('formula-input').value = '';
    },
    
    clearSelectionContent: () => {
        if(!state.selectionRange) return;
        const cells = utils.getRangeCells(state.selectionRange.start, state.selectionRange.end);
        const sheet = state.workbook[state.activeSheetIndex];
        cells.forEach(id => {
            if(sheet.data[id]) {
                delete sheet.data[id];
                gridManager.updateCellVisual(id);
            }
        });
        engine.recalculateAll();
    }
};

/**
 * SHEET MANAGER
 */
const sheetManager = {
    addSheet: (name) => {
        const newName = name || `Sheet${state.workbook.length + 1}`;
        state.workbook.push({
            name: newName,
            data: {}, // Map ID -> { value, formula, style }
            colWidths: {}
        });
        state.activeSheetIndex = state.workbook.length - 1;
        sheetManager.renderTabs();
        gridManager.render();
    },

    switchSheet: (index) => {
        state.activeSheetIndex = index;
        state.selectedCell = null;
        state.selectionRange = null;
        document.getElementById('formula-input').value = "";
        document.getElementById('selected-cell-display').innerText = "";
        sheetManager.renderTabs();
        gridManager.render();
    },

    deleteSheet: (e, index) => {
        e.stopPropagation();
        if (state.workbook.length <= 1) return alert("Must have at least one sheet.");
        if (!confirm("Delete this sheet?")) return;
        
        state.workbook.splice(index, 1);
        if (state.activeSheetIndex >= state.workbook.length) {
            state.activeSheetIndex = state.workbook.length - 1;
        }
        sheetManager.renderTabs();
        gridManager.render();
    },
    
    renameSheet: (e, index) => {
        e.stopPropagation();
        const currentName = state.workbook[index].name;
        const newName = prompt("Rename sheet:", currentName);
        if(newName && newName.trim() !== "") {
            state.workbook[index].name = newName;
            sheetManager.renderTabs();
        }
    },

    renderTabs: () => {
        const container = document.getElementById('sheet-bar');
        // Keep the Add button, remove existing tabs
        const tabs = container.querySelectorAll('.sheet-tab');
        tabs.forEach(t => t.remove());

        state.workbook.forEach((sheet, idx) => {
            const tab = document.createElement('div');
            tab.className = `sheet-tab ${idx === state.activeSheetIndex ? 'active' : ''}`;
            tab.innerText = sheet.name;
            tab.onclick = () => sheetManager.switchSheet(idx);
            tab.ondblclick = (e) => sheetManager.renameSheet(e, idx);
            
            // Simple context menu simulation (Shift+Click to delete) or just logic
            tab.title = "Double click to rename, Right click to delete";
            tab.oncontextmenu = (e) => {
                e.preventDefault();
                sheetManager.deleteSheet(e, idx);
            };

            container.insertBefore(tab, container.lastElementChild);
        });
    }
};

/**
 * FORMATTING & FILE I/O
 */
function formatCell(type, val) {
    if (!state.selectionRange) return;
    const cells = utils.getRangeCells(state.selectionRange.start, state.selectionRange.end);
    const sheet = state.workbook[state.activeSheetIndex];

    cells.forEach(id => {
        if (!sheet.data[id]) sheet.data[id] = { value: "" };
        if (!sheet.data[id].style) sheet.data[id].style = {};
        
        const style = sheet.data[id].style;
        if (type === 'bold') style.bold = !style.bold;
        if (type === 'italic') style.italic = !style.italic;
        if (type === 'bgColor') style.bgColor = val;
        
        // Re-render style
        const el = document.querySelector(`.cell[data-id="${id}"]`);
        if(el) {
            if (style.bold) el.style.fontWeight = 'bold'; else el.style.fontWeight = 'normal';
            if (style.italic) el.style.fontStyle = 'italic'; else el.style.fontStyle = 'normal';
            if (style.bgColor) el.style.backgroundColor = style.bgColor;
        }
    });
}

const fileActions = {
    downloadCSV: () => {
        const sheet = state.workbook[state.activeSheetIndex];
        let csvContent = "data:text/csv;charset=utf-8,";
        
        for (let r = 0; r < ROWS; r++) {
            const rowData = [];
            for (let c = 0; c < COLS; c++) {
                const id = utils.toId(c, r);
                let val = sheet.data[id] ? sheet.data[id].value : "";
                // Escape quotes
                if (typeof val === 'string') {
                    val = val.replace(/"/g, '""');
                    if (val.includes(',') || val.includes('"')) val = `"${val}"`;
                }
                rowData.push(val);
            }
            csvContent += rowData.join(",") + "\r\n";
        }

        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", `${sheet.name}.csv`);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    },

    uploadCSV: (input) => {
        const file = input.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            const text = e.target.result;
            const rows = text.split("\n");
            
            sheetManager.addSheet(file.name.replace('.csv', ''));
            const sheet = state.workbook[state.activeSheetIndex];

            rows.forEach((row, rIndex) => {
                if(rIndex >= ROWS) return;
                // Simple CSV split (doesn't handle complex quoted commas perfectly)
                const cols = row.split(","); 
                cols.forEach((val, cIndex) => {
                    if(cIndex >= COLS) return;
                    // Clean quotes
                    let cleanVal = val.trim();
                    if (cleanVal.startsWith('"') && cleanVal.endsWith('"')) {
                        cleanVal = cleanVal.substring(1, cleanVal.length - 1);
                    }
                    
                    const id = utils.toId(cIndex, rIndex);
                    sheet.data[id] = { value: cleanVal };
                });
            });
            
            gridManager.render();
            input.value = ''; // Reset
        };
        reader.readAsText(file);
    }
};

// Initialize Application
gridManager.init();

</script>
</body>
</html>