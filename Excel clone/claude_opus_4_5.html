<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSheet - Excel Clone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #f3f3f3;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #217346;
            border-bottom: 1px solid #1a5c38;
            flex-wrap: wrap;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 0 8px;
            border-right: 1px solid rgba(255,255,255,0.2);
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar button {
            padding: 6px 12px;
            border: none;
            background: rgba(255,255,255,0.1);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .toolbar button:hover {
            background: rgba(255,255,255,0.25);
        }

        .toolbar button.active {
            background: rgba(255,255,255,0.35);
        }

        .toolbar input[type="color"] {
            width: 32px;
            height: 28px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
        }

        .toolbar input[type="file"] {
            display: none;
        }

        .app-title {
            color: white;
            font-weight: 600;
            font-size: 16px;
            margin-right: 20px;
        }

        /* Formula Bar */
        .formula-bar {
            display: flex;
            align-items: center;
            padding: 4px 8px;
            background: #fff;
            border-bottom: 1px solid #d4d4d4;
            gap: 8px;
        }

        .cell-address {
            min-width: 80px;
            padding: 6px 10px;
            background: #f8f8f8;
            border: 1px solid #d4d4d4;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 13px;
            text-align: center;
        }

        .fx-label {
            color: #666;
            font-style: italic;
            padding: 0 8px;
        }

        .formula-input {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #d4d4d4;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 13px;
            outline: none;
        }

        .formula-input:focus {
            border-color: #217346;
            box-shadow: 0 0 0 2px rgba(33, 115, 70, 0.2);
        }

        /* Spreadsheet Container */
        .spreadsheet-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: #fff;
        }

        .grid-wrapper {
            flex: 1;
            overflow: auto;
            position: relative;
        }

        .spreadsheet {
            border-collapse: collapse;
            table-layout: fixed;
        }

        .spreadsheet th, .spreadsheet td {
            border: 1px solid #d4d4d4;
            padding: 0;
            position: relative;
        }

        /* Corner cell */
        .spreadsheet .corner {
            background: #f0f0f0;
            width: 50px;
            min-width: 50px;
            position: sticky;
            left: 0;
            top: 0;
            z-index: 30;
        }

        /* Column headers */
        .spreadsheet .col-header {
            background: linear-gradient(to bottom, #f8f8f8, #e8e8e8);
            height: 24px;
            min-height: 24px;
            text-align: center;
            font-weight: 500;
            font-size: 12px;
            color: #333;
            position: sticky;
            top: 0;
            z-index: 20;
            user-select: none;
        }

        .spreadsheet .col-header:hover {
            background: linear-gradient(to bottom, #e8e8e8, #d8d8d8);
        }

        .col-header .resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            width: 5px;
            height: 100%;
            cursor: col-resize;
            background: transparent;
        }

        .col-header .resize-handle:hover,
        .col-header .resize-handle.resizing {
            background: #217346;
        }

        /* Row headers */
        .spreadsheet .row-header {
            background: linear-gradient(to right, #f8f8f8, #e8e8e8);
            width: 50px;
            min-width: 50px;
            text-align: center;
            font-weight: 500;
            font-size: 12px;
            color: #333;
            position: sticky;
            left: 0;
            z-index: 10;
            user-select: none;
        }

        .spreadsheet .row-header:hover {
            background: linear-gradient(to right, #e8e8e8, #d8d8d8);
        }

        /* Cells */
        .spreadsheet .cell {
            width: 100px;
            min-width: 60px;
            height: 24px;
            padding: 2px 4px;
            font-size: 13px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: cell;
            user-select: none;
        }

        .spreadsheet .cell.selected {
            outline: 2px solid #217346;
            outline-offset: -1px;
            z-index: 5;
        }

        .spreadsheet .cell.in-range {
            background: rgba(33, 115, 70, 0.1) !important;
        }

        .spreadsheet .cell.editing {
            padding: 0;
        }

        .spreadsheet .cell.editing input {
            width: 100%;
            height: 100%;
            border: none;
            padding: 2px 4px;
            font-size: 13px;
            font-family: inherit;
            outline: none;
            background: #fff;
        }

        .spreadsheet .cell.bold {
            font-weight: bold;
        }

        .spreadsheet .cell.italic {
            font-style: italic;
        }

        .spreadsheet .cell.error {
            color: #cc0000;
        }

        /* Selection highlight for formula building */
        .spreadsheet .cell.formula-ref {
            outline: 2px dashed #ff6b00;
            outline-offset: -1px;
        }

        /* Sheet Tabs */
        .sheet-tabs {
            display: flex;
            align-items: center;
            padding: 4px 8px;
            background: #e8e8e8;
            border-top: 1px solid #d4d4d4;
            gap: 4px;
            min-height: 36px;
        }

        .sheet-tab {
            padding: 6px 16px;
            background: #f0f0f0;
            border: 1px solid #d4d4d4;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
            position: relative;
        }

        .sheet-tab:hover {
            background: #fff;
        }

        .sheet-tab.active {
            background: #fff;
            border-bottom: 1px solid #fff;
            margin-bottom: -1px;
            font-weight: 500;
        }

        .sheet-tab .close-btn {
            font-size: 14px;
            color: #888;
            cursor: pointer;
            padding: 0 2px;
        }

        .sheet-tab .close-btn:hover {
            color: #cc0000;
        }

        .add-sheet-btn {
            padding: 4px 12px;
            background: transparent;
            border: 1px dashed #aaa;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            color: #666;
        }

        .add-sheet-btn:hover {
            background: #fff;
            border-color: #217346;
            color: #217346;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #d4d4d4;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 150px;
            display: none;
        }

        .context-menu.visible {
            display: block;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
        }

        .context-menu-item:hover {
            background: #f0f0f0;
        }

        /* Modal for renaming */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.4);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal {
            background: white;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            min-width: 300px;
        }

        .modal h3 {
            margin-bottom: 16px;
            color: #333;
        }

        .modal input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d4d4d4;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 16px;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .modal-buttons button {
            padding: 8px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .modal-buttons .cancel-btn {
            background: #e0e0e0;
        }

        .modal-buttons .ok-btn {
            background: #217346;
            color: white;
        }

        /* Status Bar */
        .status-bar {
            padding: 4px 12px;
            background: #217346;
            color: white;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }
    </style>
</head>
<body>
    <!-- Toolbar -->
    <div class="toolbar">
        <span class="app-title">üìä WebSheet</span>
        <div class="toolbar-group">
            <button id="boldBtn" title="Bold (Ctrl+B)"><b>B</b></button>
            <button id="italicBtn" title="Italic (Ctrl+I)"><i>I</i></button>
            <input type="color" id="bgColorPicker" value="#ffffff" title="Background Color">
        </div>
        <div class="toolbar-group">
            <button id="clearBtn" title="Clear Contents">üóëÔ∏è Clear</button>
        </div>
        <div class="toolbar-group">
            <button id="downloadBtn" title="Download as CSV">‚¨áÔ∏è CSV</button>
            <button id="uploadBtn" title="Upload CSV">‚¨ÜÔ∏è Upload</button>
            <input type="file" id="fileInput" accept=".csv">
        </div>
        <div class="toolbar-group">
            <button id="undoBtn" title="Undo (Ctrl+Z)">‚Ü©Ô∏è</button>
            <button id="redoBtn" title="Redo (Ctrl+Y)">‚Ü™Ô∏è</button>
        </div>
    </div>

    <!-- Formula Bar -->
    <div class="formula-bar">
        <div class="cell-address" id="cellAddress">A1</div>
        <span class="fx-label">fx</span>
        <input type="text" class="formula-input" id="formulaInput" placeholder="Enter value or formula (e.g., =SUM(A1:A10))">
    </div>

    <!-- Spreadsheet -->
    <div class="spreadsheet-container">
        <div class="grid-wrapper" id="gridWrapper">
            <table class="spreadsheet" id="spreadsheet"></table>
        </div>
    </div>

    <!-- Sheet Tabs -->
    <div class="sheet-tabs" id="sheetTabs">
        <button class="add-sheet-btn" id="addSheetBtn" title="Add Sheet">+</button>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <span id="statusLeft">Ready</span>
        <span id="statusRight"></span>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" data-action="rename">Rename Sheet</div>
        <div class="context-menu-item" data-action="delete">Delete Sheet</div>
    </div>

    <!-- Rename Modal -->
    <div class="modal-overlay" id="renameModal">
        <div class="modal">
            <h3>Rename Sheet</h3>
            <input type="text" id="renameInput" placeholder="Sheet name">
            <div class="modal-buttons">
                <button class="cancel-btn" id="renameCancelBtn">Cancel</button>
                <button class="ok-btn" id="renameOkBtn">OK</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== CONFIGURATION ====================
        const NUM_ROWS = 100;
        const NUM_COLS = 26;
        const DEFAULT_COL_WIDTH = 100;

        // ==================== STATE MANAGEMENT ====================
        class SpreadsheetApp {
            constructor() {
                this.sheets = [];
                this.activeSheetIndex = 0;
                this.selection = { start: null, end: null };
                this.editingCell = null;
                this.isFormulaMode = false;
                this.formulaCursorPos = 0;
                this.columnWidths = {};
                this.undoStack = [];
                this.redoStack = [];
                this.isResizing = false;
                this.resizeCol = null;
                this.resizeStartX = 0;
                this.resizeStartWidth = 0;
                this.isDragging = false;
                this.dragStart = null;

                this.initializeSheet("Sheet1");
                this.initDOM();
                this.bindEvents();
                this.render();
            }

            initializeSheet(name) {
                const sheet = {
                    name: name,
                    cells: {},
                    columnWidths: {}
                };
                this.sheets.push(sheet);
                return this.sheets.length - 1;
            }

            get currentSheet() {
                return this.sheets[this.activeSheetIndex];
            }

            initDOM() {
                this.spreadsheet = document.getElementById('spreadsheet');
                this.gridWrapper = document.getElementById('gridWrapper');
                this.formulaInput = document.getElementById('formulaInput');
                this.cellAddress = document.getElementById('cellAddress');
                this.sheetTabs = document.getElementById('sheetTabs');
                this.contextMenu = document.getElementById('contextMenu');
                this.renameModal = document.getElementById('renameModal');
                this.renameInput = document.getElementById('renameInput');
                this.statusLeft = document.getElementById('statusLeft');
                this.statusRight = document.getElementById('statusRight');
            }

            // ==================== CELL UTILITIES ====================
            colToLetter(col) {
                let result = '';
                while (col >= 0) {
                    result = String.fromCharCode((col % 26) + 65) + result;
                    col = Math.floor(col / 26) - 1;
                }
                return result;
            }

            letterToCol(letters) {
                let col = 0;
                for (let i = 0; i < letters.length; i++) {
                    col = col * 26 + (letters.charCodeAt(i) - 64);
                }
                return col - 1;
            }

            cellId(row, col) {
                return `${this.colToLetter(col)}${row + 1}`;
            }

            parseCell(cellRef) {
                const match = cellRef.match(/^([A-Z]+)(\d+)$/i);
                if (!match) return null;
                return {
                    col: this.letterToCol(match[1].toUpperCase()),
                    row: parseInt(match[2]) - 1
                };
            }

            getCellData(cellId) {
                return this.currentSheet.cells[cellId] || { value: '', formula: '', display: '', format: {} };
            }

            setCellData(cellId, data) {
                if (!this.currentSheet.cells[cellId]) {
                    this.currentSheet.cells[cellId] = { value: '', formula: '', display: '', format: {} };
                }
                Object.assign(this.currentSheet.cells[cellId], data);
            }

            // ==================== FORMULA PARSING ====================
            evaluateFormula(formula, originCell) {
                if (!formula.startsWith('=')) return formula;
                
                let expr = formula.substring(1);
                
                try {
                    // Handle functions
                    expr = this.replaceFunctions(expr, originCell);
                    
                    // Handle cell references
                    expr = this.replaceCellRefs(expr, originCell);
                    
                    // Evaluate
                    const result = this.safeEval(expr);
                    return isNaN(result) ? result : (Number.isInteger(result) ? result : parseFloat(result.toFixed(10)));
                } catch (e) {
                    return '#ERROR!';
                }
            }

            replaceFunctions(expr, originCell) {
                const functions = {
                    'SUM': (range) => range.reduce((a, b) => a + (parseFloat(b) || 0), 0),
                    'AVERAGE': (range) => {
                        const nums = range.filter(x => !isNaN(parseFloat(x)) && x !== '');
                        return nums.length ? nums.reduce((a, b) => a + parseFloat(b), 0) / nums.length : 0;
                    },
                    'MIN': (range) => {
                        const nums = range.filter(x => !isNaN(parseFloat(x)) && x !== '').map(Number);
                        return nums.length ? Math.min(...nums) : 0;
                    },
                    'MAX': (range) => {
                        const nums = range.filter(x => !isNaN(parseFloat(x)) && x !== '').map(Number);
                        return nums.length ? Math.max(...nums) : 0;
                    },
                    'COUNT': (range) => range.filter(x => !isNaN(parseFloat(x)) && x !== '').length,
                    'IF': null // Special handling
                };

                for (const [fnName, fn] of Object.entries(functions)) {
                    const regex = new RegExp(`${fnName}\\(([^)]+)\\)`, 'gi');
                    expr = expr.replace(regex, (match, args) => {
                        if (fnName === 'IF') {
                            const parts = this.splitArgs(args);
                            if (parts.length >= 2) {
                                const condition = this.evaluateFormula('=' + parts[0], originCell);
                                if (condition && condition !== 0 && condition !== false && condition !== 'false') {
                                    return this.evaluateFormula('=' + parts[1], originCell);
                                } else {
                                    return parts[2] ? this.evaluateFormula('=' + parts[2], originCell) : '';
                                }
                            }
                            return '#ERROR!';
                        }
                        
                        const rangeValues = this.getRangeValues(args, originCell);
                        return fn(rangeValues);
                    });
                }
                
                return expr;
            }

            splitArgs(args) {
                const result = [];
                let depth = 0;
                let current = '';
                for (const char of args) {
                    if (char === '(') depth++;
                    else if (char === ')') depth--;
                    
                    if (char === ',' && depth === 0) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                if (current) result.push(current.trim());
                return result;
            }

            getRangeValues(rangeStr, originCell) {
                const values = [];
                
                // Handle range (A1:B5)
                if (rangeStr.includes(':')) {
                    const [start, end] = rangeStr.split(':').map(s => s.trim());
                    const startCell = this.parseCell(start);
                    const endCell = this.parseCell(end);
                    
                    if (startCell && endCell) {
                        const minRow = Math.min(startCell.row, endCell.row);
                        const maxRow = Math.max(startCell.row, endCell.row);
                        const minCol = Math.min(startCell.col, endCell.col);
                        const maxCol = Math.max(startCell.col, endCell.col);
                        
                        for (let r = minRow; r <= maxRow; r++) {
                            for (let c = minCol; c <= maxCol; c++) {
                                const cellId = this.cellId(r, c);
                                if (cellId !== originCell) {
                                    const data = this.getCellData(cellId);
                                    values.push(data.display || data.value || '');
                                }
                            }
                        }
                    }
                } else {
                    // Single cell or comma-separated cells
                    const cells = rangeStr.split(',').map(s => s.trim());
                    for (const cellRef of cells) {
                        const parsed = this.parseCell(cellRef);
                        if (parsed) {
                            const cellId = this.cellId(parsed.row, parsed.col);
                            if (cellId !== originCell) {
                                const data = this.getCellData(cellId);
                                values.push(data.display || data.value || '');
                            }
                        }
                    }
                }
                
                return values;
            }

            replaceCellRefs(expr, originCell) {
                return expr.replace(/([A-Z]+\d+)/gi, (match) => {
                    const parsed = this.parseCell(match);
                    if (parsed) {
                        const cellId = this.cellId(parsed.row, parsed.col);
                        if (cellId === originCell) return 0; // Avoid circular reference
                        const data = this.getCellData(cellId);
                        const val = data.display || data.value || 0;
                        return isNaN(val) ? `"${val}"` : val;
                    }
                    return match;
                });
            }

            safeEval(expr) {
                // Replace comparison operators
                expr = expr.replace(/=/g, '==').replace(/<==/g, '<=').replace(/>==/, '>=').replace(/<>/g, '!=');
                
                // Only allow safe characters
                if (/^[\d\s+\-*/().,"'<>=!&|]+$/.test(expr) || /^[\d\s+\-*/().,"'<>=!&|A-Za-z]+$/.test(expr)) {
                    try {
                        return Function('"use strict"; return (' + expr + ')')();
                    } catch (e) {
                        return '#ERROR!';
                    }
                }
                return '#ERROR!';
            }

            // ==================== DEPENDENCY MANAGEMENT ====================
            getCellDependencies(formula) {
                if (!formula.startsWith('=')) return [];
                const refs = [];
                const regex = /([A-Z]+\d+)(?::([A-Z]+\d+))?/gi;
                let match;
                
                while ((match = regex.exec(formula)) !== null) {
                    if (match[2]) {
                        // Range
                        const start = this.parseCell(match[1]);
                        const end = this.parseCell(match[2]);
                        if (start && end) {
                            const minRow = Math.min(start.row, end.row);
                            const maxRow = Math.max(start.row, end.row);
                            const minCol = Math.min(start.col, end.col);
                            const maxCol = Math.max(start.col, end.col);
                            for (let r = minRow; r <= maxRow; r++) {
                                for (let c = minCol; c <= maxCol; c++) {
                                    refs.push(this.cellId(r, c));
                                }
                            }
                        }
                    } else {
                        refs.push(match[1].toUpperCase());
                    }
                }
                
                return [...new Set(refs)];
            }

            recalculate() {
                // Simple recalculation - evaluate all formulas
                const cells = this.currentSheet.cells;
                const order = this.getCalculationOrder();
                
                for (const cellId of order) {
                    const data = cells[cellId];
                    if (data && data.formula && data.formula.startsWith('=')) {
                        data.display = this.evaluateFormula(data.formula, cellId);
                    } else if (data) {
                        data.display = data.value;
                    }
                }
                
                this.renderCells();
            }

            getCalculationOrder() {
                const cells = Object.keys(this.currentSheet.cells);
                const visited = new Set();
                const order = [];
                
                const visit = (cellId) => {
                    if (visited.has(cellId)) return;
                    visited.add(cellId);
                    
                    const data = this.currentSheet.cells[cellId];
                    if (data && data.formula) {
                        const deps = this.getCellDependencies(data.formula);
                        for (const dep of deps) {
                            visit(dep);
                        }
                    }
                    order.push(cellId);
                };
                
                for (const cellId of cells) {
                    visit(cellId);
                }
                
                return order;
            }

            // ==================== RENDERING ====================
            render() {
                this.renderGrid();
                this.renderSheetTabs();
                this.updateFormulaBar();
            }

            renderGrid() {
                const table = this.spreadsheet;
                table.innerHTML = '';
                
                // Header row
                const headerRow = document.createElement('tr');
                const corner = document.createElement('th');
                corner.className = 'corner';
                headerRow.appendChild(corner);
                
                for (let c = 0; c < NUM_COLS; c++) {
                    const th = document.createElement('th');
                    th.className = 'col-header';
                    th.textContent = this.colToLetter(c);
                    th.dataset.col = c;
                    th.style.width = (this.currentSheet.columnWidths[c] || DEFAULT_COL_WIDTH) + 'px';
                    
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    resizeHandle.dataset.col = c;
                    th.appendChild(resizeHandle);
                    
                    headerRow.appendChild(th);
                }
                table.appendChild(headerRow);
                
                // Data rows
                for (let r = 0; r < NUM_ROWS; r++) {
                    const row = document.createElement('tr');
                    
                    const rowHeader = document.createElement('th');
                    rowHeader.className = 'row-header';
                    rowHeader.textContent = r + 1;
                    row.appendChild(rowHeader);
                    
                    for (let c = 0; c < NUM_COLS; c++) {
                        const td = document.createElement('td');
                        td.className = 'cell';
                        td.dataset.row = r;
                        td.dataset.col = c;
                        td.style.width = (this.currentSheet.columnWidths[c] || DEFAULT_COL_WIDTH) + 'px';
                        
                        const cellId = this.cellId(r, c);
                        const data = this.getCellData(cellId);
                        td.textContent = data.display !== undefined ? data.display : data.value;
                        
                        // Apply formatting
                        if (data.format) {
                            if (data.format.bold) td.classList.add('bold');
                            if (data.format.italic) td.classList.add('italic');
                            if (data.format.bgColor) td.style.backgroundColor = data.format.bgColor;
                        }
                        
                        if (String(data.display).startsWith('#')) {
                            td.classList.add('error');
                        }
                        
                        row.appendChild(td);
                    }
                    
                    table.appendChild(row);
                }
                
                this.updateSelection();
            }

            renderCells() {
                const cells = this.spreadsheet.querySelectorAll('.cell');
                cells.forEach(td => {
                    const row = parseInt(td.dataset.row);
                    const col = parseInt(td.dataset.col);
                    const cellId = this.cellId(row, col);
                    const data = this.getCellData(cellId);
                    
                    if (!td.classList.contains('editing')) {
                        td.textContent = data.display !== undefined ? data.display : data.value;
                    }
                    
                    td.classList.toggle('bold', !!data.format?.bold);
                    td.classList.toggle('italic', !!data.format?.italic);
                    td.classList.toggle('error', String(data.display).startsWith('#'));
                    td.style.backgroundColor = data.format?.bgColor || '';
                });
            }

            renderSheetTabs() {
                const container = this.sheetTabs;
                container.querySelectorAll('.sheet-tab').forEach(el => el.remove());
                
                const addBtn = document.getElementById('addSheetBtn');
                
                this.sheets.forEach((sheet, index) => {
                    const tab = document.createElement('div');
                    tab.className = 'sheet-tab' + (index === this.activeSheetIndex ? ' active' : '');
                    tab.dataset.index = index;
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = sheet.name;
                    tab.appendChild(nameSpan);
                    
                    if (this.sheets.length > 1) {
                        const closeBtn = document.createElement('span');
                        closeBtn.className = 'close-btn';
                        closeBtn.textContent = '√ó';
                        closeBtn.dataset.index = index;
                        tab.appendChild(closeBtn);
                    }
                    
                    container.insertBefore(tab, addBtn);
                });
            }

            updateSelection() {
                // Clear previous selection
                this.spreadsheet.querySelectorAll('.cell.selected, .cell.in-range').forEach(el => {
                    el.classList.remove('selected', 'in-range');
                });
                
                if (!this.selection.start) return;
                
                const start = this.selection.start;
                const end = this.selection.end || start;
                
                const minRow = Math.min(start.row, end.row);
                const maxRow = Math.max(start.row, end.row);
                const minCol = Math.min(start.col, end.col);
                const maxCol = Math.max(start.col, end.col);
                
                for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minCol; c <= maxCol; c++) {
                        const cell = this.spreadsheet.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
                        if (cell) {
                            if (r === start.row && c === start.col) {
                                cell.classList.add('selected');
                            } else {
                                cell.classList.add('in-range');
                            }
                        }
                    }
                }
                
                this.updateFormulaBar();
                this.updateStatusBar();
            }

            updateFormulaBar() {
                if (this.selection.start) {
                    const cellId = this.cellId(this.selection.start.row, this.selection.start.col);
                    this.cellAddress.textContent = cellId;
                    const data = this.getCellData(cellId);
                    if (!this.isFormulaMode) {
                        this.formulaInput.value = data.formula || data.value || '';
                    }
                }
            }

            updateStatusBar() {
                if (this.selection.start && this.selection.end) {
                    const start = this.selection.start;
                    const end = this.selection.end;
                    const minRow = Math.min(start.row, end.row);
                    const maxRow = Math.max(start.row, end.row);
                    const minCol = Math.min(start.col, end.col);
                    const maxCol = Math.max(start.col, end.col);
                    
                    let sum = 0, count = 0;
                    for (let r = minRow; r <= maxRow; r++) {
                        for (let c = minCol; c <= maxCol; c++) {
                            const cellId = this.cellId(r, c);
                            const data = this.getCellData(cellId);
                            const val = parseFloat(data.display);
                            if (!isNaN(val)) {
                                sum += val;
                                count++;
                            }
                        }
                    }
                    
                    if (count > 1) {
                        this.statusRight.textContent = `Sum: ${sum.toFixed(2)} | Avg: ${(sum/count).toFixed(2)} | Count: ${count}`;
                    } else {
                        this.statusRight.textContent = '';
                    }
                } else {
                    this.statusRight.textContent = '';
                }
            }

            // ==================== CELL EDITING ====================
            startEditing(row, col, initialValue = null) {
                this.stopEditing();
                
                const cell = this.spreadsheet.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                if (!cell) return;
                
                this.editingCell = { row, col };
                cell.classList.add('editing');
                
                const cellId = this.cellId(row, col);
                const data = this.getCellData(cellId);
                
                const input = document.createElement('input');
                input.type = 'text';
                input.value = initialValue !== null ? initialValue : (data.formula || data.value || '');
                cell.textContent = '';
                cell.appendChild(input);
                input.focus();
                
                if (initialValue !== null) {
                    input.setSelectionRange(input.value.length, input.value.length);
                } else {
                    input.select();
                }
                
                // Sync with formula bar
                this.formulaInput.value = input.value;
                
                input.addEventListener('input', (e) => {
                    this.formulaInput.value = e.target.value;
                    this.isFormulaMode = e.target.value.startsWith('=');
                });
                
                input.addEventListener('keydown', (e) => this.handleEditKeydown(e));
            }

            stopEditing(save = true) {
                if (!this.editingCell) return;
                
                const { row, col } = this.editingCell;
                const cell = this.spreadsheet.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                const input = cell?.querySelector('input');
                
                if (cell && input) {
                    if (save) {
                        this.saveUndo();
                        const value = input.value;
                        const cellId = this.cellId(row, col);
                        
                        if (value.startsWith('=')) {
                            this.setCellData(cellId, { formula: value, value: value });
                        } else {
                            this.setCellData(cellId, { formula: '', value: value });
                        }
                        
                        this.recalculate();
                    }
                    
                    cell.classList.remove('editing');
                    const data = this.getCellData(this.cellId(row, col));
                    cell.textContent = data.display !== undefined ? data.display : data.value;
                }
                
                this.editingCell = null;
                this.isFormulaMode = false;
            }

            handleEditKeydown(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    this.stopEditing();
                    this.moveSelection(1, 0);
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    this.stopEditing();
                    this.moveSelection(0, e.shiftKey ? -1 : 1);
                } else if (e.key === 'Escape') {
                    this.stopEditing(false);
                }
            }

            // ==================== SELECTION ====================
            selectCell(row, col, extend = false) {
                if (extend && this.selection.start) {
                    this.selection.end = { row, col };
                } else {
                    this.selection.start = { row, col };
                    this.selection.end = null;
                }
                this.updateSelection();
            }

            moveSelection(dRow, dCol, extend = false) {
                if (!this.selection.start) {
                    this.selectCell(0, 0);
                    return;
                }
                
                const target = extend && this.selection.end ? this.selection.end : this.selection.start;
                const newRow = Math.max(0, Math.min(NUM_ROWS - 1, target.row + dRow));
                const newCol = Math.max(0, Math.min(NUM_COLS - 1, target.col + dCol));
                
                if (extend) {
                    this.selection.end = { row: newRow, col: newCol };
                } else {
                    this.selection.start = { row: newRow, col: newCol };
                    this.selection.end = null;
                }
                
                this.updateSelection();
                this.scrollCellIntoView(newRow, newCol);
            }

            scrollCellIntoView(row, col) {
                const cell = this.spreadsheet.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                if (cell) {
                    cell.scrollIntoView({ block: 'nearest', inline: 'nearest' });
                }
            }

            // ==================== FORMULA BAR CELL SELECTION ====================
            insertCellReference(row, col, isRange = false) {
                if (!this.isFormulaMode) return;
                
                const cellRef = this.cellId(row, col);
                const input = this.formulaInput;
                const cursorPos = input.selectionStart;
                const text = input.value;
                
                // Check if we're extending a range
                if (isRange && this.dragStart) {
                    const startRef = this.cellId(this.dragStart.row, this.dragStart.col);
                    const endRef = cellRef;
                    
                    // Find and replace the last inserted reference with range
                    const beforeCursor = text.substring(0, this.formulaCursorPos);
                    const afterCursor = text.substring(cursorPos);
                    input.value = beforeCursor + startRef + ':' + endRef + afterCursor;
                } else {
                    const beforeCursor = text.substring(0, cursorPos);
                    const afterCursor = text.substring(cursorPos);
                    input.value = beforeCursor + cellRef + afterCursor;
                    this.formulaCursorPos = cursorPos;
                }
                
                input.focus();
                
                // Also update cell input if editing
                if (this.editingCell) {
                    const cellInput = this.spreadsheet.querySelector('.cell.editing input');
                    if (cellInput) {
                        cellInput.value = input.value;
                    }
                }
            }

            // ==================== FORMATTING ====================
            applyFormat(format) {
                if (!this.selection.start) return;
                
                this.saveUndo();
                
                const start = this.selection.start;
                const end = this.selection.end || start;
                const minRow = Math.min(start.row, end.row);
                const maxRow = Math.max(start.row, end.row);
                const minCol = Math.min(start.col, end.col);
                const maxCol = Math.max(start.col, end.col);
                
                for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minCol; c <= maxCol; c++) {
                        const cellId = this.cellId(r, c);
                        const data = this.getCellData(cellId);
                        if (!data.format) data.format = {};
                        Object.assign(data.format, format);
                        this.setCellData(cellId, data);
                    }
                }
                
                this.renderCells();
            }

            toggleBold() {
                const cellId = this.cellId(this.selection.start.row, this.selection.start.col);
                const data = this.getCellData(cellId);
                this.applyFormat({ bold: !data.format?.bold });
            }

            toggleItalic() {
                const cellId = this.cellId(this.selection.start.row, this.selection.start.col);
                const data = this.getCellData(cellId);
                this.applyFormat({ italic: !data.format?.italic });
            }

            setBackgroundColor(color) {
                this.applyFormat({ bgColor: color });
            }

            clearContents() {
                if (!this.selection.start) return;
                
                this.saveUndo();
                
                const start = this.selection.start;
                const end = this.selection.end || start;
                const minRow = Math.min(start.row, end.row);
                const maxRow = Math.max(start.row, end.row);
                const minCol = Math.min(start.col, end.col);
                const maxCol = Math.max(start.col, end.col);
                
                for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minCol; c <= maxCol; c++) {
                        const cellId = this.cellId(r, c);
                        delete this.currentSheet.cells[cellId];
                    }
                }
                
                this.recalculate();
            }

            // ==================== UNDO/REDO ====================
            saveUndo() {
                const state = JSON.stringify(this.currentSheet.cells);
                this.undoStack.push({ sheetIndex: this.activeSheetIndex, state });
                if (this.undoStack.length > 50) this.undoStack.shift();
                this.redoStack = [];
            }

            undo() {
                if (this.undoStack.length === 0) return;
                
                const current = JSON.stringify(this.currentSheet.cells);
                const prev = this.undoStack.pop();
                
                this.redoStack.push({ sheetIndex: this.activeSheetIndex, state: current });
                this.sheets[prev.sheetIndex].cells = JSON.parse(prev.state);
                
                if (prev.sheetIndex !== this.activeSheetIndex) {
                    this.activeSheetIndex = prev.sheetIndex;
                    this.render();
                } else {
                    this.recalculate();
                }
            }

            redo() {
                if (this.redoStack.length === 0) return;
                
                const current = JSON.stringify(this.currentSheet.cells);
                const next = this.redoStack.pop();
                
                this.undoStack.push({ sheetIndex: this.activeSheetIndex, state: current });
                this.sheets[next.sheetIndex].cells = JSON.parse(next.state);
                
                if (next.sheetIndex !== this.activeSheetIndex) {
                    this.activeSheetIndex = next.sheetIndex;
                    this.render();
                } else {
                    this.recalculate();
                }
            }

            // ==================== SHEET MANAGEMENT ====================
            addSheet() {
                const name = `Sheet${this.sheets.length + 1}`;
                const index = this.initializeSheet(name);
                this.activeSheetIndex = index;
                this.selection = { start: null, end: null };
                this.render();
            }

            switchSheet(index) {
                if (index === this.activeSheetIndex) return;
                this.stopEditing();
                this.activeSheetIndex = index;
                this.selection = { start: null, end: null };
                this.render();
            }

            renameSheet(index, name) {
                if (name && name.trim()) {
                    this.sheets[index].name = name.trim();
                    this.renderSheetTabs();
                }
            }

            deleteSheet(index) {
                if (this.sheets.length <= 1) return;
                
                this.sheets.splice(index, 1);
                if (this.activeSheetIndex >= this.sheets.length) {
                    this.activeSheetIndex = this.sheets.length - 1;
                }
                this.selection = { start: null, end: null };
                this.render();
            }

            // ==================== CSV IMPORT/EXPORT ====================
            downloadCSV() {
                let csv = '';
                
                // Find used range
                let maxRow = 0, maxCol = 0;
                for (const cellId of Object.keys(this.currentSheet.cells)) {
                    const parsed = this.parseCell(cellId);
                    if (parsed) {
                        maxRow = Math.max(maxRow, parsed.row);
                        maxCol = Math.max(maxCol, parsed.col);
                    }
                }
                
                for (let r = 0; r <= maxRow; r++) {
                    const row = [];
                    for (let c = 0; c <= maxCol; c++) {
                        const cellId = this.cellId(r, c);
                        const data = this.getCellData(cellId);
                        let value = data.display !== undefined ? data.display : data.value;
                        
                        // Escape quotes and wrap in quotes if contains comma
                        if (typeof value === 'string') {
                            value = value.replace(/"/g, '""');
                            if (value.includes(',') || value.includes('"') || value.includes('\n')) {
                                value = `"${value}"`;
                            }
                        }
                        row.push(value || '');
                    }
                    csv += row.join(',') + '\n';
                }
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${this.currentSheet.name}.csv`;
                a.click();
                URL.revokeObjectURL(url);
            }

            uploadCSV(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    this.parseCSV(text);
                };
                reader.readAsText(file);
            }

            parseCSV(text) {
                this.saveUndo();
                
                const lines = text.split('\n');
                
                for (let r = 0; r < lines.length; r++) {
                    if (!lines[r].trim()) continue;
                    
                    const values = this.parseCSVLine(lines[r]);
                    for (let c = 0; c < values.length; c++) {
                        const cellId = this.cellId(r, c);
                        this.setCellData(cellId, { value: values[c], formula: '', display: values[c] });
                    }
                }
                
                this.recalculate();
            }

            parseCSVLine(line) {
                const values = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (inQuotes) {
                        if (char === '"' && line[i + 1] === '"') {
                            current += '"';
                            i++;
                        } else if (char === '"') {
                            inQuotes = false;
                        } else {
                            current += char;
                        }
                    } else {
                        if (char === '"') {
                            inQuotes = true;
                        } else if (char === ',') {
                            values.push(current);
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                }
                values.push(current);
                
                return values;
            }

            // ==================== EVENT HANDLERS ====================
            bindEvents() {
                // Cell click
                this.spreadsheet.addEventListener('mousedown', (e) => {
                    const cell = e.target.closest('.cell');
                    if (cell && !cell.classList.contains('editing')) {
                        const row = parseInt(cell.dataset.row);
                        const col = parseInt(cell.dataset.col);
                        
                        if (this.isFormulaMode) {
                            // Insert cell reference into formula
                            this.dragStart = { row, col };
                            this.insertCellReference(row, col);
                            
                            // Highlight the referenced cell
                            cell.classList.add('formula-ref');
                            e.preventDefault();
                            return;
                        }
                        
                        this.stopEditing();
                        this.selectCell(row, col, e.shiftKey);
                        this.isDragging = true;
                        this.dragStart = { row, col };
                    }
                    
                    // Column resize
                    const resizeHandle = e.target.closest('.resize-handle');
                    if (resizeHandle) {
                        this.isResizing = true;
                        this.resizeCol = parseInt(resizeHandle.dataset.col);
                        this.resizeStartX = e.clientX;
                        this.resizeStartWidth = this.currentSheet.columnWidths[this.resizeCol] || DEFAULT_COL_WIDTH;
                        resizeHandle.classList.add('resizing');
                        e.preventDefault();
                    }
                });

                this.spreadsheet.addEventListener('mousemove', (e) => {
                    const cell = e.target.closest('.cell');
                    if (!cell) return;
                    
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    
                    if (this.isDragging && !this.isFormulaMode) {
                        this.selection.end = { row, col };
                        this.updateSelection();
                    } else if (this.isDragging && this.isFormulaMode) {
                        // Update range in formula
                        this.insertCellReference(row, col, true);
                        
                        // Update highlighting
                        this.spreadsheet.querySelectorAll('.formula-ref').forEach(el => el.classList.remove('formula-ref'));
                        this.highlightRange(this.dragStart.row, this.dragStart.col, row, col);
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.isResizing) {
                        const delta = e.clientX - this.resizeStartX;
                        const newWidth = Math.max(40, this.resizeStartWidth + delta);
                        this.currentSheet.columnWidths[this.resizeCol] = newWidth;
                        
                        // Update column width in DOM
                        const headers = this.spreadsheet.querySelectorAll(`.col-header[data-col="${this.resizeCol}"]`);
                        const cells = this.spreadsheet.querySelectorAll(`.cell[data-col="${this.resizeCol}"]`);
                        headers.forEach(h => h.style.width = newWidth + 'px');
                        cells.forEach(c => c.style.width = newWidth + 'px');
                    }
                });

                document.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    this.dragStart = null;
                    
                    if (this.isResizing) {
                        this.isResizing = false;
                        document.querySelectorAll('.resize-handle.resizing').forEach(h => h.classList.remove('resizing'));
                    }
                    
                    // Clear formula reference highlights when not in formula mode
                    if (!this.isFormulaMode) {
                        this.spreadsheet.querySelectorAll('.formula-ref').forEach(el => el.classList.remove('formula-ref'));
                    }
                });

                // Double-click to edit
                this.spreadsheet.addEventListener('dblclick', (e) => {
                    const cell = e.target.closest('.cell');
                    if (cell) {
                        const row = parseInt(cell.dataset.row);
                        const col = parseInt(cell.dataset.col);
                        this.startEditing(row, col);
                    }
                });

                // Keyboard navigation
                document.addEventListener('keydown', (e) => {
                    if (this.editingCell) return;
                    
                    if (e.key.startsWith('Arrow')) {
                        e.preventDefault();
                        const moves = {
                            'ArrowUp': [-1, 0],
                            'ArrowDown': [1, 0],
                            'ArrowLeft': [0, -1],
                            'ArrowRight': [0, 1]
                        };
                        const [dRow, dCol] = moves[e.key];
                        this.moveSelection(dRow, dCol, e.shiftKey);
                    } else if (e.key === 'Enter') {
                        if (this.selection.start) {
                            this.startEditing(this.selection.start.row, this.selection.start.col);
                        }
                    } else if (e.key === 'Tab') {
                        e.preventDefault();
                        this.moveSelection(0, e.shiftKey ? -1 : 1);
                    } else if (e.key === 'Delete' || e.key === 'Backspace') {
                        this.clearContents();
                    } else if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
                        e.preventDefault();
                        this.undo();
                    } else if (e.key === 'y' && (e.ctrlKey || e.metaKey)) {
                        e.preventDefault();
                        this.redo();
                    } else if (e.key === 'b' && (e.ctrlKey || e.metaKey)) {
                        e.preventDefault();
                        this.toggleBold();
                    } else if (e.key === 'i' && (e.ctrlKey || e.metaKey)) {
                        e.preventDefault();
                        this.toggleItalic();
                    } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
                        // Start typing in cell
                        if (this.selection.start) {
                            this.startEditing(this.selection.start.row, this.selection.start.col, e.key);
                        }
                    }
                });

                // Formula bar
                this.formulaInput.addEventListener('focus', () => {
                    if (this.formulaInput.value.startsWith('=')) {
                        this.isFormulaMode = true;
                    }
                });

                this.formulaInput.addEventListener('input', () => {
                    this.isFormulaMode = this.formulaInput.value.startsWith('=');
                    
                    if (this.editingCell) {
                        const cell = this.spreadsheet.querySelector('.cell.editing input');
                        if (cell) {
                            cell.value = this.formulaInput.value;
                        }
                    }
                });

                this.formulaInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        if (this.selection.start) {
                            this.saveUndo();
                            const cellId = this.cellId(this.selection.start.row, this.selection.start.col);
                            const value = this.formulaInput.value;
                            
                            if (value.startsWith('=')) {
                                this.setCellData(cellId, { formula: value, value: value });
                            } else {
                                this.setCellData(cellId, { formula: '', value: value });
                            }
                            
                            this.isFormulaMode = false;
                            this.spreadsheet.querySelectorAll('.formula-ref').forEach(el => el.classList.remove('formula-ref'));
                            this.recalculate();
                            this.moveSelection(1, 0);
                        }
                    } else if (e.key === 'Escape') {
                        this.isFormulaMode = false;
                        this.spreadsheet.querySelectorAll('.formula-ref').forEach(el => el.classList.remove('formula-ref'));
                        this.updateFormulaBar();
                    }
                });

                this.formulaInput.addEventListener('blur', () => {
                    if (!this.isDragging) {
                        this.isFormulaMode = false;
                        this.spreadsheet.querySelectorAll('.formula-ref').forEach(el => el.classList.remove('formula-ref'));
                    }
                });

                // Toolbar buttons
                document.getElementById('boldBtn').addEventListener('click', () => this.toggleBold());
                document.getElementById('italicBtn').addEventListener('click', () => this.toggleItalic());
                document.getElementById('bgColorPicker').addEventListener('input', (e) => this.setBackgroundColor(e.target.value));
                document.getElementById('clearBtn').addEventListener('click', () => this.clearContents());
                document.getElementById('downloadBtn').addEventListener('click', () => this.downloadCSV());
                document.getElementById('uploadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
                document.getElementById('fileInput').addEventListener('change', (e) => {
                    if (e.target.files[0]) {
                        this.uploadCSV(e.target.files[0]);
                    }
                });
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                document.getElementById('redoBtn').addEventListener('click', () => this.redo());

                // Sheet tabs
                document.getElementById('addSheetBtn').addEventListener('click', () => this.addSheet());
                
                this.sheetTabs.addEventListener('click', (e) => {
                    const tab = e.target.closest('.sheet-tab');
                    const closeBtn = e.target.closest('.close-btn');
                    
                    if (closeBtn) {
                        const index = parseInt(closeBtn.dataset.index);
                        if (confirm(`Delete sheet "${this.sheets[index].name}"?`)) {
                            this.deleteSheet(index);
                        }
                    } else if (tab) {
                        const index = parseInt(tab.dataset.index);
                        this.switchSheet(index);
                    }
                });

                this.sheetTabs.addEventListener('contextmenu', (e) => {
                    const tab = e.target.closest('.sheet-tab');
                    if (tab) {
                        e.preventDefault();
                        this.showContextMenu(e.clientX, e.clientY, parseInt(tab.dataset.index));
                    }
                });

                // Context menu
                this.contextMenu.addEventListener('click', (e) => {
                    const item = e.target.closest('.context-menu-item');
                    if (item) {
                        const action = item.dataset.action;
                        const index = parseInt(this.contextMenu.dataset.sheetIndex);
                        
                        if (action === 'rename') {
                            this.showRenameModal(index);
                        } else if (action === 'delete') {
                            if (this.sheets.length > 1 && confirm(`Delete sheet "${this.sheets[index].name}"?`)) {
                                this.deleteSheet(index);
                            }
                        }
                        
                        this.hideContextMenu();
                    }
                });

                document.addEventListener('click', () => this.hideContextMenu());

                // Rename modal
                document.getElementById('renameOkBtn').addEventListener('click', () => {
                    const index = parseInt(this.renameModal.dataset.sheetIndex);
                    this.renameSheet(index, this.renameInput.value);
                    this.hideRenameModal();
                });

                document.getElementById('renameCancelBtn').addEventListener('click', () => this.hideRenameModal());

                this.renameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        const index = parseInt(this.renameModal.dataset.sheetIndex);
                        this.renameSheet(index, this.renameInput.value);
                        this.hideRenameModal();
                    } else if (e.key === 'Escape') {
                        this.hideRenameModal();
                    }
                });
            }

            highlightRange(r1, c1, r2, c2) {
                const minRow = Math.min(r1, r2);
                const maxRow = Math.max(r1, r2);
                const minCol = Math.min(c1, c2);
                const maxCol = Math.max(c1, c2);
                
                for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minCol; c <= maxCol; c++) {
                        const cell = this.spreadsheet.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
                        if (cell) cell.classList.add('formula-ref');
                    }
                }
            }

            showContextMenu(x, y, sheetIndex) {
                this.contextMenu.style.left = x + 'px';
                this.contextMenu.style.top = y + 'px';
                this.contextMenu.dataset.sheetIndex = sheetIndex;
                this.contextMenu.classList.add('visible');
            }

            hideContextMenu() {
                this.contextMenu.classList.remove('visible');
            }

            showRenameModal(index) {
                this.renameModal.dataset.sheetIndex = index;
                this.renameInput.value = this.sheets[index].name;
                this.renameModal.classList.add('visible');
                this.renameInput.focus();
                this.renameInput.select();
            }

            hideRenameModal() {
                this.renameModal.classList.remove('visible');
            }
        }

        // Initialize the app
        const app = new SpreadsheetApp();
    </script>
</body>
</html>