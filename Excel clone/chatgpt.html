<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Excel-like Spreadsheet Clone</title>
  <style>
    * {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f3f3f3;
      overflow: hidden;
    }

    .app {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px 8px;
      background: #ffffff;
      border-bottom: 1px solid #d0d0d0;
      box-shadow: 0 1px 2px rgba(0,0,0,0.08);
    }

    .toolbar button {
      border: 1px solid #d0d0d0;
      background: #fff;
      border-radius: 3px;
      padding: 3px 8px;
      font-size: 12px;
      cursor: pointer;
    }
    .toolbar button.active {
      background: #e5f0ff;
      border-color: #4a90e2;
    }
    .toolbar button:hover {
      background: #f3f3f3;
    }
    .toolbar label {
      font-size: 12px;
      margin-left: 8px;
    }
    .toolbar input[type="color"] {
      border: none;
      padding: 0;
      background: transparent;
      cursor: pointer;
    }
    .toolbar input[type="file"] {
      display: none;
    }

    .formula-bar {
      display: grid;
      grid-template-columns: 70px 1fr;
      align-items: center;
      padding: 4px 8px;
      gap: 4px;
      background: #f9f9f9;
      border-bottom: 1px solid #d0d0d0;
    }

    .cell-address {
      border: 1px solid #ccc;
      background: #fff;
      border-radius: 2px;
      padding: 2px 6px;
      font-size: 12px;
      min-height: 22px;
      display: flex;
      align-items: center;
    }

    .formula-input {
      border: 1px solid #ccc;
      border-radius: 2px;
      padding: 2px 6px;
      font-size: 13px;
      min-height: 24px;
      width: 100%;
    }

    .sheet-tabs {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      background: #f7f7f7;
      border-top: 1px solid #d0d0d0;
      border-bottom: 1px solid #d0d0d0;
    }

    .sheet-tab {
      padding: 3px 10px;
      border-radius: 4px;
      border: 1px solid transparent;
      cursor: pointer;
      font-size: 12px;
      background: transparent;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .sheet-tab.active {
      background: #ffffff;
      border-color: #d0d0d0;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }

    .sheet-tab span {
      pointer-events: none;
    }

    .sheet-tab .close {
      font-size: 11px;
      color: #999;
      pointer-events: auto;
    }

    .sheet-tab .close:hover {
      color: #d00;
    }

    .sheet-add {
      border-radius: 50%;
      width: 20px;
      height: 20px;
      border: 1px solid #d0d0d0;
      background: #fff;
      cursor: pointer;
      font-size: 14px;
      line-height: 18px;
      text-align: center;
    }

    .grid-container {
      flex: 1;
      overflow: auto;
      background: #ffffff;
      border-top: 1px solid #d0d0d0;
    }

    table.grid {
      border-collapse: collapse;
      table-layout: fixed;
      font-size: 12px;
      user-select: none;
    }

    .grid th,
    .grid td {
      border: 1px solid #e0e0e0;
      padding: 0;
      overflow: hidden;
      background: #fff;
    }

    .grid th {
      position: sticky;
      background: #f3f3f3;
      font-weight: 500;
      z-index: 2;
    }

    .grid th.col-header {
      top: 0;
      text-align: center;
      height: 24px;
    }

    .grid th.row-header {
      left: 0;
      text-align: right;
      padding-right: 4px;
      width: 40px;
    }

    .grid th.corner {
      top: 0;
      left: 0;
      z-index: 3;
      background: #ececec;
    }

    .cell {
      height: 22px;
      padding: 0 4px;
      text-align: left;
      vertical-align: middle;
      cursor: cell;
      white-space: nowrap;
    }

    .cell-inner {
      width: 100%;
      height: 100%;
      outline: none;
      border: none;
      padding: 2px 0;
      overflow: hidden;
    }

    .cell.selected {
      outline: 2px solid #4a90e2;
      outline-offset: -2px;
      z-index: 1;
      position: relative;
    }

    .cell.range-selected {
      background: #e5f0ff;
    }

    .resizer {
      position: absolute;
      top: 0;
      right: -3px;
      width: 6px;
      cursor: col-resize;
      user-select: none;
    }

    .col-header-wrapper {
      position: relative;
      height: 100%;
      width: 100%;
    }
  </style>
</head>
<body>
<div class="app">
  <div class="toolbar">
    <button id="btn-bold"><b>B</b></button>
    <button id="btn-italic"><i>I</i></button>
    <label>BG <input type="color" id="bg-color" value="#ffffff"></label>
    <button id="btn-clear">Clear</button>
    <span style="flex:1"></span>
    <button id="btn-download">Download CSV</button>
    <label for="file-upload" style="border:1px solid #d0d0d0;border-radius:3px;padding:3px 8px;cursor:pointer;font-size:12px;">Upload CSV</label>
    <input type="file" id="file-upload" accept=".csv,text/csv">
  </div>

  <div class="formula-bar">
    <div class="cell-address" id="cell-address">A1</div>
    <input class="formula-input" id="formula-input" placeholder="=A1+B2 or =SUM(A1:A10)" />
  </div>

  <div class="sheet-tabs" id="sheet-tabs">
    <!-- Sheet tabs here -->
    <button class="sheet-add" id="sheet-add">+</button>
  </div>

  <div class="grid-container" id="grid-container">
    <!-- Spreadsheet grid will be inserted here -->
  </div>
</div>

<script>
  // CONFIG
  const ROWS = 50;
  const COLS = 26; // A-Z

  // Data model: workbook -> sheets -> cells
  let workbook = {
    sheets: []
  };
  let activeSheetIndex = 0;

  // UI references
  const gridContainer = document.getElementById('grid-container');
  const sheetTabsEl = document.getElementById('sheet-tabs');
  const sheetAddBtn = document.getElementById('sheet-add');
  const addressDisplay = document.getElementById('cell-address');
  const formulaInput = document.getElementById('formula-input');

  const btnBold = document.getElementById('btn-bold');
  const btnItalic = document.getElementById('btn-italic');
  const bgColorInput = document.getElementById('bg-color');
  const btnClear = document.getElementById('btn-clear');
  const btnDownload = document.getElementById('btn-download');
  const fileUpload = document.getElementById('file-upload');

  let gridTable;
  let selectedCell = { row: 1, col: 1 }; // 1-based
  let selectionRange = null;
  let isMouseDown = false;

  // Helpers for column labels
  function colToLabel(colIndex) {
    // 1 -> A, 2 -> B ... 26 -> Z
    let label = '';
    let n = colIndex;
    while (n > 0) {
      let rem = (n - 1) % 26;
      label = String.fromCharCode(65 + rem) + label;
      n = Math.floor((n - 1) / 26);
    }
    return label;
  }

  function labelToCol(label) {
    let col = 0;
    for (let i = 0; i < label.length; i++) {
      col = col * 26 + (label.charCodeAt(i) - 64);
    }
    return col;
  }

  function getActiveSheet() {
    return workbook.sheets[activeSheetIndex];
  }

  function createEmptySheet(name) {
    const cells = [];
    for (let r = 1; r <= ROWS; r++) {
      cells[r] = [];
      for (let c = 1; c <= COLS; c++) {
        cells[r][c] = {
          value: "",
          formula: "",
          bold: false,
          italic: false,
          bgColor: "#ffffff"
        };
      }
    }
    return { name, cells };
  }

  // Initialize workbook with one sheet
  function initWorkbook() {
    workbook.sheets = [];
    workbook.sheets.push(createEmptySheet("Sheet1"));
    activeSheetIndex = 0;
    renderSheetTabs();
    renderGrid();
    selectCell(1, 1);
    recalcSheet();
  }

  // Sheet tabs
  function renderSheetTabs() {
    // Clear current tabs (except add button)
    sheetTabsEl.querySelectorAll('.sheet-tab').forEach(el => el.remove());

    workbook.sheets.forEach((sheet, idx) => {
      const tab = document.createElement('button');
      tab.className = 'sheet-tab' + (idx === activeSheetIndex ? ' active' : '');
      const nameSpan = document.createElement('span');
      nameSpan.textContent = sheet.name;
      tab.appendChild(nameSpan);

      const close = document.createElement('span');
      close.textContent = 'Ã—';
      close.className = 'close';
      close.title = 'Delete sheet';
      tab.appendChild(close);

      tab.addEventListener('click', (e) => {
        if (e.target === close) {
          deleteSheet(idx);
          e.stopPropagation();
        } else {
          activateSheet(idx);
        }
      });

      tab.addEventListener('dblclick', () => {
        const newName = prompt("Rename sheet:", sheet.name);
        if (newName && newName.trim()) {
          sheet.name = newName.trim();
          renderSheetTabs();
        }
      });

      sheetTabsEl.insertBefore(tab, sheetAddBtn);
    });
  }

  function activateSheet(index) {
    if (index < 0 || index >= workbook.sheets.length) return;
    activeSheetIndex = index;
    renderSheetTabs();
    renderGrid();
    selectCell(1, 1);
    recalcSheet();
  }

  function addSheet() {
    const name = "Sheet" + (workbook.sheets.length + 1);
    workbook.sheets.push(createEmptySheet(name));
    activeSheetIndex = workbook.sheets.length - 1;
    renderSheetTabs();
    renderGrid();
    selectCell(1, 1);
    recalcSheet();
  }

  function deleteSheet(index) {
    if (workbook.sheets.length === 1) {
      alert("Cannot delete the only sheet.");
      return;
    }
    workbook.sheets.splice(index, 1);
    if (activeSheetIndex >= workbook.sheets.length) {
      activeSheetIndex = workbook.sheets.length - 1;
    }
    renderSheetTabs();
    renderGrid();
    selectCell(1, 1);
    recalcSheet();
  }

  sheetAddBtn.addEventListener('click', addSheet);

  // Grid rendering
  function renderGrid() {
    gridContainer.innerHTML = '';
    const table = document.createElement('table');
    table.className = 'grid';
    gridTable = table;

    // Column widths
    const colWidths = [];
    for (let c = 1; c <= COLS; c++) {
      colWidths[c] = 80;
    }

    // Header row
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');

    const corner = document.createElement('th');
    corner.className = 'corner';
    corner.style.width = '40px';
    headerRow.appendChild(corner);

    for (let c = 1; c <= COLS; c++) {
      const th = document.createElement('th');
      th.className = 'col-header';
      th.style.width = colWidths[c] + 'px';

      const wrapper = document.createElement('div');
      wrapper.className = 'col-header-wrapper';
      wrapper.textContent = colToLabel(c);

      const resizer = document.createElement('div');
      resizer.className = 'resizer';
      wrapper.appendChild(resizer);
      th.appendChild(wrapper);

      let startX, startWidth;
      resizer.addEventListener('mousedown', (e) => {
        e.preventDefault();
        startX = e.clientX;
        startWidth = th.offsetWidth;
        document.body.style.cursor = 'col-resize';

        function onMouseMove(ev) {
          const newWidth = Math.max(40, startWidth + (ev.clientX - startX));
          th.style.width = newWidth + 'px';
        }
        function onMouseUp() {
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          document.body.style.cursor = 'default';
        }
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      });

      headerRow.appendChild(th);
    }
    thead.appendChild(headerRow);
    table.appendChild(thead);

    // Body
    const tbody = document.createElement('tbody');
    const sheet = getActiveSheet();

    for (let r = 1; r <= ROWS; r++) {
      const tr = document.createElement('tr');

      const rowHeader = document.createElement('th');
      rowHeader.className = 'row-header';
      rowHeader.textContent = r;
      tr.appendChild(rowHeader);

      for (let c = 1; c <= COLS; c++) {
        const td = document.createElement('td');
        td.className = 'cell';
        td.dataset.row = r;
        td.dataset.col = c;

        const inner = document.createElement('div');
        inner.className = 'cell-inner';
        inner.contentEditable = false;

        td.appendChild(inner);
        tr.appendChild(td);

        td.addEventListener('mousedown', (e) => {
          isMouseDown = true;
          selectCell(r, c, true);
          selectionRange = { startRow: r, startCol: c, endRow: r, endCol: c };
          updateRangeSelection();
        });

        td.addEventListener('mouseover', () => {
          if (isMouseDown && selectionRange) {
            selectionRange.endRow = r;
            selectionRange.endCol = c;
            updateRangeSelection();
          }
        });

        td.addEventListener('dblclick', () => {
          startEditCell(r, c);
        });

      }
      tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    gridContainer.appendChild(table);

    document.addEventListener('mouseup', () => {
      isMouseDown = false;
    });

    // Fill cell text & styles from sheet data
    updateGridFromData();
  }

  function updateGridFromData() {
    const sheet = getActiveSheet();
    for (let r = 1; r <= ROWS; r++) {
      for (let c = 1; c <= COLS; c++) {
        const cellData = sheet.cells[r][c];
        const td = gridTable.querySelector(`td.cell[data-row="${r}"][data-col="${c}"]`);
        if (!td) continue;
        const inner = td.firstElementChild;
        inner.textContent = cellData.display !== undefined ? cellData.display : cellData.value;
        td.style.fontWeight = cellData.bold ? 'bold' : 'normal';
        td.style.fontStyle = cellData.italic ? 'italic' : 'normal';
        td.style.backgroundColor = cellData.bgColor || '#ffffff';
      }
    }
  }

  // Selection
  function selectCell(row, col, focusFormula = false) {
    selectedCell = { row, col };
    clearSelectionClasses();
    const td = gridTable.querySelector(`td.cell[data-row="${row}"][data-col="${col}"]`);
    if (td) td.classList.add('selected');

    const addr = colToLabel(col) + row;
    addressDisplay.textContent = addr;

    const sheet = getActiveSheet();
    const cell = sheet.cells[row][col];
    formulaInput.value = cell.formula || cell.value || "";

    btnBold.classList.toggle('active', !!cell.bold);
    btnItalic.classList.toggle('active', !!cell.italic);
    bgColorInput.value = cell.bgColor || '#ffffff';

    if (focusFormula) {
      formulaInput.focus();
      formulaInput.select();
    }
  }

  function clearSelectionClasses() {
    gridTable.querySelectorAll('.cell.selected, .cell.range-selected')
      .forEach(el => {
        el.classList.remove('selected');
        el.classList.remove('range-selected');
      });
  }

  function updateRangeSelection() {
    clearSelectionClasses();
    const { startRow, startCol, endRow, endCol } = selectionRange;
    const r1 = Math.min(startRow, endRow);
    const r2 = Math.max(startRow, endRow);
    const c1 = Math.min(startCol, endCol);
    const c2 = Math.max(startCol, endCol);
    for (let r = r1; r <= r2; r++) {
      for (let c = c1; c <= c2; c++) {
        const td = gridTable.querySelector(`td.cell[data-row="${r}"][data-col="${c}"]`);
        if (!td) continue;
        if (r === selectedCell.row && c === selectedCell.col) {
          td.classList.add('selected');
        } else {
          td.classList.add('range-selected');
        }
      }
    }
  }

  // Editing
  function startEditCell(row, col) {
    selectCell(row, col);
    formulaInput.focus();
    formulaInput.select();
  }

  formulaInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      applyFormulaInput();
      moveSelection(1, 0); // move down
    }
  });

  formulaInput.addEventListener('blur', () => {
    applyFormulaInput();
  });

  function applyFormulaInput() {
    const sheet = getActiveSheet();
    const { row, col } = selectedCell;
    const cell = sheet.cells[row][col];
    const text = formulaInput.value.trim();

    if (text.startsWith('=')) {
      cell.formula = text;
      cell.value = '';
    } else {
      cell.formula = '';
      cell.value = text;
    }
    recalcSheet();
    updateGridFromData();
  }

  // Keyboard navigation
  document.addEventListener('keydown', (e) => {
    if (document.activeElement === formulaInput) return;

    const { row, col } = selectedCell;
    let handled = false;

    if (e.key === 'ArrowUp') {
      moveSelection(-1, 0);
      handled = true;
    } else if (e.key === 'ArrowDown') {
      moveSelection(1, 0);
      handled = true;
    } else if (e.key === 'ArrowLeft') {
      moveSelection(0, -1);
      handled = true;
    } else if (e.key === 'ArrowRight' || e.key === 'Tab') {
      moveSelection(0, 1);
      handled = true;
    } else if (e.key === 'Enter') {
      moveSelection(1, 0);
      handled = true;
    } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
      // start editing immediately
      formulaInput.value = e.key;
      formulaInput.focus();
      formulaInput.setSelectionRange(1,1);
      handled = true;
    }

    if (handled) {
      e.preventDefault();
    }
  });

  function moveSelection(dRow, dCol) {
    let newRow = selectedCell.row + dRow;
    let newCol = selectedCell.col + dCol;
    if (newRow < 1) newRow = 1;
    if (newRow > ROWS) newRow = ROWS;
    if (newCol < 1) newCol = 1;
    if (newCol > COLS) newCol = COLS;
    selectCell(newRow, newCol);
  }

  // Formula evaluation
  function recalcSheet() {
    const sheet = getActiveSheet();
    for (let r = 1; r <= ROWS; r++) {
      for (let c = 1; c <= COLS; c++) {
        const cell = sheet.cells[r][c];
        if (cell.formula && cell.formula.startsWith('=')) {
          cell.display = evaluateFormula(cell.formula, sheet);
        } else {
          const num = parseFloat(cell.value);
          cell.display = isNaN(num) || cell.value === "" ? cell.value : num;
        }
      }
    }
  }

  function getCellDisplay(sheet, addr) {
    const match = /^([A-Z]+)(\d+)$/.exec(addr);
    if (!match) return 0;
    const colLabel = match[1];
    const row = parseInt(match[2], 10);
    const col = labelToCol(colLabel);
    if (row < 1 || row > ROWS || col < 1 || col > COLS) return 0;
    const cell = sheet.cells[row][col];
    let v = cell.display;
    if (v === "" || v == null) return 0;
    v = parseFloat(v);
    return isNaN(v) ? 0 : v;
  }

  function evalRange(sheet, rangeText, funcName) {
    const parts = rangeText.split(',');
    let values = [];
    parts.forEach(part => {
      part = part.trim();
      if (!part) return;
      const rangeMatch = /^([A-Z]+)(\d+):([A-Z]+)(\d+)$/.exec(part);
      if (rangeMatch) {
        const c1 = labelToCol(rangeMatch[1]);
        const r1 = parseInt(rangeMatch[2], 10);
        const c2 = labelToCol(rangeMatch[3]);
        const r2 = parseInt(rangeMatch[4], 10);
        const rStart = Math.min(r1, r2);
        const rEnd = Math.max(r1, r2);
        const cStart = Math.min(c1, c2);
        const cEnd = Math.max(c1, c2);
        for (let r = rStart; r <= rEnd; r++) {
          for (let c = cStart; c <= cEnd; c++) {
            const cell = sheet.cells[r][c];
            let v = cell.display;
            if (v === "" || v == null) continue;
            v = parseFloat(v);
            if (!isNaN(v)) values.push(v);
          }
        }
      } else {
        values.push(getCellDisplay(sheet, part));
      }
    });

    if (values.length === 0) return 0;
    if (funcName === 'SUM') return values.reduce((a, b) => a + b, 0);
    if (funcName === 'AVERAGE') return values.reduce((a, b) => a + b, 0) / values.length;
    if (funcName === 'MIN') return Math.min(...values);
    if (funcName === 'MAX') return Math.max(...values);
    return 0;
  }

  function evaluateFormula(formula, sheet) {
    try {
      let expr = formula.slice(1); // remove '='

      // Handle functions: SUM, AVERAGE, MIN, MAX
      const funcs = ['SUM', 'AVERAGE', 'MIN', 'MAX'];
      funcs.forEach(fn => {
        const regex = new RegExp(fn + '\\(([^()]*)\\)', 'gi');
        let match;
        while ((match = regex.exec(expr)) !== null) {
          const rangeText = match[1];
          const result = evalRange(sheet, rangeText, fn);
          expr = expr.replace(match[0], String(result));
          regex.lastIndex = 0; // reset due to modification
        }
      });

      // Replace cell references with their numeric values
      expr = expr.replace(/\b([A-Z]+)(\d+)\b/g, (m, colLabel, rowStr) => {
        const addr = colLabel + rowStr;
        return String(getCellDisplay(sheet, addr));
      });

      // Check allowed chars
      if (!/^[0-9+\-*/().\s]+$/.test(expr)) {
        return "#ERR";
      }

      const result = Function('"use strict";return (' + expr + ')')();
      if (result === undefined || result === null || isNaN(result)) return "#ERR";
      return result;
    } catch (e) {
      return "#ERR";
    }
  }

  // Toolbar actions
  function applyStyleToSelection(callback) {
    const sheet = getActiveSheet();
    if (!selectionRange) {
      const { row, col } = selectedCell;
      selectionRange = { startRow: row, startCol: col, endRow: row, endCol: col };
    }
    const { startRow, startCol, endRow, endCol } = selectionRange;
    const r1 = Math.min(startRow, endRow);
    const r2 = Math.max(startRow, endRow);
    const c1 = Math.min(startCol, endCol);
    const c2 = Math.max(startCol, endCol);

    for (let r = r1; r <= r2; r++) {
      for (let c = c1; c <= c2; c++) {
        callback(sheet.cells[r][c]);
      }
    }
    updateGridFromData();
  }

  btnBold.addEventListener('click', () => {
    btnBold.classList.toggle('active');
    const setBold = btnBold.classList.contains('active');
    applyStyleToSelection(cell => {
      cell.bold = setBold;
    });
  });

  btnItalic.addEventListener('click', () => {
    btnItalic.classList.toggle('active');
    const setItalic = btnItalic.classList.contains('active');
    applyStyleToSelection(cell => {
      cell.italic = setItalic;
    });
  });

  bgColorInput.addEventListener('input', () => {
    const color = bgColorInput.value;
    applyStyleToSelection(cell => {
      cell.bgColor = color;
    });
  });

  btnClear.addEventListener('click', () => {
    applyStyleToSelection(cell => {
      cell.value = "";
      cell.formula = "";
      cell.display = "";
      cell.bold = false;
      cell.italic = false;
      cell.bgColor = "#ffffff";
    });
    recalcSheet();
    updateGridFromData();
  });

  // CSV download/upload
  btnDownload.addEventListener('click', () => {
    const sheet = getActiveSheet();
    let csv = '';
    for (let r = 1; r <= ROWS; r++) {
      const rowValues = [];
      for (let c = 1; c <= COLS; c++) {
        const cell = sheet.cells[r][c];
        const raw = cell.formula || cell.value || "";
        let v = String(raw).replace(/"/g, '""');
        if (v.includes(',') || v.includes('"')) {
          v = '"' + v + '"';
        }
        rowValues.push(v);
      }
      csv += rowValues.join(',') + '\n';
    }
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = getActiveSheet().name + '.csv';
    a.click();
    URL.revokeObjectURL(url);
  });

  fileUpload.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(evt) {
      const text = evt.target.result;
      loadCSVIntoActiveSheet(text);
    };
    reader.readAsText(file);
    fileUpload.value = "";
  });

  function loadCSVIntoActiveSheet(text) {
    const sheet = getActiveSheet();
    const lines = text.split(/\r?\n/);
    for (let r = 1; r <= ROWS; r++) {
      const line = lines[r - 1] || '';
      const cells = parseCSVLine(line);
      for (let c = 1; c <= COLS; c++) {
        const raw = cells[c - 1] || '';
        const cell = sheet.cells[r][c];
        if (raw.startsWith('=')) {
          cell.formula = raw;
          cell.value = '';
        } else {
          cell.formula = '';
          cell.value = raw;
        }
      }
    }
    recalcSheet();
    updateGridFromData();
  }

  function parseCSVLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (inQuotes) {
        if (ch === '"') {
          if (line[i + 1] === '"') {
            current += '"';
            i++;
          } else {
            inQuotes = false;
          }
        } else {
          current += ch;
        }
      } else {
        if (ch === ',') {
          result.push(current);
          current = '';
        } else if (ch === '"') {
          inQuotes = true;
        } else {
          current += ch;
        }
      }
    }
    result.push(current);
    return result;
  }

  // Init
  initWorkbook();
</script>
</body>
</html>
