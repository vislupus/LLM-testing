<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive World Map - Equal Earth Projection</title>
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.1"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #0c1a2d 0%, #1a3a5f 100%);
            color: #e0f0ff;
            min-height: 100vh;
            overflow-x: hidden;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        header {
            text-align: center;
            padding: 20px;
            background: rgba(10, 30, 50, 0.7);
            border-radius: 12px;
            border: 1px solid rgba(64, 156, 255, 0.2);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #7bc8ff;
            margin-bottom: 10px;
            font-size: 2.4rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .subtitle {
            color: #a8d2ff;
            font-size: 1.1rem;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .map-container {
            flex: 3;
            min-width: 300px;
            background: rgba(10, 30, 50, 0.7);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(64, 156, 255, 0.2);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }

        .map-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(64, 156, 255, 0.2);
        }

        .map-title {
            font-size: 1.4rem;
            color: #7bc8ff;
        }

        .map-controls {
            display: flex;
            gap: 10px;
        }

        .map-control-btn {
            background: rgba(25, 55, 90, 0.6);
            border: 1px solid rgba(64, 156, 255, 0.3);
            color: #a8d2ff;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .map-control-btn:hover {
            background: rgba(64, 156, 255, 0.2);
            transform: translateY(-2px);
        }

        #map {
            width: 100%;
            height: 600px;
            background: rgba(15, 35, 60, 0.8);
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid rgba(64, 156, 255, 0.1);
        }

        .controls-panel {
            flex: 1;
            min-width: 300px;
            background: rgba(10, 30, 50, 0.7);
            border-radius: 12px;
            padding: 25px;
            border: 1px solid rgba(64, 156, 255, 0.2);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel-section {
            background: rgba(25, 55, 90, 0.6);
            border-radius: 10px;
            padding: 18px;
            border-left: 4px solid #409cff;
        }

        h2 {
            color: #7bc8ff;
            font-size: 1.4rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        h2 i {
            font-size: 1.2rem;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #a8d2ff;
            font-weight: 500;
        }

        .input-with-button {
            display: flex;
            gap: 10px;
        }

        input[type="number"], input[type="text"] {
            flex: 1;
            background: rgba(10, 30, 50, 0.6);
            border: 1px solid rgba(64, 156, 255, 0.3);
            color: #e0f0ff;
            padding: 12px 15px;
            border-radius: 8px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus, input[type="text"]:focus {
            border-color: #409cff;
            box-shadow: 0 0 0 2px rgba(64, 156, 255, 0.2);
        }

        button {
            background: linear-gradient(to right, #409cff, #2a7de0);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            white-space: nowrap;
        }

        button:hover {
            background: linear-gradient(to right, #2a7de0, #1a6bc8);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
        }

        button:active {
            transform: translateY(0);
        }

        .coord-display {
            background: rgba(10, 30, 50, 0.6);
            border: 1px solid rgba(64, 156, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .coord-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(64, 156, 255, 0.1);
        }

        .coord-row:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .coord-label {
            color: #a8d2ff;
            font-weight: 500;
        }

        .coord-value {
            color: #7bc8ff;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .marker-list {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            background: rgba(10, 30, 50, 0.6);
            border-radius: 8px;
            border: 1px solid rgba(64, 156, 255, 0.2);
        }

        .marker-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid rgba(64, 156, 255, 0.1);
        }

        .marker-item:last-child {
            border-bottom: none;
        }

        .marker-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .marker-name {
            color: #e0f0ff;
            font-weight: 500;
        }

        .marker-coords {
            color: #a8d2ff;
            font-size: 0.9rem;
            font-family: 'Courier New', monospace;
        }

        .marker-actions {
            display: flex;
            gap: 8px;
        }

        .marker-action-btn {
            background: rgba(64, 156, 255, 0.2);
            border: 1px solid rgba(64, 156, 255, 0.3);
            color: #a8d2ff;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .marker-action-btn:hover {
            background: rgba(64, 156, 255, 0.4);
        }

        .footer-info {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(64, 156, 255, 0.2);
            font-size: 0.9rem;
            color: #8ab4f8;
            line-height: 1.5;
        }

        .keyboard-hint {
            font-size: 0.85rem;
            color: #8ab4f8;
            margin-top: 10px;
            text-align: center;
            font-style: italic;
        }

        .projection-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background: rgba(46, 213, 115, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(46, 213, 115, 0.3);
        }

        .projection-info i {
            color: #2ed573;
            font-size: 1.2rem;
        }

        @media (max-width: 1100px) {
            .content {
                flex-direction: column;
            }
        }

        @media (max-width: 600px) {
            .controls-panel {
                padding: 15px;
            }
            
            .input-with-button {
                flex-direction: column;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            #map {
                height: 450px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Interactive World Map - Equal Earth Projection</h1>
            <p class="subtitle">A mathematically accurate implementation of the Equal Earth projection with full forward (lat/lon → screen) and inverse (screen → lat/lon) coordinate conversion. Zoom and pan while maintaining projection correctness.</p>
        </header>
        
        <div class="content">
            <div class="map-container">
                <div class="map-header">
                    <div class="map-title">Equal Earth Projection World Map</div>
                    <div class="map-controls">
                        <button class="map-control-btn" id="reset-view">Reset View</button>
                        <button class="map-control-btn" id="toggle-grid">Toggle Grid</button>
                        <button class="map-control-btn" id="clear-markers">Clear Markers</button>
                    </div>
                </div>
                <div id="map"></div>
                <div class="projection-info">
                    <i>ℹ</i>
                    <span>Click anywhere on the map to get coordinates. Drag to pan, scroll to zoom.</span>
                </div>
            </div>
            
            <div class="controls-panel">
                <div class="panel-section">
                    <h2>Forward Projection</h2>
                    <p>Convert geographic coordinates to map position</p>
                    
                    <div class="control-group">
                        <label for="latitude">Latitude (-90° to 90°):</label>
                        <input type="number" id="latitude" min="-90" max="90" step="0.1" value="40.7128">
                    </div>
                    
                    <div class="control-group">
                        <label for="longitude">Longitude (-180° to 180°):</label>
                        <input type="number" id="longitude" min="-180" max="180" step="0.1" value="-74.0060">
                    </div>
                    
                    <div class="control-group">
                        <label for="marker-name">Marker Name (optional):</label>
                        <input type="text" id="marker-name" placeholder="e.g., New York City">
                    </div>
                    
                    <div class="input-with-button">
                        <button id="add-marker">Add Marker</button>
                        <button id="center-on-coords" style="background: linear-gradient(to right, #2ed573, #1fab58);">Center Map</button>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h2>Inverse Projection</h2>
                    <p>Click anywhere on the map to get coordinates</p>
                    
                    <div class="coord-display">
                        <div class="coord-row">
                            <span class="coord-label">Screen X, Y:</span>
                            <span class="coord-value" id="screen-coords">0, 0</span>
                        </div>
                        <div class="coord-row">
                            <span class="coord-label">Projected X, Y:</span>
                            <span class="coord-value" id="projected-coords">0.00, 0.00</span>
                        </div>
                        <div class="coord-row">
                            <span class="coord-label">Latitude, Longitude:</span>
                            <span class="coord-value" id="geo-coords">0.00°, 0.00°</span>
                        </div>
                        <div class="coord-row">
                            <span class="coord-label">Location:</span>
                            <span class="coord-value" id="location-name">Click on the map</span>
                        </div>
                    </div>
                    
                    <div class="keyboard-hint">
                        Keyboard: R = Reset view, G = Toggle grid, C = Clear markers, +/- = Zoom
                    </div>
                </div>
                
                <div class="panel-section">
                    <h2>Map Markers</h2>
                    <p>Placed markers (click to center):</p>
                    
                    <div class="marker-list" id="marker-list">
                        <!-- Marker list will be populated here -->
                        <div class="marker-item" style="text-align: center; color: #8ab4f8; padding: 20px;">
                            No markers yet. Add one using the form above.
                        </div>
                    </div>
                </div>
                
                <div class="footer-info">
                    <p><strong>Equal Earth Projection:</strong> An equal-area pseudocylindrical projection for world maps. It maintains accurate area representation while minimizing shape distortion.</p>
                    <p><strong>Forward projection:</strong> Converts latitude/longitude to projected map coordinates using the Equal Earth formulas.</p>
                    <p><strong>Inverse projection:</strong> Converts map coordinates back to latitude/longitude using iterative numerical methods.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
// Main application class
class EqualEarthMap {
    constructor() {
        // Map constants
        this.PROJECTION_SCALE = 180; // Scale factor for projection
        this.SQRT3 = Math.sqrt(3);
        
        // Equal Earth projection constants (from the 2018 paper by Šavrič, Patterson, and Jenny)
        this.A1 = 1.340264;
        this.A2 = -0.081106;
        this.A3 = 0.000893;
        this.A4 = 0.003796;
        
        // Map state
        this.markers = [];
        this.showGrid = true;
        this.mapData = null;
        this.countryPaths = [];
        this.currentTransform = {
            x: 0,
            y: 0,
            scale: 1
        };
        
        // Initialize SVG.js and set up the map
        this.initMap();
        
        // Load world map data and draw it
        this.loadWorldMapData();
        
        // Set up event listeners
        this.setupEventListeners();
        
        // Add some example markers
        this.addExampleMarkers();
    }
    
    // Initialize the SVG map
    initMap() {
        // Create SVG drawing area
        this.svg = SVG().addTo('#map').size('100%', '100%');
        
        // Create a group for all map elements (for easy zoom/pan)
        this.mapGroup = this.svg.group();
        
        // Create groups for different map elements
        this.gridGroup = this.mapGroup.group().addClass('grid-group');
        this.landGroup = this.mapGroup.group().addClass('land-group');
        this.coastlineGroup = this.mapGroup.group().addClass('coastline-group');
        this.countryGroup = this.mapGroup.group().addClass('country-group');
        this.markerGroup = this.mapGroup.group().addClass('marker-group');
        
        // Set initial view to show the whole world
        this.resetView();
        
        // Draw the graticule (grid of meridians and parallels)
        this.drawGraticule();
        
        // Add click event for inverse projection
        this.svg.on('click', (event) => {
            this.handleMapClick(event);
        });
        
        // Add zoom and pan events
        this.setupZoomPan();
    }
    
    // Set up zoom and pan functionality
    setupZoomPan() {
        let isDragging = false;
        let startX, startY;
        let startTransformX, startTransformY;
        
        // Mouse down: start dragging
        this.svg.on('mousedown', (event) => {
            if (event.button === 0) { // Left mouse button
                isDragging = true;
                startX = event.clientX;
                startY = event.clientY;
                startTransformX = this.currentTransform.x;
                startTransformY = this.currentTransform.y;
                this.svg.css('cursor', 'grabbing');
                event.preventDefault();
            }
        });
        
        // Mouse move: drag the map
        this.svg.on('mousemove', (event) => {
            if (isDragging) {
                const dx = event.clientX - startX;
                const dy = event.clientY - startY;
                
                // Update transform
                this.currentTransform.x = startTransformX + dx / this.currentTransform.scale;
                this.currentTransform.y = startTransformY + dy / this.currentTransform.scale;
                
                this.updateMapTransform();
                event.preventDefault();
            }
        });
        
        // Mouse up: stop dragging
        this.svg.on('mouseup', (event) => {
            if (event.button === 0) {
                isDragging = false;
                this.svg.css('cursor', 'grab');
            }
        });
        
        this.svg.on('mouseleave', () => {
            isDragging = false;
            this.svg.css('cursor', 'grab');
        });
        
        // Mouse wheel: zoom in/out
        this.svg.on('wheel', (event) => {
            event.preventDefault();
            
            const rect = this.svg.node.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            // Convert mouse position to map coordinates
            const mapX = (mouseX / this.currentTransform.scale) - this.currentTransform.x;
            const mapY = (mouseY / this.currentTransform.scale) - this.currentTransform.y;
            
            // Calculate zoom factor
            const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
            const newScale = this.currentTransform.scale * zoomFactor;
            
            // Limit zoom scale
            if (newScale < 0.5) return;
            if (newScale > 20) return;
            
            // Update transform
            this.currentTransform.scale = newScale;
            
            // Adjust transform to zoom toward mouse position
            this.currentTransform.x = (mouseX / newScale) - mapX;
            this.currentTransform.y = (mouseY / newScale) - mapY;
            
            this.updateMapTransform();
        });
        
        // Set initial cursor
        this.svg.css('cursor', 'grab');
    }
    
    // Update the map transform (zoom and pan)
    updateMapTransform() {
        this.mapGroup.transform({
            translate: [this.currentTransform.x * this.currentTransform.scale, 
                       this.currentTransform.y * this.currentTransform.scale],
            scale: this.currentTransform.scale
        });
    }
    
    // Reset view to show the whole world
    resetView() {
        // Calculate the bounds of the Equal Earth projection
        // The projection has x in [-√3, √3] and y in [-1, 1] for the full world
        const worldWidth = 2 * this.SQRT3 * this.PROJECTION_SCALE;
        const worldHeight = 2 * this.PROJECTION_SCALE;
        
        // Get map container dimensions
        const mapWidth = this.svg.width();
        const mapHeight = this.svg.height();
        
        // Calculate scale to fit world in view
        const scaleX = mapWidth / worldWidth;
        const scaleY = mapHeight / worldHeight;
        const scale = Math.min(scaleX, scaleY) * 0.9; // 90% to add some margin
        
        // Center the world
        this.currentTransform = {
            x: -worldWidth / 2,
            y: -worldHeight / 2,
            scale: scale
        };
        
        this.updateMapTransform();
    }
    
    // Draw the graticule (grid of meridians and parallels)
    drawGraticule() {
        this.gridGroup.clear();
        
        if (!this.showGrid) return;
        
        // Draw meridians (lines of longitude)
        for (let lon = -180; lon <= 180; lon += 30) {
            const points = [];
            for (let lat = -85; lat <= 85; lat += 5) {
                const point = this.forwardProjection(lat, lon);
                if (point) {
                    points.push([point.x, point.y]);
                }
            }
            
            if (points.length > 1) {
                this.gridGroup.polyline(points).stroke({
                    color: 'rgba(64, 156, 255, 0.3)',
                    width: 1,
                    dasharray: '2,2'
                }).fill('none');
            }
        }
        
        // Draw parallels (lines of latitude)
        for (let lat = -80; lat <= 80; lat += 20) {
            const points = [];
            for (let lon = -180; lon <= 180; lon += 5) {
                const point = this.forwardProjection(lat, lon);
                if (point) {
                    points.push([point.x, point.y]);
                }
            }
            
            if (points.length > 1) {
                this.gridGroup.polyline(points).stroke({
                    color: 'rgba(64, 156, 255, 0.3)',
                    width: 1,
                    dasharray: '2,2'
                }).fill('none');
            }
        }
        
        // Draw equator with a thicker line
        const equatorPoints = [];
        for (let lon = -180; lon <= 180; lon += 5) {
            const point = this.forwardProjection(0, lon);
            if (point) {
                equatorPoints.push([point.x, point.y]);
            }
        }
        
        if (equatorPoints.length > 1) {
            this.gridGroup.polyline(equatorPoints).stroke({
                color: 'rgba(64, 156, 255, 0.5)',
                width: 2
            }).fill('none');
        }
    }
    
    // Forward projection: convert geographic coordinates (lat, lon) to projected (x, y)
    forwardProjection(lat, lon) {
        // Convert degrees to radians
        const latRad = lat * Math.PI / 180;
        const lonRad = lon * Math.PI / 180;
        
        // Equal Earth projection formulas (from the 2018 paper)
        const theta = Math.asin(this.SQRT3 / 2 * Math.sin(latRad));
        const theta2 = theta * theta;
        const theta4 = theta2 * theta2;
        const theta6 = theta2 * theta4;
        const theta8 = theta4 * theta4;
        
        // Calculate denominator
        const denominator = this.A1 + this.A2 * theta2 + this.A3 * theta4 + this.A4 * theta6;
        
        // Calculate projected coordinates
        const x = (2 * this.SQRT3 * lonRad * Math.cos(theta)) / (3 * denominator);
        const y = theta * denominator;
        
        // Scale the coordinates
        return {
            x: x * this.PROJECTION_SCALE,
            y: -y * this.PROJECTION_SCALE // Negative because SVG Y axis goes down
        };
    }
    
    // Inverse projection: convert projected (x, y) to geographic coordinates (lat, lon)
    inverseProjection(x, y) {
        // Scale back from our projection scale
        const scaledX = x / this.PROJECTION_SCALE;
        const scaledY = -y / this.PROJECTION_SCALE; // Negative because SVG Y axis goes down
        
        // First, we need to solve for theta using Newton-Raphson method
        // y = theta * (A1 + A2*theta^2 + A3*theta^4 + A4*theta^6)
        // We want to find theta such that f(theta) = theta*polynomial(theta) - y = 0
        
        let theta = scaledY / this.A1; // Initial guess
        
        // Newton-Raphson iteration
        for (let i = 0; i < 20; i++) {
            const theta2 = theta * theta;
            const theta4 = theta2 * theta2;
            const theta6 = theta2 * theta4;
            
            const f = theta * (this.A1 + this.A2 * theta2 + this.A3 * theta4 + this.A4 * theta6) - scaledY;
            
            // Derivative: df/dtheta = A1 + 3*A2*theta^2 + 5*A3*theta^4 + 7*A4*theta^6
            const df = this.A1 + 3 * this.A2 * theta2 + 5 * this.A3 * theta4 + 7 * this.A4 * theta6;
            
            // Avoid division by zero
            if (Math.abs(df) < 1e-10) break;
            
            const delta = f / df;
            theta -= delta;
            
            // Check for convergence
            if (Math.abs(delta) < 1e-10) break;
        }
        
        // Calculate latitude
        const latRad = Math.asin((2 / this.SQRT3) * Math.sin(theta));
        
        // Calculate longitude
        const theta2 = theta * theta;
        const theta4 = theta2 * theta2;
        const theta6 = theta2 * theta4;
        const denominator = this.A1 + this.A2 * theta2 + this.A3 * theta4 + this.A4 * theta6;
        
        // Avoid division by zero
        if (Math.abs(denominator) < 1e-10 || Math.abs(Math.cos(theta)) < 1e-10) {
            return null;
        }
        
        const lonRad = (3 * scaledX * denominator) / (2 * this.SQRT3 * Math.cos(theta));
        
        // Convert radians to degrees
        const lat = latRad * 180 / Math.PI;
        const lon = lonRad * 180 / Math.PI;
        
        // Normalize longitude to [-180, 180]
        const normalizedLon = ((lon + 180) % 360 + 360) % 360 - 180;
        
        return {
            lat: lat,
            lon: normalizedLon
        };
    }
    
    // Load world map data (simplified version)
    loadWorldMapData() {
        // Simplified world map data (coordinates for a few continents)
        // In a real application, you would load a proper GeoJSON file
        this.mapData = {
            type: "FeatureCollection",
            features: [
                // Africa (simplified outline)
                {
                    type: "Feature",
                    geometry: {
                        type: "Polygon",
                        coordinates: [[
                            [-18, 35], [-13, 27], [-17, 14], [-10, 8], 
                            [8, 5], [14, -6], [25, -34], [33, -27],
                            [42, -12], [52, 12], [44, 33], [34, 35],
                            [32, 39], [12, 35], [7, 44], [-5, 36],
                            [-18, 35]
                        ]]
                    }
                },
                // Europe (simplified outline)
                {
                    type: "Feature",
                    geometry: {
                        type: "Polygon",
                        coordinates: [[
                            [-10, 35], [3, 43], [16, 48], [28, 46],
                            [40, 48], [45, 41], [60, 41], [60, 70],
                            [20, 70], [10, 60], [-5, 55], [-10, 45],
                            [-10, 35]
                        ]]
                    }
                },
                // Asia (simplified outline)
                {
                    type: "Feature",
                    geometry: {
                        type: "Polygon",
                        coordinates: [[
                            [28, 46], [40, 48], [45, 41], [60, 41],
                            [75, 43], [85, 28], [100, 20], [110, 10],
                            [120, 20], [130, 45], [140, 50], [150, 60],
                            [170, 65], [180, 70], [180, 10], [140, -10],
                            [120, -10], [110, 0], [100, -10], [80, -5],
                            [70, 0], [60, -10], [40, -10], [30, -5],
                            [20, 5], [10, 15], [5, 25], [15, 35],
                            [28, 46]
                        ]]
                    }
                },
                // North America (simplified outline)
                {
                    type: "Feature",
                    geometry: {
                        type: "Polygon",
                        coordinates: [[
                            [-170, 70], [-140, 70], [-130, 55], [-120, 50],
                            [-110, 50], [-100, 49], [-90, 50], [-80, 45],
                            [-75, 44], [-70, 44], [-65, 48], [-60, 50],
                            [-55, 51], [-50, 55], [-45, 60], [-40, 65],
                            [-35, 65], [-30, 60], [-25, 55], [-20, 50],
                            [-15, 45], [-10, 40], [-10, 25], [-20, 20],
                            [-30, 15], [-40, 10], [-50, 5], [-60, 0],
                            [-70, -5], [-80, -10], [-90, -10], [-100, -5],
                            [-110, 0], [-120, 10], [-130, 20], [-140, 30],
                            [-150, 40], [-160, 50], [-170, 60], [-170, 70]
                        ]]
                    }
                },
                // South America (simplified outline)
                {
                    type: "Feature",
                    geometry: {
                        type: "Polygon",
                        coordinates: [[
                            [-80, -10], [-70, -10], [-60, -15], [-50, -20],
                            [-40, -20], [-30, -15], [-20, -10], [-10, -5],
                            [0, 0], [10, 5], [20, 10], [30, 15],
                            [40, 20], [50, 25], [55, -10], [50, -20],
                            [40, -30], [30, -40], [20, -50], [10, -55],
                            [0, -55], [-10, -50], [-20, -45], [-30, -40],
                            [-40, -35], [-50, -30], [-60, -25], [-70, -20],
                            [-80, -15], [-80, -10]
                        ]]
                    }
                },
                // Australia (simplified outline)
                {
                    type: "Feature",
                    geometry: {
                        type: "Polygon",
                        coordinates: [[
                            [110, -10], [120, -10], [130, -25], [140, -35],
                            [150, -40], [155, -30], [150, -20], [145, -10],
                            [140, 0], [135, 10], [130, 15], [125, 20],
                            [120, 25], [115, 30], [110, 35], [105, 30],
                            [100, 25], [95, 20], [90, 15], [85, 10],
                            [80, 5], [75, 0], [70, -5], [65, -10],
                            [60, -15], [65, -25], [70, -35], [75, -40],
                            [80, -45], [85, -45], [90, -40], [95, -35],
                            [100, -30], [105, -25], [110, -20], [110, -10]
                        ]]
                    }
                },
                // Antarctica (simplified outline)
                {
                    type: "Feature",
                    geometry: {
                        type: "Polygon",
                        coordinates: [[
                            [-180, -60], [-120, -60], [-60, -60], [0, -60],
                            [60, -60], [120, -60], [180, -60], [180, -85],
                            [120, -85], [60, -85], [0, -85], [-60, -85],
                            [-120, -85], [-180, -85], [-180, -60]
                        ]]
                    }
                }
            ]
        };
        
        // Draw the world map
        this.drawWorldMap();
    }
    
    // Draw the world map from the data
    drawWorldMap() {
        this.landGroup.clear();
        this.coastlineGroup.clear();
        this.countryGroup.clear();
        
        // Draw each continent
        this.mapData.features.forEach((feature, index) => {
            const coordinates = feature.geometry.coordinates[0];
            const points = [];
            
            // Convert geographic coordinates to projected coordinates
            for (const coord of coordinates) {
                const [lon, lat] = coord;
                const projected = this.forwardProjection(lat, lon);
                if (projected) {
                    points.push([projected.x, projected.y]);
                }
            }
            
            // Draw the polygon
            if (points.length > 2) {
                // Draw land mass
                const polygon = this.landGroup.polygon(points).fill({
                    color: 'rgba(30, 70, 120, 0.6)',
                    opacity: 0.6
                }).stroke({
                    color: 'rgba(20, 50, 90, 0.8)',
                    width: 1
                });
                
                // Draw coastline
                this.coastlineGroup.polyline(points).stroke({
                    color: 'rgba(40, 90, 160, 0.8)',
                    width: 1.5
                }).fill('none');
                
                this.countryPaths.push({
                    element: polygon,
                    points: points
                });
            }
        });
    }
    
    // Handle map click for inverse projection
    handleMapClick(event) {
        const rect = this.svg.node.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;
        
        // Convert screen coordinates to map coordinates
        const mapX = (clickX / this.currentTransform.scale) - this.currentTransform.x;
        const mapY = (clickY / this.currentTransform.scale) - this.currentTransform.y;
        
        // Update screen coordinates display
        document.getElementById('screen-coords').textContent = 
            `${Math.round(clickX)}, ${Math.round(clickY)}`;
        
        document.getElementById('projected-coords').textContent = 
            `${mapX.toFixed(2)}, ${mapY.toFixed(2)}`;
        
        // Perform inverse projection
        const geoCoords = this.inverseProjection(mapX, mapY);
        
        if (geoCoords) {
            // Update geographic coordinates display
            document.getElementById('geo-coords').textContent = 
                `${geoCoords.lat.toFixed(4)}°, ${geoCoords.lon.toFixed(4)}°`;
            
            // Try to determine location name
            const locationName = this.getLocationName(geoCoords.lat, geoCoords.lon);
            document.getElementById('location-name').textContent = locationName;
        }
    }
    
    // Get a descriptive name for a location (simplified)
    getLocationName(lat, lon) {
        // Simple region detection
        if (lat > 66.5) return "Arctic Region";
        if (lat < -66.5) return "Antarctic Region";
        
        // Ocean detection
        if (this.isOcean(lat, lon)) {
            if (lat > 0 && lon > -80 && lon < 40) return "North Atlantic Ocean";
            if (lat > 0 && lon > 100 && lon < 180) return "North Pacific Ocean";
            if (lat < 0 && lon > -80 && lon < 40) return "South Atlantic Ocean";
            if (lat < 0 && lon > 100 && lon < 180) return "South Pacific Ocean";
            if (lon > 40 && lon < 100) return "Indian Ocean";
            return "Ocean";
        }
        
        // Continent detection
        if (lat > 10 && lon > -20 && lon < 60) return "Africa";
        if (lat > 35 && lon > -10 && lon < 60) return "Europe";
        if (lat > 10 && lon > 60 && lon < 180) return "Asia";
        if (lat > 10 && lon < -30 && lon > -170) return "North America";
        if (lat < 10 && lon < -30 && lon > -90) return "South America";
        if (lat < 0 && lon > 110 && lon < 180) return "Australia";
        
        return "Land";
    }
    
    // Simple check if a point is in ocean (very simplified)
    isOcean(lat, lon) {
        // This is a very simplified check
        // In a real application, you would use proper polygon intersection tests
        
        // Check if point is in one of our simplified continents
        for (const feature of this.mapData.features) {
            const coordinates = feature.geometry.coordinates[0];
            if (this.pointInPolygon(lon, lat, coordinates)) {
                return false;
            }
        }
        
        return true;
    }
    
    // Point in polygon test (ray casting algorithm)
    pointInPolygon(x, y, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i][0], yi = polygon[i][1];
            const xj = polygon[j][0], yj = polygon[j][1];
            
            const intersect = ((yi > y) !== (yj > y)) &&
                (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }
    
    // Add a marker to the map
    addMarker(lat, lon, name = "") {
        // Generate a unique ID for the marker
        const id = `marker-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        
        // Forward project the coordinates
        const projected = this.forwardProjection(lat, lon);
        
        if (!projected) {
            alert("Invalid coordinates. Latitude must be between -90 and 90, longitude between -180 and 180.");
            return null;
        }
        
        // Create marker element
        const markerGroup = this.markerGroup.group();
        
        // Draw marker circle
        const circle = markerGroup.circle(10)
            .center(projected.x, projected.y)
            .fill({
                color: '#ff4757',
                opacity: 0.8
            })
            .stroke({
                color: '#ffffff',
                width: 2
            });
        
        // Draw a pointer triangle
        const triangle = markerGroup.polygon([
            [projected.x, projected.y + 5],
            [projected.x - 5, projected.y + 15],
            [projected.x + 5, projected.y + 15]
        ]).fill('#ff4757');
        
        // Add marker name if provided
        if (name) {
            const text = markerGroup.text(name)
                .center(projected.x, projected.y + 25)
                .font({
                    family: 'Arial, sans-serif',
                    size: 12,
                    anchor: 'middle',
                    weight: 'bold'
                })
                .fill('#ffffff');
            
            // Add background to text for better readability
            const bbox = text.bbox();
            const textBg = markerGroup.rect(bbox.width + 8, bbox.height + 4)
                .center(projected.x, projected.y + 25)
                .fill('rgba(0, 0, 0, 0.6)')
                .radius(3)
                .back();
        }
        
        // Make marker clickable to center map on it
        markerGroup.on('click', (event) => {
            event.stopPropagation();
            this.centerOnCoordinates(lat, lon);
        });
        
        // Add to markers array
        const marker = {
            id: id,
            lat: lat,
            lon: lon,
            name: name || `Marker at ${lat.toFixed(2)}°, ${lon.toFixed(2)}°`,
            element: markerGroup,
            projected: projected
        };
        
        this.markers.push(marker);
        
        // Update marker list in UI
        this.updateMarkerList();
        
        return marker;
    }
    
    // Center map on specific coordinates
    centerOnCoordinates(lat, lon) {
        const projected = this.forwardProjection(lat, lon);
        
        if (!projected) return;
        
        // Get map container dimensions
        const mapWidth = this.svg.width();
        const mapHeight = this.svg.height();
        
        // Calculate new transform to center on the point
        this.currentTransform.x = (mapWidth / (2 * this.currentTransform.scale)) - projected.x;
        this.currentTransform.y = (mapHeight / (2 * this.currentTransform.scale)) - projected.y;
        
        this.updateMapTransform();
    }
    
    // Update the marker list in the UI
    updateMarkerList() {
        const markerList = document.getElementById('marker-list');
        
        if (this.markers.length === 0) {
            markerList.innerHTML = `
                <div class="marker-item" style="text-align: center; color: #8ab4f8; padding: 20px;">
                    No markers yet. Add one using the form above.
                </div>
            `;
            return;
        }
        
        // Clear the list
        markerList.innerHTML = '';
        
        // Add each marker to the list
        this.markers.forEach((marker, index) => {
            const markerItem = document.createElement('div');
            markerItem.className = 'marker-item';
            markerItem.innerHTML = `
                <div class="marker-info">
                    <div class="marker-name">${marker.name}</div>
                    <div class="marker-coords">${marker.lat.toFixed(4)}°, ${marker.lon.toFixed(4)}°</div>
                </div>
                <div class="marker-actions">
                    <button class="marker-action-btn" data-action="center" data-index="${index}">Center</button>
                    <button class="marker-action-btn" data-action="delete" data-index="${index}">Delete</button>
                </div>
            `;
            
            markerList.appendChild(markerItem);
        });
        
        // Add event listeners to the buttons
        markerList.querySelectorAll('[data-action="center"]').forEach(button => {
            button.addEventListener('click', (event) => {
                const index = parseInt(event.target.getAttribute('data-index'));
                const marker = this.markers[index];
                this.centerOnCoordinates(marker.lat, marker.lon);
            });
        });
        
        markerList.querySelectorAll('[data-action="delete"]').forEach(button => {
            button.addEventListener('click', (event) => {
                const index = parseInt(event.target.getAttribute('data-index'));
                this.removeMarker(index);
            });
        });
    }
    
    // Remove a marker
    removeMarker(index) {
        if (index >= 0 && index < this.markers.length) {
            // Remove from SVG
            this.markers[index].element.remove();
            // Remove from array
            this.markers.splice(index, 1);
            // Update UI
            this.updateMarkerList();
        }
    }
    
    // Clear all markers
    clearMarkers() {
        // Remove all markers from SVG
        this.markers.forEach(marker => marker.element.remove());
        // Clear the array
        this.markers = [];
        // Update UI
        this.updateMarkerList();
    }
    
    // Add some example markers
    addExampleMarkers() {
        // Add a few example markers for major cities
        const exampleMarkers = [
            { lat: 40.7128, lon: -74.0060, name: "New York City" },
            { lat: 51.5074, lon: -0.1278, name: "London" },
            { lat: 35.6762, lon: 139.6503, name: "Tokyo" },
            { lat: -33.8688, lon: 151.2093, name: "Sydney" },
            { lat: 0, lon: 0, name: "Null Island" }
        ];
        
        // Add them after a short delay
        setTimeout(() => {
            exampleMarkers.forEach(marker => {
                this.addMarker(marker.lat, marker.lon, marker.name);
            });
        }, 500);
    }
    
    // Set up event listeners for UI controls
    setupEventListeners() {
        // Add marker button
        document.getElementById('add-marker').addEventListener('click', () => {
            const lat = parseFloat(document.getElementById('latitude').value);
            const lon = parseFloat(document.getElementById('longitude').value);
            const name = document.getElementById('marker-name').value;
            
            if (isNaN(lat) || isNaN(lon)) {
                alert("Please enter valid numeric coordinates.");
                return;
            }
            
            if (lat < -90 || lat > 90) {
                alert("Latitude must be between -90 and 90 degrees.");
                return;
            }
            
            if (lon < -180 || lon > 180) {
                alert("Longitude must be between -180 and 180 degrees.");
                return;
            }
            
            this.addMarker(lat, lon, name);
            
            // Clear the name field
            document.getElementById('marker-name').value = '';
        });
        
        // Center on coordinates button
        document.getElementById('center-on-coords').addEventListener('click', () => {
            const lat = parseFloat(document.getElementById('latitude').value);
            const lon = parseFloat(document.getElementById('longitude').value);
            
            if (isNaN(lat) || isNaN(lon)) {
                alert("Please enter valid numeric coordinates.");
                return;
            }
            
            if (lat < -90 || lat > 90) {
                alert("Latitude must be between -90 and 90 degrees.");
                return;
            }
            
            if (lon < -180 || lon > 180) {
                alert("Longitude must be between -180 and 180 degrees.");
                return;
            }
            
            this.centerOnCoordinates(lat, lon);
        });
        
        // Reset view button
        document.getElementById('reset-view').addEventListener('click', () => {
            this.resetView();
        });
        
        // Toggle grid button
        document.getElementById('toggle-grid').addEventListener('click', () => {
            this.showGrid = !this.showGrid;
            this.drawGraticule();
            document.getElementById('toggle-grid').textContent = 
                this.showGrid ? 'Hide Grid' : 'Show Grid';
        });
        
        // Clear markers button
        document.getElementById('clear-markers').addEventListener('click', () => {
            this.clearMarkers();
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            // Don't trigger if user is typing in an input field
            if (event.target.tagName === 'INPUT') return;
            
            switch (event.key) {
                case 'r':
                case 'R':
                    this.resetView();
                    break;
                case 'g':
                case 'G':
                    this.showGrid = !this.showGrid;
                    this.drawGraticule();
                    document.getElementById('toggle-grid').textContent = 
                        this.showGrid ? 'Hide Grid' : 'Show Grid';
                    break;
                case 'c':
                case 'C':
                    this.clearMarkers();
                    break;
                case '+':
                case '=':
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        // Zoom in
                        this.currentTransform.scale *= 1.2;
                        this.updateMapTransform();
                    }
                    break;
                case '-':
                case '_':
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        // Zoom out
                        this.currentTransform.scale *= 0.8;
                        this.updateMapTransform();
                    }
                    break;
            }
        });
        
        // Allow Enter key to add marker
        document.getElementById('latitude').addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                document.getElementById('add-marker').click();
            }
        });
        
        document.getElementById('longitude').addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                document.getElementById('add-marker').click();
            }
        });
        
        document.getElementById('marker-name').addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                document.getElementById('add-marker').click();
            }
        });
    }
}

// Initialize the application when the page loads
window.addEventListener('DOMContentLoaded', () => {
    const mapApp = new EqualEarthMap();
    
    // Make the app available globally for debugging
    window.mapApp = mapApp;
});
    </script>
</body>
</html>