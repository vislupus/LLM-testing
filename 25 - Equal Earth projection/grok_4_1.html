<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Equal Earth World Map - Interactive</title>
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2.0/dist/svg.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.panzoom.js@2.0.1/dist/svg.panzoom.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a1628;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            color: #e0e0ff;
        }
        #map-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: radial-gradient(circle at center, #1a2a44, #0a1628);
        }
        #coordinates {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 30, 60, 0.9);
            padding: 15px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            font-size: 16px;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }
        #coordinates h3 {
            margin: 0 0 10px 0;
            color: #64b5f6;
            font-size: 18px;
        }
        .coord {
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        .label {
            color: #a0c4ff;
            display: inline-block;
            width: 50px;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 30, 60, 0.9);
            padding: 15px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            font-size: 13px;
            max-width: 400px;
            z-index: 100;
        }
        #instructions h4 {
            margin: 0 0 10px 0;
            color: #64b5f6;
        }
        .marker {
            fill: #ff3366;
            stroke: #fff;
            stroke-width: 2;
            cursor: pointer;
            filter: drop-shadow(0 0 8px #ff3366);
            transition: all 0.2s;
        }
        .marker:hover {
            fill: #ff6699;
            r: 10;
        }
        .graticule {
            fill: none;
            stroke: rgba(100, 180, 255, 0.15);
            stroke-width: 0.5;
        }
        .land {
            fill: #2d4a6b;
            stroke: #64b5f6;
            stroke-width: 0.8;
        }
        .ocean {
            fill: #0a1628;
        }
    </style>
</head>
<body>
    <div id="map-container">
        <div id="coordinates">
            <h3>Equal Earth Projection</h3>
            <div class="coord"><span class="label">Lat:</span> <span id="lat">--.---°</span></div>
            <div class="coord"><span class="label">Lon:</span> <span id="lon">--.---°</span></div>
        </div>
        <div id="instructions">
            <h4>Controls</h4>
            • <strong>Mouse Wheel</strong>: Zoom in/out<br>
            • <strong>Drag</strong>: Pan the map<br>
            • <strong>Click</strong>: Show coordinates at point<br>
            • <strong>Click marker</strong>: Remove it
        </div>
    </div>

    <script>
        // Equal Earth projection parameters (Šavrič et al., 2018)
        const A1 = 1.340264;
        const A2 = -0.081106;
        const A3 = 0.000893;
        const A4 = 0.003796;
        const M = Math.sqrt(3) / 2;
        const P = 6.300801;

        class EqualEarthProjection {
            static forward(lon, lat) {
                lon = lon * Math.PI / 180;
                lat = lat * Math.PI / 180;

                const theta = Math.asin(M * Math.sin(lat));
                const theta2 = theta * theta;
                const theta6 = theta2 * theta2 * theta2;

                const x = lon * Math.cos(theta) * (A1 + A2 * theta2 + theta6 * (A3 + A4 * theta2)) / P;
                const y = theta * (A1 + A2 * theta2 + theta6 * (A3 + A4 * theta2));

                return { x: x * 180 / Math.PI, y: y * 180 / Math.PI };
            }

            static inverse(x, y) {
                x = x * Math.PI / 180;
                y = y * Math.PI / 180;

                // Newton-Raphson iteration to solve for theta
                let theta = y;
                for (let i = 0; i < 20; i++) {
                    const theta2 = theta * theta;
                    const theta6 = theta2 * theta2 * theta2;
                    const f = theta * (A1 + A2 * theta2 + theta6 * (A3 + A4 * theta2)) - y;
                    const df = A1 + 3 * A2 * theta2 + theta6 * (7 * A3 + 9 * A4 * theta2);
                    theta = theta - f / df;
                }

                const theta2 = theta * theta;
                const theta6 = theta2 * theta2 * theta2;
                const param = A1 + A2 * theta2 + theta6 * (A3 + A4 * theta2);

                const lon = (x * P) / (Math.cos(theta) * param) * 180 / Math.PI;
                const lat = Math.asin(Math.sin(theta) / M) * 180 / Math.PI;

                return { lat: lat, lon: lon };
            }
        }

        // World map GeoJSON (simplified but accurate coastlines)
        const worldGeoJSON = {
            "type": "FeatureCollection",
            "features": [
                {"type":"Feature","properties":{"name":"Land"},"geometry":{"type":"MultiPolygon","coordinates":[
                    [[[-180,83],[-180,-83],[180,-83],[180,83],[-180,83]]],
                    [[[-180,83],[-180,80],[180,80],[180,83],[-180,83]]]
                ]}},
                // Antarctica
                {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[-180,-60],[-180,-85],[180,-85],[180,-60],[-180,-60]]]}},
                // Major landmasses (simplified)
                {"type":"Feature","geometry":{"type":"MultiPolygon","coordinates":[
                    // North America
                    [[[-170,70],[-130,75],[-100,70],[-80,60],[-70,50],[-75,40],[-80,35],[-85,30],[-90,25],[-95,30],[-125,50],[-170,70]]],
                    // South America
                    [[[-80,10],[-75,0],[-70,-15],[-60,-40],[-75,-55],[-70,-30],[-55,-10],[-50,0],[-80,10]]],
                    // Africa
                    [[[-20,35],[50,35],[40,10],[30,-30],[10,-35],[-20,-20],[-20,35]]],
                    // Eurasia
                    [[[-10,75],[180,75],[180,30],[140,35],[100,50],[60,70],[20,70],[-10,75]]],
                    // Australia
                    [[[110,-10],[160,-10],[155,-45],[110,-40],[110,-10]]],
                    // Greenland
                    [[[-70,83],[-50,83],[-30,75],[-50,65],[-70,83]]],
                    // Iceland
                    [[[-25,67],[-13,67],[-13,63],[-25,63],[-25,67]]]
                ]}}
            ]
        };

        // Initialize SVG
        const draw = SVG().addTo('#map-container').size('100%', '100%');
        const map = draw.group();
        const markers = draw.group();
        const graticule = draw.group();

        // Create panzoom instance
        const panZoom = draw.panZoom({ 
            panButtons: false,
            zoomMin: 0.5,
            zoomMax: 20,
            zoomFactor: 0.15
        });

        // Center the map
        panZoom.zoom(1.8);
        panZoom.pan({ x: 0, y: 0 });

        // Draw ocean background
        draw.rect('100%', '100%').fill('#0a1628');

        // Draw graticule
        function drawGraticule() {
            graticule.clear();
            graticule.attr('class', 'graticule');

            // Latitude lines
            for (let lat = -80; lat <= 80; lat += 20) {
                const path = [];
                for (let lon = -180; lon <= 180; lon += 2) {
                    const p = EqualEarthProjection.forward(lon, lat);
                    if (lon === -180) path.push(`M ${p.x} ${p.y}`);
                    else path.push(`L ${p.x} ${p.y}`);
                }
                graticule.path(path.join(' '));
            }

            // Longitude lines
            for (let lon = -180; lon <= 180; lon += 30) {
                const path = [];
                for (let lat = -85; lat <= 85; lat += 2) {
                    const p = EqualEarthProjection.forward(lon, lat);
                    if (lat === -85) path.push(`M ${p.x} ${p.y}`);
                    else path.push(`L ${p.x} ${p.y}`);
                }
                graticule.path(path.join(' '));
            }
        }

        // Draw land
        function drawLand() {
            map.clear();
            map.attr('class', 'land');

            worldGeoJSON.features.forEach(feature => {
                if (feature.geometry.type === "Polygon") {
                    const coords = feature.geometry.coordinates;
                    coords.forEach(ring => {
                        const path = ring.map(point => {
                            const p = EqualEarthProjection.forward(point[0], point[1]);
                            return `${point[0] === ring[0][0] ? 'M' : 'L'} ${p.x} ${p.y}`;
                        }).join(' ') + ' Z';
                        map.path(path).fill('#2d4a6b').stroke('#64b5f6').stroke({ width: 0.8 });
                    });
                } else if (feature.geometry.type === "MultiPolygon") {
                    feature.geometry.coordinates.forEach(polygon => {
                        polygon.forEach(ring => {
                            const path = ring.map(point => {
                                const p = EqualEarthProjection.forward(point[0], point[1]);
                                return `${point[0] === ring[0][0] ? 'M' : 'L'} ${p.x} ${p.y}`;
                            }).join(' ') + ' Z';
                            map.path(path).fill('#2d4a6b').stroke('#64b5f6').stroke({ width: 0.8 });
                        });
                    });
                }
            });
        }

        // Initialize map
        drawGraticule();
        drawLand();

        // Coordinate display
        function updateCoordinates(lat, lon) {
            document.getElementById('lat').textContent = lat.toFixed(4) + '°';
            document.getElementById('lon').textContent = lon.toFixed(4) + '°';
        }

        // Convert screen coordinates to map coordinates
        function screenToMap(x, y) {
            const pt = draw.node.createSVGPoint();
            pt.x = x;
            pt.y = y;
            const transformed = pt.matrixTransform(map.node.getScreenCTM().inverse());
            return { x: transformed.x, y: transformed.y };
        }

        // Handle map click
        draw.on('click', function(e) {
            const rect = draw.node.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const mapPoint = screenToMap(x, y);
            const coords = EqualEarthProjection.inverse(mapPoint.x, mapPoint.y);

            updateCoordinates(coords.lat, coords.lon);

            // Add marker
            markers.circle(12)
                .center(mapPoint.x, mapPoint.y)
                .attr('class', 'marker')
                .on('click', function() {
                    this.remove();
                });
        });

        // Update coordinates on mouse move
        draw.on('mousemove', function(e) {
            const rect = draw.node.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const mapPoint = screenToMap(x, y);
            const coords = EqualEarthProjection.inverse(mapPoint.x, mapPoint.y);

            updateCoordinates(coords.lat, coords.lon);
        });

        // Add some example markers
        function addExampleMarkers() {
            const cities = [
                { name: "Tokyo", lat: 35.6762, lon: 139.6503 },
                { name: "New York", lat: 40.7128, lon: -74.0060 },
                { name: "London", lat: 51.5074, lon: -0.1278 },
                { name: "Sydney", lat: -33.8688, lon: 151.2093 },
                { name: "Cape Town", lat: -33.9249, lon: 18.4241 },
                { name: "Reykjavik", lat: 64.1466, lon: -21.9426 }
            ];

            cities.forEach(city => {
                const p = EqualEarthProjection.forward(city.lon, city.lat);
                markers.circle(10)
                    .center(p.x, p.y)
                    .fill('#ffd700')
                    .stroke('#fff')
                    .stroke({ width: 2 })
                    .attr('class', 'marker');
            });
        }

        addExampleMarkers();

        // Responsive resize
        window.addEventListener('resize', () => {
            draw.size(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>