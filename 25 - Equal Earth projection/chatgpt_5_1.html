<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Equal Earth Projection – SVG.js Interactive Map</title>
  <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2/dist/svg.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #dde6f2;
    }
    #map {
      width: 100vw;
      height: 100vh;
    }
    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.65);
      color: #f5f5f5;
      padding: 10px 12px;
      border-radius: 4px;
      font-size: 12px;
      line-height: 1.4;
      max-width: 280px;
      z-index: 10;
    }
    #ui h1 {
      margin: 0 0 6px 0;
      font-size: 14px;
      font-weight: 600;
    }
    #coords {
      font-family: "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      margin: 4px 0 8px 0;
      font-size: 11px;
    }
    #ui label {
      display: inline-block;
      margin-right: 4px;
      margin-bottom: 4px;
    }
    #ui input[type="number"] {
      width: 80px;
      font-size: 11px;
      padding: 2px 3px;
      margin-left: 2px;
    }
    #ui button {
      margin-top: 4px;
      width: 100%;
      padding: 4px 0;
      font-size: 11px;
      border: none;
      border-radius: 3px;
      background: #4fc3f7;
      color: #002b36;
      font-weight: 600;
      cursor: pointer;
    }
    #ui button:hover {
      background: #81d4fa;
    }
    #ui small {
      color: #d0d0d0;
      font-size: 11px;
      display: block;
      margin-top: 6px;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="ui">
    <h1>Equal Earth Interactive Map</h1>
    <div id="coords">Lat: --°, Lon: --°</div>
    <div>
      <label>Lat
        <input id="latInput" type="number" min="-90" max="90" step="0.1" value="0">
      </label>
      <label>Lon
        <input id="lonInput" type="number" min="-180" max="180" step="0.1" value="0">
      </label>
      <button id="addMarkerBtn">Add marker at lat/lon</button>
    </div>
    <small>
      • Mouse wheel: zoom<br>
      • Drag: pan<br>
      • Click map: show lat/lon (inverse projection)<br>
      Projection: Equal Earth
    </small>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', function () {

    // --- Equal Earth projection constants ---
    const A1 = 1.340264;
    const A2 = -0.081106;
    const A3 = 0.000893;
    const A4 = 0.003796;
    const SQRT3 = Math.sqrt(3);
    const K = SQRT3 / 2;

    // Approximate extents of Equal Earth world (for initial scaling)
    const WORLD_X_MAX = 0.86158;
    const WORLD_Y_MAX = 1.316;

    // --- Projection: forward (lat, lon in degrees -> x, y in projection units) ---
    function equalEarthForward(lonDeg, latDeg) {
      const lambda = lonDeg * Math.PI / 180;
      const phi = latDeg * Math.PI / 180;

      const sinPhi = Math.sin(phi);
      const theta = Math.asin(K * sinPhi);
      const theta2 = theta * theta;
      const theta4 = theta2 * theta2;
      const theta6 = theta4 * theta2;

      const denom = SQRT3 * (A1 + 3 * A2 * theta2 + 5 * A3 * theta4 + 7 * A4 * theta6);
      const x = 2 * Math.cos(theta) * Math.sin(lambda / 2) / denom;
      const y = theta * (A1 + A2 * theta2 + A3 * theta4 + A4 * theta6);

      return { x, y };
    }

    // --- Projection: inverse (x, y in projection units -> lon, lat in degrees) ---
    function equalEarthInverse(x, y) {
      // Solve for theta via Newton–Raphson from y = theta * (A1 + A2θ² + A3θ⁴ + A4θ⁶)
      let theta = y;
      for (let i = 0; i < 10; i++) {
        const t2 = theta * theta;
        const t4 = t2 * t2;
        const t6 = t4 * t2;

        const P = A1 + A2 * t2 + A3 * t4 + A4 * t6;
        const F = A1 + 3 * A2 * t2 + 5 * A3 * t4 + 7 * A4 * t6; // derivative y'(theta)

        const fy = theta * P - y;
        theta -= fy / F;
      }

      const sinTheta = Math.sin(theta);
      let sinPhi = (2 / SQRT3) * sinTheta;
      if (sinPhi > 1) sinPhi = 1;
      if (sinPhi < -1) sinPhi = -1;
      const phi = Math.asin(sinPhi);

      const t2 = theta * theta;
      const t4 = t2 * t2;
      const t6 = t4 * t2;
      const F2 = A1 + 3 * A2 * t2 + 5 * A3 * t4 + 7 * A4 * t6;

      const cosTheta = Math.cos(theta);
      let arg = (SQRT3 * F2 * x) / (2 * cosTheta);
      if (arg > 1) arg = 1;
      if (arg < -1) arg = -1;
      const lambda = 2 * Math.asin(arg);

      const lon = lambda * 180 / Math.PI;
      const lat = phi * 180 / Math.PI;
      return { lon, lat };
    }

    // --- SVG.js setup ---
    const draw = SVG().addTo('#map').size('100%', '100%');
    const svgEl = draw.node;

    // Get initial size and center
    const bbox = svgEl.getBoundingClientRect();
    let width = bbox.width || window.innerWidth;
    let height = bbox.height || window.innerHeight;
    let cx = width / 2;
    let cy = height / 2;

    let baseScale = 0.9 * Math.min(
      width / (2 * WORLD_X_MAX),
      height / (2 * WORLD_Y_MAX)
    );

    let zoom = 1.0;
    const MIN_ZOOM = 0.5;
    const MAX_ZOOM = 20;
    let panX = 0;
    let panY = 0;

    const gWorld = draw.group();
    const gGraticule = gWorld.group();
    const gLand = gWorld.group();
    const gMarkers = gWorld.group();

    function applyTransform() {
      const S = baseScale * zoom;
      // matrix(a b c d e f): [x', y'] = [a*x + c*y + e, b*x + d*y + f]
      const a = S;
      const b = 0;
      const c = 0;
      const d = -S; // flip Y so north is up
      const e = cx + panX;
      const f = cy + panY;
      gWorld.transform({ a, b, c, d, e, f });
    }

    function screenToWorld(sx, sy) {
      const S = baseScale * zoom;
      const x = (sx - (cx + panX)) / S;
      const y = -(sy - (cy + panY)) / S;
      return { x, y };
    }

    // --- Draw graticule (latitude/longitude grid) ---
    function drawGraticule() {
      // Vertical (constant longitude) lines
      for (let lon = -150; lon <= 150; lon += 30) {
        let d = '';
        let first = true;
        for (let lat = -89; lat <= 89; lat += 4) {
          const p = equalEarthForward(lon, lat);
          if (first) {
            d += `M${p.x},${p.y}`;
            first = false;
          } else {
            d += ` L${p.x},${p.y}`;
          }
        }
        const path = gGraticule.path(d)
          .fill('none')
          .stroke({ color: '#c7d9ef', width: 0.0015, opacity: 0.8 });
        path.attr({ 'vector-effect': 'non-scaling-stroke' });
      }

      // Horizontal (constant latitude) lines
      for (let lat = -60; lat <= 60; lat += 30) {
        let d = '';
        let first = true;
        for (let lon = -180; lon <= 180; lon += 4) {
          const p = equalEarthForward(lon, lat);
          if (first) {
            d += `M${p.x},${p.y}`;
            first = false;
          } else {
            d += ` L${p.x},${p.y}`;
          }
        }
        const path = gGraticule.path(d)
          .fill('none')
          .stroke({ color: '#c7d9ef', width: 0.0015, opacity: 0.8, dasharray: '0.01 0.01' });
        path.attr({ 'vector-effect': 'non-scaling-stroke' });
      }
    }

    // --- Very simplified land polygons (coarse but sufficient) ---
    const landPolygons = [
      {
        name: "Eurasia+Africa",
        coords: [
          { lon: -10, lat: 35 },
          { lon: -17, lat: 32 },
          { lon: -17, lat: 10 },
          { lon: 0, lat: 0 },
          { lon: 10, lat: 5 },
          { lon: 13, lat: -12 },
          { lon: 15, lat: -23 },
          { lon: 18, lat: -34 },
          { lon: 32, lat: -25 },
          { lon: 40, lat: -6 },
          { lon: 50, lat: 10 },
          { lon: 52, lat: 15 },
          { lon: 58, lat: 22 },
          { lon: 55, lat: 30 },
          { lon: 50, lat: 40 },
          { lon: 35, lat: 42 },
          { lon: 22, lat: 39 },
          { lon: 12, lat: 42 },
          { lon: 0, lat: 46 },
          { lon: -3, lat: 55 },
          { lon: 10, lat: 60 },
          { lon: 20, lat: 70 },
          { lon: 60, lat: 75 },
          { lon: 100, lat: 75 },
          { lon: 140, lat: 60 },
          { lon: 160, lat: 55 },
          { lon: 170, lat: 65 },
          { lon: 150, lat: 70 },
          { lon: 110, lat: 70 },
          { lon: 80, lat: 60 },
          { lon: 60, lat: 55 },
          { lon: 40, lat: 50 },
          { lon: 30, lat: 40 },
          { lon: 20, lat: 30 },
          { lon: 15, lat: 20 },
          { lon: 10, lat: 10 },
          { lon: 5, lat: 5 },
          { lon: 0, lat: 10 },
          { lon: -5, lat: 20 },
          { lon: -10, lat: 30 },
          { lon: -10, lat: 35 }
        ]
      },
      {
        name: "North America",
        coords: [
          { lon: -170, lat: 50 },
          { lon: -160, lat: 70 },
          { lon: -140, lat: 75 },
          { lon: -120, lat: 75 },
          { lon: -90, lat: 80 },
          { lon: -60, lat: 75 },
          { lon: -50, lat: 70 },
          { lon: -50, lat: 60 },
          { lon: -60, lat: 55 },
          { lon: -70, lat: 50 },
          { lon: -80, lat: 45 },
          { lon: -82, lat: 30 },
          { lon: -81, lat: 25 },
          { lon: -90, lat: 20 },
          { lon: -100, lat: 20 },
          { lon: -110, lat: 25 },
          { lon: -120, lat: 30 },
          { lon: -130, lat: 45 },
          { lon: -150, lat: 60 },
          { lon: -170, lat: 50 }
        ]
      },
      {
        name: "South America",
        coords: [
          { lon: -81, lat: 12 },
          { lon: -75, lat: 5 },
          { lon: -77, lat: 0 },
          { lon: -77, lat: -15 },
          { lon: -70, lat: -20 },
          { lon: -63, lat: -35 },
          { lon: -55, lat: -55 },
          { lon: -40, lat: -50 },
          { lon: -35, lat: -30 },
          { lon: -40, lat: -10 },
          { lon: -50, lat: 0 },
          { lon: -60, lat: 5 },
          { lon: -70, lat: 8 },
          { lon: -81, lat: 12 }
        ]
      },
      {
        name: "Australia",
        coords: [
          { lon: 130, lat: -10 },
          { lon: 115, lat: -20 },
          { lon: 115, lat: -30 },
          { lon: 135, lat: -35 },
          { lon: 150, lat: -35 },
          { lon: 155, lat: -25 },
          { lon: 152, lat: -15 },
          { lon: 145, lat: -10 },
          { lon: 140, lat: -5 },
          { lon: 130, lat: -10 }
        ]
      },
      {
        name: "Greenland",
        coords: [
          { lon: -75, lat: 60 },
          { lon: -60, lat: 70 },
          { lon: -45, lat: 83 },
          { lon: -30, lat: 75 },
          { lon: -20, lat: 65 },
          { lon: -40, lat: 60 },
          { lon: -60, lat: 58 },
          { lon: -75, lat: 60 }
        ]
      },
      {
        name: "Antarctica",
        coords: [
          { lon: -180, lat: -75 },
          { lon: -120, lat: -82 },
          { lon: -60, lat: -78 },
          { lon: 0, lat: -82 },
          { lon: 60, lat: -78 },
          { lon: 120, lat: -82 },
          { lon: 180, lat: -75 },
          { lon: 180, lat: -90 },
          { lon: -180, lat: -90 },
          { lon: -180, lat: -75 }
        ]
      }
    ];

    function drawLand() {
      landPolygons.forEach(poly => {
        let d = '';
        poly.coords.forEach((pt, idx) => {
          const p = equalEarthForward(pt.lon, pt.lat);
          if (idx === 0) {
            d += `M${p.x},${p.y}`;
          } else {
            d += ` L${p.x},${p.y}`;
          }
        });
        d += ' Z';
        const path = gLand.path(d)
          .fill('#d8e2f2')
          .stroke({ color: '#68768a', width: 0.003, linejoin: 'round', linecap: 'round' });
        path.attr({ 'vector-effect': 'non-scaling-stroke' });
      });
    }

    // Draw everything
    drawGraticule();
    drawLand();
    applyTransform();

    // --- Overlay for interaction (captures mouse events) ---
    const overlay = draw.rect('100%', '100%')
      .fill('transparent')
      .stroke({ width: 0, color: 'none' });
    overlay.attr({ 'pointer-events': 'all' });
    overlay.front();
    overlay.node.style.cursor = 'grab';

    // --- Zoom (mouse wheel) ---
    overlay.node.addEventListener('wheel', function (e) {
      e.preventDefault();
      const rect = svgEl.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;

      // World coordinates before zoom
      const worldBefore = screenToWorld(sx, sy);

      const factor = e.deltaY < 0 ? 1.1 : 0.9;
      let newZoom = zoom * factor;
      if (newZoom < MIN_ZOOM) newZoom = MIN_ZOOM;
      if (newZoom > MAX_ZOOM) newZoom = MAX_ZOOM;

      zoom = newZoom;

      // Adjust pan so point under cursor stays fixed
      const S = baseScale * zoom;
      panX = sx - cx - worldBefore.x * S;
      panY = sy - cy + worldBefore.y * S;

      applyTransform();
    }, { passive: false });

    // --- Pan (drag) ---
    let isDragging = false;
    let dragMoved = false;
    let lastClientX = 0;
    let lastClientY = 0;

    overlay.on('mousedown', function (event) {
      event.preventDefault();
      isDragging = true;
      dragMoved = false;
      lastClientX = event.clientX;
      lastClientY = event.clientY;
      overlay.node.style.cursor = 'grabbing';
    });

    document.addEventListener('mousemove', function (event) {
      if (!isDragging) return;
      const dx = event.clientX - lastClientX;
      const dy = event.clientY - lastClientY;
      if (Math.abs(dx) > 0 || Math.abs(dy) > 0) dragMoved = true;
      lastClientX = event.clientX;
      lastClientY = event.clientY;
      panX += dx;
      panY += dy;
      applyTransform();
    });

    document.addEventListener('mouseup', function (event) {
      if (!isDragging) return;
      isDragging = false;
      overlay.node.style.cursor = 'grab';
      if (!dragMoved) {
        handleClick(event);
      }
    });

    // --- Click -> inverse projection (show lat/lon) ---
    const coordsDiv = document.getElementById('coords');

    function handleClick(event) {
      const rect = svgEl.getBoundingClientRect();
      const sx = event.clientX - rect.left;
      const sy = event.clientY - rect.top;

      const world = screenToWorld(sx, sy);
      const geo = equalEarthInverse(world.x, world.y);

      // Normalize longitude to [-180, 180]
      let lon = geo.lon;
      lon = ((lon + 180) % 360 + 360) % 360 - 180;

      const lat = geo.lat;
      coordsDiv.textContent =
        `Lat: ${lat.toFixed(4)}°, Lon: ${lon.toFixed(4)}°`;
      console.log('Clicked coordinates:', { lat, lon });

      // Optional: temporary marker at click
      const marker = gMarkers.circle(0.018)
        .center(world.x, world.y)
        .fill('rgba(230,57,70,0.8)')
        .stroke({ color: '#ffffff', width: 0.004 });
      marker.attr({ 'vector-effect': 'non-scaling-stroke' });

      // Fade out and remove after ~2 seconds
      marker.animate(2000).attr({ opacity: 0 }).after(function () {
        this.remove();
      });
    }

    // --- UI: Add marker from lat/lon inputs (forward projection) ---
    const latInput = document.getElementById('latInput');
    const lonInput = document.getElementById('lonInput');
    const addMarkerBtn = document.getElementById('addMarkerBtn');

    function addMarkerFromInputs() {
      let lat = parseFloat(latInput.value);
      let lon = parseFloat(lonInput.value);
      if (isNaN(lat) || isNaN(lon)) return;

      if (lat > 90) lat = 90;
      if (lat < -90) lat = -90;
      // Normalize lon to [-180, 180]
      lon = ((lon + 180) % 360 + 360) % 360 - 180;

      const p = equalEarthForward(lon, lat);

      const marker = gMarkers.circle(0.02)
        .center(p.x, p.y)
        .fill('#ff5722')
        .stroke({ color: '#ffffff', width: 0.004 });
      marker.attr({ 'vector-effect': 'non-scaling-stroke' });

      coordsDiv.textContent =
        `Marker at Lat: ${lat.toFixed(4)}°, Lon: ${lon.toFixed(4)}°`;
    }

    addMarkerBtn.addEventListener('click', addMarkerFromInputs);
    lonInput.addEventListener('keydown', function (e) {
      if (e.key === 'Enter') addMarkerFromInputs();
    });
    latInput.addEventListener('keydown', function (e) {
      if (e.key === 'Enter') addMarkerFromInputs();
    });

    // Initial example marker at (0, 0)
    (function addInitialMarker() {
      const p = equalEarthForward(0, 0);
      const marker = gMarkers.circle(0.02)
        .center(p.x, p.y)
        .fill('#e91e63')
        .stroke({ color: '#ffffff', width: 0.004 });
      marker.attr({ 'vector-effect': 'non-scaling-stroke' });
      coordsDiv.textContent = 'Lat: 0.0000°, Lon: 0.0000°';
    })();

  });
  </script>
</body>
</html>