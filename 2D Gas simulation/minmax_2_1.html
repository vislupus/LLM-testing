<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Gas Simulation - Statistical Mechanics</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0 30px;
        }

        h1 {
            font-size: 2.2em;
            color: #00d9ff;
            margin-bottom: 8px;
            text-shadow: 0 0 20px rgba(0, 217, 255, 0.3);
        }

        .subtitle {
            color: #888;
            font-size: 1em;
        }

        .main-content {
            display: flex;
            gap: 25px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .simulation-container {
            background: #16213e;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 18px;
            min-width: 340px;
            max-width: 360px;
        }

        .panel {
            background: #16213e;
            border-radius: 16px;
            padding: 18px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .panel-title {
            color: #00d9ff;
            font-size: 1.1em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #0f3460;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-title::before {
            content: '';
            display: inline-block;
            width: 5px;
            height: 18px;
            background: linear-gradient(180deg, #00d9ff, #00b8d9);
            border-radius: 3px;
        }

        .control-group {
            margin-bottom: 16px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #bbb;
        }

        .control-value {
            color: #00d9ff;
            font-weight: 600;
            font-family: 'Consolas', monospace;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #0f3460;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00d9ff, #00b8d9);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.7);
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: #00d9ff;
            cursor: pointer;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            font-size: 0.95em;
            padding: 5px 0;
        }

        .button-row {
            display: flex;
            gap: 12px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 12px 18px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00d9ff, #00b8d9);
            color: #1a1a2e;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 217, 255, 0.4);
        }

        .btn-secondary {
            background: #0f3460;
            color: #eee;
        }

        .btn-secondary:hover {
            background: #1a4a7a;
            transform: translateY(-2px);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(15, 52, 96, 0.5);
            font-size: 0.9em;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #999;
        }

        .stat-value {
            color: #00d9ff;
            font-family: 'Consolas', monospace;
            font-weight: 600;
        }

        .stat-value.highlight {
            color: #4ecdc4;
        }

        .stat-value.warning {
            color: #ffd93d;
        }

        .stat-value.danger {
            color: #ff6b6b;
        }

        .histogram-wrapper {
            background: #0f3460;
            border-radius: 10px;
            padding: 10px;
            margin-top: 10px;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 12px;
            font-size: 0.85em;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 16px;
            height: 4px;
            border-radius: 2px;
        }

        .instructions {
            background: rgba(15, 52, 96, 0.5);
            border-radius: 10px;
            padding: 14px;
            margin-top: 10px;
            font-size: 0.85em;
            line-height: 1.8;
        }

        .instructions-title {
            color: #00d9ff;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .key {
            display: inline-block;
            background: rgba(0, 217, 255, 0.15);
            padding: 3px 10px;
            border-radius: 5px;
            font-family: 'Consolas', monospace;
            margin-right: 6px;
            border: 1px solid rgba(0, 217, 255, 0.3);
        }

        .species-indicator {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            font-size: 0.85em;
        }

        .species-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .species-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .species-dot.type-a {
            background: #ff6b6b;
            box-shadow: 0 0 8px rgba(255, 107, 107, 0.5);
        }

        .species-dot.type-b {
            background: #4ecdc4;
            box-shadow: 0 0 8px rgba(78, 205, 196, 0.5);
        }

        @media (max-width: 1250px) {
            .main-content {
                flex-direction: column;
                align-items: center;
            }

            .sidebar {
                width: 100%;
                max-width: 600px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>2D Ideal Gas Simulation</h1>
            <p class="subtitle">Exploring Statistical Mechanics Principles in Real-Time</p>
        </header>

        <div class="main-content">
            <div class="simulation-container">
                <div id="simulation"></div>
            </div>

            <div class="sidebar">
                <div class="panel">
                    <div class="panel-title">Simulation Parameters</div>

                    <div class="control-group">
                        <div class="control-label">
                            <span>Number of Particles</span>
                            <span class="control-value" id="particle-count-value">200</span>
                        </div>
                        <input type="range" id="particle-count" min="20" max="500" value="200" step="10">
                    </div>

                    <div class="control-group">
                        <div class="control-label">
                            <span>Initial Temperature</span>
                            <span class="control-value" id="temperature-value">298 K</span>
                        </div>
                        <input type="range" id="temperature" min="100" max="600" value="298">
                    </div>

                    <div class="control-group">
                        <div class="control-label">
                            <span>Box Width Factor</span>
                            <span class="control-value" id="box-scale-value">1.00</span>
                        </div>
                        <input type="range" id="box-scale" min="0.6" max="1.4" step="0.05" value="1.0">
                    </div>

                    <div class="control-group">
                        <div class="control-label">
                            <span>Mass Ratio (Species B/A)</span>
                            <span class="control-value" id="mass-ratio-value">2.00</span>
                        </div>
                        <input type="range" id="mass-ratio" min="0.5" max="4.0" step="0.25" value="2.0">
                    </div>

                    <div class="control-group">
                        <div class="control-label">
                            <span>Particle Radius</span>
                            <span class="control-value" id="radius-value">4 px</span>
                        </div>
                        <input type="range" id="radius" min="2" max="8" value="4">
                    </div>

                    <div class="control-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="collisions" checked>
                            <span>Enable Particle Collisions</span>
                        </label>
                    </div>

                    <div class="control-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="gravity">
                            <span>Enable Gravity (g = 9.8 m/s²)</span>
                        </label>
                    </div>

                    <div class="button-row">
                        <button class="btn-primary" id="reset-btn">Reset</button>
                        <button class="btn-secondary" id="pause-btn">Pause</button>
                    </div>

                    <div class="species-indicator">
                        <div class="species-item">
                            <div class="species-dot type-a"></div>
                            <span>Species A (lighter)</span>
                        </div>
                        <div class="species-item">
                            <div class="species-dot type-b"></div>
                            <span>Species B (heavier)</span>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-title">Macroscopic Properties</div>

                    <div class="stat-row">
                        <span class="stat-label">Temperature (KE avg)</span>
                        <span class="stat-value" id="stat-temp">0 K</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Pressure (P = F/A)</span>
                        <span class="stat-value" id="stat-pressure">0 Pa</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Total Kinetic Energy</span>
                        <span class="stat-value" id="stat-energy">0 J</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Mean Speed (⟨v⟩)</span>
                        <span class="stat-value highlight" id="stat-mean-speed">0 m/s</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">RMS Speed (v_rms)</span>
                        <span class="stat-value" id="stat-rms-speed">0 m/s</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Most Probable (v_mp)</span>
                        <span class="stat-value" id="stat-mp-speed">0 m/s</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Number Density (n)</span>
                        <span class="stat-value" id="stat-density">0 m⁻²</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Simulation Time</span>
                        <span class="stat-value" id="stat-time">0.0 s</span>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-title">Speed Distribution</div>
                    <div class="histogram-wrapper" id="histogram-container"></div>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff6b6b;"></div>
                            <span>Measured</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #00d9ff;"></div>
                            <span>Maxwell-Boltzmann</span>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-title">Keyboard Controls</div>
                    <div class="instructions">
                        <div><span class="key">Space</span> Pause / Resume</div>
                        <div><span class="key">R</span> Reset simulation</div>
                        <div><span class="key">C</span> Toggle collisions</div>
                        <div><span class="key">G</span> Toggle gravity</div>
                        <div><span class="key">↑</span> Increase temperature</div>
                        <div><span class="key">↓</span> Decrease temperature</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // 2D Gas Simulation - Statistical Mechanics
        // Accurate simulation of kinetic theory
        // ============================================

        // Physical constants
        const kB = 1.380649e-23;          // Boltzmann constant (J/K)
        const amu = 1.660539e-27;         // Atomic mass unit (kg)
        const PIXELS_PER_METER = 80;      // Scale: pixels to physical meters
        const TIME_SCALE = 1.5;           // Simulation speed multiplier

        // Simulation parameters (updated from UI)
        const params = {
            numParticles: 200,
            temperature: 298,
            boxScale: 1.0,
            massRatio: 2.0,
            radius: 4,
            collisions: true,
            gravity: false
        };

        // Box dimensions (in pixels)
        let box = {
            x: 40,
            y: 30,
            width: 520,
            height: 440
        };

        // Simulation state
        let particles = [];
        let paused = false;
        let simulationTime = 0;
        let momentumTransfer = { left: 0, right: 0, top: 0, bottom: 0 };
        let pressureHistory = [];
        const PRESSURE_SAMPLE_SIZE = 100;

        // ============================================
        // Particle Class
        // ============================================
        class Particle {
            constructor(x, y, vx, vy, mass, radius, type) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.mass = mass;           // In atomic mass units
                this.radius = radius;       // In pixels
                this.type = type;           // 'A' or 'B'
                this.massKg = mass * amu;   // Mass in kilograms
            }

            update(dt) {
                // Apply gravity if enabled (9.8 m/s² downward)
                if (params.gravity) {
                    this.vy += 9.8 * PIXELS_PER_METER * dt * TIME_SCALE;
                }

                // Update position using velocity
                this.x += this.vx * dt * TIME_SCALE;
                this.y += this.vy * dt * TIME_SCALE;

                // Handle wall collisions with momentum transfer
                this.handleWallCollisions();
            }

            handleWallCollisions() {
                // Perfectly elastic collision with walls (coefficient = 1.0)
                const elastic = 1.0;

                // Left wall
                if (this.x - this.radius < box.x) {
                    this.x = box.x + this.radius;
                    // Momentum transferred to wall: Δp = 2mv (for elastic collision)
                    momentumTransfer.left += 2 * this.massKg * Math.abs(this.vx) / PIXELS_PER_METER;
                    this.vx = -this.vx * elastic;
                }

                // Right wall
                if (this.x + this.radius > box.x + box.width) {
                    this.x = box.x + box.width - this.radius;
                    momentumTransfer.right += 2 * this.massKg * Math.abs(this.vx) / PIXELS_PER_METER;
                    this.vx = -this.vx * elastic;
                }

                // Top wall
                if (this.y - this.radius < box.y) {
                    this.y = box.y + this.radius;
                    momentumTransfer.top += 2 * this.massKg * Math.abs(this.vy) / PIXELS_PER_METER;
                    this.vy = -this.vy * elastic;
                }

                // Bottom wall
                if (this.y + this.radius > box.y + box.height) {
                    this.y = box.y + box.height - this.radius;
                    momentumTransfer.bottom += 2 * this.massKg * Math.abs(this.vy) / PIXELS_PER_METER;
                    this.vy = -this.vy * elastic;
                }
            }

            kineticEnergy() {
                // KE = ½mv² (in SI units)
                const speed = this.speed();
                return 0.5 * this.massKg * speed * speed / (PIXELS_PER_METER * PIXELS_PER_METER);
            }

            speed() {
                return Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            }

            draw() {
                // Set color based on species
                if (this.type === 'A') {
                    fill(255, 107, 107);
                    stroke(255, 150, 150);
                } else {
                    fill(78, 205, 196);
                    stroke(120, 230, 220);
                }

                strokeWeight(1);
                ellipse(this.x, this.y, this.radius * 2);
            }
        }

        // ============================================
        // Collision Detection and Response
        // ============================================
        function checkParticleCollisions() {
            if (!params.collisions) return;

            // O(n²) collision detection - acceptable for n ≤ 500
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    resolveCollision(particles[i], particles[j]);
                }
            }
        }

        function resolveCollision(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const minDist = p1.radius + p2.radius;

            // Check if particles are overlapping
            if (dist < minDist && dist > 0) {
                // Collision normal unit vector
                const nx = dx / dist;
                const ny = dy / dist;

                // Relative velocity
                const dvx = p1.vx - p2.vx;
                const dvy = p1.vy - p2.vy;

                // Relative velocity along collision normal
                const dvn = dvx * nx + dvy * ny;

                // Only resolve if particles are approaching
                if (dvn > 0) {
                    // Masses (in amu)
                    const m1 = p1.mass;
                    const m2 = p2.mass;

                    // Impulse scalar for elastic collision
                    // J = 2*m1*m2*dvn / (m1 + m2)
                    const impulse = (2 * dvn) / (m1 + m2);

                    // Update velocities (conserving momentum and KE)
                    p1.vx -= impulse * m2 * nx;
                    p1.vy -= impulse * m2 * ny;
                    p2.vx += impulse * m1 * nx;
                    p2.vy += impulse * m1 * ny;

                    // Separate particles to prevent overlap
                    const overlap = minDist - dist;
                    const separationX = overlap * nx * 0.5;
                    const separationY = overlap * ny * 0.5;

                    p1.x -= separationX;
                    p1.y -= separationY;
                    p2.x += separationX;
                    p2.y += separationY;
                }
            }
        }

        // ============================================
        // Initialization
        // ============================================
        function initializeParticles() {
            particles = [];

            const baseMass = 1.0;  // Species A mass in amu
            const radiusBase = params.radius;

            for (let i = 0; i < params.numParticles; i++) {
                // Alternate between species A and B
                const type = i < params.numParticles / 2 ? 'A' : 'B';
                const mass = type === 'A' ? baseMass : baseMass * params.massRatio;

                // Radius scales with cube root of mass (constant density)
                const radius = radiusBase * Math.pow(mass / baseMass, 1/3);

                // Random position within box (avoiding walls)
                const x = box.x + radius + Math.random() * (box.width - 2 * radius);
                const y = box.y + radius + Math.random() * (box.height - 2 * radius);

                // Initialize velocities from Maxwell-Boltzmann distribution
                // For 2D: v_x, v_y are Gaussian with σ = sqrt(kT/m)
                const sigma = Math.sqrt(kB * params.temperature / (mass * amu)) / PIXELS_PER_METER;
                const vx = randomGaussian(0, sigma * 1.5);  // 1.5σ for faster thermalization
                const vy = randomGaussian(0, sigma * 1.5);

                particles.push(new Particle(x, y, vx, vy, mass, radius, type));
            }

            // Reset simulation counters
            simulationTime = 0;
            momentumTransfer = { left: 0, right: 0, top: 0, bottom: 0 };
            pressureHistory = [];
        }

        function updateBoxDimensions() {
            box.width = 520 * params.boxScale;
            box.height = 440 * params.boxScale;
        }

        // ============================================
        // Statistical Calculations
        // ============================================
        function calculateStatistics() {
            let totalKE = 0;
            let totalMass = 0;
            let speeds = [];

            for (const p of particles) {
                const ke = p.kineticEnergy();
                totalKE += ke;
                totalMass += p.massKg;
                speeds.push(p.speed());
            }

            // Temperature from equipartition theorem
            // For 2D monatomic gas: ⟨KE⟩ = N × k_B × T
            // So T = ⟨KE⟩ / (N × k_B)
            const temperature = totalKE / (particles.length * kB);

            // Mean speed
            const meanSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;

            // RMS speed (root mean square)
            const rmsSpeed = Math.sqrt(speeds.reduce((sum, s) => sum + s * s, 0) / speeds.length);

            // Most probable speed for 2D Maxwell-Boltzmann
            // v_mp = sqrt(2kT/m_avg)
            const avgMass = totalMass / particles.length;
            const mpSpeed = Math.sqrt(2 * kB * temperature / avgMass) / PIXELS_PER_METER;

            // Particle density (number per square meter)
            const area = (box.width * box.height) / (PIXELS_PER_METER * PIXELS_PER_METER);
            const density = particles.length / area;

            // Pressure from wall momentum transfer
            // P = F/A = (momentum transfer rate) / area
            let pressure = 0;
            if (simulationTime > 0.1) {
                const totalMomentum = momentumTransfer.left + momentumTransfer.right +
                                     momentumTransfer.top + momentumTransfer.bottom;
                const perimeter = 2 * (box.width + box.height) / PIXELS_PER_METER;
                // Pressure = Force/Length in 2D (or Force/Area in 3D analogy)
                pressure = totalMomentum / (perimeter * simulationTime);
            }

            return {
                temperature,
                totalKE,
                meanSpeed,
                rmsSpeed,
                mpSpeed,
                density,
                pressure,
                speeds,
                simulationTime
            };
        }

        // 2D Maxwell-Boltzmann speed distribution PDF
        function maxwellBoltzmannPDF(speed, temperature, massAmu) {
            const mass = massAmu * amu;
            const sigma = Math.sqrt(kB * temperature / mass) / PIXELS_PER_METER;
            const x = speed / sigma;
            // 2D Maxwell-Boltzmann: P(v) = (v/σ²) × exp(-v²/(2σ²))
            return (speed / (sigma * sigma)) * Math.exp(-x * x / 2);
        }

        // ============================================
        // UI Setup
        // ============================================
        function setupUIListeners() {
            // Particle count slider
            document.getElementById('particle-count').addEventListener('input', function() {
                params.numParticles = parseInt(this.value);
                document.getElementById('particle-count-value').textContent = params.numParticles;
            });

            // Temperature slider
            document.getElementById('temperature').addEventListener('input', function() {
                params.temperature = parseInt(this.value);
                document.getElementById('temperature-value').textContent = params.temperature + ' K';
            });

            // Box scale slider
            document.getElementById('box-scale').addEventListener('input', function() {
                params.boxScale = parseFloat(this.value);
                document.getElementById('box-scale-value').textContent = params.boxScale.toFixed(2);
                updateBoxDimensions();
            });

            // Mass ratio slider
            document.getElementById('mass-ratio').addEventListener('input', function() {
                params.massRatio = parseFloat(this.value);
                document.getElementById('mass-ratio-value').textContent = params.massRatio.toFixed(2);
            });

            // Radius slider
            document.getElementById('radius').addEventListener('input', function() {
                params.radius = parseInt(this.value);
                document.getElementById('radius-value').textContent = params.radius + ' px';
            });

            // Collisions checkbox
            document.getElementById('collisions').addEventListener('change', function() {
                params.collisions = this.checked;
            });

            // Gravity checkbox
            document.getElementById('gravity').addEventListener('change', function() {
                params.gravity = this.checked;
            });

            // Reset button
            document.getElementById('reset-btn').addEventListener('click', function() {
                initializeParticles();
            });

            // Pause button
            document.getElementById('pause-btn').addEventListener('click', function() {
                paused = !paused;
                this.textContent = paused ? 'Resume' : 'Pause';
            });
        }

        function keyPressed() {
            if (key === ' ') {
                paused = !paused;
                document.getElementById('pause-btn').textContent = paused ? 'Resume' : 'Pause';
            } else if (key === 'r' || key === 'R') {
                initializeParticles();
            } else if (key === 'c' || key === 'C') {
                params.collisions = !params.collisions;
                document.getElementById('collisions').checked = params.collisions;
            } else if (key === 'g' || key === 'G') {
                params.gravity = !params.gravity;
                document.getElementById('gravity').checked = params.gravity;
            } else if (keyCode === UP_ARROW) {
                params.temperature = Math.min(600, params.temperature + 10);
                document.getElementById('temperature').value = params.temperature;
                document.getElementById('temperature-value').textContent = params.temperature + ' K';
            } else if (keyCode === DOWN_ARROW) {
                params.temperature = Math.max(100, params.temperature - 10);
                document.getElementById('temperature').value = params.temperature;
                document.getElementById('temperature-value').textContent = params.temperature + ' K';
            }
        }

        // ============================================
        // p5.js Main Functions
        // ============================================
        function setup() {
            const canvas = createCanvas(600, 500);
            canvas.parent('simulation');

            updateBoxDimensions();
            initializeParticles();
            setupUIListeners();
        }

        function draw() {
            background(26, 26, 46);

            if (!paused) {
                const dt = 1 / 60;  // Fixed time step

                // Update all particles
                for (const p of particles) {
                    p.update(dt);
                }

                // Check for particle-particle collisions
                checkParticleCollisions();

                // Advance simulation time
                simulationTime += dt * TIME_SCALE;

                // Record pressure history for averaging
                if (simulationTime > 0.1) {
                    const totalMomentum = momentumTransfer.left + momentumTransfer.right +
                                         momentumTransfer.top + momentumTransfer.bottom;
                    const perimeter = 2 * (box.width + box.height) / PIXELS_PER_METER;
                    const pressure = totalMomentum / (perimeter * simulationTime);
                    pressureHistory.push(pressure);
                    if (pressureHistory.length > PRESSURE_SAMPLE_SIZE) {
                        pressureHistory.shift();
                    }
                }
            }

            // Draw the container box
            drawBox();

            // Draw all particles
            for (const p of particles) {
                p.draw();
            }

            // Update and display statistics
            updateStatisticsDisplay();
        }

        function drawBox() {
            // Box fill
            fill(15, 35, 60, 200);
            stroke(0, 217, 255);
            strokeWeight(3);
            rect(box.x, box.y, box.width, box.height, 4);

            // Wall labels
            noStroke();
            fill(100);
            textSize(11);
            textAlign(CENTER);

            // Top/bottom labels
            text('Top Wall', box.x + box.width/2, box.y - 8);
            text('Bottom Wall', box.x + box.width/2, box.y + box.height + 18);

            // Side labels (rotated)
            push();
            textAlign(CENTER);
            translate(box.x - 18, box.y + box.height/2);
            rotate(-HALF_PI);
            text('Left Wall', 0, 0);
            pop();

            push();
            translate(box.x + box.width + 18, box.y + box.height/2);
            rotate(HALF_PI);
            text('Right Wall', 0, 0);
            pop();
        }

        function updateStatisticsDisplay() {
            const stats = calculateStatistics();

            // Temperature
            const tempEl = document.getElementById('stat-temp');
            tempEl.textContent = stats.temperature.toFixed(1) + ' K';
            tempEl.className = 'stat-value';

            // Pressure (convert to mPa for readability)
            const pressureEl = document.getElementById('stat-pressure');
            const pressure = pressureHistory.length > 0
                ? pressureHistory.reduce((a, b) => a + b, 0) / pressureHistory.length
                : stats.pressure;
            pressureEl.textContent = (pressure * 1000).toFixed(3) + ' mPa';
            pressureEl.className = 'stat-value';

            // Kinetic energy (show in meV for atomic-scale energies)
            const energyEl = document.getElementById('stat-energy');
            const energyEV = stats.totalKE / 1.602e-19;
            if (energyEV < 1) {
                energyEl.textContent = (energyEV * 1000).toFixed(2) + ' meV';
            } else {
                energyEl.textContent = energyEV.toFixed(2) + ' eV';
            }

            // Mean speed
            document.getElementById('stat-mean-speed').textContent =
                (stats.meanSpeed * PIXELS_PER_METER).toFixed(1) + ' m/s';

            // RMS speed
            document.getElementById('stat-rms-speed').textContent =
                (stats.rmsSpeed * PIXELS_PER_METER).toFixed(1) + ' m/s';

            // Most probable speed
            document.getElementById('stat-mp-speed').textContent =
                (stats.mpSpeed * PIXELS_PER_METER).toFixed(1) + ' m/s';

            // Density
            document.getElementById('stat-density').textContent =
                stats.density.toExponential(2) + ' m⁻²';

            // Simulation time
            document.getElementById('stat-time').textContent =
                stats.simulationTime.toFixed(1) + ' s';

            // Draw histogram
            drawHistogram(stats);
        }

        function drawHistogram(stats) {
            // Create or get histogram canvas
            let histCanvas = document.getElementById('histogram-canvas');
            if (!histCanvas) {
                const container = document.getElementById('histogram-container');
                histCanvas = document.createElement('canvas');
                histCanvas.id = 'histogram-canvas';
                histCanvas.width = 280;
                histCanvas.height = 130;
                histCanvas.style.width = '100%';
                histCanvas.style.height = 'auto';
                container.appendChild(histCanvas);
            }

            const ctx = histCanvas.getContext('2d');
            const width = histCanvas.width;
            const height = histCanvas.height;

            // Clear canvas
            ctx.fillStyle = '#0f3460';
            ctx.fillRect(0, 0, width, height);

            const margin = { left: 45, right: 15, top: 15, bottom: 25 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            // Find max speed for x-axis
            const maxSpeed = Math.max(stats.rmsSpeed * 2.5, stats.mpSpeed * 3);

            // Create histogram bins
            const numBins = 25;
            const binWidth = maxSpeed / numBins;
            const bins = new Array(numBins).fill(0);

            for (const speed of stats.speeds) {
                const binIndex = Math.min(Math.floor(speed / binWidth), numBins - 1);
                if (binIndex >= 0) bins[binIndex]++;
            }

            // Normalize to PDF
            const binArea = plotWidth * plotHeight;
            const totalParticles = stats.speeds.length;
            const normalizedBins = bins.map(b => (b / totalParticles) * (numBins / maxSpeed));

            // Find max value for y-axis scaling
            const maxBinValue = Math.max(...normalizedBins, 0.01);
            const theoreticalMax = maxwellBoltzmannPDF(stats.mpSpeed, stats.temperature, 1.0);
            const yMax = Math.max(maxBinValue, theoreticalMax) * 1.1;

            // Draw measured distribution (bars)
            ctx.fillStyle = 'rgba(255, 107, 107, 0.6)';
            for (let i = 0; i < numBins; i++) {
                const x = margin.left + (i / numBins) * plotWidth;
                const barHeight = (normalizedBins[i] / yMax) * plotHeight;
                ctx.fillRect(x, margin.top + plotHeight - barHeight, plotWidth / numBins - 1, barHeight);
            }

            // Draw theoretical Maxwell-Boltzmann curve
            ctx.strokeStyle = '#00d9ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i <= 100; i++) {
                const speed = (i / 100) * maxSpeed;
                const theoretical = maxwellBoltzmannPDF(speed, stats.temperature, 1.0);
                const x = margin.left + (speed / maxSpeed) * plotWidth;
                const y = margin.top + plotHeight - (theoretical / yMax) * plotHeight;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw axes
            ctx.strokeStyle = 'rgba(150, 150, 150, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + plotHeight);
            ctx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
            ctx.stroke();

            // Axis labels
            ctx.fillStyle = '#888';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Speed (m/s)', margin.left + plotWidth/2, height - 5);

            ctx.save();
            ctx.translate(12, margin.top + plotHeight/2);
            ctx.rotate(-HALF_PI);
            ctx.fillText('P(v)', 0, 0);
            ctx.restore();

            // X-axis tick labels
            ctx.textAlign = 'center';
            for (let i = 0; i <= 4; i++) {
                const speed = (i / 4) * maxSpeed;
                const x = margin.left + (i / 4) * plotWidth;
                ctx.fillText((speed * PIXELS_PER_METER).toFixed(0), x, margin.top + plotHeight + 15);
            }
        }

        // Initialize histogram on page load
        window.addEventListener('load', function() {
            setTimeout(() => {
                const stats = calculateStatistics();
                drawHistogram(stats);
            }, 200);
        });
    </script>
</body>
</html>
