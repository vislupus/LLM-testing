<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Gas Simulation - Statistical Mechanics</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #container {
            display: flex;
            gap: 20px;
            padding: 20px;
            max-width: 1600px;
            width: 100%;
        }

        #canvas-container {
            position: relative;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
        }

        #main-canvas {
            display: block;
            border-radius: 12px;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 380px;
        }

        .panel {
            background: rgba(20, 20, 35, 0.95);
            border-radius: 12px;
            padding: 20px;
            color: #e0e0ff;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(100, 150, 255, 0.3);
        }

        .panel h3 {
            margin: 0 0 15px 0;
            color: #64b5f6;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(100, 180, 255, 0.5);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 12px;
            color: #b0c4ff;
        }

        .slider {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #64b5f6;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(100, 180, 255, 0.6);
        }

        .slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #64b5f6;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(100, 180, 255, 0.6);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 6px;
            font-size: 11px;
        }

        .stat-label {
            color: #8a92b2;
            font-size: 10px;
        }

        .stat-value {
            font-weight: bold;
            font-size: 14px;
            margin-top: 2px;
        }

        .chart-container {
            height: 180px;
            position: relative;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            margin-top: 10px;
            border: 1px solid rgba(100, 150, 255, 0.2);
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            flex: 1;
            padding: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn.danger {
            background: linear-gradient(135deg, #f56565, #e53e3e);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .info-text {
            font-size: 11px;
            color: #8a92b2;
            margin-top: 10px;
            line-height: 1.4;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <canvas id="main-canvas"></canvas>
        </div>
        
        <div class="sidebar">
            <div class="panel">
                <h3>‚öõÔ∏è Simulation Controls</h3>
                
                <div class="control-group">
                    <label>Number of Particles: <span id="particleCountValue">100</span></label>
                    <input type="range" class="slider" id="particleCount" min="10" max="500" step="10" value="100">
                </div>
                
                <div class="control-group">
                    <label>Temperature (K): <span id="temperatureValue">300</span></label>
                    <input type="range" class="slider" id="temperature" min="50" max="1000" step="10" value="300">
                </div>
                
                <div class="control-group">
                    <label>Box Width: <span id="boxWidthValue">600</span></label>
                    <input type="range" class="slider" id="boxWidth" min="300" max="800" step="20" value="600">
                </div>
                
                <div class="control-group">
                    <label>Box Height: <span id="boxHeightValue">600</span></label>
                    <input type="range" class="slider" id="boxHeight" min="300" max="800" step="20" value="600">
                </div>
                
                <div class="control-group">
                    <label>Particle Mass Ratio: <span id="massRatioValue">1.0</span></label>
                    <input type="range" class="slider" id="massRatio" min="0.1" max="5.0" step="0.1" value="1.0">
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="collisionsEnabled" checked>
                    <label for="collisionsEnabled">Enable Collisions</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="showTrails" checked>
                    <label for="showTrails">Show Velocity Vectors</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="showGrid">
                    <label for="showGrid">Show Grid</label>
                </div>
                
                <div class="action-buttons">
                    <button class="btn" onclick="gasSim.reset()">Reset</button>
                    <button class="btn" onclick="gasSim.togglePause()">Pause</button>
                    <button class="btn danger" onclick="gasSim.addHeat()">Add Heat</button>
                </div>
            </div>
            
            <div class="panel">
                <h3>üìä Thermodynamic Properties</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">Avg Speed</div>
                        <div class="stat-value" id="avgSpeed" style="color: #4fc3f7;">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Kinetic Energy</div>
                        <div class="stat-value" id="kineticEnergy" style="color: #ff9800;">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Temperature</div>
                        <div class="stat-value" id="calcTemp" style="color: #f44336;">0 K</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Pressure</div>
                        <div class="stat-value" id="pressure" style="color: #4caf50;">0</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <canvas id="speedChart"></canvas>
                </div>
                
                <div class="info-text">
                    The speed distribution should approach Maxwell-Boltzmann distribution as particle count increases.
                </div>
            </div>
        </div>
    </div>

    <script>
        class Particle {
            constructor(x, y, vx, vy, mass, radius, type) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.mass = mass;
                this.radius = radius;
                this.type = type;
                this.collisions = 0;
            }
            
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
            }
            
            getSpeed() {
                return Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            }
            
            getKineticEnergy() {
                const speed = this.getSpeed();
                return 0.5 * this.mass * speed * speed;
            }
        }
        
        class GasSimulation {
            constructor() {
                this.particles = [];
                this.boxWidth = 600;
                this.boxHeight = 600;
                this.collisionsEnabled = true;
                this.paused = false;
                this.showTrails = true;
                this.showGrid = false;
                
                // Physics constants
                this.kB = 1.38e-23; // Boltzmann constant (scaled for simulation)
                this.dt = 0.016; // Time step
                
                // Statistics
                this.wallCollisions = 0;
                this.pressureUpdateTimer = 0;
                this.pressure = 0;
                
                // Speed distribution data
                this.speedBins = 20;
                this.speedHistogram = new Array(this.speedBins).fill(0);
                this.maxSpeed = 10;
                
                this.init();
            }
            
            init() {
                this.particles = [];
                const numParticles = parseInt(document.getElementById('particleCount').value);
                const temperature = parseFloat(document.getElementById('temperature').value);
                const massRatio = parseFloat(document.getElementById('massRatio').value);
                
                // Create particles with Maxwell-Boltzmann distribution
                for (let i = 0; i < numParticles; i++) {
                    const type = i < numParticles / 2 ? 'light' : 'heavy';
                    const mass = type === 'light' ? 1.0 : massRatio;
                    const radius = type === 'light' ? 4 : 6;
                    
                    // Random position (avoiding overlap)
                    let x, y;
                    let attempts = 0;
                    do {
                        x = random(radius, this.boxWidth - radius);
                        y = random(radius, this.boxHeight - radius);
                        attempts++;
                    } while (this.checkOverlap(x, y, radius) && attempts < 100);
                    
                    // Maxwell-Boltzmann velocity distribution
                    const sigma = Math.sqrt(temperature / mass);
                    const vx = randomGaussian(0, sigma);
                    const vy = randomGaussian(0, sigma);
                    
                    this.particles.push(new Particle(x, y, vx, vy, mass, radius, type));
                }
            }
            
            checkOverlap(x, y, radius) {
                for (const p of this.particles) {
                    const dx = x - p.x;
                    const dy = y - p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < radius + p.radius) {
                        return true;
                    }
                }
                return false;
            }
            
            update() {
                if (this.paused) return;
                
                // Update particles
                for (const particle of this.particles) {
                    particle.update(this.dt);
                }
                
                // Handle collisions
                if (this.collisionsEnabled) {
                    this.handleWallCollisions();
                    this.handleParticleCollisions();
                } else {
                    this.handleWallBounces();
                }
                
                // Update statistics
                this.updateStatistics();
            }
            
            handleWallCollisions() {
                for (const particle of this.particles) {
                    let collision = false;
                    
                    // Left and right walls
                    if (particle.x - particle.radius <= 0) {
                        particle.x = particle.radius;
                        particle.vx = Math.abs(particle.vx);
                        collision = true;
                    } else if (particle.x + particle.radius >= this.boxWidth) {
                        particle.x = this.boxWidth - particle.radius;
                        particle.vx = -Math.abs(particle.vx);
                        collision = true;
                    }
                    
                    // Top and bottom walls
                    if (particle.y - particle.radius <= 0) {
                        particle.y = particle.radius;
                        particle.vy = Math.abs(particle.vy);
                        collision = true;
                    } else if (particle.y + particle.radius >= this.boxHeight) {
                        particle.y = this.boxHeight - particle.radius;
                        particle.vy = -Math.abs(particle.vy);
                        collision = true;
                    }
                    
                    if (collision) {
                        this.wallCollisions++;
                    }
                }
            }
            
            handleWallBounces() {
                for (const particle of this.particles) {
                    if (particle.x - particle.radius <= 0 || particle.x + particle.radius >= this.boxWidth) {
                        particle.vx *= -1;
                    }
                    if (particle.y - particle.radius <= 0 || particle.y + particle.radius >= this.boxHeight) {
                        particle.vy *= -1;
                    }
                    
                    // Keep particles in bounds
                    particle.x = constrain(particle.x, particle.radius, this.boxWidth - particle.radius);
                    particle.y = constrain(particle.y, particle.radius, this.boxHeight - particle.radius);
                }
            }
            
            handleParticleCollisions() {
                for (let i = 0; i < this.particles.length; i++) {
                    for (let j = i + 1; j < this.particles.length; j++) {
                        const p1 = this.particles[i];
                        const p2 = this.particles[j];
                        
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < p1.radius + p2.radius) {
                            this.resolveCollision(p1, p2, dx, dy, dist);
                        }
                    }
                }
            }
            
            resolveCollision(p1, p2, dx, dy, dist) {
                // Normalize collision vector
                const nx = dx / dist;
                const ny = dy / dist;
                
                // Relative velocity
                const dvx = p2.vx - p1.vx;
                const dvy = p2.vy - p1.vy;
                
                // Relative velocity in collision normal direction
                const dvn = dvx * nx + dvy * ny;
                
                // Do not resolve if velocities are separating
                if (dvn > 0) return;
                
                // Collision impulse (elastic collision)
                const impulse = 2 * dvn / (1/p1.mass + 1/p2.mass);
                
                // Update velocities
                p1.vx += impulse * nx / p1.mass;
                p1.vy += impulse * ny / p1.mass;
                p2.vx -= impulse * nx / p2.mass;
                p2.vy -= impulse * ny / p2.mass;
                
                // Separate particles
                const overlap = p1.radius + p2.radius - dist;
                const separationX = overlap * nx / 2;
                const separationY = overlap * ny / 2;
                
                p1.x -= separationX;
                p1.y -= separationY;
                p2.x += separationX;
                p2.y += separationY;
                
                // Update collision counts
                p1.collisions++;
                p2.collisions++;
            }
            
            updateStatistics() {
                if (this.particles.length === 0) return;
                
                // Calculate average speed and kinetic energy
                let totalSpeed = 0;
                let totalKE = 0;
                this.speedHistogram.fill(0);
                this.maxSpeed = 0;
                
                for (const particle of this.particles) {
                    const speed = particle.getSpeed();
                    totalSpeed += speed;
                    totalKE += particle.getKineticEnergy();
                    this.maxSpeed = Math.max(this.maxSpeed, speed);
                    
                    // Update speed histogram
                    const binIndex = Math.floor(speed / this.maxSpeed * this.speedBins);
                    if (binIndex >= 0 && binIndex < this.speedBins) {
                        this.speedHistogram[binIndex]++;
                    }
                }
                
                const avgSpeed = totalSpeed / this.particles.length;
                const avgKE = totalKE / this.particles.length;
                
                // Calculate temperature from kinetic energy
                // In 2D: KE = kT, so T = KE/k
                const temperature = avgKE;
                
                // Calculate pressure from wall collisions
                this.pressureUpdateTimer += this.dt;
                if (this.pressureUpdateTimer > 1.0) {
                    const perimeter = 2 * (this.boxWidth + this.boxHeight);
                    this.pressure = (this.wallCollisions * avgKE) / (perimeter * this.pressureUpdateTimer);
                    this.wallCollisions = 0;
                    this.pressureUpdateTimer = 0;
                }
                
                // Update display
                document.getElementById('avgSpeed').textContent = avgSpeed.toFixed(2);
                document.getElementById('kineticEnergy').textContent = avgKE.toFixed(2);
                document.getElementById('calcTemp').textContent = temperature.toFixed(1) + ' K';
                document.getElementById('pressure').textContent = this.pressure.toFixed(3);
                
                // Update speed distribution chart
                this.updateSpeedChart();
            }
            
            updateSpeedChart() {
                const canvas = document.getElementById('speedChart');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw histogram
                const barWidth = canvas.width / this.speedBins;
                const maxCount = Math.max(...this.speedHistogram);
                
                ctx.fillStyle = 'rgba(100, 181, 246, 0.6)';
                ctx.strokeStyle = 'rgba(100, 181, 246, 1)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < this.speedBins; i++) {
                    const barHeight = (this.speedHistogram[i] / maxCount) * (canvas.height - 20);
                    const x = i * barWidth;
                    const y = canvas.height - barHeight - 10;
                    
                    ctx.fillRect(x, y, barWidth - 1, barHeight);
                }
                
                // Draw Maxwell-Boltzmann theoretical curve
                const temperature = parseFloat(document.getElementById('temperature').value);
                ctx.strokeStyle = 'rgba(255, 152, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < canvas.width; i++) {
                    const speed = (i / canvas.width) * this.maxSpeed;
                    const mb = this.maxwellBoltzmann(speed, temperature);
                    const y = canvas.height - 10 - (mb * canvas.height * 0.8);
                    
                    if (i === 0) {
                        ctx.moveTo(i, y);
                    } else {
                        ctx.lineTo(i, y);
                    }
                }
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = '#e0e0ff';
                ctx.font = '10px Arial';
                ctx.fillText('Speed Distribution', 5, 15);
            }
            
            maxwellBoltzmann(v, T) {
                // 2D Maxwell-Boltzmann distribution: f(v) = (m/kT) * v * exp(-mv¬≤/2kT)
                const m = 1; // Average mass
                const k = 1; // Scaled Boltzmann constant
                return (m / (k * T)) * v * Math.exp(-m * v * v / (2 * k * T));
            }
            
            render() {
                // Clear canvas
                background(10, 10, 15);
                
                // Draw box
                push();
                translate((width - this.boxWidth) / 2, (height - this.boxHeight) / 2);
                
                // Draw grid if enabled
                if (this.showGrid) {
                    stroke(50, 50, 70);
                    strokeWeight(0.5);
                    for (let x = 0; x <= this.boxWidth; x += 50) {
                        line(x, 0, x, this.boxHeight);
                    }
                    for (let y = 0; y <= this.boxHeight; y += 50) {
                        line(0, y, this.boxWidth, y);
                    }
                }
                
                // Draw box walls
                stroke(100, 150, 255);
                strokeWeight(2);
                noFill();
                rect(0, 0, this.boxWidth, this.boxHeight);
                
                // Draw particles
                for (const particle of this.particles) {
                    // Particle color based on type and speed
                    const speed = particle.getSpeed();
                    const speedNorm = constrain(speed / 5, 0, 1);
                    
                    if (particle.type === 'light') {
                        fill(100, 181, 246, 200);
                        stroke(50, 150, 255);
                    } else {
                        fill(255, 152, 0, 200);
                        stroke(255, 100, 0);
                    }
                    
                    strokeWeight(1);
                    ellipse(particle.x, particle.y, particle.radius * 2);
                    
                    // Draw velocity vectors if enabled
                    if (this.showTrails) {
                        stroke(255, 255, 255, 100);
                        strokeWeight(1);
                        const scale = 5;
                        line(particle.x, particle.y, 
                             particle.x + particle.vx * scale, 
                             particle.y + particle.vy * scale);
                    }
                }
                
                pop();
            }
            
            reset() {
                this.init();
                this.wallCollisions = 0;
                this.pressure = 0;
                this.pressureUpdateTimer = 0;
            }
            
            togglePause() {
                this.paused = !this.paused;
            }
            
            addHeat() {
                // Add random velocity to all particles
                for (const particle of this.particles) {
                    particle.vx += randomGaussian(0, 2);
                    particle.vy += randomGaussian(0, 2);
                }
            }
            
            setBoxSize(width, height) {
                this.boxWidth = width;
                this.boxHeight = height;
                this.init();
            }
        }
        
        let gasSim;
        
        function setup() {
            const canvas = createCanvas(800, 800);
            canvas.parent('canvas-container');
            
            gasSim = new GasSimulation();
            
            // Setup controls
            setupControls();
        }
        
        function draw() {
            gasSim.update();
            gasSim.render();
        }
        
        function setupControls() {
            // Particle count
            document.getElementById('particleCount').addEventListener('input', (e) => {
                document.getElementById('particleCountValue').textContent = e.target.value;
                gasSim.init();
            });
            
            // Temperature
            document.getElementById('temperature').addEventListener('input', (e) => {
                document.getElementById('temperatureValue').textContent = e.target.value;
            });
            
            // Box width
            document.getElementById('boxWidth').addEventListener('input', (e) => {
                document.getElementById('boxWidthValue').textContent = e.target.value;
                gasSim.setBoxSize(
                    parseInt(e.target.value),
                    parseInt(document.getElementById('boxHeight').value)
                );
            });
            
            // Box height
            document.getElementById('boxHeight').addEventListener('input', (e) => {
                document.getElementById('boxHeightValue').textContent = e.target.value;
                gasSim.setBoxSize(
                    parseInt(document.getElementById('boxWidth').value),
                    parseInt(e.target.value)
                );
            });
            
            // Mass ratio
            document.getElementById('massRatio').addEventListener('input', (e) => {
                document.getElementById('massRatioValue').textContent = e.target.value;
                gasSim.init();
            });
            
            // Checkboxes
            document.getElementById('collisionsEnabled').addEventListener('change', (e) => {
                gasSim.collisionsEnabled = e.target.checked;
            });
            
            document.getElementById('showTrails').addEventListener('change', (e) => {
                gasSim.showTrails = e.target.checked;
            });
            
            document.getElementById('showGrid').addEventListener('change', (e) => {
                gasSim.showGrid = e.target.checked;
            });
        }
        
        function keyPressed() {
            if (key === ' ') {
                gasSim.togglePause();
            } else if (key === 'r' || key === 'R') {
                gasSim.reset();
            } else if (key === 'h' || key === 'H') {
                gasSim.addHeat();
            }
        }
    </script>
</body>
</html>