<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Fluid Simulation - Navier-Stokes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }
        #container {
            position: relative;
        }
        #controls {
            position: fixed;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 20px;
            border-radius: 12px;
            font-size: 13px;
            max-width: 280px;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 100;
        }
        #controls h2 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 10px;
        }
        .control-section {
            margin-bottom: 15px;
        }
        .control-section h3 {
            color: #ff6b9d;
            font-size: 14px;
            margin-bottom: 8px;
        }
        .key {
            display: inline-block;
            background: #333;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: monospace;
            margin: 2px;
            border: 1px solid #555;
        }
        .control-row {
            margin: 5px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #stats {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 15px;
            border-radius: 12px;
            font-size: 12px;
            font-family: monospace;
            border: 1px solid rgba(255,255,255,0.1);
        }
        #colorIndicator {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        #colorSwatch {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid white;
        }
        #colorLabel {
            color: white;
            font-size: 14px;
        }
        .toggle-btn {
            position: fixed;
            top: 15px;
            left: 310px;
            background: rgba(0,0,0,0.85);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            z-index: 100;
        }
        .toggle-btn:hover {
            background: rgba(50,50,50,0.9);
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="controls">
        <h2>üåä Fluid Simulation</h2>
        
        <div class="control-section">
            <h3>Mouse Controls</h3>
            <div class="control-row">Left click + drag: Add velocity & dye</div>
            <div class="control-row">Right click + drag: Add obstacles</div>
        </div>
        
        <div class="control-section">
            <h3>Color Selection</h3>
            <div class="control-row"><span class="key">1-6</span> Select color preset</div>
            <div class="control-row"><span class="key">C</span> Cycle colors</div>
        </div>
        
        <div class="control-section">
            <h3>Fluid Properties</h3>
            <div class="control-row"><span class="key">V</span> Toggle vorticity</div>
            <div class="control-row"><span class="key">‚Üë‚Üì</span> Adjust viscosity</div>
            <div class="control-row"><span class="key">‚Üê‚Üí</span> Adjust diffusion</div>
            <div class="control-row"><span class="key">+/-</span> Adjust force</div>
        </div>
        
        <div class="control-section">
            <h3>Effects & View</h3>
            <div class="control-row"><span class="key">G</span> Toggle gravity</div>
            <div class="control-row"><span class="key">O</span> Clear obstacles</div>
            <div class="control-row"><span class="key">M</span> Toggle velocity view</div>
            <div class="control-row"><span class="key">Space</span> Pause/Resume</div>
            <div class="control-row"><span class="key">R</span> Reset simulation</div>
        </div>
    </div>
    
    <button class="toggle-btn" onclick="toggleControls()">Hide Controls</button>
    
    <div id="colorIndicator">
        <div id="colorSwatch"></div>
        <span id="colorLabel">Cyan</span>
    </div>
    
    <div id="stats">
        <div>FPS: <span id="fps">60</span></div>
        <div>Viscosity: <span id="viscosity">0.0001</span></div>
        <div>Diffusion: <span id="diffusion">0.0001</span></div>
        <div>Force: <span id="force">5000</span></div>
        <div>Vorticity: <span id="vorticity">ON</span></div>
        <div>Gravity: <span id="gravity">OFF</span></div>
    </div>

    <script>
        // Fluid simulation configuration
        const SCALE = 4;
        let N;
        let size;
        
        // Fluid arrays
        let density0, density1;
        let Vx, Vy;
        let Vx0, Vy0;
        let obstacles;
        
        // Color channels (RGB for each cell)
        let colorR, colorG, colorB;
        let colorR0, colorG0, colorB0;
        
        // Simulation parameters
        let viscosity = 0.0001;
        let diffusion = 0.0001;
        let dt = 0.2;
        let forceMultiplier = 5000;
        let vorticityEnabled = true;
        let vorticityStrength = 15;
        let gravityEnabled = false;
        let gravityStrength = 0.5;
        let paused = false;
        let showVelocity = false;
        
        // Mouse state
        let pmouseXGrid, pmouseYGrid;
        let currentColor = { r: 0, g: 212, b: 255 };
        let colorIndex = 0;
        
        const colors = [
            { r: 0, g: 212, b: 255, name: 'Cyan' },
            { r: 255, g: 100, b: 150, name: 'Pink' },
            { r: 100, g: 255, b: 100, name: 'Green' },
            { r: 255, g: 200, b: 50, name: 'Gold' },
            { r: 200, g: 100, b: 255, name: 'Purple' },
            { r: 255, g: 255, b: 255, name: 'White' }
        ];
        
        // Pixel buffer for efficient rendering
        let fluidBuffer;
        
        function setup() {
            const canvasSize = min(windowWidth - 40, windowHeight - 40);
            const canvas = createCanvas(canvasSize, canvasSize);
            canvas.parent('container');
            
            N = floor(canvasSize / SCALE);
            size = (N + 2) * (N + 2);
            
            initArrays();
            fluidBuffer = createGraphics(N + 2, N + 2);
            fluidBuffer.pixelDensity(1);
            
            updateColorIndicator();
        }
        
        function initArrays() {
            density0 = new Float32Array(size);
            density1 = new Float32Array(size);
            Vx = new Float32Array(size);
            Vy = new Float32Array(size);
            Vx0 = new Float32Array(size);
            Vy0 = new Float32Array(size);
            obstacles = new Uint8Array(size);
            
            colorR = new Float32Array(size);
            colorG = new Float32Array(size);
            colorB = new Float32Array(size);
            colorR0 = new Float32Array(size);
            colorG0 = new Float32Array(size);
            colorB0 = new Float32Array(size);
        }
        
        function IX(x, y) {
            x = constrain(x, 0, N + 1);
            y = constrain(y, 0, N + 1);
            return x + y * (N + 2);
        }
        
        // Add density/color at position
        function addDensity(x, y, amount, r, g, b) {
            const idx = IX(x, y);
            if (obstacles[idx]) return;
            
            density0[idx] += amount;
            colorR[idx] += r * amount;
            colorG[idx] += g * amount;
            colorB[idx] += b * amount;
        }
        
        // Add velocity at position
        function addVelocity(x, y, amountX, amountY) {
            const idx = IX(x, y);
            if (obstacles[idx]) return;
            
            Vx[idx] += amountX;
            Vy[idx] += amountY;
        }
        
        // Set boundary conditions
        function setBnd(b, x) {
            for (let i = 1; i <= N; i++) {
                x[IX(0, i)] = b === 1 ? -x[IX(1, i)] : x[IX(1, i)];
                x[IX(N + 1, i)] = b === 1 ? -x[IX(N, i)] : x[IX(N, i)];
                x[IX(i, 0)] = b === 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
                x[IX(i, N + 1)] = b === 2 ? -x[IX(i, N)] : x[IX(i, N)];
            }
            
            x[IX(0, 0)] = 0.5 * (x[IX(1, 0)] + x[IX(0, 1)]);
            x[IX(0, N + 1)] = 0.5 * (x[IX(1, N + 1)] + x[IX(0, N)]);
            x[IX(N + 1, 0)] = 0.5 * (x[IX(N, 0)] + x[IX(N + 1, 1)]);
            x[IX(N + 1, N + 1)] = 0.5 * (x[IX(N, N + 1)] + x[IX(N + 1, N)]);
            
            // Obstacle boundaries
            for (let i = 1; i <= N; i++) {
                for (let j = 1; j <= N; j++) {
                    if (obstacles[IX(i, j)]) {
                        if (b === 1) {
                            x[IX(i, j)] = -x[IX(i - 1, j)] - x[IX(i + 1, j)];
                        } else if (b === 2) {
                            x[IX(i, j)] = -x[IX(i, j - 1)] - x[IX(i, j + 1)];
                        } else {
                            x[IX(i, j)] = 0;
                        }
                    }
                }
            }
        }
        
        // Linear solver using Gauss-Seidel relaxation
        function linSolve(b, x, x0, a, c) {
            const cRecip = 1.0 / c;
            
            for (let k = 0; k < 4; k++) {
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        if (obstacles[IX(i, j)]) continue;
                        
                        x[IX(i, j)] = (x0[IX(i, j)] + a * (
                            x[IX(i + 1, j)] +
                            x[IX(i - 1, j)] +
                            x[IX(i, j + 1)] +
                            x[IX(i, j - 1)]
                        )) * cRecip;
                    }
                }
                setBnd(b, x);
            }
        }
        
        // Diffusion step
        function diffuse(b, x, x0, diff) {
            const a = dt * diff * N * N;
            linSolve(b, x, x0, a, 1 + 4 * a);
        }
        
        // Advection step
        function advect(b, d, d0, velocX, velocY) {
            const dtx = dt * N;
            const dty = dt * N;
            
            for (let j = 1; j <= N; j++) {
                for (let i = 1; i <= N; i++) {
                    if (obstacles[IX(i, j)]) continue;
                    
                    let x = i - dtx * velocX[IX(i, j)];
                    let y = j - dty * velocY[IX(i, j)];
                    
                    x = constrain(x, 0.5, N + 0.5);
                    y = constrain(y, 0.5, N + 0.5);
                    
                    const i0 = floor(x);
                    const i1 = i0 + 1;
                    const j0 = floor(y);
                    const j1 = j0 + 1;
                    
                    const s1 = x - i0;
                    const s0 = 1 - s1;
                    const t1 = y - j0;
                    const t0 = 1 - t1;
                    
                    d[IX(i, j)] = 
                        s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) +
                        s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
                }
            }
            setBnd(b, d);
        }
        
        // Project velocity field to be divergence-free
        function project(velocX, velocY, p, div) {
            const h = 1.0 / N;
            
            for (let j = 1; j <= N; j++) {
                for (let i = 1; i <= N; i++) {
                    if (obstacles[IX(i, j)]) continue;
                    
                    div[IX(i, j)] = -0.5 * h * (
                        velocX[IX(i + 1, j)] -
                        velocX[IX(i - 1, j)] +
                        velocY[IX(i, j + 1)] -
                        velocY[IX(i, j - 1)]
                    );
                    p[IX(i, j)] = 0;
                }
            }
            
            setBnd(0, div);
            setBnd(0, p);
            linSolve(0, p, div, 1, 4);
            
            for (let j = 1; j <= N; j++) {
                for (let i = 1; i <= N; i++) {
                    if (obstacles[IX(i, j)]) continue;
                    
                    velocX[IX(i, j)] -= 0.5 * (p[IX(i + 1, j)] - p[IX(i - 1, j)]) * N;
                    velocY[IX(i, j)] -= 0.5 * (p[IX(i, j + 1)] - p[IX(i, j - 1)]) * N;
                }
            }
            
            setBnd(1, velocX);
            setBnd(2, velocY);
        }
        
        // Vorticity confinement for swirling
        function vorticityConfinement() {
            const curl = new Float32Array(size);
            
            // Calculate curl
            for (let j = 1; j <= N; j++) {
                for (let i = 1; i <= N; i++) {
                    if (obstacles[IX(i, j)]) continue;
                    
                    curl[IX(i, j)] = 
                        (Vy[IX(i + 1, j)] - Vy[IX(i - 1, j)]) -
                        (Vx[IX(i, j + 1)] - Vx[IX(i, j - 1)]);
                }
            }
            
            // Apply vorticity force
            for (let j = 2; j < N; j++) {
                for (let i = 2; i < N; i++) {
                    if (obstacles[IX(i, j)]) continue;
                    
                    const dx = abs(curl[IX(i + 1, j)]) - abs(curl[IX(i - 1, j)]);
                    const dy = abs(curl[IX(i, j + 1)]) - abs(curl[IX(i, j - 1)]);
                    
                    let len = sqrt(dx * dx + dy * dy) + 0.0001;
                    
                    let nx = dx / len;
                    let ny = dy / len;
                    
                    Vx[IX(i, j)] += vorticityStrength * dt * curl[IX(i, j)] * ny;
                    Vy[IX(i, j)] -= vorticityStrength * dt * curl[IX(i, j)] * nx;
                }
            }
        }
        
        // Apply gravity
        function applyGravity() {
            for (let j = 1; j <= N; j++) {
                for (let i = 1; i <= N; i++) {
                    if (obstacles[IX(i, j)]) continue;
                    
                    const d = density0[IX(i, j)];
                    if (d > 0.01) {
                        Vy[IX(i, j)] += gravityStrength * d * dt;
                    }
                }
            }
        }
        
        // Main fluid step
        function fluidStep() {
            // Add forces
            if (gravityEnabled) {
                applyGravity();
            }
            
            // Velocity step
            diffuse(1, Vx0, Vx, viscosity);
            diffuse(2, Vy0, Vy, viscosity);
            
            project(Vx0, Vy0, Vx, Vy);
            
            advect(1, Vx, Vx0, Vx0, Vy0);
            advect(2, Vy, Vy0, Vx0, Vy0);
            
            project(Vx, Vy, Vx0, Vy0);
            
            // Vorticity confinement
            if (vorticityEnabled) {
                vorticityConfinement();
            }
            
            // Density step
            diffuse(0, density1, density0, diffusion);
            advect(0, density0, density1, Vx, Vy);
            
            // Color channels
            diffuse(0, colorR0, colorR, diffusion);
            advect(0, colorR, colorR0, Vx, Vy);
            
            diffuse(0, colorG0, colorG, diffusion);
            advect(0, colorG, colorG0, Vx, Vy);
            
            diffuse(0, colorB0, colorB, diffusion);
            advect(0, colorB, colorB0, Vx, Vy);
            
            // Decay
            for (let i = 0; i < size; i++) {
                density0[i] *= 0.995;
                colorR[i] *= 0.995;
                colorG[i] *= 0.995;
                colorB[i] *= 0.995;
            }
        }
        
        function renderFluid() {
            fluidBuffer.loadPixels();
            
            for (let j = 0; j < N + 2; j++) {
                for (let i = 0; i < N + 2; i++) {
                    const idx = IX(i, j);
                    const pIdx = (i + j * (N + 2)) * 4;
                    
                    if (obstacles[idx]) {
                        fluidBuffer.pixels[pIdx] = 80;
                        fluidBuffer.pixels[pIdx + 1] = 80;
                        fluidBuffer.pixels[pIdx + 2] = 80;
                        fluidBuffer.pixels[pIdx + 3] = 255;
                        continue;
                    }
                    
                    const d = density0[idx];
                    
                    if (d > 0.001) {
                        // Normalize color by density
                        const invD = 1 / (d + 0.001);
                        let r = colorR[idx] * invD;
                        let g = colorG[idx] * invD;
                        let b = colorB[idx] * invD;
                        
                        // Apply intensity based on density
                        const intensity = min(d * 2, 1);
                        r = r * intensity;
                        g = g * intensity;
                        b = b * intensity;
                        
                        fluidBuffer.pixels[pIdx] = constrain(r, 0, 255);
                        fluidBuffer.pixels[pIdx + 1] = constrain(g, 0, 255);
                        fluidBuffer.pixels[pIdx + 2] = constrain(b, 0, 255);
                        fluidBuffer.pixels[pIdx + 3] = 255;
                    } else {
                        fluidBuffer.pixels[pIdx] = 0;
                        fluidBuffer.pixels[pIdx + 1] = 0;
                        fluidBuffer.pixels[pIdx + 2] = 0;
                        fluidBuffer.pixels[pIdx + 3] = 255;
                    }
                }
            }
            
            fluidBuffer.updatePixels();
            
            // Draw scaled up
            push();
            noSmooth();
            image(fluidBuffer, 0, 0, width, height);
            pop();
            
            // Draw velocity field if enabled
            if (showVelocity) {
                stroke(255, 100);
                strokeWeight(1);
                for (let j = 2; j < N; j += 4) {
                    for (let i = 2; i < N; i += 4) {
                        const idx = IX(i, j);
                        const vx = Vx[idx];
                        const vy = Vy[idx];
                        const mag = sqrt(vx * vx + vy * vy);
                        if (mag > 0.1) {
                            const x = i * SCALE;
                            const y = j * SCALE;
                            const len = min(mag * 10, SCALE * 3);
                            line(x, y, x + vx / mag * len, y + vy / mag * len);
                        }
                    }
                }
            }
        }
        
        function draw() {
            background(0);
            
            if (!paused) {
                handleMouse();
                fluidStep();
            }
            
            renderFluid();
            
            // Update FPS display
            if (frameCount % 10 === 0) {
                document.getElementById('fps').textContent = floor(frameRate());
            }
        }
        
        function handleMouse() {
            if (mouseIsPressed && mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {
                const x = floor(mouseX / SCALE);
                const y = floor(mouseY / SCALE);
                
                if (mouseButton === RIGHT) {
                    // Add obstacles
                    for (let di = -2; di <= 2; di++) {
                        for (let dj = -2; dj <= 2; dj++) {
                            const ni = x + di;
                            const nj = y + dj;
                            if (ni > 0 && ni <= N && nj > 0 && nj <= N) {
                                obstacles[IX(ni, nj)] = 1;
                            }
                        }
                    }
                } else {
                    // Add velocity and color
                    if (pmouseXGrid !== undefined) {
                        const dx = mouseX - pmouseX;
                        const dy = mouseY - pmouseY;
                        
                        const forceX = dx * forceMultiplier * dt;
                        const forceY = dy * forceMultiplier * dt;
                        
                        // Add velocity in a radius
                        const radius = 3;
                        for (let di = -radius; di <= radius; di++) {
                            for (let dj = -radius; dj <= radius; dj++) {
                                if (di * di + dj * dj <= radius * radius) {
                                    addVelocity(x + di, y + dj, forceX, forceY);
                                    addDensity(x + di, y + dj, 1, currentColor.r, currentColor.g, currentColor.b);
                                }
                            }
                        }
                    }
                }
                
                pmouseXGrid = x;
                pmouseYGrid = y;
            } else {
                pmouseXGrid = undefined;
                pmouseYGrid = undefined;
            }
        }
        
        function keyPressed() {
            // Color selection
            if (key >= '1' && key <= '6') {
                colorIndex = parseInt(key) - 1;
                currentColor = colors[colorIndex];
                updateColorIndicator();
            }
            
            if (key === 'c' || key === 'C') {
                colorIndex = (colorIndex + 1) % colors.length;
                currentColor = colors[colorIndex];
                updateColorIndicator();
            }
            
            // Vorticity toggle
            if (key === 'v' || key === 'V') {
                vorticityEnabled = !vorticityEnabled;
                document.getElementById('vorticity').textContent = vorticityEnabled ? 'ON' : 'OFF';
            }
            
            // Gravity toggle
            if (key === 'g' || key === 'G') {
                gravityEnabled = !gravityEnabled;
                document.getElementById('gravity').textContent = gravityEnabled ? 'ON' : 'OFF';
            }
            
            // Viscosity adjustment
            if (keyCode === UP_ARROW) {
                viscosity = min(viscosity * 1.5, 0.1);
                document.getElementById('viscosity').textContent = viscosity.toFixed(6);
            }
            if (keyCode === DOWN_ARROW) {
                viscosity = max(viscosity / 1.5, 0.00001);
                document.getElementById('viscosity').textContent = viscosity.toFixed(6);
            }
            
            // Diffusion adjustment
            if (keyCode === RIGHT_ARROW) {
                diffusion = min(diffusion * 1.5, 0.1);
                document.getElementById('diffusion').textContent = diffusion.toFixed(6);
            }
            if (keyCode === LEFT_ARROW) {
                diffusion = max(diffusion / 1.5, 0.00001);
                document.getElementById('diffusion').textContent = diffusion.toFixed(6);
            }
            
            // Force adjustment
            if (key === '+' || key === '=') {
                forceMultiplier = min(forceMultiplier * 1.2, 20000);
                document.getElementById('force').textContent = floor(forceMultiplier);
            }
            if (key === '-' || key === '_') {
                forceMultiplier = max(forceMultiplier / 1.2, 500);
                document.getElementById('force').textContent = floor(forceMultiplier);
            }
            
            // Clear obstacles
            if (key === 'o' || key === 'O') {
                obstacles.fill(0);
            }
            
            // Show velocity
            if (key === 'm' || key === 'M') {
                showVelocity = !showVelocity;
            }
            
            // Pause
            if (key === ' ') {
                paused = !paused;
            }
            
            // Reset
            if (key === 'r' || key === 'R') {
                density0.fill(0);
                density1.fill(0);
                Vx.fill(0);
                Vy.fill(0);
                Vx0.fill(0);
                Vy0.fill(0);
                colorR.fill(0);
                colorG.fill(0);
                colorB.fill(0);
                colorR0.fill(0);
                colorG0.fill(0);
                colorB0.fill(0);
                obstacles.fill(0);
            }
            
            return false;
        }
        
        function updateColorIndicator() {
            const swatch = document.getElementById('colorSwatch');
            const label = document.getElementById('colorLabel');
            swatch.style.backgroundColor = `rgb(${currentColor.r}, ${currentColor.g}, ${currentColor.b})`;
            label.textContent = colors[colorIndex].name;
        }
        
        function toggleControls() {
            const controls = document.getElementById('controls');
            const btn = document.querySelector('.toggle-btn');
            if (controls.style.display === 'none') {
                controls.style.display = 'block';
                btn.textContent = 'Hide Controls';
            } else {
                controls.style.display = 'none';
                btn.textContent = 'Show Controls';
            }
        }
        
        // Prevent context menu
        document.addEventListener('contextmenu', e => e.preventDefault());
        
        function windowResized() {
            // Keep canvas size fixed after initial setup
        }
    </script>
</body>
</html>