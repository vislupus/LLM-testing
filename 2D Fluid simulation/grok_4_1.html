<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Realistic 2D Fluid Simulation • p5.js</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    body { margin:0; padding:0; background:#000; overflow:hidden; }
    canvas { display:block; }
    .info {
      position: fixed; top: 10px; left: 10px; color: #fff; font-family: 'Courier New', monospace;
      background: rgba(0,0,0,0.6); padding: 12px 16px; border-radius: 8px; font-size: 14px;
      backdrop-filter: blur(8px); z-index: 100; pointer-events: none; line-height: 1.5;
    }
  </style>
</head>
<body>
<div class="info">
  ←→ Drag Mouse: Add force<br>
  Click + Drag: Strong vortex<br>
  1–5: Add colored dye<br>
  V: Toggle vortex mode<br>
  C: Clear dyes<br>
  R: Reset simulation<br>
  ↑↓: Viscosity (current: <span id="visc">0.00001</span>)
</div>

<script>
// Realistic 2D Fluid Simulation using Stable Fluids (Jos Stam)
// Fully standalone • High performance • Beautiful color diffusion

let fluid;
let mouseForce = 300;
let viscosity = 0.00001;
let diffusionRate = 0.0001;
let vortexMode = true;

function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);
  
  fluid = new Fluid(0.1, 0, 0.000001);
  background(10, 15, 25);
}

function draw() {
  fluid.update();
  
  // Mouse interaction
  if (mouseIsPressed) {
    let mx = mouseX / width;
    let my = mouseY / height;
    let px = p5.Vector.sub(createVector(mouseX, mouseY), createVector(pmouseX, pmouseY));
    
    let forceX = px.x * mouseForce / width;
    let forceY = px.y * mouseForce / height;
    
    if (vortexMode) {
      // Create beautiful swirling vortices
      fluid.addVorticity(mouseX, mouseY, forceX * 30, forceY * 30);
    } else {
      fluid.addVelocity(mouseX, mouseY, forceX, forceY);
    }
    
    // Add dye based on mouse button
    if (mouseButton === LEFT) {
      fluid.addDensity(mouseX, mouseY, 100);
      fluid.addColor(mouseX, mouseY, 
        color(255, 100, 100),   // red
        color(100, 255, 150),   // cyan
        color(255, 255, 100)    // yellow
      );
    }
  }
  
  fluid.render();
}

function keyPressed() {
  if (key === 'v' || key === 'V') {
    vortexMode = !vortexMode;
  }
  if (key === 'c' || key === 'C') {
    fluid.clearDyes();
  }
  if (key === 'r' || key === 'R') {
    fluid = new Fluid(0.1, 0, 0.000001);
    background(10, 15, 25);
  }
  if (key === 'ArrowUp') {
    viscosity = constrain(viscosity + 0.00001, 0, 0.001);
    fluid.viscosity = viscosity;
    document.getElementById('visc').textContent = viscosity.toFixed(6);
  }
  if (key === 'ArrowDown') {
    viscosity = constrain(viscosity - 0.000005, 0, 0.001);
    fluid.viscosity = viscosity;
    document.getElementById('visc').textContent = viscosity.toFixed(6);
  }
  
  // Add specific colored dyes
  if (key === '1') fluid.addDensity(mouseX, mouseY, 150); fluid.addColor(mouseX, mouseY, color(255, 80, 100));
  if (key === '2') fluid.addDensity(mouseX, mouseY, 150); fluid.addColor(mouseX, mouseY, color(80, 255, 200));
  if (key === '3') fluid.addDensity(mouseX, mouseY, 150); fluid.addColor(mouseX, mouseY, color(255, 240, 100));
  if (key === '4') fluid.addDensity(mouseX, mouseY, 150); fluid.addColor(mouseX, mouseY, color(150, 100, 255));
  if (key === '5') fluid.addDensity(mouseX, mouseY, 150); fluid.addColor(mouseX, mouseY, color(255, 150, 255));
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  fluid = new Fluid(0.1, 0, 0.000001);
}

// ====================================================================
// Stable Fluid Solver (Jos Stam + enhancements)
// ====================================================================
class Fluid {
  constructor(dt, diffusion, viscosity) {
    this.size = 160; // Grid resolution (higher = more detailed, slower)
    this.dt = dt;
    this.diff = diffusion;
    this.visc = viscosity || viscosity;
    
    this.s = createGraphics(this.size, this.size);
    this.density = createGraphics(this.size, this.size);
    this.densityR = createGraphics(this.size, this.size);
    this.densityG = createGraphics(this.size, this.size);
    this.densityB = createGraphics(this.size, this.size);
    
    this.Vx = new Array(this.size * this.size).fill(0);
    this.Vy = new Array(this.size * this.size).fill(0);
    this.Vx0 = new Array(this.size * this.size).fill(0);
    this.Vy0 = new Array(this.size * this.size).fill(0);
    
    this.dens = new Array(this.size * this.size).fill(0);
    this.densR = new Array(this.size * this.size).fill(0);
    this.densG = new Array(this.size * this.size).fill(0);
    this.densB = new Array(this.size * this.size).fill(0);
    
    this.clearDyes();
  }
  
  IX(x, y) {
    x = constrain(floor(x), 0, this.size - 1);
    y = constrain(floor(y), 0, this.size - 1);
    return x + y * this.size;
  }
  
  addDensity(x, y, amount) {
    let idx = this.IX(x / width * this.size, y / height * this.size);
    this.dens[idx] += amount;
  }
  
  addColor(x, y, r, g, b) {
    let idx = this.IX(x / width * this.size, y / height * this.size);
    if (r) { if (typeof r === 'object') this.densR[idx] += r.levels[0]; else this.densR[idx] += r; }
    if (g) { if (typeof g === 'object') this.densG[idx] += g.levels[1]; else this.densG[idx] += g; }
    if (b) { if (typeof b === 'object') this.densB[idx] += b.levels[2]; else this.densB[idx] += b; }
  }
  
  addVelocity(x, y, vx, vy) {
    let idx = this.IX(x / width * this.size, y / height * this.size);
    this.Vx[idx] += vx;
    this.Vy[idx] += vy;
  }
  
  addVorticity(x, y, vx, vy) {
    let cx = x / width * this.size;
    let cy = y / height * this.size;
    for (let i = -2; i <= 2; i++) {
      for (let j = -2; j <= 2; j++) {
        let idx = this.IX(cx + i, cy + j);
        if (idx >= 0 && idx < this.Vx.length) {
          let dist = dist(cx, cy, cx + i, cy + j);
          if (dist < 0.1) dist = 0.1;
          let force = 15 / (dist * dist);
          this.Vx[idx] += vy * force * (j);
          this.Vy[idx] -= vx * force * (i);
        }
      }
    }
  }
  
  clearDyes() {
    this.dens.fill(0);
    this.densR.fill(0);
    this.densG.fill(0);
    this.densB.fill(0);
  }
  
  step() {
    this.diffuse(1, this.Vx0, this.Vx, this.visc, this.dt);
    this.diffuse(2, this.Vy0, this.Vy, this.visc, this.dt);
    
    this.project(this.Vx0, this.Vy0, this.Vx, this.Vy);
    
    this.advect(1, this.Vx, this.Vx0, this.Vx0, this.Vy0, this.dt);
    this.advect(2, this.Vy, this.Vy0, this.Vx0, this.Vy0, this.dt);
    
    this.project(this.Vx, this.Vy, this.Vx0, this.Vy0);
    
    this.diffuseDensity(this.dens, this.diff, this.dt);
    this.diffuseColor(this.densR, this.diff, this.dt);
    this.diffuseColor(this.densG, this.diff, this.dt);
    this.diffuseColor(this.densB, this.diff, this.dt);
    
    this.advectDensity(this.dens, this.dens, this.Vx, this.Vy, this.dt);
    this.advectDensity(this.densR, this.densR, this.Vx, this.Vy, this.dt);
    this.advectDensity(this.densG, this.densG, this.Vx, this.Vy, this.dt);
    this.advectDensity(this.densB, this.densB, this.Vx, this.Vy, this.dt);
  }
  
  diffuse(b, x, x0, diff, dt) {
    let a = dt * diff * (this.size - 2) * (this.size - 2);
    this.lin_solve(b, x, x0, a, 1 + 6 * a);
  }
  
  diffuseDensity(x, diff, dt) {
    let a = dt * diff * (this.size - 2) * (this.size - 2);
    this.lin_solve(0, x, x, a, 1 + 6 * a);
  }
  
  diffuseColor(channel, diff, dt) {
    let a = dt * diff * (this.size - 2) * (this.size - 2);
    this.lin_solve(0, channel, channel, a, 1 + 6 * a);
  }
  
  lin_solve(b, x, x0, a, c) {
    let invC = 1 / c;
    for (let k = 0; k < 20; k++) {
      for (let j = 1; j < this.size - 1; j++) {
        for (let i = 1; i < this.size - 1; i++) {
          let idx = this.IX(i, j);
          x[idx] = (x0[idx] + a * (
            x[this.IX(i+1, j)] + x[this.IX(i-1, j)] +
            x[this.IX(i, j+1)] + x[this.IX(i, j-1)]
          )) * invC;
        }
      }
      this.set_bnd(b, x);
    }
  }
  
  project(vx, vy, p, div) {
    for (let j = 1; j < this.size - 1; j++) {
      for (let i = 1; i < this.size - 1; i++) {
        div[this.IX(i, j)] = -0.5 * (
          vx[this.IX(i+1, j)] - vx[this.IX(i-1, j)] +
          vy[this.IX(i, j+1)] - vy[this.IX(i, j-1)]
        ) / this.size;
        p[this.IX(i, j)] = 0;
      }
    }
    this.set_bnd(0, div); this.set_bnd(0, p);
    this.lin_solve(0, p, div, 1, 6);
    
    for (let j = 1; j < this.size - 1; j++) {
      for (let i = 1; i < this.size - 1; i++) {
        vx[this.IX(i, j)] -= 0.5 * (p[this.IX(i+1, j)] - p[this.IX(i-1, j)]) * this.size;
        vy[this.IX(i, j)] -= 0.5 * (p[this.IX(i, j+1)] - p[this.IX(i, j-1)]) * this.size;
      }
    }
    this.set_bnd(1, vx); this.set_bnd(2, vy);
  }
  
  advect(b, d, d0, vx, vy, dt) {
    let dt0 = dt * this.size;
    for (let j = 1; j < this.size - 1; j++) {
      for (let i = 1; i < this.size - 1; i++) {
        let x = i - dt0 * vx[this.IX(i, j)];
        let y = j - dt0 * vy[this.IX(i, j)];
        if (x < 0.5) x = 0.5; if (x > this.size - 1.5) x = this.size - 1.5;
        if (y < 0.5) y = 0.5; if (y > this.size - 1.5) y = this.size - 1.5;
        
        let i0 = floor(x); let i1 = i0 + 1;
        let j0 = floor(y); let j1 = j0 + 1;
        
        let s1 = x - i0; let s0 = 1 - s1;
        let t1 = y - j0; let t0 = 1 - t1;
        
        d[this.IX(i, j)] =
          s0 * (t0 * d0[this.IX(i0, j0)] + t1 * d0[this.IX(i0, j1)]) +
          s1 * (t0 * d0[this.IX(i1, j0)] + t1 * d0[this.IX(i1, j1)]);
      }
    }
    this.set_bnd(b, d);
  }
  
  advectDensity(d, d0, vx, vy, dt) {
    this.advect(0, d, d0, vx, vy, dt);
  }
  
  set_bnd(b, x) {
    for (let i = 1; i < this.size - 1; i++) {
      x[this.IX(i, 0)] = b === 2 ? -x[this.IX(i, 1)] : x[this.IX(i, 1)];
      x[this.IX(i, this.size-1)] = b === 2 ? -x[this.IX(i, this.size-2)] : x[this.IX(i, this.size-2)];
    }
    for (let j = 1; j < this.size - 1; j++) {
      x[this.IX(0, j)] = b === 1 ? -x[this.IX(1, j)] : x[this.IX(1, j)];
      x[this.IX(this.size-1, j)] = b === 1 ? -x[this.IX(this.size-2, j)] : x[this.IX(this.size-2, j)];
    }
    
    x[this.IX(0, 0)] = 0.5 * (x[this.IX(1, 0)] + x[this.IX(0, 1)]);
    x[this.IX(0, this.size-1)] = 0.5 * (x[this.IX(1, this.size-1)] + x[this.IX(0, this.size-2)]);
    x[this.IX(this.size-1, 0)] = 0.5 * (x[this.IX(this.size-2, 0)] + x[this.IX(this.size-1, 1)]);
    x[this.IX(this.size-1, this.size-1)] = 0.5 * (x[this.IX(this.size-2, this.size-1)] + x[this.IX(this.size-1, this.size-2)]);
  }
  
  update() {
    this.step();
  }
  
  render() {
    this.density.clear();
    this.densityR.clear();
    this.densityG.clear();
    this.densityB.clear();
    
    // Draw density with smooth falloff
    this.density.background(10, 15, 25);
    this.density.noStroke();
    for (let j = 0; j < this.size; j++) {
      for (let i = 0; i < this.size; i++) {
        let idx = i + j * this.size;
        let d = this.dens[idx];
        if (d > 0) {
          let alpha = constrain(d / 30, 0, 1);
          this.density.fill(255, 255, 255, alpha * 80);
          this.density.rect(i, j, 1, 1);
        }
      }
    }
    
    // Draw beautiful colored dyes
    this.densityR.imageMode(CORNER);
    this.densityR.noStroke();
    for (let j = 0; j < this.size; j++) {
      for (let i = 0; i < this.size; i++) {
        let idx = i + j * this.size;
        let r = this.densR[idx];
        let g = this.densG[idx];
        let b = this.densB[idx];
        if (r + g + b > 5) {
          let amount = (r + g + b) / 80;
          this.densityR.fill(r, 0, 0, amount * 255);
          this.densityR.rect(i, j, 1, 1);
          this.densityG.fill(0, g, 0, amount * 255);
          this.densityG.rect(i, j, 1, 1);
          this.densityB.fill(0, 0, b, amount * 255);
          this.densityB.rect(i, j, 1, 1);
        }
      }
    }
    
    // Combine everything
    image(this.density, 0, 0, width, height);
    blendMode(ADD);
    image(this.densityR, 0, 0, width, height);
    image(this.densityG, 0, 0, width, height);
    image(this.densityB, 0, 0, width, height);
    blendMode(BLEND);
    
    // Optional: Add subtle velocity field visualization
    if (mouseIsPressed && !vortexMode) {
      stroke(255, 50);
      strokeWeight(1);
      for (let j = 0; j < height; j += 30) {
        for (let i = 0; i < width; i += 30) {
          let idx = this.IX(i / width * this.size, j / height * this.size);
          let vx = this.Vx[idx] * 10;
          let vy = this.Vy[idx] * 10;
          if (abs(vx) + abs(vy) > 0.1) {
            line(i, j, i + vx, j + vy);
          }
        }
      }
    }
  }
}
</script>
</body>
</html>