<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>4D Tesseract Projection – p5.js</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      color: #eee;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <!-- p5.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>

  <script>
    // --- Geometry data ---
    let vertices4D = [];
    let edges = [];

    // Rotation state (angles in radians)
    let angles = {
      xy: 0,
      xz: 0,
      xw: 0,
      yz: 0,
      yw: 0,
      zw: 0
    };

    let rotationEnabled = {
      xy: false,
      xz: true,
      xw: true,
      yz: false,
      yw: true,
      zw: false
    };

    let rotationSpeed = 0.8; // radians per second (global speed factor)
    let paused = false;

    // Projection parameters
    let usePerspective = true;   // toggle between perspective and orthographic (3D -> 2D)
    let perspectiveDistance = 4; // camera distance for perspective projection

    function setup() {
      createCanvas(windowWidth, windowHeight);
      pixelDensity(window.devicePixelRatio || 1);
      strokeJoin(ROUND);
      strokeCap(ROUND);
      textFont("monospace");
      initTesseract();
    }

    function initTesseract() {
      vertices4D = [];
      edges = [];

      // Generate 16 vertices of a tesseract: (±1, ±1, ±1, ±1)
      for (let w = -1; w <= 1; w += 2) {
        for (let z = -1; z <= 1; z += 2) {
          for (let y = -1; y <= 1; y += 2) {
            for (let x = -1; x <= 1; x += 2) {
              vertices4D.push([x, y, z, w]);
            }
          }
        }
      }

      // Generate 32 edges: connect vertices differing in exactly one coordinate
      const n = vertices4D.length;
      for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
          const a = vertices4D[i];
          const b = vertices4D[j];
          let diffCount = 0;
          let wDiff = false;

          if (a[0] !== b[0]) diffCount++;
          if (a[1] !== b[1]) diffCount++;
          if (a[2] !== b[2]) diffCount++;
          if (a[3] !== b[3]) {
            diffCount++;
            wDiff = true; // edge along the 4th dimension
          }

          if (diffCount === 1) {
            edges.push({ a: i, b: j, isHyper: wDiff });
          }
        }
      }
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }

    function draw() {
      background(8);

      // --- Update rotation angles ---
      if (!paused) {
        const dt = deltaTime / 1000.0; // seconds since last frame
        const s = rotationSpeed;

        if (rotationEnabled.xy) angles.xy += s * dt;
        if (rotationEnabled.xz) angles.xz += s * dt;
        if (rotationEnabled.xw) angles.xw += s * dt;
        if (rotationEnabled.yz) angles.yz += s * dt;
        if (rotationEnabled.yw) angles.yw += s * dt;
        if (rotationEnabled.zw) angles.zw += s * dt;
      }

      // Precompute cos & sin for each rotation plane
      const cxy = Math.cos(angles.xy), sxy = Math.sin(angles.xy);
      const cxz = Math.cos(angles.xz), sxz = Math.sin(angles.xz);
      const cxw = Math.cos(angles.xw), sxw = Math.sin(angles.xw);
      const cyz = Math.cos(angles.yz), syz = Math.sin(angles.yz);
      const cyw = Math.cos(angles.yw), syw = Math.sin(angles.yw);
      const czw = Math.cos(angles.zw), szw = Math.sin(angles.zw);

      // --- 4D -> 3D (rotation in 4D, then drop w) ---
      const verts3D = new Array(vertices4D.length);
      let minZ = Infinity;
      let maxZ = -Infinity;

      for (let i = 0; i < vertices4D.length; i++) {
        let x = vertices4D[i][0];
        let y = vertices4D[i][1];
        let z = vertices4D[i][2];
        let w = vertices4D[i][3];

        // Rotate in XY plane
        let nx = x * cxy - y * sxy;
        let ny = x * sxy + y * cxy;
        x = nx; y = ny;

        // Rotate in XZ plane
        nx = x * cxz - z * sxz;
        let nz = x * sxz + z * cxz;
        x = nx; z = nz;

        // Rotate in XW plane
        nx = x * cxw - w * sxw;
        let nw = x * sxw + w * cxw;
        x = nx; w = nw;

        // Rotate in YZ plane
        ny = y * cyz - z * syz;
        nz = y * syz + z * cyz;
        y = ny; z = nz;

        // Rotate in YW plane
        ny = y * cyw - w * syw;
        nw = y * syw + w * cyw;
        y = ny; w = nw;

        // Rotate in ZW plane
        nz = z * czw - w * szw;
        nw = z * szw + w * czw;
        z = nz; w = nw;

        // 4D -> 3D: orthographic (drop w)
        const vx = x;
        const vy = y;
        const vz = z;

        verts3D[i] = { x: vx, y: vy, z: vz };
        if (vz < minZ) minZ = vz;
        if (vz > maxZ) maxZ = vz;
      }

      // --- 3D -> 2D projection ---
      const verts2D = new Array(vertices4D.length);
      const scale = Math.min(width, height) * 0.30; // overall size

      for (let i = 0; i < verts3D.length; i++) {
        const v = verts3D[i];
        let factor = 1;

        if (usePerspective) {
          const denom = (perspectiveDistance - v.z);
          factor = perspectiveDistance / (denom === 0 ? 1e-6 : denom);
        }

        verts2D[i] = {
          x: v.x * factor * scale,
          y: v.y * factor * scale
        };
      }

      // --- Depth-sorted edges for nicer overdraw ---
      const edgesSorted = edges
        .map(e => {
          const za = verts3D[e.a].z;
          const zb = verts3D[e.b].z;
          return { edge: e, depth: (za + zb) * 0.5 };
        })
        .sort((a, b) => a.depth - b.depth);

      push();
      translate(width / 2, height / 2);

      // --- Draw edges with subtle depth shading and color differences ---
      for (const item of edgesSorted) {
        const e = item.edge;
        const a = verts2D[e.a];
        const b = verts2D[e.b];
        const d = item.depth;

        // Normalized depth 0..1 (far -> 0, near -> 1)
        const t = (maxZ === minZ) ? 0.5 : (d - minZ) / (maxZ - minZ);
        const alpha = 90 + 150 * t;
        const weight = 0.6 + 1.4 * t;

        strokeWeight(weight);

        if (e.isHyper) {
          // Edges that connect inner/outer cubes (4th dimension)
          const r = 100 + 80 * t;
          const g = 180 + 50 * t;
          const bcol = 255;
          stroke(r, g, bcol, alpha);
        } else {
          // Edges within each 3D cube
          const c = 180 + 70 * t;
          stroke(c, c, c, alpha);
        }

        line(a.x, a.y, b.x, b.y);
      }

      // --- Optional: small vertices to help perception ---
      noStroke();
      for (let i = 0; i < verts2D.length; i++) {
        const v = verts2D[i];
        const z = verts3D[i].z;
        const t = (maxZ === minZ) ? 0.5 : (z - minZ) / (maxZ - minZ);
        const sz = 3 + 2 * t;
        fill(255, 255, 255, 120 + 80 * t);
        ellipse(v.x, v.y, sz, sz);
      }

      pop();

      // --- HUD / controls text ---
      drawHUD(perspectiveDistance);
    }

    function drawHUD(dist) {
      const modeStr = usePerspective ? "Perspective" : "Orthographic";
      const lines = [
        "4D Tesseract (Hypercube) Projection",
        "",
        "Projection: " + modeStr + "  |  Distance: " + dist.toFixed(2),
        "Rotation speed: " + rotationSpeed.toFixed(2) + " rad/s",
        "Active planes: " + activePlanesString(),
        "",
        "Controls:",
        "  Space / Mouse click : Pause / resume rotation",
        "  1–6 : Toggle rotation planes (XY, XZ, XW, YZ, YW, ZW)",
        "  O / P : Orthographic / Perspective projection",
        "  [ / ] : Decrease / increase projection distance",
        "  - / = : Slower / faster rotation",
        "  R     : Reset orientation"
      ];

      push();
      resetMatrix();
      textAlign(LEFT, TOP);
      textSize(12);
      fill(230);
      noStroke();

      let x = 12;
      let y = 12;
      for (const line of lines) {
        text(line, x, y);
        y += 14;
      }

      // FPS in bottom-right
      const fps = frameRate();
      textAlign(RIGHT, BOTTOM);
      text("FPS: " + fps.toFixed(1), width - 10, height - 10);
      pop();
    }

    function activePlanesString() {
      const labels = ["XY", "XZ", "XW", "YZ", "YW", "ZW"];
      const keys = ["xy", "xz", "xw", "yz", "yw", "zw"];
      const parts = [];
      for (let i = 0; i < keys.length; i++) {
        if (rotationEnabled[keys[i]]) parts.push(labels[i]);
      }
      return parts.length ? parts.join(", ") : "None";
    }

    function keyPressed() {
      // Pause / resume
      if (key === " ") {
        paused = !paused;
      }

      // Toggle rotation planes
      if (key === "1") rotationEnabled.xy = !rotationEnabled.xy;
      if (key === "2") rotationEnabled.xz = !rotationEnabled.xz;
      if (key === "3") rotationEnabled.xw = !rotationEnabled.xw;
      if (key === "4") rotationEnabled.yz = !rotationEnabled.yz;
      if (key === "5") rotationEnabled.yw = !rotationEnabled.yw;
      if (key === "6") rotationEnabled.zw = !rotationEnabled.zw;

      // Projection mode
      if (key === "O" || key === "o") usePerspective = false;
      if (key === "P" || key === "p") usePerspective = true;

      // Projection distance
      if (key === "[") {
        perspectiveDistance = Math.max(2.0, perspectiveDistance - 0.2);
      }
      if (key === "]") {
        perspectiveDistance = Math.min(10.0, perspectiveDistance + 0.2);
      }

      // Rotation speed
      if (key === "-" || keyCode === 189) {
        rotationSpeed = Math.max(0, rotationSpeed - 0.1);
      }
      if (key === "=" || keyCode === 187) {
        rotationSpeed = Math.min(5.0, rotationSpeed + 0.1);
      }

      // Reset orientation
      if (key === "R" || key === "r") {
        angles.xy = angles.xz = angles.xw = angles.yz = angles.yw = angles.zw = 0;
      }
    }

    function mousePressed() {
      // Left-click / tap: toggle pause
      paused = !paused;
    }
  </script>
</body>
</html>