<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy Formation Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            animation: fadeIn 0.5s ease-out;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            color: #ccc;
        }

        #sketch-container {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            animation: slideUp 0.6s ease-out;
        }

        .controls {
            margin-top: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            color: white;
            max-width: 800px;
            animation: slideUp 0.7s ease-out;
            backdrop-filter: blur(10px);
        }

        .controls h2 {
            margin-bottom: 15px;
            color: #667eea;
            font-size: 1.5rem;
        }

        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .control-group {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .control-group h3 {
            font-size: 1rem;
            margin-bottom: 8px;
            color: #ccc;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .key {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.2);
            display: flex;
            justify-content: space-around;
            text-align: center;
        }

        .stat-item {
            flex: 1;
        }

        .stat-label {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { 
                opacity: 0;
                transform: translateY(20px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Galaxy Formation Simulation</h1>
        <p class="subtitle">10,000 particles evolving into a spiral galaxy</p>
    </header>

    <div id="sketch-container"></div>

    <div class="controls">
        <h2>Simulation Controls</h2>
        <div class="control-grid">
            <div class="control-group">
                <h3>View Controls</h3>
                <div class="control-item">
                    <span>Zoom in/out</span>
                    <span class="key">Mouse Wheel</span>
                </div>
                <div class="control-item">
                    <span>Pan view</span>
                    <span class="key">Drag</span>
                </div>
                <div class="control-item">
                    <span>Toggle trails</span>
                    <span class="key">T</span>
                </div>
                <div class="control-item">
                    <span>Focus on center</span>
                    <span class="key">F</span>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Simulation</h3>
                <div class="control-item">
                    <span>Reset galaxy</span>
                    <span class="key">R</span>
                </div>
                <div class="control-item">
                    <span>Toggle pause</span>
                    <span class="key">SPACE</span>
                </div>
                <div class="control-item">
                    <span>Add perturbation</span>
                    <span class="key">P</span>
                </div>
                <div class="control-item">
                    <span>Toggle dark matter</span>
                    <span class="key">D</span>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Display</h3>
                <div class="control-item">
                    <span>Toggle quadtree</span>
                    <span class="key">Q</span>
                </div>
                <div class="control-item">
                    <span>Show orbits</span>
                    <span class="key">O</span>
                </div>
                <div class="control-item">
                    <span>Color mode</span>
                    <span class="key">C</span>
                </div>
                <div class="control-item">
                    <span>High quality</span>
                    <span class="key">H</span>
                </div>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-item">
                <div class="stat-label">Active Particles</div>
                <div class="stat-value" id="particleCount">10000</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Merged Particles</div>
                <div class="stat-value" id="mergedCount">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Simulation Speed</div>
                <div class="stat-value" id="speedValue">1.0x</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Time Elapsed</div>
                <div class="stat-value" id="timeValue">0 Myr</div>
            </div>
        </div>
    </div>

    <script>
        // Quadtree implementation for spatial partitioning
        class Quadtree {
            constructor(boundary, capacity) {
                this.boundary = boundary;
                this.capacity = capacity;
                this.particles = [];
                this.divided = false;
                this.totalMass = 0;
                this.centerOfMass = createVector(0, 0);
            }

            insert(particle) {
                if (!this.boundary.contains(particle.pos)) return false;

                if (this.particles.length < this.capacity) {
                    this.particles.push(particle);
                    this.totalMass += particle.mass;
                    this.centerOfMass.add(pVector.mult(particle.pos, particle.mass));
                    return true;
                }

                if (!this.divided) this.subdivide();

                if (this.northeast.insert(particle)) return true;
                if (this.northwest.insert(particle)) return true;
                if (this.southeast.insert(particle)) return true;
                if (this.southwest.insert(particle)) return true;

                return false;
            }

            subdivide() {
                let x = this.boundary.x;
                let y = this.boundary.y;
                let w = this.boundary.w / 2;
                let h = this.boundary.h / 2;

                this.northeast = new Quadtree(new Rectangle(x + w, y, w, h), this.capacity);
                this.northwest = new Quadtree(new Rectangle(x, y, w, h), this.capacity);
                this.southeast = new Quadtree(new Rectangle(x + w, y + h, w, h), this.capacity);
                this.southwest = new Quadtree(new Rectangle(x, y + h, w, h), this.capacity);

                this.divided = true;
            }

            query(range, found) {
                if (!this.boundary.intersects(range)) return;

                for (let p of this.particles) {
                    if (range.contains(p.pos)) found.push(p);
                }

                if (this.divided) {
                    this.northeast.query(range, found);
                    this.northwest.query(range, found);
                    this.southeast.query(range, found);
                    this.southwest.query(range, found);
                }
            }

            calculateForces(particle, theta, G, softening) {
                if (!this.boundary.intersects(new Circle(particle.pos.x, particle.pos.y, 1000))) return;

                if (this.particles.length === 0) return;

                let dx = this.centerOfMass.x / this.totalMass - particle.pos.x;
                let dy = this.centerOfMass.y / this.totalMass - particle.pos.y;
                let distance = sqrt(dx * dx + dy * dy);

                if ((this.boundary.w / distance < theta || !this.divided) && this.totalMass > 0) {
                    let force = G * particle.mass * this.totalMass / (distance * distance + softening * softening);
                    let fx = force * dx / distance;
                    let fy = force * dy / distance;
                    particle.applyForce(fx, fy);
                } else if (this.divided) {
                    this.northeast.calculateForces(particle, theta, G, softening);
                    this.northwest.calculateForces(particle, theta, G, softening);
                    this.southeast.calculateForces(particle, theta, G, softening);
                    this.southwest.calculateForces(particle, theta, G, softening);
                } else {
                    for (let p of this.particles) {
                        if (p !== particle) {
                            let dx = p.pos.x - particle.pos.x;
                            let dy = p.pos.y - particle.pos.y;
                            let distance = sqrt(dx * dx + dy * dy);
                            if (distance > 0) {
                                let force = G * particle.mass * p.mass / (distance * distance + softening * softening);
                                let fx = force * dx / distance;
                                let fy = force * dy / distance;
                                particle.applyForce(fx, fy);
                            }
                        }
                    }
                }
            }

            clear() {
                this.particles = [];
                this.totalMass = 0;
                this.centerOfMass = createVector(0, 0);
                if (this.divided) {
                    this.northeast.clear();
                    this.northwest.clear();
                    this.southeast.clear();
                    this.southwest.clear();
                }
            }

            show() {
                stroke(100, 50);
                strokeWeight(0.5);
                noFill();
                rect(this.boundary.x, this.boundary.y, this.boundary.w * 2, this.boundary.h * 2);

                if (this.divided) {
                    this.northeast.show();
                    this.northwest.show();
                    this.southeast.show();
                    this.southwest.show();
                }
            }
        }

        class Rectangle {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
            }

            contains(point) {
                return point.x >= this.x - this.w && point.x <= this.x + this.w &&
                       point.y >= this.y - this.h && point.y <= this.y + this.h;
            }

            intersects(range) {
                return !(range.x - range.w > this.x + this.w || range.x + range.w < this.x - this.w ||
                         range.y - range.h > this.y + this.h || range.y + range.h < this.y - this.h);
            }
        }

        class Circle {
            constructor(x, y, r) {
                this.x = x;
                this.y = y;
                this.r = r;
            }

            contains(point) {
                let d = dist(point.x, point.y, this.x, this.y);
                return d <= this.r;
            }

            intersects(range) {
                let xDist = abs(range.x - this.x);
                let yDist = abs(range.y - this.y);
                let w = range.w;
                let h = range.h;

                let edges = pow(xDist - w, 2) + pow(yDist - h, 2);

                if (xDist > w + this.r || yDist > h + this.r) return false;
                if (xDist <= w || yDist <= h) return true;
                return edges <= this.r * this.r;
            }
        }

        // Galaxy particle class
        class GalaxyParticle {
            constructor(x, y, mass, velocity) {
                this.pos = createVector(x, y);
                this.vel = velocity || createVector(0, 0);
                this.acc = createVector(0, 0);
                this.mass = mass;
                this.radius = sqrt(mass) * 0.5;
                this.brightness = random(150, 255);
                this.trail = [];
                this.maxTrailLength = 20;
                this.color = this.generateColor();
                this.merged = false;
                this.angularMomentum = this.pos.cross(this.vel);
            }

            generateColor() {
                let colors = [
                    [255, 200, 150], // Yellowish stars
                    [200, 220, 255], // Bluish stars
                    [255, 180, 120], // Orange stars
                    [220, 200, 255]  // Purple stars
                ];
                return random(colors);
            }

            applyForce(fx, fy) {
                this.acc.x += fx / this.mass;
                this.acc.y += fy / this.mass;
            }

            update() {
                this.vel.add(this.acc);
                this.vel.mult(0.995); // Slight damping
                this.pos.add(this.vel);
                this.acc.mult(0);

                // Update trail
                if (frameCount % 3 === 0) {
                    this.trail.push(this.pos.copy());
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                }

                // Update brightness based on velocity
                this.brightness = map(this.vel.mag(), 0, 5, 100, 255);
            }

            show() {
                // Draw trail
                if (showTrails && this.trail.length > 1) {
                    noFill();
                    for (let i = 1; i < this.trail.length; i++) {
                        let alpha = map(i, 0, this.trail.length, 0, 100);
                        stroke(this.color[0], this.color[1], this.color[2], alpha);
                        strokeWeight(map(i, 0, this.trail.length, 0.5, 2));
                        line(this.trail[i-1].x, this.trail[i-1].y, this.trail[i].x, this.trail[i].y);
                    }
                }

                // Draw particle
                noStroke();
                let brightness = this.brightness;
                if (colorMode === 'velocity') {
                    let speed = this.vel.mag();
                    let hue = map(speed, 0, 3, 0, 60);
                    fill(hue, 200, brightness);
                } else if (colorMode === 'mass') {
                    fill(this.color[0], this.color[1], this.color[2], brightness);
                } else {
                    fill(255, 255, 255, brightness);
                }

                let r = this.radius * zoom;
                if (r > 0.5) {
                    ellipse(this.pos.x, this.pos.y, r * 2);
                    
                    // Add glow effect for massive particles
                    if (this.mass > 10) {
                        fill(this.color[0], this.color[1], this.color[2], 30);
                        ellipse(this.pos.x, this.pos.y, r * 4);
                    }
                }
            }

            checkCollision(other) {
                if (this.merged || other.merged) return false;
                
                let d = p5.Vector.dist(this.pos, other.pos);
                let minDist = (this.radius + other.radius) * 0.8;
                
                if (d < minDist) {
                    // Merge particles
                    let totalMass = this.mass + other.mass;
                    
                    // Conservation of momentum
                    this.vel.mult(this.mass).add(pVector.mult(other.vel, other.mass)).div(totalMass);
                    
                    // Update position to center of mass
                    this.pos.mult(this.mass).add(pVector.mult(other.pos, other.mass)).div(totalMass);
                    
                    this.mass = totalMass;
                    this.radius = sqrt(this.mass) * 0.5;
                    
                    other.merged = true;
                    return true;
                }
                return false;
            }
        }

        // Dark matter halo
        class DarkMatterHalo {
            constructor(mass, radius) {
                this.mass = mass;
                this.radius = radius;
            }

            getForceAt(position) {
                let center = createVector(0, 0);
                let r = p5.Vector.dist(position, center);
                
                if (r > this.radius) return createVector(0, 0);
                
                // Simplified dark matter potential
                let forceMagnitude = G * this.mass / (r * r + 1000);
                let forceDirection = p5.Vector.mult(position, -1).normalize();
                
                return p5.Vector.mult(forceDirection, forceMagnitude);
            }
        }

        // Central supermassive black hole
        class CentralBlackHole {
            constructor(mass) {
                this.mass = mass;
                this.pos = createVector(0, 0);
            }

            applyGravity(particle) {
                let dx = this.pos.x - particle.pos.x;
                let dy = this.pos.y - particle.pos.y;
                let distance = sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    let force = G * this.mass * particle.mass / (distance * distance + 100);
                    let fx = force * dx / distance;
                    let fy = force * dy / distance;
                    particle.applyForce(fx, fy);
                }
            }

            show() {
                // Draw accretion disk
                noStroke();
                for (let r = 20; r < 80; r += 10) {
                    let alpha = map(r, 20, 80, 150, 20);
                    fill(255, 100, 50, alpha);
                    ellipse(this.pos.x, this.pos.y, r * 2 * zoom);
                }
                
                // Draw black hole
                fill(0);
                ellipse(this.pos.x, this.pos.y, 30 * zoom);
                
                // Draw event horizon glow
                fill(100, 50, 255, 50);
                ellipse(this.pos.x, this.pos.y, 35 * zoom);
            }
        }

        // Simulation variables
        let particles = [];
        let quadtree;
        let blackHole;
        let darkMatterHalo;
        let zoom = 0.5;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let showTrails = true;
        let showQuadtree = false;
        let showOrbits = false;
        let colorMode = 'normal';
        let isPaused = false;
        let simulationSpeed = 1;
        let timeCounter = 0;

        // Physics constants
        const G = 0.5;
        const SOFTENING = 5;
        const THETA = 0.5;
        const INITIAL_RADIUS = 400;
        const INITIAL_MASS = 1;

        function setup() {
            let canvas = createCanvas(800, 600);
            canvas.parent('sketch-container');
            
            initializeGalaxy();
        }

        function initializeGalaxy() {
            particles = [];
            quadtree = new Quadtree(new Rectangle(0, 0, width * 2, height * 2), 4);
            
            // Create central black hole
            blackHole = new CentralBlackHole(5000);
            
            // Create dark matter halo
            darkMatterHalo = new DarkMatterHalo(50000, 1500);
            
            // Create initial protogalactic cloud
            for (let i = 0; i < 10000; i++) {
                // Random position in spherical distribution
                let angle = random(TWO_PI);
                let r = random(INITIAL_RADIUS);
                let x = r * cos(angle);
                let y = r * sin(angle);
                
                // Add slight vertical displacement for disk formation
                y += random(-20, 20);
                
                // Initial velocity for rotation
                let orbitalSpeed = sqrt(G * blackHole.mass / (r + 50));
                let vx = -orbitalSpeed * sin(angle) * (0.8 + random(0.4));
                let vy = orbitalSpeed * cos(angle) * (0.8 + random(0.4));
                
                // Add random perturbations
                vx += random(-0.5, 0.5);
                vy += random(-0.5, 0.5);
                
                let mass = random(0.5, 2);
                let velocity = createVector(vx, vy);
                
                particles.push(new GalaxyParticle(x, y, mass, velocity));
            }
        }

        function draw() {
            // Subtle background
            background(220, 220, 220, 30);
            
            if (!isPaused) {
                // Update simulation speed based on FPS
                simulationSpeed = constrain(frameRate() / 60, 0.5, 2);
                timeCounter += simulationSpeed;
                
                // Clear and rebuild quadtree
                quadtree.clear();
                for (let particle of particles) {
                    if (!particle.merged) {
                        quadtree.insert(particle);
                    }
                }
                
                // Apply forces and update particles
                for (let particle of particles) {
                    if (!particle.merged) {
                        // Apply black hole gravity
                        blackHole.applyGravity(particle);
                        
                        // Apply dark matter halo
                        if (showDarkMatter) {
                            let dmForce = darkMatterHalo.getForceAt(particle.pos);
                            particle.applyForce(dmForce.x, dmForce.y);
                        }
                        
                        // Apply gravity from other particles using quadtree
                        quadtree.calculateForces(particle, THETA, G, SOFTENING);
                    }
                }
                
                // Update particles and check collisions
                let mergedCount = 0;
                for (let i = particles.length - 1; i >= 0; i--) {
                    let particle = particles[i];
                    if (!particle.merged) {
                        particle.update();
                        
                        // Check collisions with nearby particles
                        let range = new Circle(particle.pos.x, particle.pos.y, particle.radius * 4);
                        let nearby = [];
                        quadtree.query(range, nearby);
                        
                        for (let other of nearby) {
                            if (particle !== other && !other.merged) {
                                if (particle.checkCollision(other)) {
                                    mergedCount++;
                                }
                            }
                        }
                    }
                }
                
                // Remove merged particles
                particles = particles.filter(p => !p.merged);
            }
            
            // Apply transformations
            push();
            translate(width / 2 + offsetX, height / 2 + offsetY);
            scale(zoom);
            
            // Draw orbits
            if (showOrbits) {
                stroke(100, 50);
                strokeWeight(0.5);
                noFill();
                for (let r = 100; r < INITIAL_RADIUS; r += 50) {
                    ellipse(0, 0, r * 2);
                }
            }
            
            // Draw dark matter halo
            if (showDarkMatter) {
                noStroke();
                for (let r = 200; r < darkMatterHalo.radius; r += 100) {
                    let alpha = map(r, 200, darkMatterHalo.radius, 10, 2);
                    fill(100, 50, 255, alpha);
                    ellipse(0, 0, r * 2);
                }
            }
            
            // Draw particles
            for (let particle of particles) {
                particle.show();
            }
            
            // Draw black hole
            blackHole.show();
            
            // Draw quadtree
            if (showQuadtree) {
                quadtree.show();
            }
            
            pop();
            
            // Update UI stats
            updateStats();
        }

        function updateStats() {
            document.getElementById('particleCount').textContent = particles.length;
            document.getElementById('mergedCount').textContent = 10000 - particles.length;
            document.getElementById('speedValue').textContent = simulationSpeed.toFixed(1) + 'x';
            document.getElementById('timeValue').textContent = Math.floor(timeCounter / 100) + ' Myr';
        }

        function mousePressed() {
            if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {
                if (mouseButton === LEFT) {
                    isDragging = true;
                    dragStartX = mouseX - offsetX;
                    dragStartY = mouseY - offsetY;
                }
            }
        }

        function mouseDragged() {
            if (isDragging) {
                offsetX = mouseX - dragStartX;
                offsetY = mouseY - dragStartY;
            }
        }

        function mouseReleased() {
            isDragging = false;
        }

        function mouseWheel(event) {
            zoom *= (1 - event.delta * 0.001);
            zoom = constrain(zoom, 0.1, 5);
            return false;
        }

        function keyPressed() {
            switch(key) {
                case ' ':
                    isPaused = !isPaused;
                    break;
                case 'r':
                case 'R':
                    initializeGalaxy();
                    timeCounter = 0;
                    break;
                case 't':
                case 'T':
                    showTrails = !showTrails;
                    break;
                case 'f':
                case 'F':
                    offsetX = 0;
                    offsetY = 0;
                    zoom = 0.5;
                    break;
                case 'q':
                case 'Q':
                    showQuadtree = !showQuadtree;
                    break;
                case 'o':
                case 'O':
                    showOrbits = !showOrbits;
                    break;
                case 'c':
                case 'C':
                    colorMode = colorMode === 'normal' ? 'velocity' : 
                               colorMode === 'velocity' ? 'mass' : 'normal';
                    break;
                case 'd':
                case 'D':
                    showDarkMatter = !showDarkMatter;
                    break;
                case 'h':
                case 'H':
                    let quality = particles.length > 5000 ? 5000 : 10000;
                    particles = particles.slice(0, quality);
                    break;
                case 'p':
                case 'P':
                    // Add perturbation
                    for (let particle of particles) {
                        if (!particle.merged && random() < 0.1) {
                            particle.vel.add(random(-1, 1), random(-1, 1));
                        }
                    }
                    break;
            }
        }

        // Global variable for dark matter visibility
        let showDarkMatter = true;
    </script>
</body>
</html>