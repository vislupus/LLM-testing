<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy Formation Simulation - 10,000 Particles</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a2e;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #simulation-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #canvas-container {
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
        }

        .info-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.75);
            padding: 15px 20px;
            border-radius: 12px;
            color: #fff;
            font-size: 0.85rem;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 200px;
        }

        .info-title {
            font-size: 1.1rem;
            font-weight: bold;
            color: #f7b731;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(247, 183, 49, 0.3);
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            padding: 4px 0;
        }

        .info-label {
            color: #aaa;
        }

        .info-value {
            font-weight: bold;
            color: #4ecdc4;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.75);
            padding: 12px 25px;
            border-radius: 30px;
            color: #fff;
            font-size: 0.8rem;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-label {
            color: #aaa;
        }

        .slider {
            width: 80px;
            cursor: pointer;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(78, 205, 196, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(155, 89, 182, 0.4);
        }

        .stats-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.75);
            padding: 15px 20px;
            border-radius: 12px;
            color: #fff;
            font-size: 0.8rem;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stats-title {
            font-size: 1rem;
            font-weight: bold;
            color: #e94560;
            margin-bottom: 10px;
        }

        .phase-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 12px;
            color: #fff;
            font-size: 1.2rem;
            font-weight: bold;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.5s ease;
            border: 2px solid #f7b731;
        }

        .phase-indicator.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="simulation-container">
        <div id="canvas-container"></div>
    </div>

    <!-- Info Panel -->
    <div class="info-panel">
        <div class="info-title">ðŸŒŒ Galaxy Formation</div>
        <div class="info-item">
            <span class="info-label">Particles</span>
            <span class="info-value" id="particle-count">10,000</span>
        </div>
        <div class="info-item">
            <span class="info-label">Central Mass</span>
            <span class="info-value" id="central-mass">5000</span>
        </div>
        <div class="info-item">
            <span class="info-label">Dark Matter</span>
            <span class="info-value" id="dark-matter">Active</span>
        </div>
        <div class="info-item">
            <span class="info-label">Mergers</span>
            <span class="info-value" id="merger-count">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">FPS</span>
            <span class="info-value" id="fps">60</span>
        </div>
    </div>

    <!-- Stats Panel -->
    <div class="stats-panel">
        <div class="stats-title">Simulation Stats</div>
        <div class="info-item">
            <span class="info-label">Phase</span>
            <span class="info-value" id="sim-phase">Initial Cloud</span>
        </div>
        <div class="info-item">
            <span class="info-label">Total Mass</span>
            <span class="info-value" id="total-mass">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">Kinetic Energy</span>
            <span class="info-value" id="kinetic-energy">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">Radius</span>
            <span class="info-value" id="galaxy-radius">-</span>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <div class="control-group">
            <span class="control-label">Gravity:</span>
            <input type="range" class="slider" id="gravitySlider" min="0.1" max="2" step="0.1" value="0.5">
            <span id="gravityValue">0.5</span>
        </div>
        <div class="control-group">
            <span class="control-label">Dark Matter:</span>
            <input type="range" class="slider" id="dmSlider" min="0" max="2" step="0.1" value="1">
            <span id="dmValue">1.0</span>
        </div>
        <div class="control-group">
            <span class="control-label">Speed:</span>
            <input type="range" class="slider" id="speedSlider" min="0.1" max="2" step="0.1" value="1">
            <span id="speedValue">1.0x</span>
        </div>
        <div class="control-group">
            <span class="control-label">Trails:</span>
            <input type="range" class="slider" id="trailSlider" min="0" max="10" step="1" value="3">
            <span id="trailValue">3</span>
        </div>
        <button class="btn btn-secondary" onclick="resetSimulation()">Reset</button>
        <button class="btn btn-primary" onclick="togglePause()">Pause</button>
    </div>

    <!-- Phase Indicator -->
    <div class="phase-indicator" id="phaseIndicator"></div>

    <!-- p5.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>

    <script>
        // ==================== CONFIGURATION ====================
        const CONFIG = {
            canvas: {
                width: 1000,
                height: 800,
                bg: 220
            },
            particles: {
                count: 10000,
                initialRadius: 250,
                mass: 1,
                mergeDistance: 3,
                minMass: 0.5
            },
            physics: {
                gravitationalConstant: 0.3,
                softening: 10,
                darkMatterScale: 200,
                darkMatterCore: 50
            },
            central: {
                mass: 5000,
                radius: 15
            },
            quadtree: {
                maxCapacity: 8,
                maxLevel: 8
            }
        };

        // ==================== GLOBAL STATE ====================
        let particles = [];
        let quadtree;
        let centralMass;
        let isPaused = false;
        let frameCounter = 0;
        let mergerCount = 0;
        let gravityStrength = 0.5;
        let darkMatterStrength = 1.0;
        let timeScale = 1.0;
        let trailIntensity = 3;
        let simulationPhase = 'initial';

        // ==================== QUADTREE CLASS ====================
        class Rectangle {
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
            }

            contains(point) {
                return (point.pos.x >= this.x - this.w &&
                        point.pos.x < this.x + this.w &&
                        point.pos.y >= this.y - this.h &&
                        point.pos.y < this.y + this.h);
            }

            intersects(range) {
                return !(range.x - range.w > this.x + this.w ||
                         range.x + range.w < this.x - this.w ||
                         range.y - range.h > this.y + this.h ||
                         range.y + range.h < this.y - this.h);
            }
        }

        class QuadTree {
            constructor(boundary, level = 0) {
                this.boundary = boundary;
                this.level = level;
                this.particles = [];
                this.divided = false;
                this.northeast = null;
                this.northwest = null;
                this.southeast = null;
                this.southwest = null;
            }

            subdivide() {
                const x = this.boundary.x;
                const y = this.boundary.y;
                const w = this.boundary.w / 2;
                const h = this.boundary.h / 2;

                const ne = new Rectangle(x + w, y - h, w, h);
                this.northeast = new QuadTree(ne, this.level + 1);
                const nw = new Rectangle(x - w, y - h, w, h);
                this.northwest = new QuadTree(nw, this.level + 1);
                const se = new Rectangle(x + w, y + h, w, h);
                this.southeast = new QuadTree(se, this.level + 1);
                const sw = new Rectangle(x - w, y + h, w, h);
                this.southwest = new QuadTree(sw, this.level + 1);

                this.divided = true;
            }

            insert(particle) {
                if (!this.boundary.contains(particle)) {
                    return false;
                }

                if (this.particles.length < CONFIG.quadtree.maxCapacity || this.level >= CONFIG.quadtree.maxLevel) {
                    this.particles.push(particle);
                    return true;
                }

                if (!this.divided) {
                    this.subdivide();
                }

                return (this.northeast.insert(particle) ||
                        this.northwest.insert(particle) ||
                        this.southeast.insert(particle) ||
                        this.southwest.insert(particle));
            }

            query(range, found = []) {
                if (!this.boundary.intersects(range)) {
                    return found;
                }

                for (let p of this.particles) {
                    if (range.contains(p)) {
                        found.push(p);
                    }
                }

                if (this.divided) {
                    this.northwest.query(range, found);
                    this.northeast.query(range, found);
                    this.southwest.query(range, found);
                    this.southeast.query(range, found);
                }

                return found;
            }

            getCenterOfMass() {
                let totalMass = 0;
                let cx = 0, cy = 0;

                if (this.particles.length === 0 && this.divided) {
                    const children = [this.northeast, this.northwest, this.southeast, this.southwest];
                    for (let child of children) {
                        if (child) {
                            const com = child.getCenterOfMass();
                            if (com.mass > 0) {
                                totalMass += com.mass;
                                cx += com.x * com.mass;
                                cy += com.y * com.mass;
                            }
                        }
                    }
                } else {
                    for (let p of this.particles) {
                        totalMass += p.mass;
                        cx += p.pos.x * p.mass;
                        cy += p.pos.y * p.mass;
                    }
                }

                return { mass: totalMass, x: totalMass > 0 ? cx / totalMass : 0, y: totalMass > 0 ? cy / totalMass : 0 };
            }
        }

        // ==================== PARTICLE CLASS ====================
        class Particle {
            constructor(x, y, vx, vy, mass) {
                this.pos = createVector(x, y);
                this.vel = createVector(vx, vy);
                this.acc = createVector(0, 0);
                this.mass = mass;
                this.initialMass = mass;
                this.radius = sqrt(mass) * 2;
                this.trail = [];
                this.maxTrail = trailIntensity * 3;
                this.brightness = 150 + random(100);
                this.colorOffset = random(30);
                this.alive = true;
            }

            applyForce(force) {
                const f = p5.Vector.div(force, this.mass);
                this.acc.add(f);
            }

            update(dt) {
                this.vel.add(p5.Vector.mult(this.acc, dt));
                this.pos.add(p5.Vector.mult(this.vel, dt));
                this.acc.mult(0);

                // Update trail
                if (frameCounter % 2 === 0) {
                    this.trail.push(this.pos.copy());
                    if (this.trail.length > this.maxTrail) {
                        this.trail.shift();
                    }
                }

                // Check bounds
                const margin = 50;
                if (this.pos.x < -margin || this.pos.x > CONFIG.canvas.width + margin ||
                    this.pos.y < -margin || this.pos.y > CONFIG.canvas.height + margin) {
                    this.alive = false;
                }
            }

            draw() {
                if (!this.alive) return;

                noStroke();

                // Draw trail
                for (let i = 0; i < this.trail.length - 1; i++) {
                    const alpha = map(i, 0, this.trail.length - 1, 0, 50);
                    const size = map(i, 0, this.trail.length - 1, 1, this.radius * 0.8);
                    fill(this.brightness + this.colorOffset, this.brightness, this.brightness - this.colorOffset + 50, alpha);
                    ellipse(this.trail[i].x, this.trail[i].y, size, size);
                }

                // Draw particle
                const brightness = this.brightness + this.colorOffset;
                fill(brightness, brightness, brightness);
                ellipse(this.pos.x, this.pos.y, this.radius * 2, this.radius * 2);

                // Inner glow
                fill(brightness + 50, brightness + 50, brightness + 50, 100);
                ellipse(this.pos.x, this.pos.y, this.radius, this.radius);
            }

            checkMerge(other) {
                if (!this.alive || !other.alive) return false;

                const dist = p5.Vector.dist(this.pos, other.pos);
                const mergeDist = (this.radius + other.radius) * 0.8;

                if (dist < mergeDist && this.mass > other.mass * 0.5) {
                    // Merge particles
                    const newMass = this.mass + other.mass;
                    const newPos = p5.Vector.add(
                        p5.Vector.mult(this.pos, this.mass),
                        p5.Vector.mult(other.pos, other.mass)
                    ).div(newMass);

                    const newVel = p5.Vector.add(
                        p5.Vector.mult(this.vel, this.mass),
                        p5.Vector.mult(other.vel, other.mass)
                    ).div(newMass);

                    this.pos = newPos;
                    this.vel = newVel;
                    this.mass = newMass;
                    this.radius = sqrt(this.mass) * 2;
                    this.brightness = min(255, this.brightness + 10);

                    other.alive = false;
                    mergerCount++;
                    return true;
                }
                return false;
            }
        }

        // ==================== CENTRAL MASS CLASS ====================
        class CentralMass {
            constructor(x, y, mass, radius) {
                this.pos = createVector(x, y);
                this.mass = mass;
                this.radius = radius;
            }

            draw() {
                // Outer glow
                for (let r = this.radius * 4; r > this.radius; r -= 3) {
                    const alpha = map(r, this.radius, this.radius * 4, 80, 0);
                    fill(255, 220, 150, alpha);
                    ellipse(this.pos.x, this.pos.y, r * 2, r * 2);
                }

                // Core
                fill(255, 240, 200);
                ellipse(this.pos.x, this.pos.y, this.radius * 2, this.radius * 2);

                // Bright center
                fill(255, 255, 240);
                ellipse(this.pos.x, this.pos.y, this.radius * 0.8, this.radius * 0.8);
            }
        }

        // ==================== INITIALIZATION ====================
        function setup() {
            const canvas = createCanvas(CONFIG.canvas.width, CONFIG.canvas.height);
            canvas.parent('canvas-container');

            initializeSimulation();
            setupControls();
        }

        function initializeSimulation() {
            particles = [];
            mergerCount = 0;
            frameCounter = 0;
            simulationPhase = 'initial';

            const centerX = CONFIG.canvas.width / 2;
            const centerY = CONFIG.canvas.height / 2;

            // Create central mass (black hole/core)
            centralMass = new CentralMass(
                centerX,
                centerY,
                CONFIG.central.mass,
                CONFIG.central.radius
            );

            // Create particles in a protogalactic cloud
            createProtogalacticCloud(centerX, centerY);

            showPhase('Protogalactic Cloud', '10,000 particles forming...');
            updateInfoPanel();
        }

        function createProtogalacticCloud(centerX, centerY) {
            for (let i = 0; i < CONFIG.particles.count; i++) {
                // Use spherical distribution for cloud
                const theta = random(TWO_PI);
                const phi = acos(random(-1, 1));
                const r = random(CONFIG.particles.initialRadius) * pow(random(), 0.5);

                const x = centerX + r * sin(phi) * cos(theta);
                const y = centerY + r * sin(phi) * sin(theta);

                // Calculate orbital velocity for rotation
                const distFromCenter = dist(x, y, centerX, centerY);
                const orbitalSpeed = sqrt(CONFIG.physics.gravitationalConstant * CONFIG.central.mass / (distFromCenter + 10));

                // Add angular momentum (perpendicular to radius)
                const angleToCenter = atan2(y - centerY, x - centerX);
                const vAngle = angleToCenter + HALF_PI;

                // Add some randomness and variation
                const speedVariation = random(0.3, 0.7);
                const vx = cos(vAngle) * orbitalSpeed * speedVariation + random(-0.5, 0.5);
                const vy = sin(vAngle) * orbitalSpeed * speedVariation + random(-0.5, 0.5);

                // Mass varies slightly
                const mass = CONFIG.particles.mass * random(0.5, 1.5);

                particles.push(new Particle(x, y, vx, vy, mass));
            }
        }

        function setupControls() {
            document.getElementById('gravitySlider').addEventListener('input', (e) => {
                gravityStrength = parseFloat(e.target.value);
                document.getElementById('gravityValue').textContent = gravityStrength.toFixed(1);
            });

            document.getElementById('dmSlider').addEventListener('input', (e) => {
                darkMatterStrength = parseFloat(e.target.value);
                document.getElementById('dmValue').textContent = darkMatterStrength.toFixed(1);
            });

            document.getElementById('speedSlider').addEventListener('input', (e) => {
                timeScale = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = timeScale.toFixed(1) + 'x';
            });

            document.getElementById('trailSlider').addEventListener('input', (e) => {
                trailIntensity = parseInt(e.target.value);
                document.getElementById('trailValue').textContent = trailIntensity;
                particles.forEach(p => p.maxTrail = trailIntensity * 3);
            });
        }

        // ==================== PHYSICS SIMULATION ====================
        function updatePhysics(dt) {
            const centerX = CONFIG.canvas.width / 2;
            const centerY = CONFIG.canvas.height / 2;

            // Build quadtree
            const boundary = new Rectangle(centerX, centerY, CONFIG.canvas.width / 2, CONFIG.canvas.height / 2);
            quadtree = new QuadTree(boundary);

            for (let p of particles) {
                if (p.alive) {
                    quadtree.insert(p);
                }
            }

            // Calculate forces for each particle
            for (let p of particles) {
                if (!p.alive) continue;

                // Central mass gravity
                const toCenter = createVector(centerX - p.pos.x, centerY - p.pos.y);
                const distToCenter = toCenter.mag();
                toCenter.normalize();

                const centralForce = (CONFIG.physics.gravitationalConstant * CONFIG.central.mass * p.mass) /
                                   (distToCenter * distToCenter + CONFIG.physics.softening);
                p.applyForce(p5.Vector.mult(toCenter, centralForce));

                // Dark matter halo effect (affects outer particles more)
                if (darkMatterStrength > 0) {
                    const dmDist = distToCenter;
                    const dmEffect = CONFIG.physics.darkMatterScale;
                    const dmForce = (CONFIG.physics.gravitationalConstant * CONFIG.central.mass * darkMatterStrength * 0.3 * p.mass) /
                                   (dmDist * dmDist + dmEffect * dmEffect);
                    p.applyForce(p5.Vector.mult(toCenter, dmForce));
                }

                // Local particle gravity using quadtree (limited range)
                const queryRange = new Rectangle(p.pos.x, p.pos.y, 60, 60);
                const nearby = quadtree.query(queryRange);

                for (let other of nearby) {
                    if (other === p || !other.alive) continue;

                    const diff = p5.Vector.sub(other.pos, p.pos);
                    const d = diff.mag();

                    if (d > CONFIG.physics.softening && d < 60) {
                        diff.normalize();
                        const force = (CONFIG.physics.gravitationalConstant * gravityStrength * p.mass * other.mass) / (d * d);
                        p.applyForce(p5.Vector.mult(diff, force));
                    }

                    // Check for merging
                    p.checkMerge(other);
                }

                // Apply dark matter density gradient (creates spiral arms)
                if (darkMatterStrength > 0) {
                    const armAngle = atan2(p.pos.y - centerY, p.pos.x - centerX) + 0.3;
                    const armForce = darkMatterStrength * 0.002 * p.mass;
                    p.applyForce(createVector(cos(armAngle) * armForce, sin(armAngle) * armForce));
                }
            }

            // Update positions
            for (let p of particles) {
                if (p.alive) {
                    p.update(dt);
                }
            }

            // Remove dead particles
            particles = particles.filter(p => p.alive);
        }

        // ==================== DRAWING ====================
        function draw() {
            // Semi-transparent background for trail effect
            const bgAlpha = map(trailIntensity, 0, 10, 255, 200);
            background(220, bgAlpha);

            if (!isPaused) {
                // Physics substeps for stability
                const substeps = 2;
                const dt = CONFIG.physics.timeStep * timeScale / substeps;

                for (let i = 0; i < substeps; i++) {
                    updatePhysics(dt);
                }
                frameCounter++;
            }

            // Draw dark matter halo (subtle)
            drawDarkMatterHalo();

            // Draw all particles
            for (let p of particles) {
                p.draw();
            }

            // Draw central mass
            centralMass.draw();

            // Update stats
            if (frameCounter % 10 === 0) {
                updateInfoPanel();
                checkSimulationPhase();
            }

            // Update FPS
            if (frameCounter % 30 === 0) {
                document.getElementById('fps').textContent = Math.round(frameRate());
            }
        }

        function drawDarkMatterHalo() {
            if (darkMatterStrength <= 0) return;

            const centerX = CONFIG.canvas.width / 2;
            const centerY = CONFIG.canvas.height / 2;

            noFill();
            for (let r = 100; r < 400; r += 20) {
                const alpha = map(r, 100, 400, 20, 0) * darkMatterStrength;
                stroke(100, 100, 150, alpha);
                strokeWeight(1);
                ellipse(centerX, centerY, r * 2, r * 2);
            }
            noStroke();
        }

        // ==================== SIMULATION PHASE ====================
        function checkSimulationPhase() {
            const centerX = CONFIG.canvas.width / 2;
            const centerY = CONFIG.canvas.height / 2;

            // Calculate average radius
            let totalRadius = 0;
            for (let p of particles) {
                totalRadius += dist(p.pos.x, p.pos.y, centerX, centerY);
            }
            const avgRadius = totalRadius / particles.length;

            // Determine phase based on evolution
            let newPhase = simulationPhase;

            if (frameCounter < 200) {
                newPhase = 'collapse';
            } else if (frameCounter < 500) {
                newPhase = 'condensation';
            } else if (frameCounter < 1000) {
                newPhase = 'spiral_formation';
            } else if (particles.length < CONFIG.particles.count * 0.7) {
                newPhase = 'mature_galaxy';
            } else {
                newPhase = 'evolving';
            }

            if (newPhase !== simulationPhase) {
                simulationPhase = newPhase;
                showPhase(formatPhase(newPhase), getPhaseDescription(newPhase));
            }
        }

        function formatPhase(phase) {
            const phases = {
                'initial': 'Initial Cloud',
                'collapse': 'Gravitational Collapse',
                'condensation': 'Core Condensation',
                'spiral_formation': 'Spiral Arm Formation',
                'mature_galaxy': 'Mature Galaxy',
                'evolving': 'Steady Evolution'
            };
            return phases[phase] || phase;
        }

        function getPhaseDescription(phase) {
            const descriptions = {
                'initial': 'Protogalactic cloud spreading...',
                'collapse': 'Gravity pulling matter inward...',
                'condensation': 'Dense core forming...',
                'spiral_formation': 'Rotation creating spiral arms...',
                'mature_galaxy': 'Stable spiral structure...',
                'evolving': 'Continuous stellar evolution...'
            };
            return descriptions[phase] || '';
        }

        let phaseTimeout;
        function showPhase(title, subtitle) {
            const phaseEl = document.getElementById('phaseIndicator');
            phaseEl.innerHTML = `<div>${title}</div><div style="font-size: 0.8rem; margin-top: 5px; font-weight: normal; color: #aaa;">${subtitle}</div>`;
            phaseEl.classList.add('show');

            clearTimeout(phaseTimeout);
            phaseTimeout = setTimeout(() => {
                phaseEl.classList.remove('show');
            }, 2500);

            document.getElementById('sim-phase').textContent = title;
        }

        // ==================== INFO UPDATES ====================
        function updateInfoPanel() {
            document.getElementById('particle-count').textContent = particles.length.toLocaleString();
            document.getElementById('merger-count').textContent = mergerCount.toLocaleString();
            document.getElementById('dark-matter').textContent = darkMatterStrength > 0 ? 'Active' : 'Off';

            // Calculate total mass
            let totalMass = CONFIG.central.mass;
            for (let p of particles) {
                totalMass += p.mass;
            }
            document.getElementById('total-mass').textContent = totalMass.toFixed(0);

            // Calculate kinetic energy
            let kineticEnergy = 0;
            for (let p of particles) {
                kineticEnergy += 0.5 * p.mass * p.vel.magSq();
            }
            document.getElementById('kinetic-energy').textContent = kineticEnergy.toFixed(0);

            // Calculate galaxy radius
            const centerX = CONFIG.canvas.width / 2;
            const centerY = CONFIG.canvas.height / 2;
            let maxDist = 0;
            for (let p of particles) {
                const d = dist(p.pos.x, p.pos.y, centerX, centerY);
                if (d > maxDist) maxDist = d;
            }
            document.getElementById('galaxy-radius').textContent = maxDist.toFixed(0) + 'px';
        }

        // ==================== CONTROLS ====================
        function resetSimulation() {
            initializeSimulation();
            showPhase('Galaxy Reset', 'New simulation starting...');
        }

        function togglePause() {
            isPaused = !isPaused;
            const btn = event.target;
            btn.textContent = isPaused ? 'Resume' : 'Pause';
        }

        // Keyboard controls
        function keyPressed() {
            if (key === 'r' || key === 'R') {
                resetSimulation();
            }
            if (key === ' ') {
                togglePause();
            }
        }
    </script>
</body>
</html>
