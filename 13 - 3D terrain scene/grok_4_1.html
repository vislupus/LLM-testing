<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Osogovo 3D Terrain Diorama • Babylon.js</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#000; }
        canvas { width:100%; height:100%; display:block; }
    </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

<script>
// ====================================================================
// Osogovo 3D Terrain Diorama – single standalone HTML file
// Uses your local files:
//   Osogovo Height Map (Merged).png   → heightmap
//   Osogovo_map.jpg                   → diffuse texture
// ====================================================================

const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

const createScene = () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.75, 0.85, 0.95, 1);

    // ----------------------------------------------------------------
    // Camera – orbit controls
    // ----------------------------------------------------------------
    const camera = new BABYLON.ArcRotateCamera("cam", Math.PI / 2, Math.PI / 3.2, 600, BABYLON.Vector3.Zero(), scene);
    camera.attachControl(canvas, true);
    camera.lowerRadiusLimit = 120;
    camera.upperRadiusLimit = 1200;
    camera.lowerBetaLimit = 0.1;
    camera.upperBetaLimit = Math.PI / 2.1;

    // ----------------------------------------------------------------
    // Lighting + shadows
    // ----------------------------------------------------------------
    const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
    hemi.intensity = 0.65;

    const dir = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-1, -2, -0.8), scene);
    dir.position.set(200, 400, 200);
    dir.intensity = 1.2;

    const shadowGenerator = new BABYLON.ShadowGenerator(2048, dir);
    shadowGenerator.bias = 0.00005;
    shadowGenerator.normalBias = 0.02;

    // ----------------------------------------------------------------
    // Parameters
    // ----------------------------------------------------------------
    const terrainSize   = 320;                   // world units (square)
    const subdivisions  = 512;                   // detail (512 × 512 → very smooth)
    const maxHeight     = 78;                    // vertical exaggeration
    const pedestalDepth = 110;                   // how deep the box goes below height=0

    // ----------------------------------------------------------------
    // Create terrain from your heightmap
    // ----------------------------------------------------------------
    const terrain = BABYLON.MeshBuilder.CreateGroundFromHeightMap("terrain", "Osogovo Height Map (Merged).png", {
        width: terrainSize,
        height: terrainSize,
        subdivisions: subdivisions,
        minHeight: 0,
        maxHeight: maxHeight,
        onReady: (mesh) => {
            // Diffuse texture (your satellite/orthophoto)
            const mat = new BABYLON.StandardMaterial("terrainMat", scene);
            mat.diffuseTexture = new BABYLON.Texture("Osogovo_map.jpg", scene);
            mat.specularColor = new BABYLON.Color3(0.08, 0.08, 0.08);
            mat.emissiveColor = new BABYLON.Color3(0.12, 0.12, 0.12);
            mesh.material = mat;

            mesh.receiveShadows = true;
            shadowGenerator.addShadowCaster(mesh);

            // ----------------------------------------------------------------
            // Pedestal walls (vertical skirts) + flat bottom
            // ----------------------------------------------------------------
            const positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            const sp = subdivisions + 1;   // side points count

            const wallMat = new BABYLON.StandardMaterial("wallMat", scene);
            wallMat.diffuseColor = new BABYLON.Color3(0.34, 0.29, 0.23);   // nice warm stone/wood
            wallMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            wallMat.backFaceCulling = false;

            const createSkirt = (path, reverse = false) => {
                const bottomPath = path.map(p => new BABYLON.Vector3(p.x, -pedestalDepth, p.z));
                if (reverse) {
                    path = path.slice().reverse();
                    bottomPath.reverse();
                }
                const wall = BABYLON.MeshBuilder.CreateRibbon(null, {
                    pathArray: [path, bottomPath],
                    sideOrientation: BABYLON.Mesh.DOUBLESIDE
                }, scene);
                wall.material = wallMat;
                wall.receiveShadows = true;
            };

            // South (min Z)
            let path = [];
            for (let j = 0; j <= subdivisions; j++) path.push(new BABYLON.Vector3(positions[3*(0*sp + j)], positions[3*(0*sp + j)+1], positions[3*(0*sp + j)+2]));
            createSkirt(path);

            // North (max Z)
            path = [];
            for (let j = 0; j <= subdivisions; j++) path.push(new BABYLON.Vector3(positions[3*(subdivisions*sp + j)], positions[3*(subdivisions*sp + j)+1], positions[3*(subdivisions*sp + j)+2]));
            createSkirt(path, true);

            // West (min X)
            path = [];
            for (let i = 0; i <= subdivisions; i++) path.push(new BABYLON.Vector3(positions[3*(i*sp + 0)], positions[3*(i*sp + 0)+1], positions[3*(i*sp + 0)+2]));
            createSkirt(path);

            // East (max X)
            path = [];
            for (let i = 0; i <= subdivisions; i++) path.push(new BABYLON.Vector3(positions[3*(i*sp + subdivisions)], positions[3*(i*sp + subdivisions)+1], positions[3*(i*sp + subdivisions)+2]));
            createSkirt(path, true);

            // Bottom face
            const bottom = BABYLON.MeshBuilder.CreateGround("bottom", {width: terrainSize * 1.01, height: terrainSize * 1.01}, scene);
            bottom.position.y = -pedestalDepth;
            bottom.material = wallMat;
            bottom.receiveShadows = true;

            // ----------------------------------------------------------------
            // Three markers on the highest peaks with billboard GUI labels
            // ----------------------------------------------------------------
            const peakList = [];
            const numVerts = positions.length / 3;
            for (let i = 0; i < numVerts; i++) {
                peakList.push({ y: positions[3*i + 1], idx: i });
            }
            peakList.sort((a,b) => b.y - a.y);
            const top3 = peakList.slice(0, 3);

            const names = ["Ruen", "Sultan Tepe", "Golem Shilen"];

            top3.forEach((p, i) => {
                const idx = p.idx * 3;
                const x = positions[idx];
                const y = positions[idx+1];
                const z = positions[idx+2];

                // Red marker sphere
                const sphere = BABYLON.MeshBuilder.CreateSphere("peakSphere"+i, {diameter: 7}, scene);
                sphere.position.set(x, y + 3.5, z);
                const sm = new BABYLON.StandardMaterial("sphereMat"+i, scene);
                sm.diffuseColor = sm.emissiveColor = new BABYLON.Color3(1, 0.15, 0.15);
                sphere.material = sm;
                shadowGenerator.addShadowCaster(sphere);

                // Billboard label (always faces camera)
                const plane = BABYLON.MeshBuilder.CreatePlane("label"+i, {width: 56, height: 28}, scene);
                plane.position.set(x, y + 32, z);
                plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

                const adt = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(plane, 640, 320);

                const panel = new BABYLON.GUI.Rectangle();
                panel.width = "620px";
                panel.height = "280px";
                panel.cornerRadius = 20;
                panel.thickness = 5;
                panel.color = "#ffffff";
                panel.background = "#000000cc";
                adt.addControl(panel);

                const txt = new BABYLON.GUI.TextBlock();
                txt.text = `${names[i] || "Peak "+(i+1)}\n${Math.round(y * 2251 / maxHeight)} m`;   // approximate real altitude
                txt.color = "white";
                txt.fontSize = 78;
                txt.fontStyle = "bold";
                panel.addControl(txt);
            });

            // Final camera framing
            camera.setTarget(new BABYLON.Vector3(0, maxHeight * 0.4, 0));
            camera.radius = terrainSize * 2.1;
        }
    }, scene);

    return scene;
};

const scene = createScene();

engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());

</script>
</body>
</html>