<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Osogovo 3D Terrain Diorama</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 20px;
            text-align: center;
            padding: 30px 50px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        #loading .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: #4fc3f7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px 20px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }
        #info h3 {
            margin-bottom: 8px;
            color: #4fc3f7;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="loading">
        <div class="spinner"></div>
        Loading Osogovo Terrain...
    </div>
    <div id="info" style="display: none;">
        <h3>üèîÔ∏è Osogovo Mountain Range</h3>
        <p>Use mouse to orbit, scroll to zoom</p>
    </div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            terrainWidth: 100,
            terrainDepth: 100,
            subdivisions: 150,
            maxTerrainHeight: 28,
            minTerrainHeight: 0,
            pedestalDepth: 15,
            heightMapUrl: "Osogovo Height Map (Merged).png",
            textureUrl: "Osogovo_map.jpg"
        };

        // Peak data for Osogovo mountains (approximate positions)
        const PEAKS = [
            { name: "Ruen Peak", elevation: "2251m", xPercent: 0.55, zPercent: 0.45, color: "#FF4444" },
            { name: "Carev Vrv", elevation: "2085m", xPercent: 0.35, zPercent: 0.55, color: "#44FF44" },
            { name: "Shapka Peak", elevation: "2188m", xPercent: 0.65, zPercent: 0.60, color: "#4488FF" }
        ];

        // ============================================
        // INITIALIZATION
        // ============================================
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true, {
            preserveDrawingBuffer: true,
            stencil: true,
            antialias: true
        });

        // ============================================
        // MAIN SCENE CREATION
        // ============================================
        async function createScene() {
            const scene = new BABYLON.Scene(engine);
            
            // Sky gradient background
            scene.clearColor = new BABYLON.Color4(0.529, 0.808, 0.922, 1);
            scene.ambientColor = new BABYLON.Color3(0.4, 0.4, 0.4);

            // Enable fog for atmosphere
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
            scene.fogDensity = 0.002;
            scene.fogColor = new BABYLON.Color3(0.8, 0.9, 1.0);

            // ========== CAMERA ==========
            const camera = new BABYLON.ArcRotateCamera(
                "arcCamera",
                -Math.PI / 2,          // Alpha (horizontal rotation)
                Math.PI / 3.5,         // Beta (vertical angle)
                110,                   // Radius (distance)
                new BABYLON.Vector3(0, CONFIG.maxTerrainHeight / 4, 0),
                scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 35;
            camera.upperRadiusLimit = 200;
            camera.lowerBetaLimit = 0.1;
            camera.upperBetaLimit = (Math.PI / 2) - 0.05;
            camera.wheelDeltaPercentage = 0.02;
            camera.pinchDeltaPercentage = 0.002;
            camera.panningSensibility = 500;
            camera.inertia = 0.9;

            // ========== LIGHTING ==========
            // Hemispheric light (ambient fill)
            const hemiLight = new BABYLON.HemisphericLight(
                "hemiLight",
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            hemiLight.intensity = 0.5;
            hemiLight.groundColor = new BABYLON.Color3(0.4, 0.35, 0.3);
            hemiLight.specular = new BABYLON.Color3(0.2, 0.2, 0.2);

            // Directional light (sun)
            const sunLight = new BABYLON.DirectionalLight(
                "sunLight",
                new BABYLON.Vector3(-0.5, -1, -0.3).normalize(),
                scene
            );
            sunLight.intensity = 0.8;
            sunLight.position = new BABYLON.Vector3(60, 100, 60);
            sunLight.specular = new BABYLON.Color3(1, 0.95, 0.9);

            // Secondary fill light
            const fillLight = new BABYLON.DirectionalLight(
                "fillLight",
                new BABYLON.Vector3(0.5, -0.5, 0.5).normalize(),
                scene
            );
            fillLight.intensity = 0.25;
            fillLight.specular = new BABYLON.Color3(0.5, 0.5, 0.6);

            // ========== SHADOWS ==========
            const shadowGenerator = new BABYLON.ShadowGenerator(2048, sunLight);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;
            shadowGenerator.darkness = 0.3;

            // ========== TERRAIN CREATION ==========
            return new Promise((resolve, reject) => {
                const terrain = BABYLON.MeshBuilder.CreateGroundFromHeightMap(
                    "terrain",
                    CONFIG.heightMapUrl,
                    {
                        width: CONFIG.terrainWidth,
                        height: CONFIG.terrainDepth,
                        subdivisions: CONFIG.subdivisions,
                        maxHeight: CONFIG.maxTerrainHeight,
                        minHeight: CONFIG.minTerrainHeight,
                        onReady: (terrainMesh) => {
                            console.log("Terrain loaded successfully!");
                            
                            // Apply terrain material
                            const terrainMat = createTerrainMaterial(scene);
                            terrainMesh.material = terrainMat;
                            terrainMesh.receiveShadows = true;
                            shadowGenerator.addShadowCaster(terrainMesh);

                            // Store height data for later use
                            terrainMesh.updateCoordinateHeights = function() {
                                this._heightData = this.getVerticesData(BABYLON.VertexBuffer.PositionKind);
                            };
                            terrainMesh.updateCoordinateHeights();

                            // Create pedestal (walls and bottom)
                            createPedestalWalls(terrainMesh, scene, shadowGenerator);
                            createPedestalBottom(scene);
                            createPedestalFrame(scene);

                            // Create peak markers with delay to ensure everything is ready
                            setTimeout(() => {
                                createPeakMarkers(terrainMesh, scene, shadowGenerator);
                                
                                // Hide loading, show info
                                document.getElementById("loading").style.display = "none";
                                document.getElementById("info").style.display = "block";
                            }, 200);

                            resolve(scene);
                        },
                        onError: (message, exception) => {
                            console.error("Error loading height map:", message, exception);
                            document.getElementById("loading").innerHTML = 
                                `<span style="color: #ff6b6b;">‚ö†Ô∏è Error Loading Terrain</span><br><br>
                                <small>Please ensure these files exist:<br>
                                ‚Ä¢ Osogovo Height Map (Merged).png<br>
                                ‚Ä¢ Osogovo_map.jpg</small>`;
                            reject(new Error(message));
                        }
                    },
                    scene
                );
            });
        }

        // ============================================
        // TERRAIN MATERIAL
        // ============================================
        function createTerrainMaterial(scene) {
            const mat = new BABYLON.StandardMaterial("terrainMat", scene);
            mat.diffuseTexture = new BABYLON.Texture(CONFIG.textureUrl, scene);
            mat.diffuseTexture.uScale = 1;
            mat.diffuseTexture.vScale = 1;
            mat.specularColor = new BABYLON.Color3(0.15, 0.15, 0.15);
            mat.specularPower = 16;
            return mat;
        }

        // ============================================
        // PEDESTAL WALLS
        // ============================================
        function createPedestalWalls(terrain, scene, shadowGenerator) {
            const positions = terrain.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            if (!positions) {
                console.error("Could not get terrain vertex positions");
                return;
            }

            const vertsPerRow = CONFIG.subdivisions + 1;
            const bottomY = -CONFIG.pedestalDepth;

            // Wall material with gradient effect
            const wallMat = new BABYLON.StandardMaterial("wallMat", scene);
            wallMat.diffuseColor = new BABYLON.Color3(0.45, 0.35, 0.25);
            wallMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            wallMat.specularPower = 8;

            // Helper to get vertex at grid position
            const getVertex = (row, col) => {
                const idx = (row * vertsPerRow + col) * 3;
                return new BABYLON.Vector3(
                    positions[idx],
                    positions[idx + 1],
                    positions[idx + 2]
                );
            };

            // Create wall from edge vertices
            const createWall = (name, getVertexFunc, reverse = false) => {
                const topPath = [];
                const bottomPath = [];

                for (let i = 0; i < vertsPerRow; i++) {
                    const idx = reverse ? (vertsPerRow - 1 - i) : i;
                    const v = getVertexFunc(idx);
                    topPath.push(v.clone());
                    bottomPath.push(new BABYLON.Vector3(v.x, bottomY, v.z));
                }

                const wall = BABYLON.MeshBuilder.CreateRibbon(name, {
                    pathArray: [topPath, bottomPath],
                    sideOrientation: BABYLON.Mesh.DOUBLESIDE,
                    closePath: false,
                    closeArray: false
                }, scene);
                wall.material = wallMat;
                wall.receiveShadows = true;
                return wall;
            };

            // Create all four walls
            // Front wall (row 0, z = -depth/2)
            createWall("frontWall", (i) => getVertex(0, i), false);
            
            // Back wall (row = subdivisions, z = +depth/2)
            createWall("backWall", (i) => getVertex(CONFIG.subdivisions, i), true);
            
            // Left wall (col 0, x = -width/2)
            createWall("leftWall", (i) => getVertex(i, 0), true);
            
            // Right wall (col = subdivisions, x = +width/2)
            createWall("rightWall", (i) => getVertex(i, CONFIG.subdivisions), false);
        }

        // ============================================
        // PEDESTAL BOTTOM
        // ============================================
        function createPedestalBottom(scene) {
            const bottom = BABYLON.MeshBuilder.CreateGround("pedestalBottom", {
                width: CONFIG.terrainWidth,
                height: CONFIG.terrainDepth
            }, scene);
            bottom.position.y = -CONFIG.pedestalDepth;

            const bottomMat = new BABYLON.StandardMaterial("bottomMat", scene);
            bottomMat.diffuseColor = new BABYLON.Color3(0.3, 0.22, 0.15);
            bottomMat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);
            bottom.material = bottomMat;
            bottom.receiveShadows = true;
        }

        // ============================================
        // PEDESTAL DECORATIVE FRAME
        // ============================================
        function createPedestalFrame(scene) {
            const frameWidth = 1.5;
            const frameHeight = CONFIG.pedestalDepth + 1;
            const halfW = CONFIG.terrainWidth / 2;
            const halfD = CONFIG.terrainDepth / 2;
            const bottomY = -CONFIG.pedestalDepth;

            const frameMat = new BABYLON.StandardMaterial("frameMat", scene);
            frameMat.diffuseColor = new BABYLON.Color3(0.25, 0.18, 0.12);
            frameMat.specularColor = new BABYLON.Color3(0.3, 0.25, 0.2);

            // Corner posts
            const corners = [
                { x: -halfW - frameWidth/2, z: -halfD - frameWidth/2 },
                { x: halfW + frameWidth/2, z: -halfD - frameWidth/2 },
                { x: -halfW - frameWidth/2, z: halfD + frameWidth/2 },
                { x: halfW + frameWidth/2, z: halfD + frameWidth/2 }
            ];

            corners.forEach((corner, i) => {
                const post = BABYLON.MeshBuilder.CreateBox(`cornerPost${i}`, {
                    width: frameWidth * 1.5,
                    height: frameHeight,
                    depth: frameWidth * 1.5
                }, scene);
                post.position = new BABYLON.Vector3(corner.x, bottomY + frameHeight/2, corner.z);
                post.material = frameMat;
            });

            // Edge rails
            const railMat = new BABYLON.StandardMaterial("railMat", scene);
            railMat.diffuseColor = new BABYLON.Color3(0.35, 0.25, 0.18);

            // Front and back rails
            [-halfD - frameWidth/2, halfD + frameWidth/2].forEach((z, i) => {
                const rail = BABYLON.MeshBuilder.CreateBox(`railFB${i}`, {
                    width: CONFIG.terrainWidth,
                    height: frameWidth,
                    depth: frameWidth
                }, scene);
                rail.position = new BABYLON.Vector3(0, bottomY + frameWidth/2, z);
                rail.material = railMat;
            });

            // Left and right rails
            [-halfW - frameWidth/2, halfW + frameWidth/2].forEach((x, i) => {
                const rail = BABYLON.MeshBuilder.CreateBox(`railLR${i}`, {
                    width: frameWidth,
                    height: frameWidth,
                    depth: CONFIG.terrainDepth
                }, scene);
                rail.position = new BABYLON.Vector3(x, bottomY + frameWidth/2, 0);
                rail.material = railMat;
            });
        }

        // ============================================
        // PEAK MARKERS
        // ============================================
        function createPeakMarkers(terrain, scene, shadowGenerator) {
            const positions = terrain._heightData || terrain.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            const vertsPerRow = CONFIG.subdivisions + 1;

            PEAKS.forEach((peak, index) => {
                // Convert percentage to terrain coordinates
                const terrainX = (peak.xPercent - 0.5) * CONFIG.terrainWidth;
                const terrainZ = (peak.zPercent - 0.5) * CONFIG.terrainDepth;

                // Find height at this position
                let height = getHeightAtPosition(terrainX, terrainZ, positions, vertsPerRow);
                
                // Fallback if height calculation fails
                if (isNaN(height) || height === undefined) {
                    height = CONFIG.maxTerrainHeight * 0.75;
                }

                // Create marker components
                createMarkerPin(scene, peak, terrainX, terrainZ, height, index, shadowGenerator);
                createBillboardLabel(scene, peak, terrainX, terrainZ, height, index);
            });
        }

        // ============================================
        // HEIGHT SAMPLING
        // ============================================
        function getHeightAtPosition(x, z, positions, vertsPerRow) {
            // Convert world position to grid position
            const gridX = ((x / CONFIG.terrainWidth) + 0.5) * (vertsPerRow - 1);
            const gridZ = ((z / CONFIG.terrainDepth) + 0.5) * (vertsPerRow - 1);

            // Get integer grid coordinates
            const x0 = Math.floor(gridX);
            const z0 = Math.floor(gridZ);
            const x1 = Math.min(x0 + 1, vertsPerRow - 1);
            const z1 = Math.min(z0 + 1, vertsPerRow - 1);

            // Get fractional parts for interpolation
            const fx = gridX - x0;
            const fz = gridZ - z0;

            // Get heights at four corners
            const getHeight = (gx, gz) => {
                const idx = (gz * vertsPerRow + gx) * 3 + 1; // +1 for Y component
                return positions[idx] || 0;
            };

            const h00 = getHeight(x0, z0);
            const h10 = getHeight(x1, z0);
            const h01 = getHeight(x0, z1);
            const h11 = getHeight(x1, z1);

            // Bilinear interpolation
            const h0 = h00 * (1 - fx) + h10 * fx;
            const h1 = h01 * (1 - fx) + h11 * fx;
            return h0 * (1 - fz) + h1 * fz;
        }

        // ============================================
        // MARKER PIN CREATION
        // ============================================
        function createMarkerPin(scene, peak, x, z, height, index, shadowGenerator) {
            const poleHeight = 6;
            const sphereRadius = 1.2;

            // Parse color
            const color = BABYLON.Color3.FromHexString(peak.color);

            // Create pole
            const pole = BABYLON.MeshBuilder.CreateCylinder(`pole${index}`, {
                height: poleHeight,
                diameterTop: 0.3,
                diameterBottom: 0.5,
                tessellation: 12
            }, scene);
            pole.position = new BABYLON.Vector3(x, height + poleHeight / 2, z);

            const poleMat = new BABYLON.StandardMaterial(`poleMat${index}`, scene);
            poleMat.diffuseColor = new BABYLON.Color3(0.85, 0.85, 0.85);
            poleMat.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
            poleMat.specularPower = 64;
            pole.material = poleMat;
            shadowGenerator.addShadowCaster(pole);

            // Create marker sphere
            const sphere = BABYLON.MeshBuilder.CreateSphere(`markerSphere${index}`, {
                diameter: sphereRadius * 2,
                segments: 24
            }, scene);
            sphere.position = new BABYLON.Vector3(x, height + poleHeight + sphereRadius, z);

            const sphereMat = new BABYLON.StandardMaterial(`sphereMat${index}`, scene);
            sphereMat.diffuseColor = color;
            sphereMat.emissiveColor = color.scale(0.3);
            sphereMat.specularColor = new BABYLON.Color3(1, 1, 1);
            sphereMat.specularPower = 32;
            sphere.material = sphereMat;
            shadowGenerator.addShadowCaster(sphere);

            // Create glow ring around sphere
            const ring = BABYLON.MeshBuilder.CreateTorus(`ring${index}`, {
                diameter: sphereRadius * 3,
                thickness: 0.15,
                tessellation: 32
            }, scene);
            ring.position = sphere.position.clone();
            ring.rotation.x = Math.PI / 2;

            const ringMat = new BABYLON.StandardMaterial(`ringMat${index}`, scene);
            ringMat.diffuseColor = color;
            ringMat.emissiveColor = color.scale(0.5);
            ringMat.alpha = 0.7;
            ring.material = ringMat;

            // Animate ring
            scene.registerBeforeRender(() => {
                ring.rotation.z += 0.01;
            });

            // Create base disc on terrain
            const baseDisc = BABYLON.MeshBuilder.CreateDisc(`baseDisc${index}`, {
                radius: 1.5,
                tessellation: 24
            }, scene);
            baseDisc.position = new BABYLON.Vector3(x, height + 0.1, z);
            baseDisc.rotation.x = Math.PI / 2;

            const discMat = new BABYLON.StandardMaterial(`discMat${index}`, scene);
            discMat.diffuseColor = color;
            discMat.emissiveColor = color.scale(0.2);
            discMat.alpha = 0.8;
            baseDisc.material = discMat;
        }

        // ============================================
        // BILLBOARD LABEL CREATION
        // ============================================
        function createBillboardLabel(scene, peak, x, z, height, index) {
            const labelHeight = height + 12;

            // Create plane for label
            const labelPlane = BABYLON.MeshBuilder.CreatePlane(`labelPlane${index}`, {
                width: 12,
                height: 5
            }, scene);
            labelPlane.position = new BABYLON.Vector3(x, labelHeight, z);
            labelPlane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

            // Create dynamic texture for text rendering
            const textureWidth = 600;
            const textureHeight = 250;
            const dynamicTexture = new BABYLON.DynamicTexture(
                `labelTexture${index}`,
                { width: textureWidth, height: textureHeight },
                scene,
                true
            );

            const ctx = dynamicTexture.getContext();

            // Draw rounded rectangle background
            const padding = 10;
            const cornerRadius = 20;
            
            ctx.fillStyle = "rgba(20, 25, 40, 0.9)";
            ctx.beginPath();
            roundRect(ctx, padding, padding, textureWidth - padding * 2, textureHeight - padding * 2, cornerRadius);
            ctx.fill();

            // Draw border
            ctx.strokeStyle = peak.color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            roundRect(ctx, padding, padding, textureWidth - padding * 2, textureHeight - padding * 2, cornerRadius);
            ctx.stroke();

            // Draw accent line at top
            ctx.fillStyle = peak.color;
            ctx.fillRect(padding + 20, padding, textureWidth - padding * 2 - 40, 6);

            // Draw peak name
            ctx.fillStyle = "#FFFFFF";
            ctx.font = "bold 52px 'Segoe UI', Arial, sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(peak.name, textureWidth / 2, textureHeight / 2 - 30);

            // Draw elevation
            ctx.fillStyle = peak.color;
            ctx.font = "bold 44px 'Segoe UI', Arial, sans-serif";
            ctx.fillText(peak.elevation, textureWidth / 2, textureHeight / 2 + 40);

            // Draw small mountain icon
            ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
            ctx.font = "36px Arial";
            ctx.fillText("üèîÔ∏è", textureWidth - 60, textureHeight - 50);

            dynamicTexture.update();

            // Create material with texture
            const labelMat = new BABYLON.StandardMaterial(`labelMat${index}`, scene);
            labelMat.diffuseTexture = dynamicTexture;
            labelMat.diffuseTexture.hasAlpha = true;
            labelMat.useAlphaFromDiffuseTexture = true;
            labelMat.emissiveTexture = dynamicTexture;
            labelMat.disableLighting = true;
            labelMat.backFaceCulling = false;
            labelPlane.material = labelMat;

            // Create connecting line from label to marker
            const linePoints = [
                new BABYLON.Vector3(x, labelHeight - 2.5, z),
                new BABYLON.Vector3(x, height + 8, z)
            ];
            
            const line = BABYLON.MeshBuilder.CreateLines(`labelLine${index}`, {
                points: linePoints
            }, scene);
            line.color = BABYLON.Color3.FromHexString(peak.color);
            line.alpha = 0.6;
        }

        // Helper function to draw rounded rectangles
        function roundRect(ctx, x, y, width, height, radius) {
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        // ============================================
        // ENGINE INITIALIZATION
        // ============================================
        createScene().then(scene => {
            // Start render loop
            engine.runRenderLoop(() => {
                scene.render();
            });

            // Auto-rotate camera slowly
            let autoRotate = true;
            scene.registerBeforeRender(() => {
                if (autoRotate) {
                    scene.activeCamera.alpha += 0.001;
                }
            });

            // Stop auto-rotate on user interaction
            canvas.addEventListener("pointerdown", () => {
                autoRotate = false;
            });

        }).catch(error => {
            console.error("Failed to create scene:", error);
        });

        // Handle window resize
        window.addEventListener("resize", () => {
            engine.resize();
        });

        // Keyboard controls
        window.addEventListener("keydown", (e) => {
            if (e.key === "r" || e.key === "R") {
                // Reset camera
                const camera = engine.scenes[0].activeCamera;
                camera.alpha = -Math.PI / 2;
                camera.beta = Math.PI / 3.5;
                camera.radius = 110;
            }
        });
    </script>
</body>
</html>