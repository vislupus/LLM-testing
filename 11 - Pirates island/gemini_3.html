<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Pirate Island Defenders</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* HUD Top */
        #hud-top {
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 18px;
            font-weight: bold;
        }

        .stat-box {
            text-shadow: 1px 1px 2px black;
        }

        .health-bar-container {
            width: 300px;
            height: 20px;
            background: #444;
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
        }
        
        #island-hp-bar {
            width: 100%;
            height: 100%;
            background: #2ecc71;
            transition: width 0.3s;
        }

        /* Bottom Controls */
        #hud-bottom {
            pointer-events: auto;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            padding: 20px;
            text-align: center;
        }

        .ship-card {
            display: inline-block;
            background: rgba(255,255,255,0.1);
            border: 2px solid #666;
            border-radius: 8px;
            padding: 10px;
            margin: 0 10px;
            width: 180px;
            text-align: left;
            transition: 0.2s;
            position: relative;
        }

        .ship-card.active {
            border-color: #f1c40f;
            background: rgba(241, 196, 15, 0.2);
            transform: translateY(-10px);
        }

        .ship-title { font-weight: bold; margin-bottom: 5px; }
        .ship-stats { font-size: 12px; color: #ccc; margin-bottom: 8px; }
        
        button.upgrade-btn {
            background: #e67e22;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            width: 100%;
            margin-top: 2px;
        }
        
        button.upgrade-btn:hover { background: #d35400; }
        button.upgrade-btn:disabled { background: #555; color: #888; cursor: not-allowed; }

        #game-over {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 100;
        }
        
        #game-over h1 { color: #e74c3c; font-size: 48px; }
        #restart-btn {
            padding: 15px 30px;
            font-size: 20px;
            background: #2ecc71;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px;
        }

        .key-hint {
            position: absolute;
            top: 5px; right: 5px;
            background: #333;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            font-size: 12px;
        }

    </style>
    <!-- Babylon.js CDN -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>

    <canvas id="renderCanvas"></canvas>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div id="hud-top">
            <div class="stat-box">
                <div>GOLD: <span id="gold-display" style="color:#f1c40f">0</span></div>
                <div>WAVE: <span id="wave-display">1</span></div>
                <div style="font-size:12px; color:#aaa; margin-top:5px;">Controls: WASD / Arrows to Move</div>
            </div>
            <div class="stat-box">
                <div>ISLAND HEALTH</div>
                <div class="health-bar-container">
                    <div id="island-hp-bar"></div>
                </div>
            </div>
        </div>

        <div id="hud-bottom">
            <!-- Ship 1 -->
            <div class="ship-card" id="card-0" onclick="selectShip(0)">
                <div class="key-hint">1</div>
                <div class="ship-title" style="color:#ff5e5e">Red Corsair</div>
                <div class="ship-stats" id="stats-0">Dmg: 10 | Spd: 10</div>
                <button class="upgrade-btn" onclick="upgradeShip(0, 'damage')">Upg Dmg (50g)</button>
                <button class="upgrade-btn" onclick="upgradeShip(0, 'speed')">Upg Spd (50g)</button>
            </div>
            <!-- Ship 2 -->
            <div class="ship-card" id="card-1" onclick="selectShip(1)">
                <div class="key-hint">2</div>
                <div class="ship-title" style="color:#5eff5e">Green Galleon</div>
                <div class="ship-stats" id="stats-1">Dmg: 10 | Spd: 10</div>
                <button class="upgrade-btn" onclick="upgradeShip(1, 'damage')">Upg Dmg (50g)</button>
                <button class="upgrade-btn" onclick="upgradeShip(1, 'speed')">Upg Spd (50g)</button>
            </div>
            <!-- Ship 3 -->
            <div class="ship-card" id="card-2" onclick="selectShip(2)">
                <div class="key-hint">3</div>
                <div class="ship-title" style="color:#5e5eff">Blue Brig</div>
                <div class="ship-stats" id="stats-2">Dmg: 10 | Spd: 10</div>
                <button class="upgrade-btn" onclick="upgradeShip(2, 'damage')">Upg Dmg (50g)</button>
                <button class="upgrade-btn" onclick="upgradeShip(2, 'speed')">Upg Spd (50g)</button>
            </div>
        </div>
    </div>

    <div id="game-over">
        <h1>ISLAND LOST!</h1>
        <p>The pirates have plundered everything.</p>
        <button id="restart-btn" onclick="location.reload()">Try Again</button>
    </div>

    <script>
        // --- Game State ---
        const GAME_STATE = {
            gold: 0,
            wave: 1,
            islandHp: 1000,
            maxIslandHp: 1000,
            activeShipIndex: 0,
            gameOver: false,
            enemySpawnTimer: 0,
            enemySpawnRate: 200, // Frames between spawns
            ships: [], // Stores friendly ship objects
            enemies: [], // Stores enemy meshes
            projectiles: [] // Stores active cannonballs
        };

        // --- Babylon Setup ---
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        let scene;

        // UI Elements
        const uiGold = document.getElementById("gold-display");
        const uiWave = document.getElementById("wave-display");
        const uiHpBar = document.getElementById("island-hp-bar");
        const shipCards = [
            document.getElementById("card-0"),
            document.getElementById("card-1"),
            document.getElementById("card-2")
        ];

        const createScene = function () {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.5, 0.8, 1); // Sky color
            // Fog for depth
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
            scene.fogDensity = 0.01;
            scene.fogColor = new BABYLON.Color3(0.5, 0.8, 1);

            // Camera (Orbit)
            const camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2, Math.PI / 3, 60, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 20;
            camera.upperRadiusLimit = 100;
            camera.upperBetaLimit = Math.PI / 2.2; // Don't go under water

            // Lights
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.8;
            const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
            dirLight.position = new BABYLON.Vector3(20, 40, 20);
            dirLight.intensity = 0.5;

            // --- Environment ---
            
            // Water
            const waterMesh = BABYLON.MeshBuilder.CreateGround("water", {width: 500, height: 500}, scene);
            const waterMat = new BABYLON.StandardMaterial("waterMat", scene);
            waterMat.diffuseColor = new BABYLON.Color3(0, 0.4, 0.8);
            waterMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            waterMat.alpha = 0.9;
            waterMesh.material = waterMat;

            // Island Base
            const island = BABYLON.MeshBuilder.CreateCylinder("island", {diameter: 25, height: 2}, scene);
            island.position.y = 0.5;
            const islandMat = new BABYLON.StandardMaterial("islandMat", scene);
            islandMat.diffuseColor = new BABYLON.Color3(0.1, 0.6, 0.2);
            island.material = islandMat;

            // Island Props (Palm Trees & Rocks)
            const createPalm = (x, z) => {
                const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk", {diameter:0.5, height:4}, scene);
                trunk.position = new BABYLON.Vector3(x, 2, z);
                trunk.material = new BABYLON.StandardMaterial("trunkMat", scene);
                trunk.material.diffuseColor = new BABYLON.Color3(0.4, 0.3, 0.1);

                const leaves = BABYLON.MeshBuilder.CreateCylinder("leaves", {diameterTop:0, diameterBottom:3, height:1.5}, scene);
                leaves.position = new BABYLON.Vector3(x, 4, z);
                leaves.material = new BABYLON.StandardMaterial("leafMat", scene);
                leaves.material.diffuseColor = new BABYLON.Color3(0.2, 0.8, 0.2);
            };
            createPalm(3, 2);
            createPalm(-4, -1);
            createPalm(1, -5);

            const rock = BABYLON.MeshBuilder.CreateSphere("rock", {diameter: 3}, scene);
            rock.position = new BABYLON.Vector3(-2, 1, 3);
            rock.scaling.y = 0.5;
            const rockMat = new BABYLON.StandardMaterial("rockMat", scene);
            rockMat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            rock.material = rockMat;

            // --- Setup Friendly Ships ---
            // Ship Class Definition
            class FriendlyShip {
                constructor(id, x, z, colorHex) {
                    this.id = id;
                    this.mesh = this.createMesh(colorHex);
                    this.mesh.position = new BABYLON.Vector3(x, 0.5, z);
                    
                    // Stats
                    this.damage = 10;
                    this.speed = 0.2; // Movement speed
                    this.fireRate = 60; // Frames between shots
                    this.range = 30;
                    this.cooldown = 0;
                    this.costDmg = 50;
                    this.costSpd = 50;

                    // Selection Ring
                    this.ring = BABYLON.MeshBuilder.CreateTorus("ring", {diameter: 5, thickness: 0.2}, scene);
                    this.ring.parent = this.mesh;
                    this.ring.material = new BABYLON.StandardMaterial("ringMat", scene);
                    this.ring.material.emissiveColor = new BABYLON.Color3(1, 1, 0);
                    this.ring.isVisible = (id === 0);
                }

                createMesh(color) {
                    const root = new BABYLON.TransformNode("shipRoot" + this.id);
                    
                    // Hull
                    const hull = BABYLON.MeshBuilder.CreateBox("hull", {width: 2, height: 1, depth: 4}, scene);
                    hull.parent = root;
                    hull.position.y = 0.5;
                    const hullMat = new BABYLON.StandardMaterial("hullMat", scene);
                    hullMat.diffuseColor = new BABYLON.Color3(0.4, 0.2, 0.1);
                    hull.material = hullMat;

                    // Mast
                    const mast = BABYLON.MeshBuilder.CreateCylinder("mast", {diameter: 0.2, height: 5}, scene);
                    mast.parent = root;
                    mast.position.y = 3;

                    // Sail
                    const sail = BABYLON.MeshBuilder.CreateBox("sail", {width: 2.5, height: 2, depth: 0.2}, scene);
                    sail.parent = root;
                    sail.position.y = 4;
                    sail.position.z = 0.5;
                    const sailMat = new BABYLON.StandardMaterial("sailMat", scene);
                    sailMat.diffuseColor = BABYLON.Color3.FromHexString(color);
                    sail.material = sailMat;

                    return root;
                }

                move(dirVector) {
                    if(dirVector.length() === 0) return;
                    
                    // Rotate towards movement
                    const angle = Math.atan2(dirVector.x, dirVector.z);
                    // Smooth rotation
                    this.mesh.rotation.y = BABYLON.Scalar.Lerp(this.mesh.rotation.y, angle, 0.1);

                    // Move
                    this.mesh.position.addInPlace(dirVector.scale(this.speed));

                    // Bounds check (don't go too far out)
                    const dist = this.mesh.position.length();
                    if (dist > 80) {
                        this.mesh.position.scaleInPlace(80/dist);
                    }
                    // Bounds check (don't clip island too badly)
                    if (dist < 13) {
                         this.mesh.position.scaleInPlace(13/dist);
                    }
                }

                update() {
                    if (this.cooldown > 0) this.cooldown--;

                    // Auto Fire Logic
                    if (this.cooldown <= 0) {
                        let closest = null;
                        let closestDist = 9999;

                        GAME_STATE.enemies.forEach(enemy => {
                            const d = BABYLON.Vector3.Distance(this.mesh.position, enemy.position);
                            if (d < this.range && d < closestDist) {
                                closestDist = d;
                                closest = enemy;
                            }
                        });

                        if (closest) {
                            fireCannon(this, closest);
                            this.cooldown = this.fireRate;
                        }
                    }
                }
            }

            // Create the 3 ships
            GAME_STATE.ships.push(new FriendlyShip(0, -15, 0, "#ff5e5e"));
            GAME_STATE.ships.push(new FriendlyShip(1, 15, 0, "#5eff5e"));
            GAME_STATE.ships.push(new FriendlyShip(2, 0, 15, "#5e5eff"));

            // Input Handling
            const inputMap = {};
            scene.actionManager = new BABYLON.ActionManager(scene);
            scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {
                inputMap[evt.sourceEvent.key] = true;
                
                // Ship Selection Keys
                if (evt.sourceEvent.key === "1") selectShip(0);
                if (evt.sourceEvent.key === "2") selectShip(1);
                if (evt.sourceEvent.key === "3") selectShip(2);
            }));
            scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {
                inputMap[evt.sourceEvent.key] = false;
            }));

            // --- Game Loop ---
            scene.registerBeforeRender(() => {
                if (GAME_STATE.gameOver) return;

                // 1. Player Input (Movement)
                const activeShip = GAME_STATE.ships[GAME_STATE.activeShipIndex];
                let moveDir = new BABYLON.Vector3(0, 0, 0);

                if (inputMap["w"] || inputMap["ArrowUp"]) moveDir.z = 1;
                if (inputMap["s"] || inputMap["ArrowDown"]) moveDir.z = -1;
                if (inputMap["a"] || inputMap["ArrowLeft"]) moveDir.x = -1;
                if (inputMap["d"] || inputMap["ArrowRight"]) moveDir.x = 1;

                // Normalize so diagonal isn't faster
                moveDir.normalize();
                
                // Adjust input relative to camera
                // Simplified: We map WASD to world space roughly based on camera alpha
                // But for top-down simplicity, let's just map direct World coordinates or simple tank controls.
                // Let's do: W = North, S = South, etc relative to world, camera is orbital so user adjusts.
                // Actually, easier for user: relative to camera view.
                
                const camAlpha = camera.alpha; // rotation around Y
                // Create a rotation matrix from camera angle
                const matrix = BABYLON.Matrix.RotationY(-camAlpha - Math.PI/2); 
                // -PI/2 adjust because camera starts at specific angle relative to Z
                
                const rotatedDir = BABYLON.Vector3.TransformCoordinates(moveDir, matrix);
                
                if (moveDir.length() > 0) {
                   activeShip.move(rotatedDir);
                }

                // 2. Update Ships
                GAME_STATE.ships.forEach(s => s.update());

                // 3. Spawn Enemies
                GAME_STATE.enemySpawnTimer--;
                if (GAME_STATE.enemySpawnTimer <= 0) {
                    spawnEnemy();
                    // Difficulty Ramp
                    const baseRate = Math.max(50, 200 - (GAME_STATE.wave * 10));
                    GAME_STATE.enemySpawnTimer = baseRate;
                }

                // 4. Update Enemies
                for (let i = GAME_STATE.enemies.length - 1; i >= 0; i--) {
                    const enemy = GAME_STATE.enemies[i];
                    
                    // Move towards center (0,0,0)
                    const dir = enemy.position.scale(-1).normalize();
                    enemy.position.addInPlace(dir.scale(0.1 + (GAME_STATE.wave * 0.01)));
                    enemy.lookAt(new BABYLON.Vector3(0,0,0));

                    // Check Collision with Island
                    if (enemy.position.length() < 12) {
                        // Damage Island
                        takeIslandDamage(50);
                        // Kill Enemy
                        enemy.dispose();
                        GAME_STATE.enemies.splice(i, 1);
                        continue;
                    }
                }

                // 5. Update Projectiles
                for (let i = GAME_STATE.projectiles.length - 1; i >= 0; i--) {
                    const proj = GAME_STATE.projectiles[i];
                    const speed = 1.0;
                    
                    // Move projectile
                    const step = proj.direction.scale(speed);
                    proj.mesh.position.addInPlace(step);
                    proj.life--;

                    // Collision Detection with Enemies
                    let hit = false;
                    for (let j = GAME_STATE.enemies.length - 1; j >= 0; j--) {
                        const enemy = GAME_STATE.enemies[j];
                        if (proj.mesh.intersectsMesh(enemy, true)) {
                            // HIT!
                            enemy.hp -= proj.damage;
                            if (enemy.hp <= 0) {
                                // Reward Gold
                                addGold(10 + GAME_STATE.wave);
                                enemy.dispose();
                                GAME_STATE.enemies.splice(j, 1);
                            }
                            hit = true;
                            break; 
                        }
                    }

                    if (hit || proj.life <= 0) {
                        proj.mesh.dispose();
                        GAME_STATE.projectiles.splice(i, 1);
                    }
                }

                // Check Wave Progression
                // Simple logic: every 500 frames or based on kills? 
                // Let's make wave progress based on time for this prototype
                if (performance.now() % 20000 < 20) { // Every ~20 seconds
                   // Simple check to avoid rapid increment
                   // Actually, let's just increment wave every 5 enemies killed?
                   // Let's stick to a spawn timer ramp up logic handled in step 3.
                }
            });

            // Wave Timer Logic outside render loop
            setInterval(() => {
                if(!GAME_STATE.gameOver) {
                    GAME_STATE.wave++;
                    uiWave.innerText = GAME_STATE.wave;
                }
            }, 20000); // New wave every 20 seconds

            return scene;
        };

        // --- Helper Functions ---

        function selectShip(index) {
            GAME_STATE.activeShipIndex = index;
            
            // Visual Update
            GAME_STATE.ships.forEach((ship, i) => {
                ship.ring.isVisible = (i === index);
            });

            // UI Update
            shipCards.forEach((card, i) => {
                if(i === index) card.classList.add('active');
                else card.classList.remove('active');
            });
        }

        function spawnEnemy() {
            const angle = Math.random() * Math.PI * 2;
            const distance = 90;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;

            // Enemy Mesh
            const mesh = BABYLON.MeshBuilder.CreateBox("enemy", {width: 2, height: 1.5, depth: 4}, scene);
            mesh.position = new BABYLON.Vector3(x, 0.5, z);
            const mat = new BABYLON.StandardMaterial("enemyMat", scene);
            mat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2); // Black/Dark Grey
            mesh.material = mat;

            // Add Sail (Black)
            const sail = BABYLON.MeshBuilder.CreateBox("enemySail", {width: 2, height: 2, depth: 0.1}, scene);
            sail.parent = mesh;
            sail.position.y = 2;
            const sailMat = new BABYLON.StandardMaterial("sailMat", scene);
            sailMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
            sailMat.emissiveColor = new BABYLON.Color3(0.2,0,0); // Slight red glow
            sail.material = sailMat;

            // Enemy Stats
            mesh.hp = 20 + (GAME_STATE.wave * 10);
            
            GAME_STATE.enemies.push(mesh);
        }

        function fireCannon(ship, target) {
            // Create projectile
            const cannonball = BABYLON.MeshBuilder.CreateSphere("ball", {diameter: 0.8}, scene);
            cannonball.position = ship.mesh.position.clone();
            cannonball.position.y += 1; // Fire from deck height
            const ballMat = new BABYLON.StandardMaterial("ballMat", scene);
            ballMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
            cannonball.material = ballMat;

            // Calculate direction
            const direction = target.position.subtract(ship.mesh.position).normalize();

            GAME_STATE.projectiles.push({
                mesh: cannonball,
                direction: direction,
                damage: ship.damage,
                life: 60 // Disappear after 60 frames if no hit
            });
        }

        function takeIslandDamage(amount) {
            GAME_STATE.islandHp -= amount;
            const percent = Math.max(0, (GAME_STATE.islandHp / GAME_STATE.maxIslandHp) * 100);
            uiHpBar.style.width = percent + "%";
            
            // Flash effect?
            scene.clearColor = new BABYLON.Color3(1, 0.5, 0.5);
            setTimeout(() => {
                if(scene) scene.clearColor = new BABYLON.Color3(0.5, 0.8, 1);
            }, 100);

            if (GAME_STATE.islandHp <= 0) {
                endGame();
            }
        }

        function addGold(amount) {
            GAME_STATE.gold += amount;
            uiGold.innerText = GAME_STATE.gold;
        }

        function upgradeShip(shipIndex, type) {
            // Prevent event bubbling to ship selection
            event.stopPropagation(); 

            const ship = GAME_STATE.ships[shipIndex];
            
            if (type === 'damage') {
                if (GAME_STATE.gold >= ship.costDmg) {
                    GAME_STATE.gold -= ship.costDmg;
                    ship.damage += 5;
                    ship.costDmg = Math.floor(ship.costDmg * 1.5);
                }
            } else if (type === 'speed') {
                if (GAME_STATE.gold >= ship.costSpd) {
                    GAME_STATE.gold -= ship.costSpd;
                    ship.speed += 0.05;
                    ship.costSpd = Math.floor(ship.costSpd * 1.5);
                }
            }
            
            // Update UI text
            addGold(0); // Refresh gold text
            updateShipUI(shipIndex);
        }

        function updateShipUI(index) {
            const s = GAME_STATE.ships[index];
            const statsDiv = document.getElementById(`stats-${index}`);
            statsDiv.innerHTML = `Dmg: ${s.damage} | Spd: ${s.speed.toFixed(2)}`;
            
            const btns = document.querySelectorAll(`#card-${index} button`);
            btns[0].innerText = `Upg Dmg (${s.costDmg}g)`;
            btns[1].innerText = `Upg Spd (${s.costSpd}g)`;
        }

        function endGame() {
            GAME_STATE.gameOver = true;
            document.getElementById("game-over").style.display = "flex";
        }

        // Initialize
        const sceneObj = createScene();

        // Resize handler
        window.addEventListener("resize", function () {
            engine.resize();
        });

        // Render Loop
        engine.runRenderLoop(function () {
            if (sceneObj) {
                sceneObj.render();
            }
        });
        
        // Initial UI Selection
        selectShip(0);

    </script>
</body>
</html>