<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pirate Island Defense ‚Äî Babylon.js Single-File Prototype</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background:#071021; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #renderCanvas { width: 100%; height: 100%; display: block; touch-action: none; }

    /* Simple HUD */
    .hud {
      position: fixed; left: 14px; top: 14px;
      display: grid; gap: 10px;
      color: #eef6ff;
      user-select: none;
      pointer-events: none;
    }
    .panel {
      pointer-events: auto;
      min-width: 300px;
      padding: 10px 12px;
      border-radius: 16px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.16);
      backdrop-filter: blur(8px);
      box-shadow: 0 18px 70px rgba(0,0,0,.45);
    }
    .row { display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap: wrap; }
    .big { font-weight: 950; font-size: 14px; letter-spacing: .2px; }
    .muted { opacity: .78; font-weight: 700; font-size: 12px; }
    .pill {
      display:inline-block;
      padding: 2px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.16);
      font-weight: 900;
      font-size: 12px;
    }
    .hpbar {
      height: 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.12);
      overflow: hidden;
    }
    .hpfill { height:100%; width:50%; background: linear-gradient(90deg, #35d39f, #ffd166, #ff6b87); }

    .buttons { display:grid; gap: 8px; margin-top: 8px; }
    button {
      width: 100%;
      border: 1px solid rgba(255,255,255,.20);
      background: rgba(255,255,255,.10);
      color: #eef6ff;
      font-weight: 950;
      padding: 9px 10px;
      border-radius: 14px;
      cursor: pointer;
    }
    button:hover { background: rgba(255,255,255,.14); }
    button:disabled { opacity: .45; cursor: not-allowed; }
    .hint { margin-top: 6px; font-size: 12px; opacity: .75; font-weight: 750; line-height: 1.25; }

    /* Center overlay (between waves / game over) */
    .overlay {
      position: fixed; inset: 0;
      display: none;
      align-items: center; justify-content: center;
      background: radial-gradient(1200px 700px at 50% 35%, rgba(103,179,255,.20), rgba(0,0,0,.62));
      color:#eef6ff;
    }
    .card {
      width: min(780px, 92vw);
      border-radius: 20px;
      background: rgba(9,13,28,.78);
      border: 1px solid rgba(255,255,255,.18);
      box-shadow: 0 20px 90px rgba(0,0,0,.62);
      padding: 16px 16px 14px;
    }
    .card h1 { margin:0; font-size: 28px; letter-spacing:.2px; }
    .card p { margin: 10px 0; opacity:.82; font-weight: 700; line-height:1.35; }
    .card .row { margin-top: 8px; }
    .kbd {
      display:inline-block; padding:2px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
      font-weight: 900;
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <div class="hud">
    <div class="panel">
      <div class="row">
        <div class="big">üèùÔ∏è Pirate Island Defense</div>
        <div class="pill" id="statePill">WAVE</div>
      </div>
      <div class="row" style="margin-top:6px">
        <div class="muted">Gold: <span id="gold">0</span></div>
        <div class="muted">Wave: <span id="wave">1</span></div>
        <div class="muted">Enemies: <span id="enemies">0</span></div>
      </div>
      <div class="muted" style="margin-top:8px">Island HP: <span id="hpText">100</span>/100</div>
      <div class="hpbar" style="margin-top:6px"><div class="hpfill" id="hpFill"></div></div>

      <div class="hint">
        Select ship: <span class="kbd">1</span> <span class="kbd">2</span> <span class="kbd">3</span> ‚Ä¢
        Steer: <span class="kbd">W A S D</span> ‚Ä¢ Orbit camera: mouse ‚Ä¢ Fire: <span class="kbd">Space</span><br/>
        Ships auto-fire when enemies are in range. Upgrades are available between waves.
      </div>
    </div>

    <div class="panel">
      <div class="row">
        <div class="big">‚õµ Selected Ship: <span id="shipName">1</span></div>
        <div class="muted">Auto-fire: <span id="autoFire">ON</span></div>
      </div>
      <div class="row" style="margin-top:6px">
        <div class="muted">DMG: <span id="stDmg">6</span></div>
        <div class="muted">Rate: <span id="stRate">1.1</span>/s</div>
        <div class="muted">Speed: <span id="stSpeed">8</span></div>
        <div class="muted">Range: <span id="stRange">70</span></div>
      </div>

      <div class="buttons">
        <button id="btnDmg">Upgrade Damage (+2) ‚Äî <span id="costDmg">40</span>g</button>
        <button id="btnRate">Upgrade Fire Rate (+15%) ‚Äî <span id="costRate">45</span>g</button>
        <button id="btnSpeed">Upgrade Speed (+1.2) ‚Äî <span id="costSpeed">35</span>g</button>
        <button id="btnRange">Upgrade Range (+10) ‚Äî <span id="costRange">30</span>g</button>
      </div>
      <div class="hint" id="upgradeHint">Upgrades enabled between waves.</div>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="card">
      <h1 id="ovTitle">Wave Cleared!</h1>
      <p id="ovText">Spend gold to upgrade your ships, then start the next wave.</p>
      <div class="row">
        <button id="btnNextWave" class="primary">Start Next Wave</button>
        <button id="btnRestart">Restart</button>
      </div>
      <p class="muted" style="margin-top:10px">
        Tip: keep ships spread around the island so enemies get cross-fired. Use <span class="kbd">Space</span> for manual shots.
      </p>
    </div>
  </div>

  <!-- Babylon.js (CDN). Single HTML file; no external assets used beyond the library. -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>

  <script>
  (() => {
    // ============================================================
    // Babylon.js single-file prototype: 3 pirate ships defend island
    // ============================================================

    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

    // ---------- HUD refs ----------
    const $ = (id)=>document.getElementById(id);
    const ui = {
      gold: $("gold"),
      wave: $("wave"),
      enemies: $("enemies"),
      hpText: $("hpText"),
      hpFill: $("hpFill"),
      shipName: $("shipName"),
      autoFire: $("autoFire"),
      stDmg: $("stDmg"),
      stRate: $("stRate"),
      stSpeed: $("stSpeed"),
      stRange: $("stRange"),
      statePill: $("statePill"),

      btnDmg: $("btnDmg"),
      btnRate: $("btnRate"),
      btnSpeed: $("btnSpeed"),
      btnRange: $("btnRange"),
      costDmg: $("costDmg"),
      costRate: $("costRate"),
      costSpeed: $("costSpeed"),
      costRange: $("costRange"),
      upgradeHint: $("upgradeHint"),

      overlay: $("overlay"),
      ovTitle: $("ovTitle"),
      ovText: $("ovText"),
      btnNextWave: $("btnNextWave"),
      btnRestart: $("btnRestart"),
    };

    // ---------- Game constants ----------
    const ISLAND_RADIUS = 55;
    const OCEAN_RADIUS = 900;
    const ENEMY_SPAWN_R = 430;
    const FRIEND_R = 120;

    // ---------- Game state ----------
    let gold = 90;
    let wave = 1;
    let islandHP = 100;
    let inIntermission = true; // start in upgrade screen
    let gameOver = false;

    // Input
    const keys = new Set();
    window.addEventListener("keydown", (e) => {
      keys.add(e.key.toLowerCase());
      // prevent page scroll with space/arrow
      if ([" ", "arrowup", "arrowdown", "arrowleft", "arrowright"].includes(e.key.toLowerCase())) e.preventDefault();
    });
    window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

    // ---------- Scene ----------
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.02, 0.05, 0.10, 1);

    // Camera (orbiting)
    const camera = new BABYLON.ArcRotateCamera("cam",
      -Math.PI/2, Math.PI/3.2, 320,
      new BABYLON.Vector3(0, 0, 0), scene
    );
    camera.attachControl(canvas, true);
    camera.lowerRadiusLimit = 140;
    camera.upperRadiusLimit = 650;
    camera.lowerBetaLimit = 0.25;
    camera.upperBetaLimit = 1.35;
    camera.wheelDeltaPercentage = 0.01;

    // Lighting
    const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0.2, 1, 0.2), scene);
    hemi.intensity = 0.85;
    const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.25, -1, -0.25), scene);
    sun.position = new BABYLON.Vector3(140, 220, 140);
    sun.intensity = 0.9;

    // A soft sky dome
    const sky = BABYLON.MeshBuilder.CreateSphere("sky", { diameter: 2000, segments: 24 }, scene);
    sky.isPickable = false;
    sky.infiniteDistance = true;
    sky.material = new BABYLON.StandardMaterial("skyMat", scene);
    sky.material.backFaceCulling = false;
    sky.material.disableLighting = true;
    sky.material.emissiveColor = new BABYLON.Color3(0.03, 0.08, 0.16);

    // ---------- Stylized ocean shader (no textures) ----------
    BABYLON.Effect.ShadersStore["oceanVertexShader"] = `
      precision highp float;
      attribute vec3 position;
      attribute vec3 normal;
      attribute vec2 uv;
      uniform mat4 worldViewProjection;
      uniform mat4 world;
      uniform float time;
      varying vec3 vPosW;
      varying vec3 vNrmW;
      varying vec2 vUV;

      float wave(vec2 p){
        float a = 0.7;
        float f = 0.035;
        float w = 0.0;
        w += sin(p.x*f + time*1.3) * a;
        w += cos(p.y*f*1.1 + time*1.1) * a*0.9;
        w += sin((p.x+p.y)*f*0.75 + time*0.9) * a*0.6;
        return w;
      }

      void main(){
        vec3 pos = position;
        float w = wave(pos.xz);
        pos.y += w;
        vec4 worldPos = world * vec4(pos,1.0);
        vPosW = worldPos.xyz;

        // approximate normal by sampling nearby heights
        float e = 1.2;
        float w1 = wave(pos.xz + vec2(e,0.0));
        float w2 = wave(pos.xz + vec2(0.0,e));
        vec3 dx = vec3(e, w1 - w, 0.0);
        vec3 dz = vec3(0.0, w2 - w, e);
        vec3 n = normalize(cross(dz, dx));
        vNrmW = normalize((world * vec4(n,0.0)).xyz);

        vUV = uv;
        gl_Position = worldViewProjection * vec4(pos,1.0);
      }
    `;

    BABYLON.Effect.ShadersStore["oceanFragmentShader"] = `
      precision highp float;
      varying vec3 vPosW;
      varying vec3 vNrmW;
      varying vec2 vUV;
      uniform vec3 cameraPosition;
      uniform float time;

      void main(){
        vec3 V = normalize(cameraPosition - vPosW);
        float fres = pow(1.0 - max(dot(normalize(vNrmW), V), 0.0), 3.0);

        vec3 deep = vec3(0.02, 0.18, 0.28);
        vec3 shallow = vec3(0.05, 0.35, 0.46);
        float depthMix = clamp((vPosW.y + 2.0) * 0.18, 0.0, 1.0);

        vec3 col = mix(deep, shallow, depthMix);
        col = mix(col, vec3(0.55,0.85,1.0), fres*0.35);

        // subtle moving sparkle
        float s = sin(vPosW.x*0.03 + time*2.1) * cos(vPosW.z*0.03 - time*1.7);
        col += vec3(0.10,0.12,0.14) * max(0.0, s) * 0.10;

        gl_FragColor = vec4(col, 1.0);
      }
    `;

    const ocean = BABYLON.MeshBuilder.CreateGround("ocean", { width: OCEAN_RADIUS*2, height: OCEAN_RADIUS*2, subdivisions: 160 }, scene);
    ocean.isPickable = false;
    const oceanMat = new BABYLON.ShaderMaterial("oceanMat", scene, { vertex: "ocean", fragment: "ocean" }, {
      attributes: ["position","normal","uv"],
      uniforms: ["world","worldViewProjection","time","cameraPosition"]
    });
    oceanMat.backFaceCulling = true;
    oceanMat.setFloat("time", 0);
    ocean.material = oceanMat;

    // ---------- Island (procedural) ----------
    function makeIsland(){
      const root = new BABYLON.TransformNode("islandRoot", scene);

      // sand ring
      const sand = BABYLON.MeshBuilder.CreateCylinder("sand", {
        diameterTop: ISLAND_RADIUS*2.4,
        diameterBottom: ISLAND_RADIUS*2.55,
        height: 8,
        tessellation: 48
      }, scene);
      sand.position.y = 3;
      sand.material = new BABYLON.StandardMaterial("sandMat", scene);
      sand.material.diffuseColor = new BABYLON.Color3(0.92, 0.82, 0.56);
      sand.material.specularColor = new BABYLON.Color3(0.08, 0.08, 0.08);
      sand.parent = root;

      // grassy top
      const grass = BABYLON.MeshBuilder.CreateCylinder("grass", {
        diameterTop: ISLAND_RADIUS*2.1,
        diameterBottom: ISLAND_RADIUS*2.35,
        height: 10,
        tessellation: 48
      }, scene);
      grass.position.y = 6;
      const gMat = new BABYLON.StandardMaterial("grassMat", scene);
      gMat.diffuseColor = new BABYLON.Color3(0.20, 0.62, 0.26);
      gMat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);
      grass.material = gMat;
      grass.parent = root;

      // roughen edge vertices a bit (stylized)
      for (const mesh of [sand, grass]){
        const pos = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
        for (let i=0;i<pos.length;i+=3){
          const x = pos[i], y = pos[i+1], z = pos[i+2];
          const r = Math.sqrt(x*x + z*z);
          const jitter = (Math.sin((x+z)*0.12) + Math.cos((x-z)*0.08)) * 0.35;
          // more jitter near outer edge
          const t = BABYLON.Scalar.Clamp((r - ISLAND_RADIUS*0.6) / (ISLAND_RADIUS*0.8), 0, 1);
          pos[i] = x + (x/r) * jitter * t;
          pos[i+2] = z + (z/r) * jitter * t;
          // small bumps on top
          if (y > 0) pos[i+1] = y + (Math.sin(x*0.09) * Math.cos(z*0.08)) * 0.25 * (1-t);
        }
        mesh.setVerticesData(BABYLON.VertexBuffer.PositionKind, pos);
        mesh.updateVerticesData(BABYLON.VertexBuffer.PositionKind, pos);
        mesh.refreshBoundingInfo();
      }

      // Props: rocks & palms
      function rock(x,z, s=1){
        const r = BABYLON.MeshBuilder.CreateSphere("rock", { diameter: 6*s, segments: 10 }, scene);
        r.position.set(x, 10.2, z);
        r.scaling.y = 0.65 + Math.random()*0.5;
        r.scaling.x = 0.8 + Math.random()*0.6;
        r.scaling.z = 0.8 + Math.random()*0.6;
        r.rotation.y = Math.random()*Math.PI;
        const m = new BABYLON.StandardMaterial("rockMat", scene);
        m.diffuseColor = new BABYLON.Color3(0.42,0.45,0.50);
        m.specularColor = new BABYLON.Color3(0.06,0.06,0.06);
        r.material = m;
        r.parent = root;
      }

      function palm(x,z, s=1){
        const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk", { height: 18*s, diameterTop: 1.6*s, diameterBottom: 2.6*s, tessellation: 10 }, scene);
        trunk.position.set(x, 14*s, z);
        trunk.rotation.z = (Math.random()*0.35 - 0.17);
        trunk.rotation.x = (Math.random()*0.35 - 0.17);
        const tm = new BABYLON.StandardMaterial("trunkMat", scene);
        tm.diffuseColor = new BABYLON.Color3(0.45, 0.30, 0.18);
        tm.specularColor = new BABYLON.Color3(0.04,0.04,0.04);
        trunk.material = tm;
        trunk.parent = root;

        // leaves (planes)
        const leafMat = new BABYLON.StandardMaterial("leafMat", scene);
        leafMat.diffuseColor = new BABYLON.Color3(0.12,0.60,0.26);
        leafMat.specularColor = new BABYLON.Color3(0.03,0.03,0.03);
        leafMat.backFaceCulling = false;

        const crown = new BABYLON.TransformNode("crown", scene);
        crown.parent = trunk;
        crown.position.y = 9*s;

        for (let i=0;i<6;i++){
          const leaf = BABYLON.MeshBuilder.CreatePlane("leaf", { width: 12*s, height: 3.2*s }, scene);
          leaf.material = leafMat;
          leaf.parent = crown;
          leaf.position.y = 1.2*s;
          leaf.rotation.y = i * (Math.PI*2/6);
          leaf.rotation.x = Math.PI/2.8;
          leaf.position.z = 2.8*s;
        }
      }

      // place props
      rock( 12,  18, 1.2);
      rock(-22, -10, 1.0);
      rock( 25, -22, 0.9);
      rock(-10,  28, 1.1);

      palm( 10, -6, 1.0);
      palm(-14, 10, 0.95);
      palm( 18, 16, 0.9);

      return root;
    }
    const island = makeIsland();

    // A small invisible "island collider" for push-back logic
    const islandCollider = BABYLON.MeshBuilder.CreateCylinder("islandCol", { diameter: ISLAND_RADIUS*2.0, height: 40, tessellation: 24 }, scene);
    islandCollider.isVisible = false;
    islandCollider.position.y = 12;

    // ---------- Particle texture (procedural radial gradient) ----------
    function makeParticleTexture(name){
      const size = 64;
      const dt = new BABYLON.DynamicTexture(name, { width: size, height: size }, scene, false);
      const c = dt.getContext();
      const g = c.createRadialGradient(size/2, size/2, 2, size/2, size/2, size/2);
      g.addColorStop(0, "rgba(255,255,255,1)");
      g.addColorStop(0.25, "rgba(255,255,255,0.85)");
      g.addColorStop(0.6, "rgba(255,255,255,0.25)");
      g.addColorStop(1, "rgba(255,255,255,0)");
      c.fillStyle = g;
      c.fillRect(0,0,size,size);
      dt.update();
      return dt;
    }
    const particleTex = makeParticleTexture("ptex");

    function explosionFX(pos, tint = new BABYLON.Color3(1,0.8,0.5), size=1.0){
      const ps = new BABYLON.ParticleSystem("boom", 220, scene);
      ps.particleTexture = particleTex;
      ps.emitter = pos.clone();
      ps.minEmitBox = new BABYLON.Vector3(-0.2, -0.2, -0.2).scale(size);
      ps.maxEmitBox = new BABYLON.Vector3( 0.2,  0.2,  0.2).scale(size);

      ps.color1 = new BABYLON.Color4(tint.r, tint.g, tint.b, 1.0);
      ps.color2 = new BABYLON.Color4(1.0, 1.0, 1.0, 1.0);
      ps.colorDead = new BABYLON.Color4(0,0,0,0);

      ps.minSize = 0.4*size;
      ps.maxSize = 1.6*size;
      ps.minLifeTime = 0.25;
      ps.maxLifeTime = 0.75;

      ps.emitRate = 900;
      ps.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
      ps.gravity = new BABYLON.Vector3(0, -2.5, 0);

      ps.direction1 = new BABYLON.Vector3(-1, 0.3, -1);
      ps.direction2 = new BABYLON.Vector3( 1, 1.1,  1);
      ps.minAngularSpeed = 0;
      ps.maxAngularSpeed = Math.PI;

      ps.minEmitPower = 6*size;
      ps.maxEmitPower = 14*size;
      ps.updateSpeed = 0.014;

      ps.start();
      setTimeout(() => { ps.stop(); }, 90);
      setTimeout(() => { ps.dispose(); }, 900);
    }

    // ---------- Ship factory (friendly & enemy) ----------
    function createShip(name, color3, scale=1.0){
      const root = new BABYLON.TransformNode(name, scene);

      // Hull
      const hull = BABYLON.MeshBuilder.CreateBox(name+"_hull", { width: 10*scale, height: 2.6*scale, depth: 26*scale }, scene);
      hull.position.y = 2.2*scale;
      hull.parent = root;

      // Bow wedge
      const bow = BABYLON.MeshBuilder.CreateCylinder(name+"_bow", { diameterTop: 0.1*scale, diameterBottom: 8.2*scale, height: 6.5*scale, tessellation: 3 }, scene);
      bow.rotation.x = Math.PI/2;
      bow.position.set(0, 2.2*scale, 14.5*scale);
      bow.parent = root;

      // Deck
      const deck = BABYLON.MeshBuilder.CreateBox(name+"_deck", { width: 9.0*scale, height: 0.6*scale, depth: 20*scale }, scene);
      deck.position.set(0, 3.2*scale, -1*scale);
      deck.parent = root;

      // Mast
      const mast = BABYLON.MeshBuilder.CreateCylinder(name+"_mast", { diameter: 0.9*scale, height: 15*scale, tessellation: 10 }, scene);
      mast.position.set(0, 9.5*scale, 0);
      mast.parent = root;

      // Sail
      const sail = BABYLON.MeshBuilder.CreatePlane(name+"_sail", { width: 10.5*scale, height: 10.5*scale }, scene);
      sail.position.set(0, 10*scale, 3*scale);
      sail.rotation.y = Math.PI/2;
      sail.parent = root;

      // Cannons (decor)
      const cannonL = BABYLON.MeshBuilder.CreateCylinder(name+"_canL", { diameter: 0.8*scale, height: 3.2*scale, tessellation: 12 }, scene);
      cannonL.rotation.z = Math.PI/2;
      cannonL.position.set(-4.9*scale, 3.5*scale, 4*scale);
      cannonL.parent = root;

      const cannonR = cannonL.clone(name+"_canR");
      cannonR.position.x = 4.9*scale;
      cannonR.parent = root;

      // Materials
      const hullMat = new BABYLON.StandardMaterial(name+"_hullMat", scene);
      hullMat.diffuseColor = color3;
      hullMat.specularColor = new BABYLON.Color3(0.05,0.05,0.05);

      const deckMat = new BABYLON.StandardMaterial(name+"_deckMat", scene);
      deckMat.diffuseColor = new BABYLON.Color3(0.38, 0.26, 0.14);
      deckMat.specularColor = new BABYLON.Color3(0.04,0.04,0.04);

      const mastMat = new BABYLON.StandardMaterial(name+"_mastMat", scene);
      mastMat.diffuseColor = new BABYLON.Color3(0.42, 0.28, 0.16);
      mastMat.specularColor = new BABYLON.Color3(0.03,0.03,0.03);

      const sailMat = new BABYLON.StandardMaterial(name+"_sailMat", scene);
      sailMat.diffuseColor = new BABYLON.Color3(0.92, 0.92, 0.96);
      sailMat.emissiveColor = new BABYLON.Color3(0.05, 0.05, 0.08);
      sailMat.specularColor = new BABYLON.Color3(0.02,0.02,0.02);
      sailMat.backFaceCulling = false;

      hull.material = hullMat;
      bow.material = hullMat;
      deck.material = deckMat;
      mast.material = mastMat;
      sail.material = sailMat;
      cannonL.material = mastMat;
      cannonR.material = mastMat;

      // Waterline bobbing offset
      root.position.y = 0.4;

      // Selection ring (toggle visibility)
      const ring = BABYLON.MeshBuilder.CreateTorus(name+"_ring", { diameter: 18*scale, thickness: 0.45*scale, tessellation: 32 }, scene);
      ring.rotation.x = Math.PI/2;
      ring.position.y = 0.8*scale;
      ring.parent = root;
      const ringMat = new BABYLON.StandardMaterial(name+"_ringMat", scene);
      ringMat.emissiveColor = new BABYLON.Color3(0.4, 0.75, 1.0);
      ringMat.diffuseColor = new BABYLON.Color3(0,0,0);
      ring.material = ringMat;
      ring.isVisible = false;

      // A subtle shadow ‚Äúblob‚Äù
      const shadow = BABYLON.MeshBuilder.CreateDisc(name+"_shadow", { radius: 9*scale, tessellation: 28 }, scene);
      shadow.rotation.x = Math.PI/2;
      shadow.position.y = 0.05;
      shadow.parent = root;
      const sm = new BABYLON.StandardMaterial(name+"_shadowMat", scene);
      sm.diffuseColor = new BABYLON.Color3(0,0,0);
      sm.alpha = 0.18;
      shadow.material = sm;

      return { root, ring };
    }

    // Friendly ships (3)
    const friendly = [];
    const friendlyColors = [
      new BABYLON.Color3(0.25, 0.62, 1.0),
      new BABYLON.Color3(0.25, 0.85, 0.55),
      new BABYLON.Color3(1.0, 0.62, 0.25),
    ];

    function makeFriendlyShips(){
      const angles = [0, Math.PI*2/3, Math.PI*4/3];
      for (let i=0;i<3;i++){
        const s = createShip("friendly"+(i+1), friendlyColors[i], 1.0);
        const a = angles[i];
        s.root.position.x = Math.cos(a) * FRIEND_R;
        s.root.position.z = Math.sin(a) * FRIEND_R;
        s.root.rotation.y = -a + Math.PI/2;

        friendly.push({
          id: i+1,
          ...s,
          heading: s.root.rotation.y,
          vel: 0,
          turnVel: 0,
          // base stats (upgradeable)
          stats: {
            dmg: 6,
            fireRate: 1.1, // shots per second
            speed: 8.0,
            range: 75,
            auto: true
          },
          cooldown: 0
        });
      }
    }
    makeFriendlyShips();

    let selectedIndex = 0;
    function selectShip(i){
      selectedIndex = BABYLON.Scalar.Clamp(i, 0, friendly.length-1);
      friendly.forEach((s, idx)=> s.ring.isVisible = (idx===selectedIndex));
      refreshShipUI();
    }
    selectShip(0);

    // Enemies
    const enemies = []; // {root, heading, speed, hp, cooldown}
    function spawnEnemy(){
      const theta = Math.random() * Math.PI*2;
      const x = Math.cos(theta) * ENEMY_SPAWN_R;
      const z = Math.sin(theta) * ENEMY_SPAWN_R;

      const s = createShip("enemy", new BABYLON.Color3(0.95, 0.22, 0.34), 1.0);
      s.root.position.set(x, 0.4, z);

      const dirToCenter = new BABYLON.Vector3(-x, 0, -z).normalize();
      const heading = Math.atan2(dirToCenter.x, dirToCenter.z); // y-rotation
      s.root.rotation.y = heading;

      const hp = 18 + wave*4;
      const speed = 4.0 + wave*0.25;

      // make ring invisible always
      s.ring.isVisible = false;

      enemies.push({
        root: s.root,
        heading,
        speed,
        hp,
        maxHp: hp,
        reached: false
      });
    }

    // Cannonballs
    const balls = []; // {mesh, vel:Vector3, dmg, fromFriendly:boolean, ownerIdx?}
    const ballMatFriendly = new BABYLON.StandardMaterial("ballF", scene);
    ballMatFriendly.diffuseColor = new BABYLON.Color3(0.85, 0.95, 1.0);
    ballMatFriendly.emissiveColor = new BABYLON.Color3(0.10, 0.20, 0.30);
    ballMatFriendly.specularColor = new BABYLON.Color3(0.05,0.05,0.05);

    const ballMatEnemy = new BABYLON.StandardMaterial("ballE", scene);
    ballMatEnemy.diffuseColor = new BABYLON.Color3(1.0, 0.55, 0.60);
    ballMatEnemy.emissiveColor = new BABYLON.Color3(0.20, 0.05, 0.07);
    ballMatEnemy.specularColor = new BABYLON.Color3(0.05,0.05,0.05);

    function fireCannon(fromShip, targetPos, dmg, muzzleSide = 1){
      // Spawn from the side of the ship (left/right) for pirate vibes
      const forward = new BABYLON.Vector3(Math.sin(fromShip.heading), 0, Math.cos(fromShip.heading));
      const right = new BABYLON.Vector3(forward.z, 0, -forward.x);

      const muzzle = fromShip.root.position
        .add(forward.scale(12))
        .add(right.scale(5 * muzzleSide));
      muzzle.y = 3.2;

      const ball = BABYLON.MeshBuilder.CreateSphere("ball", { diameter: 2.2, segments: 10 }, scene);
      ball.material = fromShip.isEnemy ? ballMatEnemy : ballMatFriendly;
      ball.position.copyFrom(muzzle);

      // Aim with a slight arc
      const to = targetPos.subtract(muzzle);
      to.y = 0;
      const dir = to.normalize();

      const speed = 58;
      const vel = dir.scale(speed);
      vel.y = 16; // arc

      balls.push({
        mesh: ball,
        vel,
        dmg,
        life: 5.0,
        fromFriendly: !fromShip.isEnemy,
      });
    }

    // ---------- Upgrades ----------
    function upgradeCosts(s){
      // Costs scale slightly with how upgraded the ship is
      const t = s.stats;
      return {
        dmg: 40 + Math.floor((t.dmg-6)*4),
        rate: 45 + Math.floor((t.fireRate-1.1)*40),
        speed: 35 + Math.floor((t.speed-8)*14),
        range: 30 + Math.floor((t.range-75)*1.2),
      };
    }

    function refreshShipUI(){
      const s = friendly[selectedIndex];
      ui.shipName.textContent = String(s.id);
      ui.autoFire.textContent = s.stats.auto ? "ON" : "OFF";
      ui.stDmg.textContent = s.stats.dmg.toFixed(0);
      ui.stRate.textContent = s.stats.fireRate.toFixed(2);
      ui.stSpeed.textContent = s.stats.speed.toFixed(1);
      ui.stRange.textContent = s.stats.range.toFixed(0);

      const cost = upgradeCosts(s);
      ui.costDmg.textContent = cost.dmg;
      ui.costRate.textContent = cost.rate;
      ui.costSpeed.textContent = cost.speed;
      ui.costRange.textContent = cost.range;

      const enabled = inIntermission && !gameOver;
      ui.btnDmg.disabled = !enabled || gold < cost.dmg;
      ui.btnRate.disabled = !enabled || gold < cost.rate;
      ui.btnSpeed.disabled = !enabled || gold < cost.speed;
      ui.btnRange.disabled = !enabled || gold < cost.range;

      ui.upgradeHint.textContent = enabled ? "Upgrades enabled between waves." : "Upgrades enabled between waves.";
      ui.statePill.textContent = gameOver ? "DEFEAT" : (inIntermission ? "UPGRADE" : "WAVE");
    }

    function spend(cost){
      if (gold < cost) return false;
      gold -= cost;
      return true;
    }

    ui.btnDmg.addEventListener("click", () => {
      const s = friendly[selectedIndex];
      const cost = upgradeCosts(s).dmg;
      if (!inIntermission || !spend(cost)) return;
      s.stats.dmg += 2;
      refreshAllUI();
    });

    ui.btnRate.addEventListener("click", () => {
      const s = friendly[selectedIndex];
      const cost = upgradeCosts(s).rate;
      if (!inIntermission || !spend(cost)) return;
      s.stats.fireRate *= 1.15;
      refreshAllUI();
    });

    ui.btnSpeed.addEventListener("click", () => {
      const s = friendly[selectedIndex];
      const cost = upgradeCosts(s).speed;
      if (!inIntermission || !spend(cost)) return;
      s.stats.speed += 1.2;
      refreshAllUI();
    });

    ui.btnRange.addEventListener("click", () => {
      const s = friendly[selectedIndex];
      const cost = upgradeCosts(s).range;
      if (!inIntermission || !spend(cost)) return;
      s.stats.range += 10;
      refreshAllUI();
    });

    function refreshAllUI(){
      ui.gold.textContent = gold.toFixed(0);
      ui.wave.textContent = wave.toFixed(0);
      ui.enemies.textContent = enemies.length.toFixed(0);
      ui.hpText.textContent = Math.max(0, islandHP).toFixed(0);
      ui.hpFill.style.width = (Math.max(0, islandHP)/100*100).toFixed(1) + "%";
      refreshShipUI();
    }

    // ---------- Waves ----------
    let enemiesToSpawn = 0;
    let spawnTimer = 0;

    function beginWave(){
      if (gameOver) return;
      inIntermission = false;
      enemiesToSpawn = 3 + wave*2;
      spawnTimer = 0;
      ui.overlay.style.display = "none";
      refreshAllUI();
    }

    function endWave(){
      inIntermission = true;
      ui.overlay.style.display = "flex";
      ui.ovTitle.textContent = "Wave Cleared!";
      ui.ovText.textContent = "Spend gold to upgrade ships, then start the next wave.";
      refreshAllUI();
    }

    ui.btnNextWave.addEventListener("click", () => {
      if (gameOver) return;
      wave += 1;
      beginWave();
    });

    ui.btnRestart.addEventListener("click", () => restartGame());

    function restartGame(){
      // reset state
      gold = 90;
      wave = 1;
      islandHP = 100;
      inIntermission = true;
      gameOver = false;

      // cleanup enemies/balls
      enemies.splice(0).forEach(e => e.root.dispose());
      balls.splice(0).forEach(b => b.mesh.dispose());

      // reset friendly positions & stats
      const angles = [0, Math.PI*2/3, Math.PI*4/3];
      friendly.forEach((s, i) => {
        const a = angles[i];
        s.root.position.x = Math.cos(a) * FRIEND_R;
        s.root.position.z = Math.sin(a) * FRIEND_R;
        s.heading = -a + Math.PI/2;
        s.root.rotation.y = s.heading;
        s.vel = 0;
        s.turnVel = 0;
        s.cooldown = 0;
        s.stats = { dmg: 6, fireRate: 1.1, speed: 8.0, range: 75, auto: true };
      });
      selectShip(0);

      enemiesToSpawn = 0;
      spawnTimer = 0;

      ui.overlay.style.display = "flex";
      ui.ovTitle.textContent = "Ready to Defend!";
      ui.ovText.textContent = "Upgrade before the first wave, then start when ready.";
      refreshAllUI();
    }

    // Initial overlay state
    ui.overlay.style.display = "flex";
    ui.ovTitle.textContent = "Ready to Defend!";
    ui.ovText.textContent = "Upgrade before the first wave, then start when ready.";

    // ---------- Selection keys ----------
    scene.onKeyboardObservable.add((kbInfo) => {
      if (kbInfo.type !== BABYLON.KeyboardEventTypes.KEYDOWN) return;
      const k = kbInfo.event.key;
      if (k === "1") selectShip(0);
      if (k === "2") selectShip(1);
      if (k === "3") selectShip(2);
    });

    // ---------- Per-frame update ----------
    let t = 0;
    const gravity = new BABYLON.Vector3(0, -18, 0);

    function nearestEnemy(pos){
      let best = null;
      let bestD2 = Infinity;
      for (const e of enemies){
        const d2 = BABYLON.Vector3.DistanceSquared(pos, e.root.position);
        if (d2 < bestD2){
          bestD2 = d2; best = e;
        }
      }
      return best ? { e: best, d: Math.sqrt(bestD2) } : null;
    }

    function pushOutOfIsland(node, radius){
      const p = node.position;
      const v = new BABYLON.Vector3(p.x, 0, p.z);
      const d = v.length();
      const minD = radius;
      if (d < minD && d > 0.0001){
        const n = v.scale(1/d);
        node.position.x = n.x * minD;
        node.position.z = n.z * minD;
      }
    }

    function doGameOver(){
      gameOver = true;
      inIntermission = true;
      ui.overlay.style.display = "flex";
      ui.ovTitle.textContent = "Island Overrun!";
      ui.ovText.textContent = `Final Score: ${gold} gold ‚Ä¢ You reached wave ${wave}.`;
      refreshAllUI();
    }

    // Small ‚Äúbob‚Äù for ships based on time and position (matches ocean vibe)
    function bob(node, amp=0.35){
      const px = node.position.x, pz = node.position.z;
      node.position.y = 0.45 + Math.sin(px*0.03 + t*1.7)*amp*0.35 + Math.cos(pz*0.03 - t*1.3)*amp*0.35;
      node.rotation.z = Math.sin(px*0.02 + t*1.2) * 0.015;
      node.rotation.x = Math.cos(pz*0.02 - t*1.1) * 0.015;
    }

    function updateFriendly(dt){
      // Selection controls apply to selected ship only
      const s = friendly[selectedIndex];

      // Toggle auto-fire with "f"
      if (keys.has("f")){
        keys.delete("f");
        s.stats.auto = !s.stats.auto;
        refreshShipUI();
      }

      // steering
      const forward = (keys.has("w") ? 1 : 0) + (keys.has("arrowup") ? 1 : 0) - (keys.has("s") ? 1 : 0) - (keys.has("arrowdown") ? 1 : 0);
      const turn = (keys.has("d") ? 1 : 0) + (keys.has("arrowright") ? 1 : 0) - (keys.has("a") ? 1 : 0) - (keys.has("arrowleft") ? 1 : 0);

      // boat-like dynamics
      const accel = 10.0;
      const turnAccel = 2.8;

      s.vel += forward * accel * dt;
      s.vel *= Math.pow(0.25, dt); // damping
      s.vel = BABYLON.Scalar.Clamp(s.vel, -s.stats.speed*0.45, s.stats.speed);

      s.turnVel += turn * turnAccel * dt;
      s.turnVel *= Math.pow(0.20, dt);
      s.turnVel = BABYLON.Scalar.Clamp(s.turnVel, -2.2, 2.2);

      s.heading += s.turnVel * dt * (0.9 + Math.abs(s.vel)*0.08);
      s.root.rotation.y = s.heading;

      const dir = new BABYLON.Vector3(Math.sin(s.heading), 0, Math.cos(s.heading));
      s.root.position.addInPlace(dir.scale(s.vel * dt));

      // keep around ocean bounds
      const r = Math.sqrt(s.root.position.x*s.root.position.x + s.root.position.z*s.root.position.z);
      if (r > OCEAN_RADIUS*0.92){
        const n = new BABYLON.Vector3(s.root.position.x, 0, s.root.position.z).normalize();
        s.root.position.x = n.x * OCEAN_RADIUS*0.92;
        s.root.position.z = n.z * OCEAN_RADIUS*0.92;
        s.vel *= -0.2;
      }

      // avoid island
      pushOutOfIsland(s.root, ISLAND_RADIUS + 25);

      // bob
      bob(s.root, 0.42);

      // cooldown
      s.cooldown = Math.max(0, s.cooldown - dt);

      // auto-fire
      if (!inIntermission && s.stats.auto && s.cooldown <= 0){
        const ne = nearestEnemy(s.root.position);
        if (ne && ne.d <= s.stats.range){
          s.cooldown = 1 / s.stats.fireRate;
          fireCannon({ root: s.root, heading: s.heading, isEnemy:false }, ne.e.root.position, s.stats.dmg, Math.random()<0.5 ? -1 : 1);
        }
      }

      // manual fire (space)
      if (!inIntermission && keys.has(" ") && s.cooldown <= 0){
        const ne = nearestEnemy(s.root.position);
        if (ne){
          s.cooldown = 1 / s.stats.fireRate;
          fireCannon({ root: s.root, heading: s.heading, isEnemy:false }, ne.e.root.position, s.stats.dmg, Math.random()<0.5 ? -1 : 1);
        }
      }

      // non-selected ships still bob & auto-fire (if enabled)
      for (let i=0;i<friendly.length;i++){
        if (i === selectedIndex) continue;
        const o = friendly[i];
        bob(o.root, 0.40);
        o.cooldown = Math.max(0, o.cooldown - dt);

        // mild idle drift in intermission
        if (inIntermission){
          o.vel *= Math.pow(0.1, dt);
          continue;
        }

        if (o.stats.auto && o.cooldown <= 0){
          const ne = nearestEnemy(o.root.position);
          if (ne && ne.d <= o.stats.range){
            o.cooldown = 1 / o.stats.fireRate;
            fireCannon({ root: o.root, heading: o.heading, isEnemy:false }, ne.e.root.position, o.stats.dmg, Math.random()<0.5 ? -1 : 1);
          }
        }
      }
    }

    function updateEnemies(dt){
      for (let i=enemies.length-1;i>=0;i--){
        const e = enemies[i];

        // Sail toward island
        const to = new BABYLON.Vector3(-e.root.position.x, 0, -e.root.position.z);
        const d = to.length();
        const dir = d > 0.001 ? to.scale(1/d) : new BABYLON.Vector3(0,0,1);

        // turn toward target smoothly
        const desired = Math.atan2(dir.x, dir.z);
        let delta = desired - e.heading;
        while (delta > Math.PI) delta -= Math.PI*2;
        while (delta < -Math.PI) delta += Math.PI*2;
        e.heading += delta * dt * 1.4;
        e.root.rotation.y = e.heading;

        // move
        const fwd = new BABYLON.Vector3(Math.sin(e.heading), 0, Math.cos(e.heading));
        e.root.position.addInPlace(fwd.scale(e.speed * dt));

        // bob
        bob(e.root, 0.38);

        // If reached island: damage it
        if (d < ISLAND_RADIUS + 14){
          // impact
          explosionFX(e.root.position.clone(), new BABYLON.Color3(1.0,0.55,0.35), 1.1);
          e.root.dispose();
          enemies.splice(i,1);

          islandHP -= (8 + wave*1.5);
          if (islandHP <= 0){
            islandHP = 0;
            doGameOver();
          }
          continue;
        }
      }
    }

    function updateBalls(dt){
      for (let i=balls.length-1;i>=0;i--){
        const b = balls[i];
        b.life -= dt;
        if (b.life <= 0){
          b.mesh.dispose();
          balls.splice(i,1);
          continue;
        }

        // integrate
        b.vel.addInPlace(gravity.scale(dt));
        b.mesh.position.addInPlace(b.vel.scale(dt));

        // water hit
        if (b.mesh.position.y < 0.2){
          explosionFX(b.mesh.position.clone(), new BABYLON.Color3(0.55,0.85,1.0), 0.65);
          b.mesh.dispose();
          balls.splice(i,1);
          continue;
        }

        if (!b.fromFriendly) continue;

        // hit enemies
        for (let j=enemies.length-1;j>=0;j--){
          const e = enemies[j];
          const d2 = BABYLON.Vector3.DistanceSquared(b.mesh.position, e.root.position);
          if (d2 < 11*11){
            e.hp -= b.dmg;
            explosionFX(b.mesh.position.clone(), new BABYLON.Color3(1.0,0.8,0.45), 0.7);

            b.mesh.dispose();
            balls.splice(i,1);

            if (e.hp <= 0){
              explosionFX(e.root.position.clone(), new BABYLON.Color3(1.0,0.55,0.35), 1.25);
              e.root.dispose();
              enemies.splice(j,1);

              // gold reward
              gold += 12 + Math.floor(wave*2.5);
            }
            break;
          }
        }
      }
    }

    function updateWaveLogic(dt){
      if (gameOver) return;

      if (inIntermission){
        // Wave is not running; no spawns
        return;
      }

      // spawn enemies over time
      spawnTimer -= dt;
      if (enemiesToSpawn > 0 && spawnTimer <= 0){
        spawnTimer = Math.max(0.6, 1.5 - wave*0.06);
        spawnEnemy();
        enemiesToSpawn--;
      }

      // if wave is done and no enemies remain
      if (enemiesToSpawn <= 0 && enemies.length === 0){
        endWave();
      }
    }

    // ---------- Main loop ----------
    scene.onBeforeRenderObservable.add(() => {
      const dt = engine.getDeltaTime() / 1000;
      t += dt;
      oceanMat.setFloat("time", t);

      if (!gameOver){
        updateFriendly(dt);
        updateEnemies(dt);
        updateBalls(dt);
        updateWaveLogic(dt);
      }

      refreshAllUI();
    });

    // Start wave 1 button behavior:
    // If wave=1 and intermission, Next Wave should begin wave 1 (without increment).
    ui.btnNextWave.addEventListener("click", () => {
      if (gameOver) return;
      // If still on wave 1 and we haven't started it, keep wave as 1.
      beginWave();
      ui.overlay.style.display = "none";
    });

    // Small tweak: if user already clicked Next once, it increments in the other handler.
    // To keep behavior clean, we‚Äôll override: when intermission ends, ‚ÄúNext Wave‚Äù becomes ‚ÄúStart Next Wave‚Äù.
    const originalEndWave = endWave;
    endWave = function(){
      inIntermission = true;
      ui.overlay.style.display = "flex";
      ui.ovTitle.textContent = "Wave Cleared!";
      ui.ovText.textContent = "Spend gold to upgrade ships, then start the next wave.";
      ui.btnNextWave.textContent = "Start Next Wave";
      refreshAllUI();
    };

    // Start screen button text
    ui.btnNextWave.textContent = "Start Wave 1";

    // Render loop
    engine.runRenderLoop(() => scene.render());
    window.addEventListener("resize", () => engine.resize());

    // Initial UI paint
    refreshAllUI();

  })();
  </script>
</body>
</html>
