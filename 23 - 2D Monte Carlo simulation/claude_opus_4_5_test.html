<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Monte Carlo Simulations</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            padding: 20px;
            color: #fff;
        }
        
        h1 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-weight: 500;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
            font-size: 26px;
        }
        
        #main-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        #canvas-wrapper {
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 212, 255, 0.3);
        }
        
        #controls {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 16px;
            min-width: 300px;
            max-width: 320px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-height: 85vh;
            overflow-y: auto;
        }
        
        .control-section {
            margin-bottom: 18px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .control-section h3 {
            color: #00d4ff;
            font-size: 13px;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: 600;
        }
        
        .control-row {
            margin-bottom: 12px;
        }
        
        .control-row label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-size: 12px;
            color: #aaa;
        }
        
        .control-row label span {
            color: #ff6b9d;
            font-weight: 600;
            font-family: 'Consolas', monospace;
        }
        
        input[type="range"] {
            width: 100%;
            height: 5px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00d4ff, #00a8cc);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 212, 255, 0.4);
        }
        
        select {
            width: 100%;
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.4);
            color: #fff;
            font-size: 13px;
            cursor: pointer;
            outline: none;
        }
        
        select:focus {
            border-color: #00d4ff;
        }
        
        .button-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        button {
            flex: 1;
            min-width: 70px;
            padding: 10px 12px;
            border: none;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #00d4ff, #00a8cc);
            color: #000;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #ff6b9d, #e55a8a);
            color: #fff;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: #000;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .result-box {
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 10px;
            margin-top: 10px;
        }
        
        .result-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }
        
        .result-row:last-child {
            margin-bottom: 0;
        }
        
        .result-label {
            color: #888;
        }
        
        .result-value {
            color: #00d4ff;
            font-weight: 600;
            font-family: 'Consolas', monospace;
        }
        
        .result-value.highlight {
            color: #4ade80;
            font-size: 14px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-box .value {
            font-size: 18px;
            font-weight: 700;
            color: #00d4ff;
            font-family: 'Consolas', monospace;
        }
        
        .stat-box .label {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
            margin-top: 4px;
        }
        
        .description {
            font-size: 11px;
            color: #888;
            line-height: 1.6;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .tab-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #aaa;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        
        .tab-btn:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .tab-btn.active {
            background: linear-gradient(135deg, #00d4ff, #00a8cc);
            color: #000;
            border-color: transparent;
        }
        
        .convergence-graph {
            width: 100%;
            height: 80px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <h1>ðŸŽ² 2D Monte Carlo Simulations</h1>
    
    <div id="main-container">
        <div id="canvas-wrapper"></div>
        
        <div id="controls">
            <div class="control-section">
                <h3>Simulation Type</h3>
                <div class="tab-buttons">
                    <button class="tab-btn active" onclick="setSimulation('pi')">Ï€ Estimate</button>
                    <button class="tab-btn" onclick="setSimulation('integral')">Integration</button>
                    <button class="tab-btn" onclick="setSimulation('ising')">Ising Model</button>
                    <button class="tab-btn" onclick="setSimulation('walk')">Random Walk</button>
                    <button class="tab-btn" onclick="setSimulation('buffon')">Buffon's Needle</button>
                    <button class="tab-btn" onclick="setSimulation('percolation')">Percolation</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Parameters</h3>
                <div class="control-row">
                    <label>Sample Rate: <span id="rateVal">100</span>/frame</label>
                    <input type="range" id="sampleRate" min="1" max="500" value="100">
                </div>
                <div class="control-row" id="tempControl" style="display: none;">
                    <label>Temperature: <span id="tempVal">2.27</span></label>
                    <input type="range" id="temperature" min="0.1" max="5" step="0.01" value="2.27">
                </div>
                <div class="control-row" id="probControl" style="display: none;">
                    <label>Probability: <span id="probVal">0.59</span></label>
                    <input type="range" id="probability" min="0" max="1" step="0.01" value="0.59">
                </div>
                <div class="control-row" id="walkersControl" style="display: none;">
                    <label>Walkers: <span id="walkersVal">50</span></label>
                    <input type="range" id="walkers" min="1" max="200" value="50">
                </div>
                <div class="control-row" id="functionControl" style="display: none;">
                    <label>Function:</label>
                    <select id="integralFunction">
                        <option value="semicircle">Semicircle (Ï€/4)</option>
                        <option value="parabola">1-xÂ² (2/3)</option>
                        <option value="sine">sin(Ï€x) (2/Ï€)</option>
                        <option value="gaussian">Gaussian</option>
                        <option value="sqrt">âˆšx (2/3)</option>
                    </select>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Actions</h3>
                <div class="button-row">
                    <button class="btn-primary" onclick="resetSimulation()">Reset</button>
                    <button class="btn-secondary" onclick="togglePause()">Pause</button>
                    <button class="btn-success" onclick="burst()">Burst +1000</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="sampleCount">0</div>
                        <div class="label">Samples</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="fpsDisplay">60</div>
                        <div class="label">FPS</div>
                    </div>
                </div>
                
                <div class="result-box" id="resultsBox">
                    <div class="result-row">
                        <span class="result-label">Estimate:</span>
                        <span class="result-value highlight" id="estimate">--</span>
                    </div>
                    <div class="result-row">
                        <span class="result-label">True Value:</span>
                        <span class="result-value" id="trueValue">Ï€ = 3.14159...</span>
                    </div>
                    <div class="result-row">
                        <span class="result-label">Error:</span>
                        <span class="result-value" id="errorVal">--</span>
                    </div>
                    <div class="result-row">
                        <span class="result-label">Std Error:</span>
                        <span class="result-value" id="stdError">--</span>
                    </div>
                </div>
                
                <canvas id="convergenceGraph" class="convergence-graph"></canvas>
            </div>
            
            <div class="control-section">
                <div class="description" id="description">
                    <strong>Ï€ Estimation:</strong> Randomly throw darts at a square. 
                    The ratio of darts inside the inscribed circle to total darts 
                    approximates Ï€/4. Classic Monte Carlo demonstration!
                </div>
            </div>
        </div>
    </div>

    <script>
        // Simulation state
        let simulationType = 'pi';
        let paused = false;
        let sampleRate = 100;
        
        // Canvas dimensions
        let canvasWidth = 600;
        let canvasHeight = 600;
        
        // Pi estimation
        let piPoints = [];
        let piInside = 0;
        let piTotal = 0;
        
        // Integration
        let integralPoints = [];
        let integralInside = 0;
        let integralTotal = 0;
        let integralFunction = 'semicircle';
        
        // Ising model
        let isingGrid = [];
        let isingSize = 100;
        let temperature = 2.27; // Critical temperature â‰ˆ 2.269
        let magnetization = 0;
        let energy = 0;
        
        // Random walk
        let walkers = [];
        let numWalkers = 50;
        let walkSteps = 0;
        let msd = 0; // Mean squared displacement
        
        // Buffon's needle
        let needles = [];
        let needleCrossings = 0;
        let needleTotal = 0;
        let lineSpacing = 60;
        let needleLength = 50;
        
        // Percolation
        let percGrid = [];
        let percSize = 100;
        let percProbability = 0.59; // Critical probability â‰ˆ 0.5927
        let percolates = false;
        let clusterSizes = [];
        
        // Convergence history
        let convergenceHistory = [];
        let convergenceCanvas;
        
        function setup() {
            canvasWidth = min(600, windowWidth - 380);
            canvasHeight = min(600, windowHeight - 120);
            canvasWidth = max(400, canvasWidth);
            canvasHeight = canvasWidth;
            
            const canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('canvas-wrapper');
            
            convergenceCanvas = document.getElementById('convergenceGraph');
            convergenceCanvas.width = convergenceCanvas.offsetWidth;
            convergenceCanvas.height = convergenceCanvas.offsetHeight;
            
            setupControls();
            resetSimulation();
        }
        
        function setupControls() {
            document.getElementById('sampleRate').addEventListener('input', function() {
                sampleRate = parseInt(this.value);
                document.getElementById('rateVal').textContent = sampleRate;
            });
            
            document.getElementById('temperature').addEventListener('input', function() {
                temperature = parseFloat(this.value);
                document.getElementById('tempVal').textContent = temperature.toFixed(2);
            });
            
            document.getElementById('probability').addEventListener('input', function() {
                percProbability = parseFloat(this.value);
                document.getElementById('probVal').textContent = percProbability.toFixed(2);
                if (simulationType === 'percolation') resetSimulation();
            });
            
            document.getElementById('walkers').addEventListener('input', function() {
                numWalkers = parseInt(this.value);
                document.getElementById('walkersVal').textContent = numWalkers;
                if (simulationType === 'walk') resetSimulation();
            });
            
            document.getElementById('integralFunction').addEventListener('change', function() {
                integralFunction = this.value;
                if (simulationType === 'integral') resetSimulation();
            });
        }
        
        function setSimulation(type) {
            simulationType = type;
            
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Show/hide relevant controls
            document.getElementById('tempControl').style.display = type === 'ising' ? 'block' : 'none';
            document.getElementById('probControl').style.display = type === 'percolation' ? 'block' : 'none';
            document.getElementById('walkersControl').style.display = type === 'walk' ? 'block' : 'none';
            document.getElementById('functionControl').style.display = type === 'integral' ? 'block' : 'none';
            
            // Update description
            const descriptions = {
                pi: `<strong>Ï€ Estimation:</strong> Randomly throw darts at a square. The ratio of darts inside the inscribed circle to total darts approximates Ï€/4. Classic Monte Carlo demonstration!`,
                integral: `<strong>Monte Carlo Integration:</strong> Estimate the area under a curve by randomly sampling points and counting how many fall below the curve. Converges as 1/âˆšN.`,
                ising: `<strong>Ising Model:</strong> 2D lattice of magnetic spins. At critical temperature Tâ‰ˆ2.27, the system undergoes a phase transition. Uses Metropolis algorithm.`,
                walk: `<strong>Random Walk:</strong> Particles perform random steps. Mean squared displacement grows linearly with time (diffusion). Demonstrates Brownian motion.`,
                buffon: `<strong>Buffon's Needle:</strong> Drop needles on lined paper. The probability of crossing a line relates to Ï€. If Lâ‰¤d: P = 2L/(Ï€d), so Ï€ = 2LÂ·N/(dÂ·crossings).`,
                percolation: `<strong>Site Percolation:</strong> Randomly fill lattice sites. At critical probability pâ‰ˆ0.593, an infinite cluster spans the system. Shows phase transition.`
            };
            document.getElementById('description').innerHTML = descriptions[type];
            
            resetSimulation();
        }
        
        function resetSimulation() {
            convergenceHistory = [];
            
            switch(simulationType) {
                case 'pi':
                    piPoints = [];
                    piInside = 0;
                    piTotal = 0;
                    break;
                    
                case 'integral':
                    integralPoints = [];
                    integralInside = 0;
                    integralTotal = 0;
                    break;
                    
                case 'ising':
                    initIsing();
                    break;
                    
                case 'walk':
                    initWalkers();
                    break;
                    
                case 'buffon':
                    needles = [];
                    needleCrossings = 0;
                    needleTotal = 0;
                    break;
                    
                case 'percolation':
                    initPercolation();
                    break;
            }
            
            updateResults();
        }
        
        function initIsing() {
            isingGrid = [];
            for (let i = 0; i < isingSize; i++) {
                isingGrid[i] = [];
                for (let j = 0; j < isingSize; j++) {
                    isingGrid[i][j] = random() < 0.5 ? 1 : -1;
                }
            }
            computeIsingStats();
        }
        
        function initWalkers() {
            walkers = [];
            const cx = canvasWidth / 2;
            const cy = canvasHeight / 2;
            for (let i = 0; i < numWalkers; i++) {
                walkers.push({
                    x: cx,
                    y: cy,
                    startX: cx,
                    startY: cy,
                    hue: (i / numWalkers) * 360
                });
            }
            walkSteps = 0;
            msd = 0;
        }
        
        function initPercolation() {
            percGrid = [];
            for (let i = 0; i < percSize; i++) {
                percGrid[i] = [];
                for (let j = 0; j < percSize; j++) {
                    percGrid[i][j] = random() < percProbability ? 1 : 0;
                }
            }
            checkPercolation();
        }
        
        // Monte Carlo step functions
        function stepPi() {
            for (let i = 0; i < sampleRate; i++) {
                const x = random(-1, 1);
                const y = random(-1, 1);
                const inside = x*x + y*y <= 1;
                
                if (inside) piInside++;
                piTotal++;
                
                if (piPoints.length < 5000) {
                    piPoints.push({ x, y, inside });
                }
            }
        }
        
        function stepIntegral() {
            for (let i = 0; i < sampleRate; i++) {
                const x = random(0, 1);
                const y = random(0, 1);
                const fval = evaluateFunction(x);
                const inside = y <= fval && fval >= 0;
                
                if (inside) integralInside++;
                integralTotal++;
                
                if (integralPoints.length < 5000) {
                    integralPoints.push({ x, y, inside, fval });
                }
            }
        }
        
        function evaluateFunction(x) {
            switch(integralFunction) {
                case 'semicircle': return sqrt(max(0, 1 - x*x));
                case 'parabola': return 1 - x*x;
                case 'sine': return sin(PI * x);
                case 'gaussian': return exp(-x*x * 3);
                case 'sqrt': return sqrt(x);
                default: return 0;
            }
        }
        
        function getTrueIntegral() {
            switch(integralFunction) {
                case 'semicircle': return PI / 4;
                case 'parabola': return 2/3;
                case 'sine': return 2 / PI;
                case 'gaussian': return 0.554; // approximate
                case 'sqrt': return 2/3;
                default: return 1;
            }
        }
        
        function stepIsing() {
            const beta = 1 / temperature;
            
            for (let i = 0; i < sampleRate * 10; i++) {
                const x = floor(random(isingSize));
                const y = floor(random(isingSize));
                
                const spin = isingGrid[x][y];
                
                // Sum of neighbors (periodic boundary)
                const left = isingGrid[(x - 1 + isingSize) % isingSize][y];
                const right = isingGrid[(x + 1) % isingSize][y];
                const up = isingGrid[x][(y - 1 + isingSize) % isingSize];
                const down = isingGrid[x][(y + 1) % isingSize];
                
                const neighborSum = left + right + up + down;
                const deltaE = 2 * spin * neighborSum;
                
                // Metropolis acceptance
                if (deltaE <= 0 || random() < exp(-beta * deltaE)) {
                    isingGrid[x][y] = -spin;
                }
            }
            
            computeIsingStats();
        }
        
        function computeIsingStats() {
            let m = 0;
            let e = 0;
            
            for (let i = 0; i < isingSize; i++) {
                for (let j = 0; j < isingSize; j++) {
                    m += isingGrid[i][j];
                    e -= isingGrid[i][j] * (
                        isingGrid[(i+1) % isingSize][j] +
                        isingGrid[i][(j+1) % isingSize]
                    );
                }
            }
            
            magnetization = abs(m) / (isingSize * isingSize);
            energy = e / (isingSize * isingSize);
        }
        
        function stepWalk() {
            const stepSize = 5;
            
            for (let w of walkers) {
                for (let i = 0; i < sampleRate / 10; i++) {
                    const angle = random(TWO_PI);
                    w.x += cos(angle) * stepSize;
                    w.y += sin(angle) * stepSize;
                    
                    // Reflect at boundaries
                    if (w.x < 0) w.x = -w.x;
                    if (w.x > canvasWidth) w.x = 2 * canvasWidth - w.x;
                    if (w.y < 0) w.y = -w.y;
                    if (w.y > canvasHeight) w.y = 2 * canvasHeight - w.y;
                }
            }
            
            walkSteps += sampleRate / 10;
            
            // Compute mean squared displacement
            let totalSqDist = 0;
            for (let w of walkers) {
                const dx = w.x - w.startX;
                const dy = w.y - w.startY;
                totalSqDist += dx*dx + dy*dy;
            }
            msd = totalSqDist / walkers.length;
        }
        
        function stepBuffon() {
            for (let i = 0; i < sampleRate / 5; i++) {
                const cx = random(50, canvasWidth - 50);
                const cy = random(50, canvasHeight - 50);
                const angle = random(PI);
                
                const x1 = cx - cos(angle) * needleLength / 2;
                const x2 = cx + cos(angle) * needleLength / 2;
                const y1 = cy - sin(angle) * needleLength / 2;
                const y2 = cy + sin(angle) * needleLength / 2;
                
                // Check if needle crosses a line
                const line1 = floor(y1 / lineSpacing);
                const line2 = floor(y2 / lineSpacing);
                const crosses = line1 !== line2;
                
                if (crosses) needleCrossings++;
                needleTotal++;
                
                if (needles.length < 500) {
                    needles.push({ x1, y1, x2, y2, crosses });
                }
            }
        }
        
        function checkPercolation() {
            // Simple flood fill from top row
            const visited = Array(percSize).fill().map(() => Array(percSize).fill(false));
            const queue = [];
            
            // Start from all filled cells in top row
            for (let i = 0; i < percSize; i++) {
                if (percGrid[i][0] === 1) {
                    queue.push([i, 0]);
                    visited[i][0] = true;
                }
            }
            
            percolates = false;
            let clusterSize = 0;
            
            while (queue.length > 0) {
                const [x, y] = queue.shift();
                clusterSize++;
                
                if (y === percSize - 1) {
                    percolates = true;
                }
                
                // Check neighbors
                const neighbors = [[x-1,y], [x+1,y], [x,y-1], [x,y+1]];
                for (const [nx, ny] of neighbors) {
                    if (nx >= 0 && nx < percSize && ny >= 0 && ny < percSize) {
                        if (percGrid[nx][ny] === 1 && !visited[nx][ny]) {
                            visited[nx][ny] = true;
                            queue.push([nx, ny]);
                        }
                    }
                }
            }
        }
        
        function draw() {
            if (!paused) {
                switch(simulationType) {
                    case 'pi': stepPi(); break;
                    case 'integral': stepIntegral(); break;
                    case 'ising': stepIsing(); break;
                    case 'walk': stepWalk(); break;
                    case 'buffon': stepBuffon(); break;
                    case 'percolation': break; // Static
                }
                
                updateResults();
                updateConvergence();
            }
            
            render();
            
            if (frameCount % 10 === 0) {
                document.getElementById('fpsDisplay').textContent = floor(frameRate());
            }
        }
        
        function render() {
            switch(simulationType) {
                case 'pi': renderPi(); break;
                case 'integral': renderIntegral(); break;
                case 'ising': renderIsing(); break;
                case 'walk': renderWalk(); break;
                case 'buffon': renderBuffon(); break;
                case 'percolation': renderPercolation(); break;
            }
        }
        
        function renderPi() {
            background(20, 24, 40);
            
            // Draw square and circle
            noFill();
            stroke(100);
            strokeWeight(2);
            const margin = 50;
            const size = canvasWidth - margin * 2;
            rect(margin, margin, size, size);
            
            stroke(0, 212, 255, 150);
            ellipse(canvasWidth/2, canvasHeight/2, size, size);
            
            // Draw points
            noStroke();
            for (let p of piPoints) {
                const x = map(p.x, -1, 1, margin, canvasWidth - margin);
                const y = map(p.y, -1, 1, margin, canvasHeight - margin);
                
                if (p.inside) {
                    fill(0, 212, 255, 150);
                } else {
                    fill(255, 100, 150, 150);
                }
                ellipse(x, y, 4, 4);
            }
            
            // Labels
            fill(255);
            noStroke();
            textSize(14);
            textAlign(CENTER);
            text('Inside: Ï€/4 â‰ˆ ' + (piInside/piTotal || 0).toFixed(4), canvasWidth/2, 30);
        }
        
        function renderIntegral() {
            background(20, 24, 40);
            
            const margin = 50;
            const w = canvasWidth - margin * 2;
            const h = canvasHeight - margin * 2;
            
            // Draw axes
            stroke(100);
            strokeWeight(2);
            line(margin, margin, margin, canvasHeight - margin);
            line(margin, canvasHeight - margin, canvasWidth - margin, canvasHeight - margin);
            
            // Draw function curve
            stroke(0, 212, 255);
            strokeWeight(3);
            noFill();
            beginShape();
            for (let i = 0; i <= 100; i++) {
                const x = i / 100;
                const y = evaluateFunction(x);
                const px = map(x, 0, 1, margin, canvasWidth - margin);
                const py = map(y, 0, 1, canvasHeight - margin, margin);
                vertex(px, py);
            }
            endShape();
            
            // Draw points
            noStroke();
            for (let p of integralPoints) {
                const px = map(p.x, 0, 1, margin, canvasWidth - margin);
                const py = map(p.y, 0, 1, canvasHeight - margin, margin);
                
                if (p.inside) {
                    fill(0, 212, 255, 120);
                } else {
                    fill(255, 100, 150, 80);
                }
                ellipse(px, py, 4, 4);
            }
            
            // Labels
            fill(255);
            textSize(14);
            textAlign(CENTER);
            text('âˆ«f(x)dx â‰ˆ ' + (integralInside/integralTotal || 0).toFixed(4), canvasWidth/2, 30);
        }
        
        function renderIsing() {
            background(20, 24, 40);
            
            const cellSize = canvasWidth / isingSize;
            
            noStroke();
            for (let i = 0; i < isingSize; i++) {
                for (let j = 0; j < isingSize; j++) {
                    if (isingGrid[i][j] === 1) {
                        fill(0, 212, 255);
                    } else {
                        fill(255, 100, 150);
                    }
                    rect(i * cellSize, j * cellSize, cellSize, cellSize);
                }
            }
            
            // Info overlay
            fill(0, 0, 0, 180);
            rect(10, 10, 180, 60, 8);
            fill(255);
            textSize(12);
            textAlign(LEFT);
            text(`Magnetization: ${magnetization.toFixed(3)}`, 20, 30);
            text(`Energy/spin: ${energy.toFixed(3)}`, 20, 50);
            text(`T/Tc: ${(temperature/2.269).toFixed(2)}`, 20, 70);
        }
        
        function renderWalk() {
            // Fade effect
            fill(20, 24, 40, 30);
            rect(0, 0, canvasWidth, canvasHeight);
            
            // Draw walkers
            noStroke();
            for (let w of walkers) {
                colorMode(HSB);
                fill(w.hue, 80, 100, 0.8);
                ellipse(w.x, w.y, 8, 8);
            }
            colorMode(RGB);
            
            // Info
            fill(0, 0, 0, 180);
            rect(10, 10, 200, 50, 8);
            fill(255);
            textSize(12);
            textAlign(LEFT);
            text(`Steps: ${floor(walkSteps)}`, 20, 30);
            text(`MSD: ${msd.toFixed(1)} (D â‰ˆ ${(msd/(4*walkSteps) || 0).toFixed(2)})`, 20, 50);
        }
        
        function renderBuffon() {
            background(20, 24, 40);
            
            // Draw parallel lines
            stroke(80);
            strokeWeight(1);
            for (let y = lineSpacing; y < canvasHeight; y += lineSpacing) {
                line(0, y, canvasWidth, y);
            }
            
            // Draw needles
            strokeWeight(2);
            for (let n of needles) {
                if (n.crosses) {
                    stroke(0, 212, 255);
                } else {
                    stroke(255, 100, 150, 150);
                }
                line(n.x1, n.y1, n.x2, n.y2);
            }
            
            // Info
            fill(0, 0, 0, 180);
            noStroke();
            rect(10, 10, 200, 50, 8);
            fill(255);
            textSize(12);
            textAlign(LEFT);
            const piEst = needleCrossings > 0 ? (2 * needleLength * needleTotal) / (lineSpacing * needleCrossings) : 0;
            text(`Crossings: ${needleCrossings}/${needleTotal}`, 20, 30);
            text(`Ï€ estimate: ${piEst.toFixed(5)}`, 20, 50);
        }
        
        function renderPercolation() {
            background(20, 24, 40);
            
            const cellSize = canvasWidth / percSize;
            
            noStroke();
            for (let i = 0; i < percSize; i++) {
                for (let j = 0; j < percSize; j++) {
                    if (percGrid[i][j] === 1) {
                        fill(0, 212, 255);
                    } else {
                        fill(40, 44, 60);
                    }
                    rect(i * cellSize, j * cellSize, cellSize, cellSize);
                }
            }
            
            // Info overlay
            fill(0, 0, 0, 180);
            rect(10, 10, 200, 50, 8);
            fill(255);
            textSize(12);
            textAlign(LEFT);
            text(`p = ${percProbability.toFixed(3)} (pc â‰ˆ 0.593)`, 20, 30);
            fill(percolates ? color(0, 255, 150) : color(255, 100, 100));
            text(percolates ? 'âœ“ PERCOLATES' : 'âœ— Does not percolate', 20, 50);
        }
        
        function updateResults() {
            let estimate, trueVal, error;
            let sampleCount;
            
            switch(simulationType) {
                case 'pi':
                    estimate = 4 * piInside / piTotal || 0;
                    trueVal = PI;
                    sampleCount = piTotal;
                    document.getElementById('trueValue').textContent = 'Ï€ = 3.14159...';
                    break;
                    
                case 'integral':
                    estimate = integralInside / integralTotal || 0;
                    trueVal = getTrueIntegral();
                    sampleCount = integralTotal;
                    document.getElementById('trueValue').textContent = 'True = ' + trueVal.toFixed(5);
                    break;
                    
                case 'ising':
                    estimate = magnetization;
                    trueVal = temperature < 2.269 ? 1 : 0;
                    sampleCount = frameCount * sampleRate * 10;
                    document.getElementById('trueValue').textContent = 'Tc â‰ˆ 2.269';
                    document.getElementById('estimate').textContent = 'M = ' + estimate.toFixed(4);
                    document.getElementById('errorVal').textContent = 'E = ' + energy.toFixed(3);
                    document.getElementById('sampleCount').textContent = formatNumber(sampleCount);
                    document.getElementById('stdError').textContent = '--';
                    return;
                    
                case 'walk':
                    estimate = msd / (4 * walkSteps) || 0;
                    trueVal = 6.25; // stepSizeÂ²/4 = 25/4
                    sampleCount = floor(walkSteps) * numWalkers;
                    document.getElementById('trueValue').textContent = 'D â‰ˆ 6.25';
                    document.getElementById('estimate').textContent = 'D = ' + estimate.toFixed(3);
                    document.getElementById('errorVal').textContent = 'MSD = ' + msd.toFixed(1);
                    document.getElementById('sampleCount').textContent = formatNumber(sampleCount);
                    document.getElementById('stdError').textContent = '--';
                    return;
                    
                case 'buffon':
                    estimate = needleCrossings > 0 ? (2 * needleLength * needleTotal) / (lineSpacing * needleCrossings) : 0;
                    trueVal = PI;
                    sampleCount = needleTotal;
                    document.getElementById('trueValue').textContent = 'Ï€ = 3.14159...';
                    break;
                    
                case 'percolation':
                    estimate = percProbability;
                    trueVal = 0.5927;
                    sampleCount = percSize * percSize;
                    document.getElementById('trueValue').textContent = 'pc â‰ˆ 0.5927';
                    document.getElementById('estimate').textContent = percolates ? 'PERCOLATES' : 'No path';
                    document.getElementById('errorVal').textContent = 'p = ' + percProbability.toFixed(3);
                    document.getElementById('sampleCount').textContent = formatNumber(sampleCount);
                    document.getElementById('stdError').textContent = '--';
                    return;
            }
            
            error = abs(estimate - trueVal);
            const stdErr = sampleCount > 0 ? 1 / sqrt(sampleCount) : 0;
            
            document.getElementById('estimate').textContent = estimate.toFixed(6);
            document.getElementById('errorVal').textContent = error.toFixed(6);
            document.getElementById('stdError').textContent = 'Â±' + stdErr.toFixed(6);
            document.getElementById('sampleCount').textContent = formatNumber(sampleCount);
        }
        
        function updateConvergence() {
            let value;
            switch(simulationType) {
                case 'pi':
                    value = 4 * piInside / piTotal || 0;
                    break;
                case 'integral':
                    value = integralInside / integralTotal || 0;
                    break;
                case 'buffon':
                    value = needleCrossings > 0 ? (2 * needleLength * needleTotal) / (lineSpacing * needleCrossings) : 0;
                    break;
                case 'ising':
                    value = magnetization;
                    break;
                default:
                    value = 0;
            }
            
            if (frameCount % 5 === 0) {
                convergenceHistory.push(value);
                if (convergenceHistory.length > 200) {
                    convergenceHistory.shift();
                }
                drawConvergenceGraph();
            }
        }
        
        function drawConvergenceGraph() {
            const ctx = convergenceCanvas.getContext('2d');
            const w = convergenceCanvas.width;
            const h = convergenceCanvas.height;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, w, h);
            
            if (convergenceHistory.length < 2) return;
            
            // Find range
            let trueVal;
            switch(simulationType) {
                case 'pi': case 'buffon': trueVal = PI; break;
                case 'integral': trueVal = getTrueIntegral(); break;
                case 'ising': trueVal = 0.5; break;
                default: trueVal = 1;
            }
            
            const minVal = min(...convergenceHistory, trueVal) - 0.1;
            const maxVal = max(...convergenceHistory, trueVal) + 0.1;
            
            // Draw true value line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            const trueY = h - (trueVal - minVal) / (maxVal - minVal) * h;
            ctx.moveTo(0, trueY);
            ctx.lineTo(w, trueY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw convergence line
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < convergenceHistory.length; i++) {
                const x = (i / (convergenceHistory.length - 1)) * w;
                const y = h - (convergenceHistory[i] - minVal) / (maxVal - minVal) * h;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
        
        function formatNumber(n) {
            if (n >= 1000000) return (n/1000000).toFixed(1) + 'M';
            if (n >= 1000) return (n/1000).toFixed(1) + 'K';
            return n.toString();
        }
        
        function togglePause() {
            paused = !paused;
            document.querySelector('.btn-secondary').textContent = paused ? 'Resume' : 'Pause';
        }
        
        function burst() {
            const originalRate = sampleRate;
            sampleRate = 1000;
            
            switch(simulationType) {
                case 'pi': stepPi(); break;
                case 'integral': stepIntegral(); break;
                case 'ising': stepIsing(); break;
                case 'walk': stepWalk(); break;
                case 'buffon': stepBuffon(); break;
            }
            
            sampleRate = originalRate;
            updateResults();
        }
    </script>
</body>
</html>