<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolutionary Ecosystem Monte Carlo Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            height: 100vh;
        }
        #sidebar {
            width: 300px;
            background-color: #333;
            padding: 20px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        #canvas-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #111;
        }
        h1 { font-size: 1.2rem; margin-bottom: 10px; color: #4db6ac; }
        h2 { font-size: 1rem; margin-top: 20px; margin-bottom: 5px; border-bottom: 1px solid #555; }
        .control-group { margin-bottom: 10px; }
        label { display: flex; justify-content: space-between; font-size: 0.85rem; color: #bbb; }
        input[type=range] { width: 100%; margin-top: 5px; cursor: pointer; }
        .value-display { color: #fff; font-weight: bold; }
        .stats-box {
            background: #222;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.8rem;
            margin-top: 10px;
        }
        .stat-row { display: flex; justify-content: space-between; }
        .legend-dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; }
        button {
            margin-top: 20px;
            padding: 10px;
            background-color: #4db6ac;
            border: none;
            color: white;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
        }
        button:hover { background-color: #26a69a; }
    </style>
</head>
<body>

    <div id="sidebar">
        <h1>Eco-Evolution Sim</h1>
        
        <div class="stats-box">
            <div class="stat-row"><span style="color:#4caf50">Plants:</span> <span id="disp-plants">0</span></div>
            <div class="stat-row"><span style="color:#29b6f6">Herbivores:</span> <span id="disp-prey">0</span></div>
            <div class="stat-row"><span style="color:#ef5350">Predators:</span> <span id="disp-pred">0</span></div>
            <div class="stat-row" style="margin-top:5px; color:#aaa">Avg Speed Gene: <span id="disp-gene">0.0</span></div>
        </div>

        <h2>Parameters</h2>
        
        <div class="control-group">
            <label>Mutation Rate <span id="val-mut" class="value-display">0.1</span></label>
            <input type="range" id="sl-mut" min="0" max="0.5" step="0.01" value="0.1">
        </div>
        <div class="control-group">
            <label>Plant Growth Rate <span id="val-growth" class="value-display">0.2</span></label>
            <input type="range" id="sl-growth" min="0" max="1.0" step="0.01" value="0.2">
        </div>
        <div class="control-group">
            <label>Herbivore Reproduction <span id="val-hrep" class="value-display">0.6</span></label>
            <input type="range" id="sl-hrep" min="0.1" max="1.0" step="0.05" value="0.6">
        </div>
        <div class="control-group">
            <label>Predator Metabolism <span id="val-pmet" class="value-display">1.5</span></label>
            <input type="range" id="sl-pmet" min="0.5" max="3.0" step="0.1" value="1.5">
        </div>
        
        <button onclick="resetSimulation()">Reset Simulation</button>
        
        <div style="margin-top: auto; font-size: 0.75rem; color: #666;">
            <p><strong>Visuals:</strong><br>
            Prey brightness = Speed/Metabolism<br>
            Predator size = Strength<br>
            <br>
            Graph shows population over time.
            </p>
        </div>
    </div>

    <div id="canvas-container"></div>

<script>
// --- CONFIGURATION ---
const CELL_SIZE = 10;
const GRID_W = 80; // Will be recalculated based on screen
const GRID_H = 60;
const PLANT_ENERGY = 15;
const HERBIVORE_START_ENERGY = 40;
const PREDATOR_START_ENERGY = 60;
const HISTORY_LEN = 200; // Graph width

// --- STATE ---
let grid = []; // 2D Array storing contents: 0=Empty, 1=Plant, Object=Agent
let agents = []; // List of active agents for iteration
let statsHistory = [];
let cols, rows;
let cnv;

// UI Elements
let sliderMut, sliderGrowth, sliderHRep, sliderPMet;

function setup() {
    let container = document.getElementById('canvas-container');
    let w = container.clientWidth;
    let h = container.clientHeight;
    
    // Calculate grid size to fit, leaving room for graph at bottom
    cols = Math.floor((w - 20) / CELL_SIZE);
    rows = Math.floor((h - 120) / CELL_SIZE); 

    cnv = createCanvas(cols * CELL_SIZE, rows * CELL_SIZE + 100);
    cnv.parent('canvas-container');
    noSmooth();

    // Initialize UI refs
    sliderMut = select('#sl-mut');
    sliderGrowth = select('#sl-growth');
    sliderHRep = select('#sl-hrep');
    sliderPMet = select('#sl-pmet');

    // Update label listeners
    sliderMut.input(() => select('#val-mut').html(sliderMut.value()));
    sliderGrowth.input(() => select('#val-growth').html(sliderGrowth.value()));
    sliderHRep.input(() => select('#val-hrep').html(sliderHRep.value()));
    sliderPMet.input(() => select('#val-pmet').html(sliderPMet.value()));

    resetSimulation();
}

function resetSimulation() {
    grid = [];
    agents = [];
    statsHistory = [];
    
    // Init Grid
    for (let x = 0; x < cols; x++) {
        grid[x] = [];
        for (let y = 0; y < rows; y++) {
            grid[x][y] = null;
        }
    }

    // Spawn Initial Population
    // Plants
    for(let i=0; i<cols*rows*0.2; i++) spawnPlant();
    // Herbivores
    for(let i=0; i<100; i++) spawnAgent('herbivore');
    // Predators
    for(let i=0; i<20; i++) spawnAgent('predator');
}

// --- AGENT CLASS ---
class Agent {
    constructor(x, y, type, genes) {
        this.x = x;
        this.y = y;
        this.type = type; // 'herbivore' or 'predator'
        this.dead = false;
        this.age = 0;
        
        // Genes: { speed: 0.0-1.0, sense: 1-5 }
        // Speed correlates to metabolism cost
        if (genes) {
            this.genes = genes;
        } else {
            this.genes = {
                speed: random(0.3, 0.8),
                sense: floor(random(1, 3))
            };
        }
        
        this.energy = type === 'herbivore' ? HERBIVORE_START_ENERGY : PREDATOR_START_ENERGY;
    }

    update() {
        this.age++;
        
        // 1. Metabolism Cost
        // Faster speed = higher cost. Predators have base multiplier.
        let cost = this.genes.speed * 0.5; 
        if (this.type === 'predator') cost *= parseFloat(sliderPMet.value());
        this.energy -= cost;

        // 2. Check Death
        if (this.energy <= 0) {
            this.die();
            return;
        }

        // 3. Reproduction
        // Herbivores reproduce easier than predators
        let repThresh = this.type === 'herbivore' ? 
            HERBIVORE_START_ENERGY * (2 - parseFloat(sliderHRep.value())) : 
            PREDATOR_START_ENERGY * 2.0;
            
        if (this.energy > repThresh) {
            this.reproduce();
        }

        // 4. Action (Move/Eat)
        // Monte Carlo Step: Probability of acting depends on speed gene
        if (random() < this.genes.speed) {
            this.act();
        }
    }

    act() {
        // Simple AI: Look for food or empty space
        let bestMove = null;
        let neighbors = this.getNeighbors(this.genes.sense);
        
        if (this.type === 'herbivore') {
            // Prioritize: 1. Flee Predator (not implemented for speed), 2. Find Plant, 3. Random
            let plants = neighbors.filter(n => grid[n.x][n.y] === 'plant');
            if (plants.length > 0) {
                bestMove = random(plants); // Move to random available food
            } else {
                let empties = neighbors.filter(n => grid[n.x][n.y] === null);
                if (empties.length > 0) bestMove = random(empties);
            }
        } else if (this.type === 'predator') {
            // Prioritize: 1. Find Prey, 2. Random
            let prey = neighbors.filter(n => {
                let c = grid[n.x][n.y];
                return c && c instanceof Agent && c.type === 'herbivore';
            });
            if (prey.length > 0) {
                bestMove = random(prey);
            } else {
                let empties = neighbors.filter(n => grid[n.x][n.y] === null);
                if (empties.length > 0) bestMove = random(empties);
            }
        }

        if (bestMove) {
            this.moveTo(bestMove.x, bestMove.y);
        }
    }

    moveTo(tx, ty) {
        let targetContent = grid[tx][ty];

        // Interaction
        if (this.type === 'herbivore' && targetContent === 'plant') {
            this.energy += PLANT_ENERGY;
        } else if (this.type === 'predator' && targetContent instanceof Agent && targetContent.type === 'herbivore') {
            this.energy += targetContent.energy * 0.8; // Gain percent of prey energy
            targetContent.die();
        }

        // Update Grid
        grid[this.x][this.y] = null; // Clear old spot
        this.x = tx;
        this.y = ty;
        grid[this.x][this.y] = this; // Occupy new spot
    }

    reproduce() {
        let neighbors = this.getNeighbors(1);
        let empties = neighbors.filter(n => grid[n.x][n.y] === null);
        
        if (empties.length > 0) {
            let spot = random(empties);
            let mutRate = parseFloat(sliderMut.value());
            
            // Mutate Genes
            let newSpeed = constrain(this.genes.speed + random(-mutRate, mutRate), 0.1, 1.0);
            let newSense = this.genes.sense;
            if (random() < mutRate) newSense = constrain(newSense + floor(random(-1, 2)), 1, 5);

            let child = new Agent(spot.x, spot.y, this.type, { speed: newSpeed, sense: newSense });
            
            // Energy Transfer
            this.energy /= 2;
            child.energy = this.energy;
            
            agents.push(child);
            grid[spot.x][spot.y] = child;
        }
    }

    die() {
        this.dead = true;
        if (grid[this.x][this.y] === this) {
            grid[this.x][this.y] = null; // Become organic matter (empty)
        }
    }

    getNeighbors(range) {
        let found = [];
        for (let dx = -range; dx <= range; dx++) {
            for (let dy = -range; dy <= range; dy++) {
                if (dx === 0 && dy === 0) continue;
                let nx = (this.x + dx + cols) % cols; // Wrap world
                let ny = (this.y + dy + rows) % rows;
                found.push({x: nx, y: ny});
            }
        }
        return found;
    }

    draw() {
        let cx = this.x * CELL_SIZE;
        let cy = this.y * CELL_SIZE;
        
        noStroke();
        if (this.type === 'herbivore') {
            // Visualizing Trait: Brightness = Speed
            let b = map(this.genes.speed, 0.1, 1.0, 100, 255);
            fill(50, b, 255); 
            rect(cx, cy, CELL_SIZE, CELL_SIZE);
        } else {
            // Predator
            fill(255, 80, 80);
            // Visualizing Trait: Size based on energy/strength
            let s = map(this.energy, 0, 200, CELL_SIZE*0.6, CELL_SIZE);
            s = constrain(s, 2, CELL_SIZE);
            let offset = (CELL_SIZE - s)/2;
            rect(cx+offset, cy+offset, s, s);
        }
    }
}

// --- SIMULATION LOGIC ---

function spawnPlant() {
    let x = floor(random(cols));
    let y = floor(random(rows));
    if (grid[x][y] === null) {
        grid[x][y] = 'plant';
    }
}

function spawnAgent(type) {
    let placed = false;
    let attempts = 0;
    while(!placed && attempts < 100) {
        let x = floor(random(cols));
        let y = floor(random(rows));
        if (grid[x][y] === null) {
            let a = new Agent(x, y, type);
            agents.push(a);
            grid[x][y] = a;
            placed = true;
        }
        attempts++;
    }
}

function draw() {
    background(20);

    // 1. Grow Plants
    let growthRate = parseFloat(sliderGrowth.value());
    let growthSteps = (cols * rows) * 0.01 * growthRate; // 1% of grid capacity * rate per frame
    for(let i=0; i<growthSteps; i++) spawnPlant();

    // 2. Update Agents
    // Shuffle to prevent movement bias
    agents.sort(() => Math.random() - 0.5);
    
    for (let i = agents.length - 1; i >= 0; i--) {
        let a = agents[i];
        a.update();
        if (a.dead) {
            agents.splice(i, 1);
        }
    }

    // 3. Draw Grid
    for (let x = 0; x < cols; x++) {
        for (let y = 0; y < rows; y++) {
            let content = grid[x][y];
            if (content === 'plant') {
                fill(76, 175, 80);
                noStroke();
                // Small dot for plant
                rect(x * CELL_SIZE + 2, y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
            } else if (content instanceof Agent) {
                content.draw();
            }
        }
    }

    // 4. Update Stats & Graph
    updateStats();
    drawGraph();
}

function updateStats() {
    let counts = { plant: 0, herb: 0, pred: 0, speedSum: 0 };
    
    // Count plants from grid (since they aren't in a list)
    // To optimize, we could approximate or maintain a counter, 
    // but looping grid for render anyway, let's count there? 
    // Actually, render loop logic is separate. Let's just do a quick estimation or separate count.
    // For accuracy, let's count properly.
    for(let x=0; x<cols; x++) {
        for(let y=0; y<rows; y++) {
            if (grid[x][y] === 'plant') counts.plant++;
        }
    }

    for(let a of agents) {
        if(a.type === 'herbivore') {
            counts.herb++;
            counts.speedSum += a.genes.speed;
        }
        else counts.pred++;
    }

    let avgSpeed = counts.herb > 0 ? (counts.speedSum / counts.herb).toFixed(2) : "0.00";

    // Update DOM
    if (frameCount % 10 === 0) {
        select('#disp-plants').html(counts.plant);
        select('#disp-prey').html(counts.herb);
        select('#disp-pred').html(counts.pred);
        select('#disp-gene').html(avgSpeed);
        
        // Push to history
        statsHistory.push(counts);
        if (statsHistory.length > width / 2) statsHistory.shift(); // Keep history within screen width
    }
}

function drawGraph() {
    // Draw area at bottom
    let graphH = 100;
    let graphY = height - graphH;
    
    fill(30);
    rect(0, graphY, width, graphH);
    
    if (statsHistory.length < 2) return;

    // Find max for scaling
    let maxPop = 1;
    for (let s of statsHistory) {
        maxPop = max(maxPop, s.plant, s.herb, s.pred);
    }

    noFill();
    strokeWeight(2);

    // Helper to map and draw lines
    function drawLine(prop, r, g, b) {
        stroke(r, g, b);
        beginShape();
        for (let i = 0; i < statsHistory.length; i++) {
            let x = map(i, 0, statsHistory.length - 1, 0, width);
            let val = statsHistory[i][prop];
            let y = map(val, 0, maxPop, graphY + graphH - 5, graphY + 5);
            vertex(x, y);
        }
        endShape();
    }

    drawLine('plant', 76, 175, 80);
    drawLine('herb', 41, 182, 246);
    drawLine('pred', 239, 83, 80);
    
    // Border
    stroke(100);
    strokeWeight(1);
    line(0, graphY, width, graphY);
}

</script>
</body>
</html>