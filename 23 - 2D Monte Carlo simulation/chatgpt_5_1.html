<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2D Monte Carlo Ecosystem - p5.js</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
    }
    body {
      display: flex;
      flex-direction: row;
    }
    #canvas-container {
      flex: 3;
      position: relative;
      background: #000;
    }
    #side-panel {
      flex: 1;
      max-width: 320px;
      background: #1b1b1b;
      padding: 12px 14px;
      box-sizing: border-box;
      overflow-y: auto;
      border-left: 1px solid #333;
    }
    h2 {
      margin: 4px 0 6px 0;
      font-size: 18px;
      color: #46d1ff;
    }
    .small {
      font-size: 11px;
      color: #aaa;
      margin-bottom: 8px;
    }
    .stats {
      font-size: 12px;
      background: rgba(255,255,255,0.03);
      border-radius: 4px;
      padding: 6px 8px;
      margin-bottom: 10px;
    }
    .stats div {
      display: flex;
      justify-content: space-between;
      margin-bottom: 2px;
    }
    .control-group {
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid #333;
    }
    .control-group:last-child {
      border-bottom: none;
    }
    label {
      font-size: 12px;
      display: flex;
      justify-content: space-between;
      margin-top: 4px;
      margin-bottom: 2px;
    }
    input[type=range] {
      width: 100%;
    }
    button {
      width: 100%;
      padding: 6px 8px;
      margin-top: 6px;
      border: none;
      border-radius: 4px;
      background: #46d1ff;
      color: #000;
      font-weight: 600;
      cursor: pointer;
      font-size: 13px;
    }
    button:hover {
      filter: brightness(1.1);
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div id="side-panel">
    <h2>Monte Carlo Ecosystem</h2>
    <div class="small">
      Space: pause/resume Â· R: reset<br>
      Traits evolve via mutation and selection.
    </div>

    <div class="stats">
      <div><span>Time step</span><span id="timeLabel">0</span></div>
      <div><span>Herbivores</span><span id="popHerbLabel">0</span></div>
      <div><span>Predators</span><span id="popPredLabel">0</span></div>
      <div><span>Avg plants / cell</span><span id="plantAvgLabel">0</span></div>
    </div>

    <div class="stats">
      <div><strong>Average traits</strong></div>
      <div><span>Herb speed</span><span id="avgHerbSpeedLabel">0</span></div>
      <div><span>Herb vision</span><span id="avgHerbVisionLabel">0</span></div>
      <div><span>Pred speed</span><span id="avgPredSpeedLabel">0</span></div>
      <div><span>Pred vision</span><span id="avgPredVisionLabel">0</span></div>
    </div>

    <div class="control-group">
      <strong style="font-size:13px;">Evolution parameters</strong>
      <label>Mutation rate
        <span id="valMutation">0.03</span>
      </label>
      <input type="range" id="sliderMutation" min="0" max="0.2" step="0.005" value="0.03">

      <label>Simulation speed (steps/frame)
        <span id="valSimSpeed">1</span>
      </label>
      <input type="range" id="sliderSimSpeed" min="1" max="10" step="1" value="1">
    </div>

    <div class="control-group">
      <strong style="font-size:13px;">Resources & carrying capacity</strong>
      <label>Plant carrying capacity
        <span id="valCap">2.0</span>
      </label>
      <input type="range" id="sliderCap" min="0.5" max="5" step="0.1" value="2">

      <label>Plant growth rate
        <span id="valGrowth">0.03</span>
      </label>
      <input type="range" id="sliderGrowth" min="0" max="0.1" step="0.005" value="0.03">
    </div>

    <div class="control-group">
      <strong style="font-size:13px;">Initial populations</strong>
      <label>Initial herbivores
        <span id="valHerbInit">120</span>
      </label>
      <input type="range" id="sliderHerbInit" min="20" max="400" step="20" value="120">

      <label>Initial predators
        <span id="valPredInit">40</span>
      </label>
      <input type="range" id="sliderPredInit" min="0" max="200" step="10" value="40">
    </div>

    <div class="control-group">
      <strong style="font-size:13px;">Interaction strengths</strong>
      <label>Herbivore plant gain
        <span id="valHerbEff">1.5</span>
      </label>
      <input type="range" id="sliderHerbEff" min="0.5" max="3" step="0.1" value="1.5">

      <label>Predator prey gain
        <span id="valPredGain">12</span>
      </label>
      <input type="range" id="sliderPredGain" min="3" max="25" step="1" value="12">
    </div>

    <button id="btnReset">Reset simulation</button>
  </div>

  <script>
    // ------------- Global configuration -------------
    const gridW = 80;
    const gridH = 60;
    const MAX_HERB = 800;
    const MAX_PRED = 400;
    const HISTORY_MAX = 300;

    // Trait bounds
    const HERB_SPEED_MIN = 0.3;
    const HERB_SPEED_MAX = 2.0;
    const HERB_VISION_MIN = 1;
    const HERB_VISION_MAX = 6;
    const HERB_REPRO_MIN = 0.01;
    const HERB_REPRO_MAX = 0.3;

    const PRED_SPEED_MIN = 0.4;
    const PRED_SPEED_MAX = 2.5;
    const PRED_VISION_MIN = 1;
    const PRED_VISION_MAX = 8;
    const PRED_REPRO_MIN = 0.01;
    const PRED_REPRO_MAX = 0.3;

    // World state
    let plants = [];       // float per cell
    let herbivores = [];   // array of Herbivore
    let predators = [];    // array of Predator

    let herbGrid;          // 2D array of arrays of Herbivore

    // Stats history
    let herbHistory = [];
    let predHistory = [];
    let plantHistory = [];

    // Averages for display
    let avgHerbSpeed = 0;
    let avgHerbVision = 0;
    let avgPredSpeed = 0;
    let avgPredVision = 0;

    let timeStep = 0;
    let paused = false;

    // Parameters (controlled by sliders)
    let mutationRate = 0.03;
    let plantCapacity = 2.0;
    let plantGrowthRate = 0.03;
    let herbEnergyGain = 1.5;
    let predEnergyGain = 12;

    let simStepsPerFrame = 1;
    let initialHerbCount = 120;
    let initialPredCount = 40;

    // DOM elements
    const sliderMutation   = document.getElementById('sliderMutation');
    const sliderCap        = document.getElementById('sliderCap');
    const sliderGrowth     = document.getElementById('sliderGrowth');
    const sliderHerbInit   = document.getElementById('sliderHerbInit');
    const sliderPredInit   = document.getElementById('sliderPredInit');
    const sliderHerbEff    = document.getElementById('sliderHerbEff');
    const sliderPredGain   = document.getElementById('sliderPredGain');
    const sliderSimSpeed   = document.getElementById('sliderSimSpeed');
    const btnReset         = document.getElementById('btnReset');

    // Labels
    const valMutation      = document.getElementById('valMutation');
    const valCap           = document.getElementById('valCap');
    const valGrowth        = document.getElementById('valGrowth');
    const valHerbInit      = document.getElementById('valHerbInit');
    const valPredInit      = document.getElementById('valPredInit');
    const valHerbEff       = document.getElementById('valHerbEff');
    const valPredGain      = document.getElementById('valPredGain');
    const valSimSpeed      = document.getElementById('valSimSpeed');

    const timeLabel        = document.getElementById('timeLabel');
    const popHerbLabel     = document.getElementById('popHerbLabel');
    const popPredLabel     = document.getElementById('popPredLabel');
    const plantAvgLabel    = document.getElementById('plantAvgLabel');
    const avgHerbSpeedLabel   = document.getElementById('avgHerbSpeedLabel');
    const avgHerbVisionLabel  = document.getElementById('avgHerbVisionLabel');
    const avgPredSpeedLabel   = document.getElementById('avgPredSpeedLabel');
    const avgPredVisionLabel  = document.getElementById('avgPredVisionLabel');

    // ------------- Agent classes -------------

    class Herbivore {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.energy = 10;
        this.speed = random(HERB_SPEED_MIN, HERB_SPEED_MAX);
        this.vision = random(HERB_VISION_MIN, HERB_VISION_MAX);
        this.reproRate = random(HERB_REPRO_MIN, HERB_REPRO_MAX);
        this.alive = true;
      }
    }

    class Predator {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.energy = 12;
        this.speed = random(PRED_SPEED_MIN, PRED_SPEED_MAX);
        this.vision = random(PRED_VISION_MIN, PRED_VISION_MAX);
        this.reproRate = random(PRED_REPRO_MIN, PRED_REPRO_MAX);
        this.alive = true;
      }
    }

    // ------------- Parameter + UI wiring -------------

    function readParameters() {
      mutationRate   = parseFloat(sliderMutation.value);
      plantCapacity  = parseFloat(sliderCap.value);
      plantGrowthRate= parseFloat(sliderGrowth.value);
      herbEnergyGain = parseFloat(sliderHerbEff.value);
      predEnergyGain = parseFloat(sliderPredGain.value);
      simStepsPerFrame = parseInt(sliderSimSpeed.value, 10);
      initialHerbCount = parseInt(sliderHerbInit.value, 10);
      initialPredCount = parseInt(sliderPredInit.value, 10);

      valMutation.textContent  = mutationRate.toFixed(3);
      valCap.textContent       = plantCapacity.toFixed(1);
      valGrowth.textContent    = plantGrowthRate.toFixed(3);
      valHerbInit.textContent  = initialHerbCount;
      valPredInit.textContent  = initialPredCount;
      valHerbEff.textContent   = herbEnergyGain.toFixed(1);
      valPredGain.textContent  = predEnergyGain.toFixed(1);
      valSimSpeed.textContent  = simStepsPerFrame;
    }

    sliderMutation.addEventListener('input', readParameters);
    sliderCap.addEventListener('input', readParameters);
    sliderGrowth.addEventListener('input', readParameters);
    sliderHerbInit.addEventListener('input', readParameters);
    sliderPredInit.addEventListener('input', readParameters);
    sliderHerbEff.addEventListener('input', readParameters);
    sliderPredGain.addEventListener('input', readParameters);
    sliderSimSpeed.addEventListener('input', readParameters);
    btnReset.addEventListener('click', () => {
      resetSimulation();
    });

    // ------------- Utility -------------

    function plantIndex(x, y) {
      return x + y * gridW;
    }

    function mutateTrait(value, minVal, maxVal) {
      const factor = 1 + randomGaussian(0, mutationRate);
      let out = value * factor;
      return constrain(out, minVal, maxVal);
    }

    function spawnHerbChild(parent) {
      const child = new Herbivore(parent.x, parent.y);
      child.speed = mutateTrait(parent.speed, HERB_SPEED_MIN, HERB_SPEED_MAX);
      child.vision = mutateTrait(parent.vision, HERB_VISION_MIN, HERB_VISION_MAX);
      child.reproRate = mutateTrait(parent.reproRate, HERB_REPRO_MIN, HERB_REPRO_MAX);
      child.energy = parent.energy * 0.5;
      return child;
    }

    function spawnPredChild(parent) {
      const child = new Predator(parent.x, parent.y);
      child.speed = mutateTrait(parent.speed, PRED_SPEED_MIN, PRED_SPEED_MAX);
      child.vision = mutateTrait(parent.vision, PRED_VISION_MIN, PRED_VISION_MAX);
      child.reproRate = mutateTrait(parent.reproRate, PRED_REPRO_MIN, PRED_REPRO_MAX);
      child.energy = parent.energy * 0.5;
      return child;
    }

    function buildHerbGrid() {
      herbGrid = Array.from({ length: gridW }, () =>
        Array.from({ length: gridH }, () => [])
      );
      for (let h of herbivores) {
        if (!h.alive) continue;
        herbGrid[h.x][h.y].push(h);
      }
    }

    // ------------- Simulation init -------------

    function resetSimulation() {
      readParameters();
      timeStep = 0;
      herbivores = [];
      predators = [];
      plants = new Array(gridW * gridH);

      // Initialize plants with random values below capacity
      for (let i = 0; i < plants.length; i++) {
        plants[i] = random(0, plantCapacity * 0.7);
      }

      // Spawn herbivores
      for (let i = 0; i < initialHerbCount; i++) {
        const x = floor(random(gridW));
        const y = floor(random(gridH));
        herbivores.push(new Herbivore(x, y));
      }

      // Spawn predators
      for (let i = 0; i < initialPredCount; i++) {
        const x = floor(random(gridW));
        const y = floor(random(gridH));
        predators.push(new Predator(x, y));
      }

      herbHistory = [];
      predHistory = [];
      plantHistory = [];

      recordStats(); // initial
    }

    // ------------- Simulation step -------------

    function stepSimulation() {
      // Plant regrowth with simple logistic rule
      for (let i = 0; i < plants.length; i++) {
        let p = plants[i];
        if (p < plantCapacity && plantGrowthRate > 0) {
          let growth = plantGrowthRate * (1 - p / plantCapacity);
          if (growth < 0) growth = 0;
          p += growth;
          if (p > plantCapacity) p = plantCapacity;
          plants[i] = p;
        }
      }

      // Update herbivores
      shuffle(herbivores, true);
      let newHerbs = [];
      const herbReproEnergy = 14;

      for (let h of herbivores) {
        if (!h.alive) continue;

        // Metabolic cost
        const moveCost = 0.02 + 0.01 * h.speed + 0.005 * h.vision;
        h.energy -= moveCost;
        if (h.energy <= 0) {
          h.alive = false;
          continue;
        }

        // Movement driven by local plant gradient (within vision range)
        const stepProb = map(h.speed, HERB_SPEED_MIN, HERB_SPEED_MAX, 0.3, 1.0, true);
        if (random() < stepProb) {
          let bestX = h.x;
          let bestY = h.y;
          let bestPlant = plants[plantIndex(h.x, h.y)];
          const vRange = floor(h.vision);

          for (let dy = -vRange; dy <= vRange; dy++) {
            const ny = h.y + dy;
            if (ny < 0 || ny >= gridH) continue;
            for (let dx = -vRange; dx <= vRange; dx++) {
              const nx = h.x + dx;
              if (nx < 0 || nx >= gridW) continue;
              const idx = plantIndex(nx, ny);
              const val = plants[idx];
              if (val > bestPlant + 0.01) {
                bestPlant = val;
                bestX = nx;
                bestY = ny;
              }
            }
          }

          let dirX = Math.sign(bestX - h.x);
          let dirY = Math.sign(bestY - h.y);
          if (dirX === 0 && dirY === 0) {
            dirX = floor(random(-1, 2));
            dirY = floor(random(-1, 2));
          }

          const nx = constrain(h.x + dirX, 0, gridW - 1);
          const ny = constrain(h.y + dirY, 0, gridH - 1);
          h.x = nx;
          h.y = ny;
        }

        // Feeding from plants
        const pIdx = plantIndex(h.x, h.y);
        let avail = plants[pIdx];
        if (avail > 0) {
          const bite = min(avail, 0.4);
          plants[pIdx] -= bite;
          h.energy += bite * herbEnergyGain;
          if (plants[pIdx] < 0) plants[pIdx] = 0;
        }

        // Reproduction (energy + stochastic)
        if (h.energy > herbReproEnergy && herbivores.length + newHerbs.length < MAX_HERB) {
          if (random() < h.reproRate) {
            const child = spawnHerbChild(h);
            newHerbs.push(child);
            h.energy *= 0.5; // share energy with child
          }
        }

        // Random death (aging / accidents)
        if (random() < 0.0005) {
          h.alive = false;
        }
      }

      herbivores = herbivores.filter(h => h.alive);
      herbivores.push(...newHerbs);

      // Occupancy grid for predators to find prey
      buildHerbGrid();

      // Update predators
      shuffle(predators, true);
      let newPreds = [];
      const predReproEnergy = 20;

      for (let p of predators) {
        if (!p.alive) continue;

        const moveCost = 0.03 + 0.015 * p.speed + 0.008 * p.vision;
        p.energy -= moveCost;
        if (p.energy <= 0) {
          p.alive = false;
          continue;
        }

        // Movement: biased towards nearest herbivore within vision
        const stepProbP = map(p.speed, PRED_SPEED_MIN, PRED_SPEED_MAX, 0.3, 1.0, true);
        if (random() < stepProbP) {
          let bestHX = -1;
          let bestHY = -1;
          let bestDistSq = Infinity;
          const vRangeP = floor(p.vision);

          for (let dy = -vRangeP; dy <= vRangeP; dy++) {
            const ny = p.y + dy;
            if (ny < 0 || ny >= gridH) continue;
            for (let dx = -vRangeP; dx <= vRangeP; dx++) {
              const nx = p.x + dx;
              if (nx < 0 || nx >= gridW) continue;
              const list = herbGrid[nx][ny];
              if (list && list.length > 0) {
                const d2 = dx * dx + dy * dy;
                if (d2 < bestDistSq) {
                  bestDistSq = d2;
                  bestHX = nx;
                  bestHY = ny;
                }
              }
            }
          }

          let dirX, dirY;
          if (bestHX >= 0) {
            dirX = Math.sign(bestHX - p.x);
            dirY = Math.sign(bestHY - p.y);
          } else {
            dirX = floor(random(-1, 2));
            dirY = floor(random(-1, 2));
          }

          const nx = constrain(p.x + dirX, 0, gridW - 1);
          const ny = constrain(p.y + dirY, 0, gridH - 1);
          p.x = nx;
          p.y = ny;
        }

        // Feeding on herbivores in same cell
        const cellList = herbGrid[p.x][p.y];
        if (cellList && cellList.length > 0) {
          const idxH = floor(random(cellList.length));
          const prey = cellList[idxH];
          if (prey.alive) {
            prey.alive = false;
            p.energy += predEnergyGain;
          }
        }

        // Reproduction
        if (p.energy > predReproEnergy && predators.length + newPreds.length < MAX_PRED) {
          if (random() < p.reproRate) {
            const child = spawnPredChild(p);
            newPreds.push(child);
            p.energy *= 0.5;
          }
        }

        if (random() < 0.0005) {
          p.alive = false;
        }
      }

      predators = predators.filter(p => p.alive);
      predators.push(...newPreds);

      timeStep++;
      recordStats();
    }

    // ------------- Statistics -------------

    function recordStats() {
      // Populations
      const herbCount = herbivores.length;
      const predCount = predators.length;

      let totalPlant = 0;
      for (let i = 0; i < plants.length; i++) totalPlant += plants[i];
      const avgPlant = totalPlant / plants.length;

      herbHistory.push(herbCount);
      predHistory.push(predCount);
      plantHistory.push(avgPlant);

      if (herbHistory.length > HISTORY_MAX) {
        herbHistory.shift();
        predHistory.shift();
        plantHistory.shift();
      }

      // Average traits
      if (herbCount > 0) {
        let sSum = 0, vSum = 0;
        for (let h of herbivores) {
          sSum += h.speed;
          vSum += h.vision;
        }
        avgHerbSpeed = sSum / herbCount;
        avgHerbVision = vSum / herbCount;
      } else {
        avgHerbSpeed = 0;
        avgHerbVision = 0;
      }

      if (predCount > 0) {
        let sSum = 0, vSum = 0;
        for (let p of predators) {
          sSum += p.speed;
          vSum += p.vision;
        }
        avgPredSpeed = sSum / predCount;
        avgPredVision = vSum / predCount;
      } else {
        avgPredSpeed = 0;
        avgPredVision = 0;
      }

      // Update DOM stats
      timeLabel.textContent = timeStep;
      popHerbLabel.textContent = herbCount;
      popPredLabel.textContent = predCount;
      plantAvgLabel.textContent = avgPlant.toFixed(2);

      avgHerbSpeedLabel.textContent = avgHerbSpeed.toFixed(2);
      avgHerbVisionLabel.textContent = avgHerbVision.toFixed(2);
      avgPredSpeedLabel.textContent = avgPredSpeed.toFixed(2);
      avgPredVisionLabel.textContent = avgPredVision.toFixed(2);
    }

    // ------------- Drawing -------------

    function drawEnvironment() {
      const worldWidth = width - 220;
      const worldHeight = height;
      const cellSize = min(worldWidth / gridW, worldHeight / gridH);
      const offsetX = 0;
      const offsetY = (worldHeight - gridH * cellSize) / 2;

      // Draw plant field
      noStroke();
      const soil = color(60, 40, 30);
      const lush = color(20, 150, 40);

      for (let y = 0; y < gridH; y++) {
        for (let x = 0; x < gridW; x++) {
          const idx = plantIndex(x, y);
          const p = plants[idx];
          const level = constrain(p / plantCapacity, 0, 1);
          const c = lerpColor(soil, lush, level);
          fill(c);
          rect(offsetX + x * cellSize, offsetY + y * cellSize, cellSize, cellSize);
        }
      }

      // Draw herbivores (color by speed, size by vision)
      stroke(0);
      for (let h of herbivores) {
        const sx = offsetX + (h.x + 0.5) * cellSize;
        const sy = offsetY + (h.y + 0.5) * cellSize;

        const t = constrain((h.speed - HERB_SPEED_MIN) / (HERB_SPEED_MAX - HERB_SPEED_MIN), 0, 1);
        const slowCol = color(50, 120, 255);
        const fastCol = color(255, 255, 0);
        const c = lerpColor(slowCol, fastCol, t);
        fill(c);

        const r = cellSize * (0.25 + 0.15 * (h.vision / HERB_VISION_MAX));
        ellipse(sx, sy, r, r);
      }

      // Draw predators (red/orange, size by speed)
      for (let p of predators) {
        const sx = offsetX + (p.x + 0.5) * cellSize;
        const sy = offsetY + (p.y + 0.5) * cellSize;

        const t = constrain((p.speed - PRED_SPEED_MIN) / (PRED_SPEED_MAX - PRED_SPEED_MIN), 0, 1);
        const slowCol = color(200, 80, 80);
        const fastCol = color(255, 200, 80);
        const c = lerpColor(slowCol, fastCol, t);
        fill(c);

        const r = cellSize * (0.3 + 0.2 * t);
        ellipse(sx, sy, r, r);
      }
    }

    function drawGraphs() {
      const statsX = width - 210;
      const statsY = 10;
      const statsW = 200;
      const statsH = height - 20;

      // Background
      noStroke();
      fill(0, 180);
      rect(statsX, statsY, statsW, statsH);

      const n = herbHistory.length;
      if (n < 2) return;

      // Axes
      stroke(80);
      strokeWeight(1);
      line(statsX + 10, statsY + statsH - 15, statsX + statsW - 10, statsY + statsH - 15); // x
      line(statsX + 10, statsY + statsH - 15, statsX + 10, statsY + 20); // y

      // Determine ranges
      const maxHerb = max(1, ...herbHistory);
      const maxPred = max(1, ...predHistory);
      const maxPlant = max(0.1, ...plantHistory);

      const x0 = statsX + 10;
      const x1 = statsX + statsW - 10;
      const y0 = statsY + statsH - 15;
      const y1 = statsY + 25;

      // Herbivores (green)
      noFill();
      stroke(50, 220, 50);
      strokeWeight(1.5);
      beginShape();
      for (let i = 0; i < n; i++) {
        const x = map(i, 0, n - 1, x0, x1);
        const y = map(herbHistory[i], 0, maxHerb, y0, y1);
        vertex(x, y);
      }
      endShape();

      // Predators (red)
      stroke(240, 80, 80);
      beginShape();
      for (let i = 0; i < n; i++) {
        const x = map(i, 0, n - 1, x0, x1);
        const y = map(predHistory[i], 0, maxPred, y0, y1);
        vertex(x, y);
      }
      endShape();

      // Plants (blue) - scaled to same vertical span using its own max
      stroke(80, 150, 255);
      beginShape();
      for (let i = 0; i < n; i++) {
        const x = map(i, 0, n - 1, x0, x1);
        const y = map(plantHistory[i], 0, maxPlant, y0, y1);
        vertex(x, y);
      }
      endShape();

      // Legend
      noStroke();
      textSize(11);
      fill(230);
      text("Populations (recent)", statsX + 30, statsY + 15);

      textSize(9);
      fill(50, 220, 50);
      text("Herbivores", statsX + 18, statsY + 32);
      fill(240, 80, 80);
      text("Predators", statsX + 18, statsY + 44);
      fill(80, 150, 255);
      text("Plants (avg)", statsX + 18, statsY + 56);
    }

    // ------------- p5.js setup/draw -------------

    function setup() {
      const container = document.getElementById('canvas-container');
      const cw = container.clientWidth;
      const ch = window.innerHeight;

      const cnv = createCanvas(cw, ch);
      cnv.parent('canvas-container');

      textFont('sans-serif');
      readParameters();
      resetSimulation();
    }

    function windowResized() {
      const container = document.getElementById('canvas-container');
      const cw = container.clientWidth;
      const ch = window.innerHeight;
      resizeCanvas(cw, ch);
    }

    function draw() {
      background(20);

      if (!paused) {
        for (let i = 0; i < simStepsPerFrame; i++) {
          stepSimulation();
        }
      }

      drawEnvironment();
      drawGraphs();
    }

    function keyPressed() {
      if (key === ' ' || key === 'Spacebar') {
        paused = !paused;
      } else if (key === 'r' || key === 'R') {
        resetSimulation();
      }
    }
  </script>
</body>
</html>