<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EcoSim: Evolutionary Monte Carlo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        :root {
            --bg: #121212;
            --panel: #1e1e1e;
            --text: #e0e0e0;
            --accent: #4caf50;
            --danger: #f44336;
            --warn: #ff9800;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #sidebar {
            width: 320px;
            background-color: var(--panel);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            border-right: 1px solid #333;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            z-index: 10;
        }

        #canvas-container {
            flex-grow: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            background-color: #000;
        }

        canvas {
            display: block;
        }

        #sim-canvas { flex-grow: 1; }
        #stats-canvas { height: 150px; width: 100%; border-top: 1px solid #333; background: #000; }

        h2 { margin: 0 0 5px 0; font-size: 1.2rem; color: var(--accent); }
        h3 { margin: 10px 0 5px 0; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 1px; color: #888; border-bottom: 1px solid #444; padding-bottom: 2px;}

        .control-group {
            margin-bottom: 10px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            margin-bottom: 4px;
        }
        
        input[type=range] { width: 100%; cursor: pointer; accent-color: var(--accent); }

        .val-display { font-family: monospace; color: var(--accent); }

        .stats-box {
            background: #111;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            line-height: 1.6;
            font-family: monospace;
        }
        .stat-row { display: flex; justify-content: space-between; }
        .c-plants { color: var(--accent); }
        .c-herb { color: #2196f3; }
        .c-pred { color: var(--danger); }

        button {
            width: 100%;
            padding: 10px;
            background: #333;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
        }
        button:hover { background: #444; }
        button.reset { background: var(--danger); margin-top: 10px; }

        .legend {
            display: flex;
            gap: 10px;
            font-size: 0.75rem;
            margin-bottom: 10px;
        }
        .dot { width: 10px; height: 10px; display: inline-block; border-radius: 50%; margin-right: 5px; }
    </style>
</head>
<body>

    <div id="sidebar">
        <h2>EcoSim Evolution</h2>
        
        <div class="legend">
            <div><span class="dot" style="background:var(--accent)"></span>Plant</div>
            <div><span class="dot" style="background:#2196f3"></span>Herb</div>
            <div><span class="dot" style="background:var(--danger)"></span>Pred</div>
        </div>

        <div class="stats-box">
            <div class="stat-row"><span>Plants:</span> <span id="stat-p" class="c-plants">0</span></div>
            <div class="stat-row"><span>Herbivores:</span> <span id="stat-h" class="c-herb">0</span></div>
            <div class="stat-row"><span>Predators:</span> <span id="stat-pr" class="c-pred">0</span></div>
            <div class="stat-row" style="margin-top:5px; color:#888;">Avg Herb Speed: <span id="stat-speed" style="color:#fff">0</span></div>
            <div class="stat-row" style="color:#888;">Avg Pred Vision: <span id="stat-vision" style="color:#fff">0</span></div>
        </div>

        <h3>Environment</h3>
        <div class="control-group">
            <label>Plant Growth Rate <span id="v-growth" class="val-display">5</span></label>
            <input type="range" id="sl-growth" min="0" max="20" value="5">
        </div>
        <div class="control-group">
            <label>Plant Energy <span id="v-plantE" class="val-display">15</span></label>
            <input type="range" id="sl-plantE" min="5" max="50" value="15">
        </div>

        <h3>Evolution</h3>
        <div class="control-group">
            <label>Mutation Rate <span id="v-mut" class="val-display">10%</span></label>
            <input type="range" id="sl-mut" min="0" max="50" value="10">
        </div>
        <div class="control-group">
            <label>Metabolism Cost <span id="v-metab" class="val-display">1.0</span></label>
            <input type="range" id="sl-metab" min="0.5" max="3.0" step="0.1" value="1.0">
        </div>

        <h3>Initial Settings</h3>
        <div class="control-group">
            <label>Init Herbivores <span id="v-initH" class="val-display">40</span></label>
            <input type="range" id="sl-initH" min="10" max="200" value="40">
        </div>
        <div class="control-group">
            <label>Init Predators <span id="v-initP" class="val-display">10</span></label>
            <input type="range" id="sl-initP" min="5" max="50" value="10">
        </div>

        <button class="reset" onclick="resetSimulation()">Reset Simulation</button>
    </div>

    <div id="canvas-container">
        <div id="sim-canvas"></div>
        <div id="stats-canvas"></div>
    </div>

<script>
    // --- CONFIGURATION ---
    const CONFIG = {
        w: 800, h: 600, // Will be resized by container
        gridSize: 20, // Spatial hashing cell size
    };

    // --- STATE ---
    let agents = [];
    let plants = [];
    let grid = [];
    let cols, rows;
    
    // Stats history
    let history = {
        plants: [],
        herbs: [],
        preds: [],
        maxLen: 200
    };

    // UI Parameters (linked to sliders)
    const PARAMS = {
        plantGrowth: 5,
        plantEnergy: 15,
        mutationRate: 0.1,
        metabolism: 1.0,
        initHerbs: 40,
        initPreds: 10
    };

    // --- P5.JS SETUP ---
    let simCanvas, statsCanvas;
    let simGraphics, statsGraphics;

    function setup() {
        // Initialize Canvases
        const simContainer = document.getElementById('sim-canvas');
        const statsContainer = document.getElementById('stats-canvas');
        
        CONFIG.w = simContainer.clientWidth;
        CONFIG.h = simContainer.clientHeight;
        
        simCanvas = createCanvas(CONFIG.w, CONFIG.h);
        simCanvas.parent('sim-canvas');
        
        // We need a separate graphics buffer for the stats graph or draw on a separate canvas.
        // p5 usually manages one main canvas. We'll handle the graph manually on a separate p5 instance or just draw it below.
        // For simplicity in this single-file setup, we will use a secondary off-screen graphics buffer for the graph 
        // and draw it as an image on the main canvas, OR just use the DOM canvas for stats.
        // Let's create a second p5 instance for stats to keep code clean.
        new p5(statsSketch, 'stats-canvas');

        // Setup Grid
        cols = ceil(width / CONFIG.gridSize);
        rows = ceil(height / CONFIG.gridSize);
        grid = new Array(cols * rows).fill().map(() => []);

        // Bind UI
        bindUI();

        resetSimulation();
    }

    function bindUI() {
        const bind = (id, paramKey, displayId, multiplier = 1, suffix = '') => {
            const el = document.getElementById(id);
            const disp = document.getElementById(displayId);
            el.addEventListener('input', (e) => {
                let val = parseFloat(e.target.value);
                if (id === 'sl-mut') val = val / 100; // Special case for percentage
                PARAMS[paramKey] = val;
                disp.innerText = val.toFixed(1) + suffix;
            });
        };

        bind('sl-growth', 'plantGrowth', 'v-growth');
        bind('sl-plantE', 'plantEnergy', 'v-plantE');
        bind('sl-mut', 'mutationRate', 'v-mut');
        bind('sl-metab', 'metabolism', 'v-metab');
        bind('sl-initH', 'initHerbs', 'v-initH');
        bind('sl-initP', 'initPreds', 'v-initP');
    }

    function resetSimulation() {
        agents = [];
        plants = [];
        
        // Initial Population
        for(let i=0; i<PARAMS.initHerbs; i++) {
            agents.push(new Herbivore(random(width), random(height)));
        }
        for(let i=0; i<PARAMS.initPreds; i++) {
            agents.push(new Predator(random(width), random(height)));
        }
        
        // Initial Plants
        for(let i=0; i<200; i++) {
            plants.push(createVector(random(width), random(height)));
        }

        // Reset Stats
        history.plants = [];
        history.herbs = [];
        history.preds = [];
    }

    function windowResized() {
        const simContainer = document.getElementById('sim-canvas');
        resizeCanvas(simContainer.clientWidth, simContainer.clientHeight);
        cols = ceil(width / CONFIG.gridSize);
        rows = ceil(height / CONFIG.gridSize);
        grid = new Array(cols * rows).fill().map(() => []);
    }

    // --- MAIN LOOP ---
    function draw() {
        background(20);

        // 1. Grow Plants (Monte Carlo: Randomly spawn N plants per frame based on rate)
        // We try to spawn `plantGrowth` plants
        let spawnAttempts = PARAMS.plantGrowth;
        for(let i=0; i<spawnAttempts; i++) {
            let px = random(width);
            let py = random(height);
            // Only spawn if not overcrowded locally? (Simple version: just spawn)
            plants.push(createVector(px, py));
        }
        
        // Limit plant count to prevent lag
        if (plants.length > 1500) plants.splice(0, plants.length - 1500);

        // 2. Spatial Hashing (Rebuild Grid)
        for(let cell of grid) cell.length = 0;
        
        // Add agents to grid
        for(let a of agents) {
            let gx = floor(a.pos.x / CONFIG.gridSize);
            let gy = floor(a.pos.y / CONFIG.gridSize);
            if (gx >= 0 && gx < cols && gy >= 0 && gy < rows) {
                grid[gx + gy * cols].push(a);
            }
        }

        // Add plants to grid (separate grid or same? Same is fine for checks)
        // Actually, let's just check plants via a separate spatial lookup or naive if count is low.
        // Naive plant check is O(Agents * Plants). If Agents=100, Plants=1000 -> 100k checks. Doable.
        // If optimization needed, we can plant-hash too. Let's stick to naive for plants to keep code simpler, 
        // but use grid for Agent-Agent collisions.

        // 3. Update Agents
        for (let i = agents.length - 1; i >= 0; i--) {
            let a = agents[i];
            a.update();
            a.show();
            
            if (a.dead) {
                agents.splice(i, 1);
            }
        }

        // 4. Draw Plants
        noStroke();
        fill(76, 175, 80); // Green
        for (let p of plants) {
            ellipse(p.x, p.y, 4, 4);
        }

        // 5. Update Stats (Every 5 frames to save CPU)
        if (frameCount % 5 === 0) {
            updateStats();
        }
    }

    function updateStats() {
        let hCount = 0;
        let pCount = 0;
        let avgSpeed = 0;
        let avgVision = 0;

        for(let a of agents) {
            if (a.type === 'herbivore') {
                hCount++;
                avgSpeed += a.dna.speed;
            } else if (a.type === 'predator') {
                pCount++;
                avgVision += a.dna.vision;
            }
        }

        if (hCount > 0) avgSpeed /= hCount;
        if (pCount > 0) avgVision /= pCount;

        // DOM Text
        document.getElementById('stat-p').innerText = plants.length;
        document.getElementById('stat-h').innerText = hCount;
        document.getElementById('stat-pr').innerText = pCount;
        document.getElementById('stat-speed').innerText = avgSpeed.toFixed(2);
        document.getElementById('stat-vision').innerText = avgVision.toFixed(1);

        // History Arrays
        history.plants.push(plants.length);
        history.herbs.push(hCount);
        history.preds.push(pCount);

        if (history.plants.length > history.maxLen) {
            history.plants.shift();
            history.herbs.shift();
            history.preds.shift();
        }
    }

    // --- STATS SKETCH (Second Canvas) ---
    function statsSketch(p) {
        p.setup = function() {
            let c = p.createCanvas(p.windowWidth, 150);
            c.parent('stats-canvas');
            p.frameRate(30);
        };

        p.draw = function() {
            p.background(20);
            p.noFill();
            p.strokeWeight(2);
            
            // Scaling
            let maxVal = Math.max(
                Math.max(...history.plants), 
                Math.max(...history.herbs), 
                Math.max(...history.preds), 
                100
            );
            
            let w = p.width / history.maxLen;
            let hScale = (p.height - 20) / maxVal;

            // Draw Plants (Green)
            p.stroke(76, 175, 80);
            p.beginShape();
            for(let i=0; i<history.plants.length; i++) {
                p.vertex(i * w, p.height - 10 - history.plants[i] * hScale);
            }
            p.endShape();

            // Draw Herbivores (Blue)
            p.stroke(33, 150, 243);
            p.beginShape();
            for(let i=0; i<history.herbs.length; i++) {
                p.vertex(i * w, p.height - 10 - history.herbs[i] * hScale);
            }
            p.endShape();

            // Draw Predators (Red)
            p.stroke(244, 67, 54);
            p.beginShape();
            for(let i=0; i<history.preds.length; i++) {
                p.vertex(i * w, p.height - 10 - history.preds[i] * hScale);
            }
            p.endShape();
        };

        p.windowResized = function() {
            p.resizeCanvas(p.windowWidth, 150);
        };
    }

    // --- AGENT CLASSES ---

    class Agent {
        constructor(x, y, type) {
            this.pos = createVector(x, y);
            this.vel = createVector(0, 0);
            this.acc = createVector(0, 0);
            this.type = type;
            this.energy = 100;
            this.age = 0;
            this.maxAge = 1000;
            this.dead = false;
            
            // DNA / Traits
            this.dna = {
                speed: 2,       // Max speed
                vision: 50,     // Detection radius
                reproThresh: 150, // Energy needed to reproduce
                size: 6
            };
        }

        mutate(dna) {
            let rate = PARAMS.mutationRate;
            if (random() < rate) dna.speed += random(-0.2, 0.2);
            if (random() < rate) dna.vision += random(-5, 5);
            if (random() < rate) dna.reproThresh += random(-10, 10);
            
            // Clamp
            dna.speed = constrain(dna.speed, 0.5, 5.0);
            dna.vision = constrain(dna.vision, 10, 150);
            dna.reproThresh = constrain(dna.reproThresh, 50, 300);
            
            return dna;
        }

        wrapEdges() {
            if (this.pos.x < 0) this.pos.x = width;
            if (this.pos.x > width) this.pos.x = 0;
            if (this.pos.y < 0) this.pos.y = height;
            if (this.pos.y > height) this.pos.y = 0;
        }

        checkDeath() {
            this.energy -= PARAMS.metabolism;
            this.age++;
            if (this.energy <= 0 || this.age > this.maxAge) {
                this.dead = true;
            }
        }
    }

    class Herbivore extends Agent {
        constructor(x, y, dna) {
            super(x, y, 'herbivore');
            if (dna) this.dna = dna;
            this.vel = p5.Vector.random2D().mult(this.dna.speed);
        }

        update() {
            // Behavior
            this.seekPlants();
            this.move();
            this.checkDeath();
            this.reproduce();
        }

        seekPlants() {
            // Naive search: Find closest plant
            let record = Infinity;
            let closest = null;
            
            // Optimization: Only check a subset of plants or use grid. 
            // For this demo, checking all plants is O(N*M). If it lags, reduce plant count.
            // Let's assume ~500 plants max.
            
            for (let p of plants) {
                let d = dist(this.pos.x, this.pos.y, p.x, p.y);
                if (d < this.dna.vision && d < record) {
                    record = d;
                    closest = p;
                }
            }

            if (closest) {
                let desired = p5.Vector.sub(closest, this.pos);
                desired.setMag(this.dna.speed);
                let steer = p5.Vector.sub(desired, this.vel);
                steer.limit(0.2); // Turning force
                this.acc.add(steer);
                
                // Eat
                if (record < this.dna.size) {
                    this.energy += PARAMS.plantEnergy;
                    // Remove plant
                    let idx = plants.indexOf(closest);
                    if (idx > -1) plants.splice(idx, 1);
                }
            } else {
                // Wander randomly
                if (random() < 0.05) {
                    this.vel = p5.Vector.random2D().mult(this.dna.speed);
                }
            }
        }

        move() {
            this.vel.add(this.acc);
            this.vel.limit(this.dna.speed);
            this.pos.add(this.vel);
            this.acc.mult(0);
            this.wrapEdges();
        }

        reproduce() {
            if (this.energy > this.dna.reproThresh) {
                this.energy /= 2;
                let childDNA = this.mutate({...this.dna}); // Copy DNA
                agents.push(new Herbivore(this.pos.x, this.pos.y, childDNA));
            }
        }

        show() {
            // Color based on Speed (Blue=Slow, Green=Fast)
            let hue = map(this.dna.speed, 0.5, 5.0, 200, 120); 
            colorMode(HSB);
            fill(hue, 200, 200);
            noStroke();
            ellipse(this.pos.x, this.pos.y, this.dna.size * 2);
            colorMode(RGB);
        }
    }

    class Predator extends Agent {
        constructor(x, y, dna) {
            super(x, y, 'predator');
            this.maxAge = 1500;
            this.dna.size = 8;
            if (dna) this.dna = dna;
            this.vel = p5.Vector.random2D().mult(this.dna.speed);
            this.dna.speed = 2.5; // Base speed
        }

        update() {
            this.seekHerbivores();
            this.move();
            this.checkDeath();
            this.reproduce();
        }

        seekHerbivores() {
            // Use Spatial Grid for efficiency
            let gx = floor(this.pos.x / CONFIG.gridSize);
            let gy = floor(this.pos.y / CONFIG.gridSize);
            
            let record = Infinity;
            let closest = null;

            // Check 3x3 grid cells around agent
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    let cx = gx + i;
                    let cy = gy + j;
                    if (cx >= 0 && cx < cols && cy >= 0 && cy < rows) {
                        let cellAgents = grid[cx + cy * cols];
                        for (let other of cellAgents) {
                            if (other.type === 'herbivore') {
                                let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);
                                if (d < this.dna.vision && d < record) {
                                    record = d;
                                    closest = other;
                                }
                            }
                        }
                    }
                }
            }

            if (closest) {
                let desired = p5.Vector.sub(closest.pos, this.pos);
                desired.setMag(this.dna.speed);
                let steer = p5.Vector.sub(desired, this.vel);
                steer.limit(0.5); // Predators turn sharper
                this.acc.add(steer);

                // Eat
                if (record < this.dna.size + closest.dna.size) {
                    this.energy += closest.energy * 0.8; // Gain 80% of prey energy
                    closest.dead = true;
                }
            } else {
                // Wander
                if (random() < 0.05) {
                    this.vel = p5.Vector.random2D().mult(this.dna.speed);
                }
            }
        }

        move() {
            this.vel.add(this.acc);
            this.vel.limit(this.dna.speed);
            this.pos.add(this.vel);
            this.acc.mult(0);
            this.wrapEdges();
        }

        reproduce() {
            if (this.energy > this.dna.reproThresh) {
                this.energy /= 2;
                let childDNA = this.mutate({...this.dna});
                agents.push(new Predator(this.pos.x, this.pos.y, childDNA));
            }
        }

        show() {
            // Color based on Vision (Red=Low, Pink=High)
            let hue = map(this.dna.vision, 10, 150, 0, 300); 
            colorMode(HSB);
            fill(hue, 200, 200);
            noStroke();
            // Draw triangle for predator
            push();
            translate(this.pos.x, this.pos.y);
            rotate(this.vel.heading());
            triangle(0, -this.dna.size, -this.dna.size/2, this.dna.size, this.dna.size/2, this.dna.size);
            pop();
            colorMode(RGB);
        }
    }

</script>
</body>
</html>