<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ecosystem Evolution Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0a1929, #0d1f33);
            color: #e0f7fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(25, 118, 210, 0.15);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 280px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1000;
        }
        
        #controls h3 {
            margin: 0 0 10px 0;
            color: #4fc3f7;
            font-size: 14px;
            border-bottom: 1px solid rgba(79, 195, 247, 0.3);
            padding-bottom: 8px;
        }
        
        .control-group {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        label {
            font-size: 11px;
            color: #bbdefb;
            flex: 1;
        }
        
        input[type="range"] {
            width: 80px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            height: 6px;
            border: none;
        }
        
        input[type="number"] {
            width: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e0f7fa;
            padding: 4px;
            border-radius: 4px;
            font-size: 11px;
        }
        
        button {
            background: linear-gradient(to right, #2196F3, #21CBF3);
            color: white;
            border: none;
            padding: 6px 12px;
            margin: 2px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        .value-display {
            color: #4fc3f7;
            font-weight: 600;
            font-size: 11px;
            min-width: 30px;
            text-align: right;
        }
        
        #stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(25, 118, 210, 0.15);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 11px;
            min-width: 200px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        #stats h3 {
            margin: 0 0 8px 0;
            color: #4fc3f7;
            font-size: 14px;
            border-bottom: 1px solid rgba(79, 195, 247, 0.3);
            padding-bottom: 8px;
        }
        
        .stat-line {
            margin: 4px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .stat-label {
            color: #bbdefb;
        }
        
        .stat-value {
            color: #4fc3f7;
            font-weight: 600;
        }
        
        #graph {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(25, 118, 210, 0.15);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(79, 195, 247, 0.8);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(79, 195, 247, 0.8);
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>Simulation Parameters</h3>
        <div class="control-group">
            <label>Grid Size:</label>
            <input type="range" id="gridSize" min="30" max="120" value="60">
            <span class="value-display" id="gridSizeValue">60</span>
        </div>
        <div class="control-group">
            <label>Initial Plants:</label>
            <input type="range" id="initPlants" min="50" max="500" value="200">
            <span class="value-display" id="initPlantsValue">200</span>
        </div>
        <div class="control-group">
            <label>Initial Herbivores:</label>
            <input type="range" id="initHerbivores" min="10" max="100" value="30">
            <span class="value-display" id="initHerbivoresValue">30</span>
        </div>
        <div class="control-group">
            <label>Initial Predators:</label>
            <input type="range" id="initPredators" min="5" max="50" value="10">
            <span class="value-display" id="initPredatorsValue">10</span>
        </div>
        <div class="control-group">
            <label>Mutation Rate:</label>
            <input type="range" id="mutationRate" min="0" max="0.2" step="0.01" value="0.05">
            <span class="value-display" id="mutationRateValue">0.05</span>
        </div>
        <div class="control-group">
            <label>Carrying Capacity:</label>
            <input type="range" id="carryingCapacity" min="100" max="1000" value="400">
            <span class="value-display" id="carryingCapacityValue">400</span>
        </div>
        <div class="control-group">
            <label>Plant Growth Rate:</label>
            <input type="range" id="plantGrowth" min="0.1" max="2" step="0.1" value="0.5">
            <span class="value-display" id="plantGrowthValue">0.5</span>
        </div>
        <div class="control-group">
            <label>Hunt Success Rate:</label>
            <input type="range" id="huntSuccess" min="0.1" max="1" step="0.05" value="0.4">
            <span class="value-display" id="huntSuccessValue">0.4</span>
        </div>
        <div class="control-group">
            <label>Energy Transfer:</label>
            <input type="range" id="energyTransfer" min="0.1" max="1" step="0.05" value="0.5">
            <span class="value-display" id="energyTransferValue">0.5</span>
        </div>
        <div class="control-group">
            <button id="resetBtn">Reset</button>
            <button id="pauseBtn">Pause</button>
        </div>
        <div class="control-group">
            <button id="speedBtn">Speed: 1x</button>
        </div>
    </div>
    
    <div id="stats">
        <h3>Population Statistics</h3>
        <div class="stat-line">
            <span class="stat-label">Plants:</span>
            <span class="stat-value" id="plantCount">0</span>
        </div>
        <div class="stat-line">
            <span class="stat-label">Herbivores:</span>
            <span class="stat-value" id="herbivoreCount">0</span>
        </div>
        <div class="stat-line">
            <span class="stat-label">Predators:</span>
            <span class="stat-value" id="predatorCount">0</span>
        </div>
        <div class="stat-line">
            <span class="stat-label">Avg Herb Speed:</span>
            <span class="stat-value" id="avgHerbSpeed">0</span>
        </div>
        <div class="stat-line">
            <span class="stat-label">Avg Herb Vision:</span>
            <span class="stat-value" id="avgHerbVision">0</span>
        </div>
        <div class="stat-line">
            <span class="stat-label">Avg Pred Speed:</span>
            <span class="stat-value" id="avgPredSpeed">0</span>
        </div>
        <div class="stat-line">
            <span class="stat-label">Avg Pred Vision:</span>
            <span class="stat-value" id="avgPredVision">0</span>
        </div>
        <div class="stat-line">
            <span class="stat-label">Avg Herb Reprod:</span>
            <span class="stat-value" id="avgHerbReprod">0</span>
        </div>
        <div class="stat-line">
            <span class="stat-label">Avg Pred Reprod:</span>
            <span class="stat-value" id="avgPredReprod">0</span>
        </div>
        <div class="stat-line">
            <span class="stat-label">Time:</span>
            <span class="stat-value" id="timeStep">0</span>
        </div>
        <div class="stat-line">
            <span class="stat-label">FPS:</span>
            <span class="stat-value" id="fps">60</span>
        </div>
    </div>
    
    <div id="graph"></div>
    
    <script>
        // Global simulation state
        let sim = {
            gridSize: 60,
            cellSize: 10,
            plants: [],
            herbivores: [],
            predators: [],
            mutationRate: 0.05,
            carryingCapacity: 400,
            plantGrowthRate: 0.5,
            huntSuccessRate: 0.4,
            energyTransfer: 0.5,
            isPaused: false,
            timeStep: 0,
            speedMultiplier: 1,
            history: {
                plants: [],
                herbivores: [],
                predators: [],
                maxLength: 200
            },
            spatialHash: new Map()
        };
        
        // Trait ranges
        const TRAITS = {
            herbivore: {
                speed: { min: 0.1, max: 2.0, default: 1.0 },
                vision: { min: 1, max: 8, default: 3 },
                reproduction: { min: 0.01, max: 0.2, default: 0.05 }
            },
            predator: {
                speed: { min: 0.1, max: 2.0, default: 1.2 },
                vision: { min: 1, max: 8, default: 4 },
                reproduction: { min: 0.01, max: 0.15, default: 0.03 },
                huntSuccess: { min: 0.1, max: 1.0, default: 0.4 }
            }
        };
        
        // Base entity class
        class Entity {
            constructor(x, y, type) {
                this.pos = createVector(x, y);
                this.type = type;
                this.energy = 50;
                this.age = 0;
                this.alive = true;
            }
            
            getGridPos() {
                return {
                    x: floor(this.pos.x / sim.cellSize),
                    y: floor(this.pos.y / sim.cellSize)
                };
            }
        }
        
        // Plant class
        class Plant extends Entity {
            constructor(x, y) {
                super(x, y, 'plant');
                this.energy = random(20, 40);
                this.maxEnergy = 100;
                this.growthRate = sim.plantGrowthRate;
            }
            
            update() {
                if (!this.alive) return;
                this.age++;
                
                // Grow if below max and under capacity
                if (sim.plants.length < sim.carryingCapacity * 2) {
                    this.energy = min(this.energy + this.growthRate, this.maxEnergy);
                }
                
                // Reproduce if mature and enough energy
                if (this.energy > 60 && random() < 0.02 * sim.speedMultiplier) {
                    this.reproduce();
                }
            }
            
            reproduce() {
                const offspring = new Plant(
                    this.pos.x + random(-sim.cellSize, sim.cellSize),
                    this.pos.y + random(-sim.cellSize, sim.cellSize)
                );
                offspring.energy = this.energy * 0.3;
                this.energy *= 0.7;
                sim.plants.push(offspring);
            }
            
            draw() {
                if (!this.alive) return;
                const size = map(this.energy, 0, this.maxEnergy, 3, 8);
                fill(100, 200 + this.energy, 100, 180);
                noStroke();
                circle(this.pos.x, this.pos.y, size);
            }
        }
        
        // Animal base class
        class Animal extends Entity {
            constructor(x, y, type, traits) {
                super(x, y, type);
                this.traits = traits;
                this.target = null;
                this.lastMeal = 0;
            }
            
            move() {
                if (random() > this.traits.speed / TRAITS[this.type].speed.max) return;
                
                // Random walk with occasional directed movement
                if (this.target && this.target.alive) {
                    // Move towards target
                    const dir = p5.Vector.sub(this.target.pos, this.pos);
                    dir.normalize().mult(this.traits.speed * sim.cellSize * 0.3);
                    this.pos.add(dir);
                } else {
                    // Random walk
                    this.pos.add(p5.Vector.random2D().mult(this.traits.speed * 2));
                }
                
                // Keep in bounds
                this.pos.x = constrain(this.pos.x, 0, width - 1);
                this.pos.y = constrain(this.pos.y, 0, height - 1);
            }
            
            findTarget(preyArray) {
                if (!preyArray || preyArray.length === 0) return null;
                
                const visionRange = this.traits.vision * sim.cellSize;
                let closest = null;
                let closestDist = visionRange;
                
                // Use spatial hash for efficiency
                const gridPos = this.getGridPos();
                const searchRadius = ceil(this.traits.vision);
                
                for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                    for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                        const key = `${gridPos.x + dx},${gridPos.y + dy}`;
                        const entities = sim.spatialHash.get(key) || [];
                        
                        for (const prey of entities) {
                            if (!prey.alive || prey === this) continue;
                            if (this.type === 'herbivore' && prey.type !== 'plant') continue;
                            if (this.type === 'predator' && prey.type !== 'herbivore') continue;
                            
                            const d = p5.Vector.dist(this.pos, prey.pos);
                            if (d < closestDist) {
                                closestDist = d;
                                closest = prey;
                            }
                        }
                    }
                }
                
                return closest;
            }
            
            mutateTraits() {
                for (let trait in this.traits) {
                    if (random() < sim.mutationRate) {
                        const range = TRAITS[this.type][trait];
                        const mutation = randomGaussian(0, (range.max - range.min) * 0.1);
                        this.traits[trait] = constrain(this.traits[trait] + mutation, range.min, range.max);
                    }
                }
            }
            
            getColor() {
                const baseHue = this.type === 'herbivore' ? 200 : 0;
                const speedFactor = map(this.traits.speed, TRAITS[this.type].speed.min, TRAITS[this.type].speed.max, 0, 1);
                const hue = baseHue + speedFactor * 60;
                colorMode(HSB);
                const c = color(hue, 70, 90, 200);
                colorMode(RGB);
                return c;
            }
        }
        
        // Herbivore class
        class Herbivore extends Animal {
            constructor(x, y, traits = null) {
                const defaultTraits = traits || {
                    speed: TRAITS.herbivore.speed.default,
                    vision: TRAITS.herbivore.vision.default,
                    reproduction: TRAITS.herbivore.reproduction.default
                };
                super(x, y, 'herbivore', defaultTraits);
                this.energy = 60;
                this.maxEnergy = 100;
                this.maxAge = 500;
            }
            
            update() {
                if (!this.alive) return;
                this.age++;
                this.lastMeal++;
                
                // Energy decay
                this.energy -= 0.2 * sim.speedMultiplier;
                
                // Find and eat plants
                if (this.energy < 80) {
                    this.target = this.findTarget(sim.plants);
                    if (this.target) {
                        const d = p5.Vector.dist(this.pos, this.target.pos);
                        if (d < sim.cellSize) {
                            // Eat plant
                            this.energy = min(this.energy + this.target.energy * sim.energyTransfer, this.maxEnergy);
                            this.target.alive = false;
                            this.lastMeal = 0;
                            this.target = null;
                        }
                    }
                }
                
                // Move
                this.move();
                
                // Reproduce
                if (this.energy > 60 && random() < this.traits.reproduction * sim.speedMultiplier) {
                    this.reproduce();
                }
                
                // Death
                if (this.energy <= 0 || this.age > this.maxAge || this.lastMeal > 100) {
                    this.alive = false;
                }
            }
            
            reproduce() {
                const offspring = new Herbivore(
                    this.pos.x + random(-sim.cellSize, sim.cellSize),
                    this.pos.y + random(-sim.cellSize, sim.cellSize),
                    { ...this.traits }
                );
                offspring.mutateTraits();
                offspring.energy = this.energy * 0.4;
                this.energy *= 0.6;
                sim.herbivores.push(offspring);
            }
            
            draw() {
                if (!this.alive) return;
                const size = map(this.energy, 0, this.maxEnergy, 4, 10);
                fill(this.getColor());
                stroke(255, 100);
                strokeWeight(0.5);
                circle(this.pos.x, this.pos.y, size);
                
                // Vision range indicator (subtle)
                noFill();
                stroke(100, 50);
                strokeWeight(0.3);
                circle(this.pos.x, this.pos.y, this.traits.vision * sim.cellSize * 2);
            }
        }
        
        // Predator class
        class Predator extends Animal {
            constructor(x, y, traits = null) {
                const defaultTraits = traits || {
                    speed: TRAITS.predator.speed.default,
                    vision: TRAITS.predator.vision.default,
                    reproduction: TRAITS.predator.reproduction.default,
                    huntSuccess: TRAITS.predator.huntSuccess.default
                };
                super(x, y, 'predator', defaultTraits);
                this.energy = 80;
                this.maxEnergy = 120;
                this.maxAge = 600;
            }
            
            update() {
                if (!this.alive) return;
                this.age++;
                this.lastMeal++;
                
                // Energy decay
                this.energy -= 0.3 * sim.speedMultiplier;
                
                // Find and hunt herbivores
                if (this.energy < 90) {
                    this.target = this.findTarget(sim.herbivores);
                    if (this.target) {
                        const d = p5.Vector.dist(this.pos, this.target.pos);
                        if (d < sim.cellSize && random() < this.traits.huntSuccess) {
                            // Hunt success
                            this.energy = min(this.energy + this.target.energy * sim.energyTransfer, this.maxEnergy);
                            this.target.alive = false;
                            this.lastMeal = 0;
                            this.target = null;
                        }
                    }
                }
                
                // Move
                this.move();
                
                // Reproduce
                if (this.energy > 80 && random() < this.traits.reproduction * sim.speedMultiplier) {
                    this.reproduce();
                }
                
                // Death
                if (this.energy <= 0 || this.age > this.maxAge || this.lastMeal > 150) {
                    this.alive = false;
                }
            }
            
            reproduce() {
                const offspring = new Predator(
                    this.pos.x + random(-sim.cellSize, sim.cellSize),
                    this.pos.y + random(-sim.cellSize, sim.cellSize),
                    { ...this.traits }
                );
                offspring.mutateTraits();
                offspring.energy = this.energy * 0.4;
                this.energy *= 0.6;
                sim.predators.push(offspring);
            }
            
            draw() {
                if (!this.alive) return;
                const size = map(this.energy, 0, this.maxEnergy, 5, 12);
                fill(this.getColor());
                stroke(255, 100);
                strokeWeight(0.5);
                circle(this.pos.x, this.pos.y, size);
                
                // Vision range indicator
                noFill();
                stroke(150, 50);
                strokeWeight(0.3);
                circle(this.pos.x, this.pos.y, this.traits.vision * sim.cellSize * 2);
            }
        }
        
        // Spatial hashing for efficient neighbor queries
        function updateSpatialHash() {
            sim.spatialHash.clear();
            const allEntities = [...sim.plants, ...sim.herbivores, ...sim.predators];
            
            for (const entity of allEntities) {
                if (!entity.alive) continue;
                const gridPos = entity.getGridPos();
                const key = `${gridPos.x},${gridPos.y}`;
                
                if (!sim.spatialHash.has(key)) {
                    sim.spatialHash.set(key, []);
                }
                sim.spatialHash.get(key).push(entity);
            }
        }
        
        // Monte Carlo simulation step
        function simulateStep() {
            if (sim.isPaused) return;
            
            // Update multiple times based on speed multiplier
            for (let s = 0; s < sim.speedMultiplier; s++) {
                sim.timeStep++;
                
                // Update plants
                for (const plant of sim.plants) {
                    plant.update();
                }
                
                // Update herbivores
                for (const herbivore of sim.herbivores) {
                    herbivore.update();
                }
                
                // Update predators
                for (const predator of sim.predators) {
                    predator.update();
                }
                
                // Remove dead entities
                sim.plants = sim.plants.filter(p => p.alive);
                sim.herbivores = sim.herbivores.filter(h => h.alive);
                sim.predators = sim.predators.filter(p => p.alive);
                
                // Update spatial hash
                updateSpatialHash();
                
                // Record history
                if (sim.timeStep % 5 === 0) {
                    sim.history.plants.push(sim.plants.length);
                    sim.history.herbivores.push(sim.herbivores.length);
                    sim.history.predators.push(sim.predators.length);
                    
                    if (sim.history.plants.length > sim.history.maxLength) {
                        sim.history.plants.shift();
                        sim.history.herbivores.shift();
                        sim.history.predators.shift();
                    }
                }
            }
        }
        
        // Initialize simulation
        function initSimulation() {
            sim.plants = [];
            sim.herbivores = [];
            sim.predators = [];
            sim.timeStep = 0;
            sim.history = { plants: [], herbivores: [], predators: [], maxLength: 200 };
            
            // Create plants
            for (let i = 0; i < parseInt(document.getElementById('initPlants').value); i++) {
                const x = random(width);
                const y = random(height);
                sim.plants.push(new Plant(x, y));
            }
            
            // Create herbivores
            for (let i = 0; i < parseInt(document.getElementById('initHerbivores').value); i++) {
                const x = random(width);
                const y = random(height);
                sim.herbivores.push(new Herbivore(x, y));
            }
            
            // Create predators
            for (let i = 0; i < parseInt(document.getElementById('initPredators').value); i++) {
                const x = random(width);
                const y = random(height);
                sim.predators.push(new Predator(x, y));
            }
            
            updateSpatialHash();
        }
        
        // Draw everything
        function draw() {
            // Update simulation parameters from UI
            sim.mutationRate = parseFloat(document.getElementById('mutationRate').value);
            sim.carryingCapacity = parseInt(document.getElementById('carryingCapacity').value);
            sim.plantGrowthRate = parseFloat(document.getElementById('plantGrowth').value);
            sim.huntSuccessRate = parseFloat(document.getElementById('huntSuccess').value);
            sim.energyTransfer = parseFloat(document.getElementById('energyTransfer').value);
            
            // Run simulation
            simulateStep();
            
            // Clear background
            background(10, 15, 25);
            
            // Draw grid
            push();
            stroke(30, 40, 60);
            strokeWeight(0.3);
            for (let x = 0; x < width; x += sim.cellSize) {
                line(x, 0, x, height);
            }
            for (let y = 0; y < height; y += sim.cellSize) {
                line(0, y, width, y);
            }
            pop();
            
            // Draw entities
            for (const plant of sim.plants) {
                plant.draw();
            }
            for (const herbivore of sim.herbivores) {
                herbivore.draw();
            }
            for (const predator of sim.predators) {
                predator.draw();
            }
            
            // Update statistics
            updateStats();
            
            // Draw population graph
            drawGraph();
        }
        
        // Update statistics display
        function updateStats() {
            document.getElementById('plantCount').textContent = sim.plants.length;
            document.getElementById('herbivoreCount').textContent = sim.herbivores.length;
            document.getElementById('predatorCount').textContent = sim.predators.length;
            document.getElementById('timeStep').textContent = sim.timeStep;
            document.getElementById('fps').textContent = frameRate().toFixed(1);
            
            // Calculate average traits
            if (sim.herbivores.length > 0) {
                let avgSpeed = 0, avgVision = 0, avgReprod = 0;
                for (const h of sim.herbivores) {
                    avgSpeed += h.traits.speed;
                    avgVision += h.traits.vision;
                    avgReprod += h.traits.reproduction;
                }
                document.getElementById('avgHerbSpeed').textContent = (avgSpeed / sim.herbivores.length).toFixed(2);
                document.getElementById('avgHerbVision').textContent = (avgVision / sim.herbivores.length).toFixed(1);
                document.getElementById('avgHerbReprod').textContent = (avgReprod / sim.herbivores.length).toFixed(3);
            }
            
            if (sim.predators.length > 0) {
                let avgSpeed = 0, avgVision = 0, avgReprod = 0;
                for (const p of sim.predators) {
                    avgSpeed += p.traits.speed;
                    avgVision += p.traits.vision;
                    avgReprod += p.traits.reproduction;
                }
                document.getElementById('avgPredSpeed').textContent = (avgSpeed / sim.predators.length).toFixed(2);
                document.getElementById('avgPredVision').textContent = (avgVision / sim.predators.length).toFixed(1);
                document.getElementById('avgPredReprod').textContent = (avgReprod / sim.predators.length).toFixed(3);
            }
        }
        
        // Draw population graph
        function drawGraph() {
            const graphWidth = 300;
            const graphHeight = 150;
            const margin = 40;
            
            push();
            translate(width - graphWidth - margin, height - graphHeight - margin);
            
            // Background
            fill(20, 30, 50, 180);
            stroke(100, 150, 255, 100);
            strokeWeight(1);
            rect(0, 0, graphWidth, graphHeight);
            
            if (sim.history.plants.length > 1) {
                const maxPop = max([...sim.history.plants, ...sim.history.herbivores, ...sim.history.predators, 1]);
                
                // Draw axes
                stroke(100, 100);
                strokeWeight(0.5);
                line(0, graphHeight, graphWidth, graphHeight);
                line(0, 0, 0, graphHeight);
                
                // Draw population curves
                const drawCurve = (data, color) => {
                    stroke(color);
                    strokeWeight(2);
                    noFill();
                    beginShape();
                    for (let i = 0; i < data.length; i++) {
                        const x = map(i, 0, data.length - 1, 0, graphWidth);
                        const y = graphHeight - map(data[i], 0, maxPop, 0, graphHeight);
                        vertex(x, y);
                    }
                    endShape();
                };
                
                drawCurve(sim.history.plants, color(100, 255, 100));
                drawCurve(sim.history.herbivores, color(100, 200, 255));
                drawCurve(sim.history.predators, color(255, 100, 100));
                
                // Legend
                fill(255);
                textAlign(RIGHT, TOP);
                textSize(10);
                text('Plants', graphWidth - 5, 5);
                text('Herbivores', graphWidth - 5, 18);
                text('Predators', graphWidth - 5, 31);
            }
            
            pop();
        }
        
        // p5.js setup
        function setup() {
            const canvasSize = min(windowWidth * 0.6, windowHeight * 0.9);
            createCanvas(canvasSize, canvasSize);
            frameRate(60);
            
            // Set initial grid size
            sim.gridSize = parseInt(document.getElementById('gridSize').value);
            sim.cellSize = width / sim.gridSize;
            
            initSimulation();
            
            // Setup UI event listeners
            setupControls();
        }
        
        // Setup UI controls
        function setupControls() {
            // Sliders
            const sliders = ['gridSize', 'initPlants', 'initHerbivores', 'initPredators', 
                           'mutationRate', 'carryingCapacity', 'plantGrowth', 'huntSuccess', 'energyTransfer'];
            sliders.forEach(id => {
                const slider = document.getElementById(id);
                const display = document.getElementById(id + 'Value');
                slider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    display.textContent = id === 'mutationRate' ? value.toFixed(2) : 
                                         (id.includes('Growth') || id.includes('Success') || id.includes('Transfer')) ? value.toFixed(1) : 
                                         value;
                });
            });
            
            // Buttons
            document.getElementById('resetBtn').addEventListener('click', () => {
                sim.gridSize = parseInt(document.getElementById('gridSize').value);
                sim.cellSize = width / sim.gridSize;
                initSimulation();
            });
            
            document.getElementById('pauseBtn').addEventListener('click', (e) => {
                sim.isPaused = !sim.isPaused;
                e.target.textContent = sim.isPaused ? 'Resume' : 'Pause';
            });
            
            document.getElementById('speedBtn').addEventListener('click', (e) => {
                const speeds = [1, 2, 5, 10];
                const currentIndex = speeds.indexOf(sim.speedMultiplier);
                sim.speedMultiplier = speeds[(currentIndex + 1) % speeds.length];
                e.target.textContent = `Speed: ${sim.speedMultiplier}x`;
            });
        }
        
        // p5.js draw loop
        function draw() {
            draw();
        }
        
        function windowResized() {
            const canvasSize = min(windowWidth * 0.6, windowHeight * 0.9);
            resizeCanvas(canvasSize, canvasSize);
            sim.cellSize = width / sim.gridSize;
        }
    </script>
</body>
</html>