<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolutionary Ecosystem Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #0f0f1a);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #container {
            display: flex;
            gap: 20px;
            padding: 20px;
            max-width: 1600px;
            width: 100%;
        }

        #canvas-container {
            position: relative;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
        }

        #main-canvas {
            display: block;
            border-radius: 12px;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 350px;
        }

        .panel {
            background: rgba(20, 20, 35, 0.95);
            border-radius: 12px;
            padding: 20px;
            color: #e0e0ff;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(100, 150, 255, 0.3);
        }

        .panel h3 {
            margin: 0 0 15px 0;
            color: #64b5f6;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(100, 180, 255, 0.5);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #b0c4ff;
        }

        .slider {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #64b5f6;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(100, 180, 255, 0.6);
        }

        .slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #64b5f6;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(100, 180, 255, 0.6);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 6px;
            font-size: 11px;
        }

        .stat-label {
            color: #8a92b2;
            font-size: 10px;
        }

        .stat-value {
            font-weight: bold;
            font-size: 14px;
            margin-top: 2px;
        }

        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .chart-container {
            height: 150px;
            position: relative;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            margin-top: 10px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            flex: 1;
            padding: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn.danger {
            background: linear-gradient(135deg, #f56565, #e53e3e);
        }

        .info-text {
            font-size: 11px;
            color: #8a92b2;
            margin-top: 10px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <canvas id="main-canvas"></canvas>
        </div>
        
        <div class="sidebar">
            <div class="panel">
                <h3>üåç Ecosystem Controls</h3>
                
                <div class="control-group">
                    <label>Mutation Rate: <span id="mutationRateValue">0.05</span></label>
                    <input type="range" class="slider" id="mutationRate" min="0" max="0.2" step="0.01" value="0.05">
                </div>
                
                <div class="control-group">
                    <label>Plant Growth Rate: <span id="plantGrowthValue">0.03</span></label>
                    <input type="range" class="slider" id="plantGrowth" min="0.01" max="0.1" step="0.005" value="0.03">
                </div>
                
                <div class="control-group">
                    <label>Carrying Capacity: <span id="carryingCapacityValue">500</span></label>
                    <input type="range" class="slider" id="carryingCapacity" min="100" max="1000" step="50" value="500">
                </div>
                
                <div class="control-group">
                    <label>Simulation Speed: <span id="simSpeedValue">1.0</span>x</label>
                    <input type="range" class="slider" id="simSpeed" min="0.1" max="3.0" step="0.1" value="1.0">
                </div>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4ade80;"></div>
                        <span>Plants</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #60a5fa;"></div>
                        <span>Herbivores</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f87171;"></div>
                        <span>Predators</span>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h3>üìä Population Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">Plants</div>
                        <div class="stat-value" id="plantCount" style="color: #4ade80;">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Herbivores</div>
                        <div class="stat-value" id="herbivoreCount" style="color: #60a5fa;">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Predators</div>
                        <div class="stat-value" id="predatorCount" style="color: #f87171;">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Generation</div>
                        <div class="stat-value" id="generation" style="color: #fbbf24;">0</div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <canvas id="populationChart"></canvas>
                </div>
            </div>
            
            <div class="panel">
                <h3>üß¨ Evolution Traits</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">Avg Herbivore Speed</div>
                        <div class="stat-value" id="avgHerbSpeed" style="color: #60a5fa;">1.0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Avg Predator Speed</div>
                        <div class="stat-value" id="avgPredSpeed" style="color: #f87171;">1.2</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Avg Vision Range</div>
                        <div class="stat-value" id="avgVision" style="color: #a78bfa;">3.0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Avg Reproduction</div>
                        <div class="stat-value" id="avgRepro" style="color: #f472b6;">0.02</div>
                    </div>
                </div>
                
                <div class="info-text">
                    <strong>Tip:</strong> Watch as species evolve over generations! Faster predators catch more prey, while better vision helps both species survive.
                </div>
            </div>
            
            <div class="panel">
                <h3>üéÆ Actions</h3>
                <div class="action-buttons">
                    <button class="btn" onclick="ecosystem.addRandomEntities()">Add Life</button>
                    <button class="btn" onclick="ecosystem.togglePause()">Pause</button>
                    <button class="btn danger" onclick="ecosystem.reset()">Reset</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class Entity {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.energy = 50;
                this.age = 0;
                this.alive = true;
                
                // Evolvable traits
                if (type === 'herbivore') {
                    this.speed = 1.0 + random(-0.2, 0.2);
                    this.visionRange = 3 + random(-1, 1);
                    this.reproductionRate = 0.02 + random(-0.005, 0.005);
                    this.maxEnergy = 80 + random(-10, 10);
                    this.size = 4 + random(-1, 1);
                } else if (type === 'predator') {
                    this.speed = 1.2 + random(-0.3, 0.3);
                    this.visionRange = 4 + random(-1, 1);
                    this.reproductionRate = 0.015 + random(-0.005, 0.005);
                    this.maxEnergy = 100 + random(-15, 15);
                    this.size = 5 + random(-1, 1);
                }
            }
            
            mutate() {
                const mutationRate = ecosystem.mutationRate;
                
                if (random() < mutationRate) {
                    this.speed *= random(0.9, 1.1);
                    this.speed = constrain(this.speed, 0.5, 2.5);
                }
                if (random() < mutationRate) {
                    this.visionRange *= random(0.9, 1.1);
                    this.visionRange = constrain(this.visionRange, 1, 8);
                }
                if (random() < mutationRate) {
                    this.reproductionRate *= random(0.9, 1.1);
                    this.reproductionRate = constrain(this.reproductionRate, 0.005, 0.05);
                }
                if (random() < mutationRate) {
                    this.maxEnergy *= random(0.9, 1.1);
                    this.maxEnergy = constrain(this.maxEnergy, 50, 150);
                }
                if (random() < mutationRate) {
                    this.size *= random(0.95, 1.05);
                    this.size = constrain(this.size, 3, 8);
                }
            }
            
            reproduce() {
                if (this.energy > this.maxEnergy * 0.6 && random() < this.reproductionRate) {
                    this.energy *= 0.5;
                    const offspring = new Entity(this.x, this.y, this.type);
                    offspring.speed = this.speed;
                    offspring.visionRange = this.visionRange;
                    offspring.reproductionRate = this.reproductionRate;
                    offspring.maxEnergy = this.maxEnergy;
                    offspring.size = this.size;
                    offspring.mutate();
                    return offspring;
                }
                return null;
            }
        }
        
        class Ecosystem {
            constructor() {
                this.gridSize = 100;
                this.cellSize = 6;
                this.grid = [];
                this.entities = [];
                this.plants = [];
                
                this.mutationRate = 0.05;
                this.plantGrowthRate = 0.03;
                this.carryingCapacity = 500;
                this.simSpeed = 1.0;
                this.paused = false;
                this.generation = 0;
                
                this.populationHistory = {
                    plants: [],
                    herbivores: [],
                    predators: []
                };
                
                this.init();
            }
            
            init() {
                // Initialize grid
                for (let i = 0; i < this.gridSize; i++) {
                    this.grid[i] = [];
                    for (let j = 0; j < this.gridSize; j++) {
                        this.grid[i][j] = null;
                    }
                }
                
                // Add initial plants
                for (let i = 0; i < 200; i++) {
                    this.addPlant();
                }
                
                // Add initial herbivores
                for (let i = 0; i < 30; i++) {
                    const x = floor(random(this.gridSize));
                    const y = floor(random(this.gridSize));
                    this.addEntity(new Entity(x, y, 'herbivore'));
                }
                
                // Add initial predators
                for (let i = 0; i < 10; i++) {
                    const x = floor(random(this.gridSize));
                    const y = floor(random(this.gridSize));
                    this.addEntity(new Entity(x, y, 'predator'));
                }
            }
            
            addPlant() {
                const x = floor(random(this.gridSize));
                const y = floor(random(this.gridSize));
                if (!this.grid[x][y]) {
                    this.grid[x][y] = 'plant';
                    this.plants.push({x, y, energy: 20});
                }
            }
            
            addEntity(entity) {
                if (!this.grid[entity.x][entity.y]) {
                    this.entities.push(entity);
                    this.grid[entity.x][entity.y] = entity.type;
                }
            }
            
            removeEntity(entity) {
                const index = this.entities.indexOf(entity);
                if (index > -1) {
                    this.entities.splice(index, 1);
                    this.grid[entity.x][entity.y] = null;
                    entity.alive = false;
                }
            }
            
            update() {
                if (this.paused) return;
                
                const updatesPerFrame = Math.floor(this.simSpeed * 10);
                
                for (let u = 0; u < updatesPerFrame; u++) {
                    // Monte Carlo selection - randomly pick entities to update
                    const numUpdates = Math.min(this.entities.length, 20);
                    
                    for (let i = 0; i < numUpdates; i++) {
                        if (this.entities.length === 0) break;
                        
                        const entity = random(this.entities);
                        if (!entity.alive) continue;
                        
                        this.updateEntity(entity);
                    }
                    
                    // Plant growth
                    if (random() < this.plantGrowthRate && this.plants.length < this.carryingCapacity) {
                        this.addPlant();
                    }
                    
                    // Plant spreading
                    for (let i = 0; i < this.plants.length; i++) {
                        if (random() < 0.001) {
                            const plant = this.plants[i];
                            const dx = floor(random(-2, 3));
                            const dy = floor(random(-2, 3));
                            const nx = constrain(plant.x + dx, 0, this.gridSize - 1);
                            const ny = constrain(plant.y + dy, 0, this.gridSize - 1);
                            
                            if (!this.grid[nx][ny]) {
                                this.grid[nx][ny] = 'plant';
                                this.plants.push({x: nx, y: ny, energy: 20});
                            }
                        }
                    }
                }
                
                this.generation++;
                this.updateStatistics();
            }
            
            updateEntity(entity) {
                entity.age++;
                entity.energy -= 0.5;
                
                // Death from starvation or old age
                if (entity.energy <= 0 || entity.age > 1000) {
                    this.removeEntity(entity);
                    return;
                }
                
                // Movement
                let targetX = entity.x;
                let targetY = entity.y;
                
                if (entity.type === 'herbivore') {
                    // Look for plants
                    const nearestPlant = this.findNearest(entity, 'plant');
                    if (nearestPlant) {
                        targetX = nearestPlant.x;
                        targetY = nearestPlant.y;
                    } else {
                        // Random walk
                        targetX += floor(random(-3, 4));
                        targetY += floor(random(-3, 4));
                    }
                } else if (entity.type === 'predator') {
                    // Look for herbivores
                    const nearestPrey = this.findNearest(entity, 'herbivore');
                    if (nearestPrey) {
                        targetX = nearestPrey.x;
                        targetY = nearestPrey.y;
                    } else {
                        // Random walk
                        targetX += floor(random(-3, 4));
                        targetY += floor(random(-3, 4));
                    }
                }
                
                // Move towards target
                const dx = targetX - entity.x;
                const dy = targetY - entity.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    const moveX = floor(dx / dist * entity.speed);
                    const moveY = floor(dy / dist * entity.speed);
                    
                    const newX = constrain(entity.x + moveX, 0, this.gridSize - 1);
                    const newY = constrain(entity.y + moveY, 0, this.gridSize - 1);
                    
                    if (!this.grid[newX][newY]) {
                        this.grid[entity.x][entity.y] = null;
                        entity.x = newX;
                        entity.y = newY;
                        this.grid[newX][newY] = entity.type;
                    }
                }
                
                // Feeding
                if (entity.type === 'herbivore') {
                    const plant = this.plants.find(p => p.x === entity.x && p.y === entity.y);
                    if (plant) {
                        entity.energy += plant.energy;
                        const plantIndex = this.plants.indexOf(plant);
                        this.plants.splice(plantIndex, 1);
                    }
                } else if (entity.type === 'predator') {
                    const prey = this.entities.find(e => 
                        e.type === 'herbivore' && 
                        e.x === entity.x && 
                        e.y === entity.y
                    );
                    if (prey) {
                        entity.energy += 30;
                        this.removeEntity(prey);
                    }
                }
                
                // Reproduction
                const offspring = entity.reproduce();
                if (offspring) {
                    // Try to place offspring nearby
                    for (let attempt = 0; attempt < 8; attempt++) {
                        const ox = constrain(entity.x + floor(random(-2, 3)), 0, this.gridSize - 1);
                        const oy = constrain(entity.y + floor(random(-2, 3)), 0, this.gridSize - 1);
                        
                        if (!this.grid[ox][oy]) {
                            offspring.x = ox;
                            offspring.y = oy;
                            this.addEntity(offspring);
                            break;
                        }
                    }
                }
            }
            
            findNearest(entity, targetType) {
                let nearest = null;
                let minDist = entity.visionRange;
                
                if (targetType === 'plant') {
                    for (const plant of this.plants) {
                        const dist = Math.sqrt(
                            Math.pow(plant.x - entity.x, 2) + 
                            Math.pow(plant.y - entity.y, 2)
                        );
                        if (dist < minDist) {
                            minDist = dist;
                            nearest = plant;
                        }
                    }
                } else {
                    for (const other of this.entities) {
                        if (other.type === targetType && other.alive) {
                            const dist = Math.sqrt(
                                Math.pow(other.x - entity.x, 2) + 
                                Math.pow(other.y - entity.y, 2)
                            );
                            if (dist < minDist) {
                                minDist = dist;
                                nearest = other;
                            }
                        }
                    }
                }
                
                return nearest;
            }
            
            updateStatistics() {
                const herbivores = this.entities.filter(e => e.type === 'herbivore' && e.alive);
                const predators = this.entities.filter(e => e.type === 'predator' && e.alive);
                
                // Update counts
                document.getElementById('plantCount').textContent = this.plants.length;
                document.getElementById('herbivoreCount').textContent = herbivores.length;
                document.getElementById('predatorCount').textContent = predators.length;
                document.getElementById('generation').textContent = this.generation;
                
                // Update trait averages
                if (herbivores.length > 0) {
                    const avgSpeed = herbivores.reduce((sum, h) => sum + h.speed, 0) / herbivores.length;
                    document.getElementById('avgHerbSpeed').textContent = avgSpeed.toFixed(2);
                }
                
                if (predators.length > 0) {
                    const avgSpeed = predators.reduce((sum, p) => sum + p.speed, 0) / predators.length;
                    document.getElementById('avgPredSpeed').textContent = avgSpeed.toFixed(2);
                }
                
                const allAnimals = [...herbivores, ...predators];
                if (allAnimals.length > 0) {
                    const avgVision = allAnimals.reduce((sum, a) => sum + a.visionRange, 0) / allAnimals.length;
                    const avgRepro = allAnimals.reduce((sum, a) => sum + a.reproductionRate, 0) / allAnimals.length;
                    
                    document.getElementById('avgVision').textContent = avgVision.toFixed(1);
                    document.getElementById('avgRepro').textContent = avgRepro.toFixed(3);
                }
                
                // Update population history
                if (this.generation % 10 === 0) {
                    this.populationHistory.plants.push(this.plants.length);
                    this.populationHistory.herbivores.push(herbivores.length);
                    this.populationHistory.predators.push(predators.length);
                    
                    // Keep only last 50 data points
                    if (this.populationHistory.plants.length > 50) {
                        this.populationHistory.plants.shift();
                        this.populationHistory.herbivores.shift();
                        this.populationHistory.predators.shift();
                    }
                    
                    this.drawPopulationChart();
                }
            }
            
            drawPopulationChart() {
                const canvas = document.getElementById('populationChart');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const data = [
                    { values: this.populationHistory.plants, color: '#4ade80', label: 'Plants' },
                    { values: this.populationHistory.herbivores, color: '#60a5fa', label: 'Herbivores' },
                    { values: this.populationHistory.predators, color: '#f87171', label: 'Predators' }
                ];
                
                const maxValue = Math.max(
                    ...this.populationHistory.plants,
                    ...this.populationHistory.herbivores,
                    ...this.populationHistory.predators,
                    1
                );
                
                data.forEach(dataset => {
                    ctx.strokeStyle = dataset.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    dataset.values.forEach((value, index) => {
                        const x = (index / (dataset.values.length - 1 || 1)) * canvas.width;
                        const y = canvas.height - (value / maxValue) * canvas.height * 0.9;
                        
                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    
                    ctx.stroke();
                });
            }
            
            render() {
                background(10, 10, 15);
                
                // Draw grid
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const x = i * this.cellSize;
                        const y = j * this.cellSize;
                        
                        if (this.grid[i][j] === 'plant') {
                            fill(74, 222, 128, 200);
                            noStroke();
                            rect(x, y, this.cellSize, this.cellSize);
                        }
                    }
                }
                
                // Draw entities
                for (const entity of this.entities) {
                    if (!entity.alive) continue;
                    
                    const x = entity.x * this.cellSize + this.cellSize / 2;
                    const y = entity.y * this.cellSize + this.cellSize / 2;
                    
                    if (entity.type === 'herbivore') {
                        // Color based on speed evolution
                        const speedNorm = (entity.speed - 0.5) / 2.0;
                        fill(96, 165, 250, 200);
                    } else if (entity.type === 'predator') {
                        // Color based on speed evolution
                        fill(248, 113, 113, 200);
                    }
                    
                    noStroke();
                    ellipse(x, y, entity.size * 2);
                    
                    // Energy indicator
                    fill(255, 255, 255, 100);
                    arc(x, y, entity.size * 2, entity.size * 2, 
                        -PI/2, -PI/2 + (entity.energy / entity.maxEnergy) * TWO_PI);
                }
            }
            
            addRandomEntities() {
                // Add random plants
                for (let i = 0; i < 20; i++) {
                    this.addPlant();
                }
                
                // Add random herbivores
                for (let i = 0; i < 5; i++) {
                    const x = floor(random(this.gridSize));
                    const y = floor(random(this.gridSize));
                    this.addEntity(new Entity(x, y, 'herbivore'));
                }
                
                // Add random predators
                for (let i = 0; i < 2; i++) {
                    const x = floor(random(this.gridSize));
                    const y = floor(random(this.gridSize));
                    this.addEntity(new Entity(x, y, 'predator'));
                }
            }
            
            togglePause() {
                this.paused = !this.paused;
            }
            
            reset() {
                this.entities = [];
                this.plants = [];
                this.generation = 0;
                this.populationHistory = {
                    plants: [],
                    herbivores: [],
                    predators: []
                };
                this.init();
            }
        }
        
        let ecosystem;
        
        function setup() {
            const canvas = createCanvas(600, 600);
            canvas.parent('canvas-container');
            
            ecosystem = new Ecosystem();
            
            // Setup controls
            document.getElementById('mutationRate').addEventListener('input', (e) => {
                ecosystem.mutationRate = parseFloat(e.target.value);
                document.getElementById('mutationRateValue').textContent = e.target.value;
            });
            
            document.getElementById('plantGrowth').addEventListener('input', (e) => {
                ecosystem.plantGrowthRate = parseFloat(e.target.value);
                document.getElementById('plantGrowthValue').textContent = e.target.value;
            });
            
            document.getElementById('carryingCapacity').addEventListener('input', (e) => {
                ecosystem.carryingCapacity = parseInt(e.target.value);
                document.getElementById('carryingCapacityValue').textContent = e.target.value;
            });
            
            document.getElementById('simSpeed').addEventListener('input', (e) => {
                ecosystem.simSpeed = parseFloat(e.target.value);
                document.getElementById('simSpeedValue').textContent = e.target.value;
            });
        }
        
        function draw() {
            ecosystem.update();
            ecosystem.render();
        }
        
        function mousePressed() {
            const gridX = floor(mouseX / ecosystem.cellSize);
            const gridY = floor(mouseY / ecosystem.cellSize);
            
            if (keyIsDown(SHIFT)) {
                // Add plant
                if (!ecosystem.grid[gridX][gridY]) {
                    ecosystem.grid[gridX][gridY] = 'plant';
                    ecosystem.plants.push({x: gridX, y: gridY, energy: 20});
                }
            } else if (keyIsDown(CONTROL)) {
                // Add herbivore
                if (!ecosystem.grid[gridX][gridY]) {
                    ecosystem.addEntity(new Entity(gridX, gridY, 'herbivore'));
                }
            } else if (keyIsDown(ALT)) {
                // Add predator
                if (!ecosystem.grid[gridX][gridY]) {
                    ecosystem.addEntity(new Entity(gridX, gridY, 'predator'));
                }
            }
        }
    </script>
</body>
</html>