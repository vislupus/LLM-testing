<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ecosystem Monte Carlo Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .simulation-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px;
        }
        .controls {
            width: 320px;
            background: #16213e;
            padding: 15px;
            overflow-y: auto;
            border-left: 1px solid #0f3460;
        }
        h2, h3 {
            color: #e94560;
            margin-bottom: 10px;
            font-size: 16px;
        }
        h3 {
            color: #0f9b8e;
            margin-top: 15px;
        }
        .control-group {
            margin-bottom: 12px;
        }
        .control-group label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 4px;
        }
        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #0f3460;
            outline: none;
            -webkit-appearance: none;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #e94560;
            cursor: pointer;
        }
        .value-display {
            font-size: 11px;
            color: #e94560;
            text-align: right;
        }
        button {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: none;
            border-radius: 4px;
            background: #0f3460;
            color: #eee;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        button:hover {
            background: #e94560;
        }
        .stats-panel {
            background: #0f3460;
            border-radius: 6px;
            padding: 10px;
            margin-top: 15px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin: 4px 0;
        }
        .stat-label {
            color: #aaa;
        }
        .stat-value {
            font-weight: bold;
        }
        .stat-value.plants { color: #4ade80; }
        .stat-value.herbivores { color: #60a5fa; }
        .stat-value.predators { color: #f87171; }
        .legend {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            font-size: 11px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        #canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .charts {
            background: #0f3460;
            border-radius: 6px;
            padding: 10px;
            margin-top: 15px;
        }
        canvas.charts-canvas {
            border-radius: 4px;
        }
        .info-text {
            font-size: 11px;
            color: #888;
            margin-top: 10px;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="simulation-area">
            <div id="canvas-container"></div>
        </div>
        <div class="controls">
            <h2>Ecosystem Simulation</h2>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #4ade80;"></div>
                    <span>Plants</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #60a5fa;"></div>
                    <span>Herbivores</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f87171;"></div>
                    <span>Predators</span>
                </div>
            </div>

            <button onclick="togglePause()" id="pauseBtn">Pause</button>
            <button onclick="resetSimulation()">Reset Simulation</button>
            <button onclick="randomizeTraits()">Randomize Traits</button>

            <h3>Population Settings</h3>
            <div class="control-group">
                <label>Initial Plants: <span class="value-display" id="initPlantsVal">500</span></label>
                <input type="range" id="initPlants" min="100" max="2000" value="500" oninput="updateParam('initPlants', this.value)">
            </div>
            <div class="control-group">
                <label>Initial Herbivores: <span class="value-display" id="initHerbivoresVal">50</span></label>
                <input type="range" id="initHerbivores" min="10" max="200" value="50" oninput="updateParam('initHerbivores', this.value)">
            </div>
            <div class="control-group">
                <label>Initial Predators: <span class="value-display" id="initPredatorsVal">10</span></label>
                <input type="range" id="initPredators" min="2" max="50" value="10" oninput="updateParam('initPredators', this.value)">
            </div>
            <div class="control-group">
                <label>Carrying Capacity: <span class="value-display" id="carryingCapacityVal">3000</span></label>
                <input type="range" id="carryingCapacity" min="1000" max="8000" value="3000" oninput="updateParam('carryingCapacity', this.value)">
            </div>

            <h3>Evolution Settings</h3>
            <div class="control-group">
                <label>Mutation Rate: <span class="value-display" id="mutationRateVal">0.1</span></label>
                <input type="range" id="mutationRate" min="0" max="0.5" step="0.01" value="0.1" oninput="updateParam('mutationRate', this.value)">
            </div>
            <div class="control-group">
                <label>Mutation Strength: <span class="value-display" id="mutationStrengthVal">0.2</span></label>
                <input type="range" id="mutationStrength" min="0.05" max="0.5" step="0.01" value="0.2" oninput="updateParam('mutationStrength', this.value)">
            </div>

            <h3>Herbivore Traits</h3>
            <div class="control-group">
                <label>Base Speed: <span class="value-display" id="herbSpeedVal">1.0</span></label>
                <input type="range" id="herbSpeed" min="0.5" max="2.0" step="0.1" value="1.0" oninput="updateParam('herbSpeed', this.value)">
            </div>
            <div class="control-group">
                <label>Vision Range: <span class="value-display" id="herbVisionVal">5</span></label>
                <input type="range" id="herbVision" min="2" max="15" step="1" value="5" oninput="updateParam('herbVision', this.value)">
            </div>
            <div class="control-group">
                <label>Reproduction Rate: <span class="value-display" id="herbReproVal">0.05</span></label>
                <input type="range" id="herbRepro" min="0.01" max="0.15" step="0.01" value="0.05" oninput="updateParam('herbRepro', this.value)">
            </div>
            <div class="control-group">
                <label>Energy Efficiency: <span class="value-display" id="herbEfficiencyVal">0.8</span></label>
                <input type="range" id="herbEfficiency" min="0.5" max="1.2" step="0.05" value="0.8" oninput="updateParam('herbEfficiency', this.value)">
            </div>

            <h3>Predator Traits</h3>
            <div class="control-group">
                <label>Base Speed: <span class="value-display" id="predSpeedVal">1.2</span></label>
                <input type="range" id="predSpeed" min="0.6" max="2.5" step="0.1" value="1.2" oninput="updateParam('predSpeed', this.value)">
            </div>
            <div class="control-group">
                <label>Vision Range: <span class="value-display" id="predVisionVal">7</span></label>
                <input type="range" id="predVision" min="3" max="20" step="1" value="7" oninput="updateParam('predVision', this.value)">
            </div>
            <div class="control-group">
                <label>Reproduction Rate: <span class="value-display" id="predReproVal">0.03</span></label>
                <input type="range" id="predRepro" min="0.005" max="0.1" step="0.005" value="0.03" oninput="updateParam('predRepro', this.value)">
            </div>
            <div class="control-group">
                <label>Hunting Success: <span class="value-display" id="predHuntVal">0.6</span></label>
                <input type="range" id="predHunt" min="0.2" max="1.0" step="0.05" value="0.6" oninput="updateParam('predHunt', this.value)">
            </div>

            <h3>Interactions</h3>
            <div class="control-group">
                <label>Plant Growth Rate: <span class="value-display" id="plantGrowthVal">0.05</span></label>
                <input type="range" id="plantGrowth" min="0.01" max="0.15" step="0.01" value="0.05" oninput="updateParam('plantGrowth', this.value)">
            </div>
            <div class="control-group">
                <label>Herbivore Eat Amount: <span class="value-display" id="herbEatVal">3</span></label>
                <input type="range" id="herbEat" min="1" max="8" step="0.5" value="3" oninput="updateParam('herbEat', this.value)">
            </div>
            <div class="control-group">
                <label>Predator Eat Amount: <span class="value-display" id="predEatVal">8</span></label>
                <input type="range" id="predEat" min="3" max="15" step="1" value="8" oninput="updateParam('predEat', this.value)">
            </div>

            <div class="stats-panel">
                <h3>Current Statistics</h3>
                <div class="stat-row">
                    <span class="stat-label">Plants:</span>
                    <span class="stat-value plants" id="statPlants">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Herbivores:</span>
                    <span class="stat-value herbivores" id="statHerbivores">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Predators:</span>
                    <span class="stat-value predators" id="statPredators">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Generation:</span>
                    <span class="stat-value" id="statGeneration">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Avg Herb Speed:</span>
                    <span class="stat-value" id="avgHerbSpeed">-</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Avg Pred Speed:</span>
                    <span class="stat-value" id="avgPredSpeed">-</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">FPS:</span>
                    <span class="stat-value" id="statFPS">0</span>
                </div>
            </div>

            <div class="charts">
                <h3>Population History</h3>
                <canvas id="populationChart" width="290" height="100"></canvas>
            </div>

            <div class="charts">
                <h3>Average Trait Evolution</h3>
                <canvas id="traitChart" width="290" height="100"></canvas>
            </div>

            <div class="info-text">
                <strong>Controls:</strong><br>
                Mouse: Select agents<br>
                R: Reset simulation<br>
                Space: Pause/Resume<br>
                <br>
                <strong>Evolution:</strong><br>
                Traits mutate during reproduction.<br>
                Watch for predator-prey cycles!
            </div>
        </div>
    </div>

    <script>
        // Simulation parameters
        let params = {
            gridSize: 8,
            initPlants: 500,
            initHerbivores: 50,
            initPredators: 10,
            carryingCapacity: 3000,
            mutationRate: 0.1,
            mutationStrength: 0.2,
            herbSpeed: 1.0,
            herbVision: 5,
            herbRepro: 0.05,
            herbEfficiency: 0.8,
            predSpeed: 1.2,
            predVision: 7,
            predRepro: 0.03,
            predHunt: 0.6,
            plantGrowth: 0.05,
            herbEat: 3,
            predEat: 8
        };

        let paused = false;
        let grid = [];
        let herbivores = [];
        let predators = [];
        let plants = [];
        let generation = 0;
        let populationHistory = [];
        let traitHistory = [];
        let maxHistory = 290;
        let selectedAgent = null;

        let canvasWidth, canvasHeight;
        let cols, rows;
        let popChartCtx, traitChartCtx;

        // Color schemes
        const PLANT_COLOR = [74, 222, 128];
        const HERB_BASE_COLOR = [96, 165, 250];
        const PRED_BASE_COLOR = [248, 113, 113];

        function setup() {
            let container = document.getElementById('canvas-container');
            canvasWidth = container.offsetWidth;
            canvasHeight = container.offsetHeight;

            let canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('canvas-container');

            cols = floor(width / params.gridSize);
            rows = floor(height / params.gridSize);

            // Setup chart canvases
            let popCanvas = document.getElementById('populationChart');
            popChartCtx = popCanvas.getContext('2d');

            let traitCanvas = document.getElementById('traitChart');
            traitChartCtx = traitCanvas.getContext('2d');

            initializeSimulation();
        }

        function initializeSimulation() {
            // Clear all data structures
            grid = [];
            herbivores = [];
            predators = [];
            plants = [];
            populationHistory = [];
            traitHistory = [];
            generation = 0;
            selectedAgent = null;

            // Initialize grid
            for (let i = 0; i < cols; i++) {
                grid[i] = [];
                for (let j = 0; j < rows; j++) {
                    grid[i][j] = { plant: 0, occupied: false };
                }
            }

            // Spawn initial plants
            for (let i = 0; i < params.initPlants; i++) {
                let x = floor(random(cols));
                let y = floor(random(rows));
                grid[x][y].plant = min(grid[x][y].plant + random(1, 3), 5);
            }

            // Spawn initial herbivores
            for (let i = 0; i < params.initHerbivores; i++) {
                let x = floor(random(cols));
                let y = floor(random(rows));
                herbivores.push(createAgent('herbivore', x, y));
            }

            // Spawn initial predators
            for (let i = 0; i < params.initPredators; i++) {
                let x = floor(random(cols));
                let y = floor(random(rows));
                predators.push(createAgent('predator', x, y));
            }
        }

        function createAgent(type, x, y) {
            let agent = {
                x: x,
                y: y,
                type: type,
                energy: 50 + random(30),
                age: 0,
                traits: {}
            };

            // Set traits based on type and current parameters
            if (type === 'herbivore') {
                agent.traits = {
                    speed: params.herbSpeed + random(-0.1, 0.1),
                    vision: params.herbVision + random(-1, 1),
                    reproduction: params.herbRepro + random(-0.01, 0.01),
                    efficiency: params.herbEfficiency + random(-0.1, 0.1)
                };
                agent.traits.speed = constrain(agent.traits.speed, 0.3, 3);
                agent.traits.vision = constrain(agent.traits.vision, 1, 20);
                agent.traits.reproduction = constrain(agent.traits.reproduction, 0.01, 0.2);
                agent.traits.efficiency = constrain(agent.traits.efficiency, 0.3, 1.5);
            } else {
                agent.traits = {
                    speed: params.predSpeed + random(-0.1, 0.1),
                    vision: params.predVision + random(-1, 1),
                    reproduction: params.predRepro + random(-0.005, 0.005),
                    huntSuccess: params.predHunt + random(-0.05, 0.05)
                };
                agent.traits.speed = constrain(agent.traits.speed, 0.4, 4);
                agent.traits.vision = constrain(agent.traits.vision, 2, 25);
                agent.traits.reproduction = constrain(agent.traits.reproduction, 0.005, 0.15);
                agent.traits.huntSuccess = constrain(agent.traits.huntSuccess, 0.1, 1);
            }

            return agent;
        }

        function draw() {
            background(26, 26, 46);

            if (!paused) {
                updateSimulation();
            }

            drawGrid();
            drawPlants();
            drawAgents(herbivores);
            drawAgents(predators);

            if (selectedAgent) {
                drawSelectedAgent();
            }

            updateStats();
            drawCharts();
        }

        function updateSimulation() {
            generation++;

            // Update plants (growth)
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (grid[i][j].plant < 5) {
                        // Probabilistic growth based on carrying capacity
                        let currentTotal = getTotalPlants();
                        let growthProb = params.plantGrowth * (1 - currentTotal / params.carryingCapacity);
                        if (random() < growthProb) {
                            grid[i][j].plant = min(grid[i][j].plant + 0.5, 5);
                        }
                    }
                }
            }

            // Shuffle update order for stochastic behavior
            shuffleArray(herbivores);
            shuffleArray(predators);

            // Update herbivores
            let newHerbivores = [];
            for (let i = herbivores.length - 1; i >= 0; i--) {
                let herb = herbivores[i];

                // Stochastic decision-making
                let action = random();

                if (action < 0.4) {
                    // Move towards food or randomly
                    moveHerbivore(herb);
                } else if (action < 0.7) {
                    // Eat nearby plants
                    eatPlants(herb);
                } else if (action < 0.95) {
                    // Attempt reproduction
                    if (random() < herb.traits.reproduction && herb.energy > 80) {
                        let offspring = reproduce(herb);
                        if (offspring) newHerbivores.push(offspring);
                    }
                }

                // Metabolism
                herb.energy -= 0.5 / herb.traits.efficiency;
                herb.age++;

                // Death conditions
                if (herb.energy <= 0 || herb.age > 2000) {
                    herbivores.splice(i, 1);
                }
            }
            herbivores = herbivores.concat(newHerbivores);

            // Update predators
            let newPredators = [];
            for (let i = predators.length - 1; i >= 0; i--) {
                let pred = predators[i];

                // Stochastic decision-making
                let action = random();

                if (action < 0.4) {
                    // Move towards prey or randomly
                    movePredator(pred);
                } else if (action < 0.6) {
                    // Hunt nearby herbivores
                    huntHerbivores(pred);
                } else if (action < 0.9) {
                    // Attempt reproduction
                    if (random() < pred.traits.reproduction && pred.energy > 100) {
                        let offspring = reproduce(pred);
                        if (offspring) newPredators.push(offspring);
                    }
                }

                // Metabolism
                pred.energy -= 0.8;
                pred.age++;

                // Death conditions
                if (pred.energy <= 0 || pred.age > 2500) {
                    predators.splice(i, 1);
                }
            }
            predators = predators.concat(newPredators);

            // Update population history
            if (generation % 5 === 0) {
                populationHistory.push({
                    plants: getTotalPlants(),
                    herbivores: herbivores.length,
                    predators: predators.length
                });

                if (populationHistory.length > maxHistory) {
                    populationHistory.shift();
                }

                // Update trait history
                let avgHerbSpeed = getAverageTrait('herbivore', 'speed');
                let avgPredSpeed = getAverageTrait('predator', 'speed');

                traitHistory.push({
                    herbSpeed: avgHerbSpeed,
                    predSpeed: avgPredSpeed
                });

                if (traitHistory.length > maxHistory) {
                    traitHistory.shift();
                }
            }
        }

        function moveHerbivore(herb) {
            let bestMove = null;
            let bestScore = -1;

            // Look for food in vision range
            let vision = floor(herb.traits.vision);

            // Check nearby cells for food
            for (let dx = -vision; dx <= vision; dx++) {
                for (let dy = -vision; dy <= vision; dy++) {
                    if (dx === 0 && dy === 0) continue;

                    let nx = (herb.x + dx + cols) % cols;
                    let ny = (herb.y + dy + rows) % rows;
                    let dist = sqrt(dx * dx + dy * dy);

                    if (dist <= vision && grid[nx][ny].plant > 0) {
                        // Score based on food amount and distance
                        let score = (grid[nx][ny].plant / dist) * random();
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = { x: nx, y: ny };
                        }
                    }
                }
            }

            // Move towards food or random walk
            let steps = floor(herb.traits.speed) + 1;
            for (let s = 0; s < steps; s++) {
                if (bestMove && random() < 0.7) {
                    // Move towards food
                    let dx = bestMove.x - herb.x;
                    let dy = bestMove.y - herb.y;

                    // Normalize and apply movement
                    let moveX = dx !== 0 ? (dx > 0 ? 1 : -1) : 0;
                    let moveY = dy !== 0 ? (dy > 0 ? 1 : -1) : 0;

                    let newX = (herb.x + moveX + cols) % cols;
                    let newY = (herb.y + moveY + rows) % rows;

                    herb.x = newX;
                    herb.y = newY;

                    // Update best move to continue towards food
                    bestMove.x = (bestMove.x - moveX + cols) % cols;
                    bestMove.y = (bestMove.y - moveY + rows) % rows;
                } else {
                    // Random walk
                    herb.x = (herb.x + floor(random(-1, 2)) + cols) % cols;
                    herb.y = (herb.y + floor(random(-1, 2)) + rows) % rows;
                }
            }
        }

        function eatPlants(herb) {
            let vision = floor(herb.traits.vision);
            let eatAmount = params.herbEat;

            // Find and eat nearby plants
            for (let dx = -vision; dx <= vision; dx++) {
                for (let dy = -vision; dy <= vision; dy++) {
                    let nx = (herb.x + dx + cols) % cols;
                    let ny = (herb.y + dy + rows) % rows;

                    if (grid[nx][ny].plant > 0) {
                        let eaten = min(grid[nx][ny].plant, eatAmount);
                        grid[nx][ny].plant -= eaten;
                        herb.energy += eaten * 10;
                        eatAmount -= eaten;

                        if (eatAmount <= 0) break;
                    }
                }
                if (eatAmount <= 0) break;
            }
        }

        function movePredator(pred) {
            let bestMove = null;
            let bestScore = -1;

            // Look for herbivores in vision range
            let vision = floor(pred.traits.vision);

            // Find nearest herbivore
            for (let herb of herbivores) {
                let dx = herb.x - pred.x;
                let dy = herb.y - pred.y;
                let dist = sqrt(dx * dx + dy * dy);

                if (dist <= vision && dist > 0) {
                    let score = herb.energy / dist * random();
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = { x: herb.x, y: herb.y, herb: herb };
                    }
                }
            }

            // Move towards prey or random walk
            let steps = floor(pred.traits.speed) + 1;
            for (let s = 0; s < steps; s++) {
                if (bestMove && random() < 0.75) {
                    // Move towards prey
                    let dx = bestMove.x - pred.x;
                    let dy = bestMove.y - pred.y;

                    let moveX = dx !== 0 ? (dx > 0 ? 1 : -1) : 0;
                    let moveY = dy !== 0 ? (dy > 0 ? 1 : -1) : 0;

                    pred.x = (pred.x + moveX + cols) % cols;
                    pred.y = (pred.y + moveY + rows) % rows;

                    // Update target position
                    bestMove.x = (bestMove.x - moveX + cols) % cols;
                    bestMove.y = (bestMove.y - moveY + rows) % rows;
                } else {
                    // Random walk
                    pred.x = (pred.x + floor(random(-1, 2)) + cols) % cols;
                    pred.y = (pred.y + floor(random(-1, 2)) + rows) % rows;
                }
            }
        }

        function huntHerbivores(pred) {
            let vision = floor(pred.traits.vision);
            let huntSuccess = pred.traits.huntSuccess;

            // Find and hunt nearby herbivores
            for (let i = herbivores.length - 1; i >= 0; i--) {
                let herb = herbivores[i];
                let dx = herb.x - pred.x;
                let dy = herb.y - pred.y;
                let dist = sqrt(dx * dx + dy * dy);

                if (dist <= vision) {
                    if (random() < huntSuccess) {
                        // Successful hunt
                        let eaten = min(params.predEat, herb.energy);
                        pred.energy += eaten * 8;
                        herb.energy -= eaten * 8;

                        // Remove dead herbivores
                        if (herb.energy <= 0) {
                            herbivores.splice(i, 1);
                        }
                    }
                    break; // Only hunt one at a time
                }
            }
        }

        function reproduce(parent) {
            if (parent.energy < 80) return null;

            // Stochastic reproduction check
            if (random() > params.mutationRate) {
                return null;
            }

            // Create offspring with potential mutations
            let offspring = createAgent(parent.type, parent.x, parent.y);

            // Apply mutations to traits
            for (let trait in parent.traits) {
                if (random() < 0.5) { // 50% chance per trait to mutate
                    let mutation = random(-params.mutationStrength, params.mutationStrength);
                    offspring.traits[trait] = parent.traits[trait] + mutation;

                    // Constrain to valid ranges
                    if (trait === 'speed') {
                        offspring.traits[trait] = constrain(offspring.traits[trait],
                            parent.type === 'herbivore' ? 0.3 : 0.4,
                            parent.type === 'herbivore' ? 3 : 4);
                    } else if (trait === 'vision') {
                        offspring.traits[trait] = constrain(offspring.traits[trait],
                            parent.type === 'herbivore' ? 1 : 2,
                            parent.type === 'herbivore' ? 20 : 25);
                    } else if (trait === 'reproduction') {
                        offspring.traits[trait] = constrain(offspring.traits[trait],
                            parent.type === 'herbivore' ? 0.01 : 0.005,
                            parent.type === 'herbivore' ? 0.2 : 0.15);
                    } else if (trait === 'efficiency') {
                        offspring.traits[trait] = constrain(offspring.traits[trait], 0.3, 1.5);
                    } else if (trait === 'huntSuccess') {
                        offspring.traits[trait] = constrain(offspring.traits[trait], 0.1, 1);
                    }
                } else {
                    offspring.traits[trait] = parent.traits[trait];
                }
            }

            // Energy cost for reproduction
            parent.energy -= 40;
            offspring.energy = 40;

            return offspring;
        }

        function drawGrid() {
            noStroke();
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    fill(30, 30, 50);
                    rect(i * params.gridSize, j * params.gridSize,
                         params.gridSize - 1, params.gridSize - 1);
                }
            }
        }

        function drawPlants() {
            noStroke();
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (grid[i][j].plant > 0) {
                        let brightness = map(grid[i][j].plant, 0, 5, 100, 255);
                        fill(74, 222, 128, brightness);
                        let size = map(grid[i][j].plant, 0, 5, 2, params.gridSize - 2);
                        ellipse(i * params.gridSize + params.gridSize / 2,
                               j * params.gridSize + params.gridSize / 2,
                               size, size);
                    }
                }
            }
        }

        function drawAgents(agents) {
            for (let agent of agents) {
                let displayColor = agent.type === 'herbivore' ? HERB_BASE_COLOR : PRED_BASE_COLOR;

                // Color variation based on traits
                let speedNorm = agent.type === 'herbivore'
                    ? map(agent.traits.speed, 0.3, 3, 0, 1)
                    : map(agent.traits.speed, 0.4, 4, 0, 1);

                let visionNorm = agent.type === 'herbivore'
                    ? map(agent.traits.vision, 1, 20, 0, 1)
                    : map(agent.traits.vision, 2, 25, 0, 1);

                fill(displayColor[0] + speedNorm * 50,
                     displayColor[1] + visionNorm * 30,
                     displayColor[2], 220);

                // Size based on energy
                let baseSize = params.gridSize * 0.6;
                let sizeMod = map(agent.energy, 0, 150, 0.5, 1.5);
                let size = baseSize * sizeMod;

                ellipse(agent.x * params.gridSize + params.gridSize / 2,
                       agent.y * params.gridSize + params.gridSize / 2,
                       size, size);

                // Vision range indicator (faint)
                if (agent === selectedAgent) {
                    noFill();
                    stroke(255, 255, 255, 50);
                    let visionPixels = agent.traits.vision * params.gridSize;
                    ellipse(agent.x * params.gridSize + params.gridSize / 2,
                           agent.y * params.gridSize + params.gridSize / 2,
                           visionPixels * 2, visionPixels * 2);
                }
            }
        }

        function drawSelectedAgent() {
            if (selectedAgent && (herbivores.includes(selectedAgent) || predators.includes(selectedAgent))) {
                noFill();
                stroke(255, 255, 0, 200);
                strokeWeight(2);
                let x = selectedAgent.x * params.gridSize + params.gridSize / 2;
                let y = selectedAgent.y * params.gridSize + params.gridSize / 2;
                ellipse(x, y, params.gridSize + 4, params.gridSize + 4);
                strokeWeight(1);
            } else {
                selectedAgent = null;
            }
        }

        function getTotalPlants() {
            let total = 0;
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    total += grid[i][j].plant;
                }
            }
            return total;
        }

        function getAverageTrait(type, traitName) {
            let agents = type === 'herbivore' ? herbivores : predators;
            if (agents.length === 0) return 0;

            let sum = 0;
            for (let agent of agents) {
                sum += agent.traits[traitName];
            }
            return sum / agents.length;
        }

        function updateStats() {
            document.getElementById('statPlants').textContent = getTotalPlants();
            document.getElementById('statHerbivores').textContent = herbivores.length;
            document.getElementById('statPredators').textContent = predators.length;
            document.getElementById('statGeneration').textContent = generation;

            let avgHerbSpeed = getAverageTrait('herbivore', 'speed');
            let avgPredSpeed = getAverageTrait('predator', 'speed');

            document.getElementById('avgHerbSpeed').textContent = avgHerbSpeed.toFixed(2);
            document.getElementById('avgPredSpeed').textContent = avgPredSpeed.toFixed(2);
            document.getElementById('statFPS').textContent = floor(frameRate());
        }

        function drawCharts() {
            // Population chart
            popChartCtx.fillStyle = '#0f3460';
            popChartCtx.fillRect(0, 0, 290, 100);

            if (populationHistory.length > 1) {
                let maxPop = 0;
                for (let p of populationHistory) {
                    maxPop = max(maxPop, p.plants, p.herbivores * 10, p.predators * 20);
                }
                maxPop = max(maxPop, 100);

                // Draw plant population
                popChartCtx.strokeStyle = '#4ade80';
                popChartCtx.lineWidth = 1;
                popChartCtx.beginPath();
                for (let i = 0; i < populationHistory.length; i++) {
                    let x = i * (290 / maxHistory);
                    let y = 100 - (populationHistory[i].plants / maxPop) * 95;
                    if (i === 0) popChartCtx.moveTo(x, y);
                    else popChartCtx.lineTo(x, y);
                }
                popChartCtx.stroke();

                // Draw herbivore population (scaled)
                popChartCtx.strokeStyle = '#60a5fa';
                popChartCtx.beginPath();
                for (let i = 0; i < populationHistory.length; i++) {
                    let x = i * (290 / maxHistory);
                    let y = 100 - (populationHistory[i].herbivores * 10 / maxPop) * 95;
                    if (i === 0) popChartCtx.moveTo(x, y);
                    else popChartCtx.lineTo(x, y);
                }
                popChartCtx.stroke();

                // Draw predator population (scaled)
                popChartCtx.strokeStyle = '#f87171';
                popChartCtx.beginPath();
                for (let i = 0; i < populationHistory.length; i++) {
                    let x = i * (290 / maxHistory);
                    let y = 100 - (populationHistory[i].predators * 20 / maxPop) * 95;
                    if (i === 0) popChartCtx.moveTo(x, y);
                    else popChartCtx.lineTo(x, y);
                }
                popChartCtx.stroke();
            }

            // Trait evolution chart
            traitChartCtx.fillStyle = '#0f3460';
            traitChartCtx.fillRect(0, 0, 290, 100);

            if (traitHistory.length > 1) {
                let maxVal = 5;

                // Draw herbivore speed
                traitChartCtx.strokeStyle = '#60a5fa';
                traitChartCtx.lineWidth = 1;
                traitChartCtx.beginPath();
                for (let i = 0; i < traitHistory.length; i++) {
                    let x = i * (290 / maxHistory);
                    let y = 100 - (traitHistory[i].herbSpeed / maxVal) * 95;
                    if (i === 0) traitChartCtx.moveTo(x, y);
                    else traitChartCtx.lineTo(x, y);
                }
                traitChartCtx.stroke();

                // Draw predator speed
                traitChartCtx.strokeStyle = '#f87171';
                traitChartCtx.beginPath();
                for (let i = 0; i < traitHistory.length; i++) {
                    let x = i * (290 / maxHistory);
                    let y = 100 - (traitHistory[i].predSpeed / maxVal) * 95;
                    if (i === 0) traitChartCtx.moveTo(x, y);
                    else traitChartCtx.lineTo(x, y);
                }
                traitChartCtx.stroke();
            }
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                let j = floor(random(i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function togglePause() {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        }

        function resetSimulation() {
            initializeSimulation();
        }

        function randomizeTraits() {
            for (let herb of herbivores) {
                herb.traits.speed = random(0.5, 2);
                herb.traits.vision = random(3, 10);
                herb.traits.reproduction = random(0.02, 0.08);
                herb.traits.efficiency = random(0.6, 1.0);
            }
            for (let pred of predators) {
                pred.traits.speed = random(0.8, 2);
                pred.traits.vision = random(5, 12);
                pred.traits.reproduction = random(0.02, 0.05);
                pred.traits.huntSuccess = random(0.4, 0.8);
            }
        }

        function updateParam(name, value) {
            params[name] = parseFloat(value);
            document.getElementById(name + 'Val').textContent = value;
        }

        function mousePressed() {
            // Find agent under mouse
            let gx = floor(mouseX / params.gridSize);
            let gy = floor(mouseY / params.gridSize);

            for (let herb of herbivores) {
                if (herb.x === gx && herb.y === gy) {
                    selectedAgent = herb;
                    return;
                }
            }

            for (let pred of predators) {
                if (pred.x === gx && pred.y === gy) {
                    selectedAgent = pred;
                    return;
                }
            }

            selectedAgent = null;
        }

        function keyPressed() {
            if (key === ' ' || key === 'Space') {
                togglePause();
            } else if (key === 'r' || key === 'R') {
                resetSimulation();
            }
        }

        function windowResized() {
            let container = document.getElementById('canvas-container');
            canvasWidth = container.offsetWidth;
            canvasHeight = container.offsetHeight;
            resizeCanvas(canvasWidth, canvasHeight);

            cols = floor(width / params.gridSize);
            rows = floor(height / params.gridSize);

            // Reinitialize grid with new dimensions
            grid = [];
            for (let i = 0; i < cols; i++) {
                grid[i] = [];
                for (let j = 0; j < rows; j++) {
                    grid[i][j] = { plant: 0, occupied: false };
                }
            }

            // Reposition agents
            for (let herb of herbivores) {
                herb.x = constrain(herb.x, 0, cols - 1);
                herb.y = constrain(herb.y, 0, rows - 1);
            }
            for (let pred of predators) {
                pred.x = constrain(pred.x, 0, cols - 1);
                pred.y = constrain(pred.y, 0, rows - 1);
            }
        }
    </script>

<script>
/**
 * Iframe 元素高亮注入脚本
 * 需要在目标网站中引入此脚本来支持跨域 iframe 高亮功能
 *
 * 使用方法：
 * 1. 将此脚本添加到目标网站的 HTML 中
 * 2. 或通过浏览器扩展、用户脚本等方式注入
 */

(function () {
  "use strict";

  // 检查是否在 iframe 中
  if (window.self === window.top) {
    return; // 不在 iframe 中，不执行
  }

  // 检查是否已经初始化过
  if (window.__iframeHighlightInitialized) {
    return;
  }
  window.__iframeHighlightInitialized = true;
  console.log("Iframe 高亮脚本已加载");

  // 创建高亮覆盖层
  var overlay = document.createElement("div");
  overlay.id = "iframe-highlight-overlay";
  overlay.style.cssText = "\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n    pointer-events: none;\n    z-index: 999999;\n    overflow: hidden;\n  ";

  // 创建悬停高亮框（虚线边框）
  var highlightBox = document.createElement("div");
  highlightBox.id = "iframe-highlight-box";
  highlightBox.style.cssText = "\n    position: absolute;\n    border: 2px dashed #007AFF;\n    background: rgba(0, 122, 255, 0.08);\n    pointer-events: none;\n    display: none;\n    transition: all 0.1s ease;\n    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.8);\n    border-radius: 2px;\n  ";

  // 创建选中节点的常驻高亮框（实线边框）
  var selectedBox = document.createElement("div");
  selectedBox.id = "iframe-selected-box";
  selectedBox.style.cssText = "\n    position: absolute;\n    border: 2px solid #007AFF;\n    pointer-events: none;\n    display: none;\n    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.9), 0 0 8px rgba(255, 107, 53, 0.4);\n    border-radius: 2px;\n    z-index: 1000000;\n  ";

  // 创建悬停标签显示
  var tagLabel = document.createElement("div");
  tagLabel.id = "iframe-tag-label";
  tagLabel.style.cssText = "\n    position: absolute;\n    background: #007AFF;\n    color: white;\n    padding: 2px 6px;\n    font-size: 11px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    border-radius: 2px;\n    pointer-events: none;\n    display: none;\n    white-space: nowrap;\n    z-index: 1000001;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    font-weight: 500;\n  ";

  // 创建选中节点标签
  var selectedLabel = document.createElement("div");
  selectedLabel.id = "iframe-selected-label";
  selectedLabel.style.cssText = "\n    position: absolute;\n    background: #007AFF;\n    color: white;\n    padding: 3px 8px;\n    font-size: 11px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    border-radius: 3px;\n    pointer-events: none;\n    display: none;\n    white-space: nowrap;\n    z-index: 1000002;\n    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);\n    font-weight: 600;\n  ";
  overlay.appendChild(highlightBox);
  overlay.appendChild(selectedBox);
  overlay.appendChild(tagLabel);
  overlay.appendChild(selectedLabel);
  document.body.appendChild(overlay);

  // 存储当前选中的元素
  var selectedElement = null;
  var highlightEnabled = false;

  // 更新选中元素的高亮显示
  function updateSelectedHighlight(element) {
    console.log("updateSelectedHighlight called with:", element);
    if (!element) {
      selectedBox.style.display = "none";
      selectedLabel.style.display = "none";
      selectedElement = null;
      console.log("Cleared selected highlight");
      return;
    }
    selectedElement = element;
    var rect = element.getBoundingClientRect();
    console.log("Selected element rect:", rect);

    // 更新选中高亮框位置
    selectedBox.style.display = "block";
    selectedBox.style.left = "".concat(rect.left - 2, "px");
    selectedBox.style.top = "".concat(rect.top - 2, "px");
    selectedBox.style.width = "".concat(rect.width + 4, "px");
    selectedBox.style.height = "".concat(rect.height + 4, "px");

    // 更新选中标签位置和内容
    selectedLabel.style.display = "block";
    selectedLabel.textContent = "\u2713 <".concat(element.tagName.toLowerCase(), ">");

    // 计算标签位置，确保不超出视窗
    var labelTop = rect.top - 28;
    var labelLeft = rect.left;

    // 如果标签会超出顶部，显示在元素下方
    if (labelTop < 5) {
      labelTop = rect.bottom + 5;
    }

    // 如果标签会超出右侧，向左调整
    var labelWidth = selectedLabel.offsetWidth || 100; // 预估宽度
    if (labelLeft + labelWidth > window.innerWidth - 10) {
      labelLeft = window.innerWidth - labelWidth - 10;
    }
    selectedLabel.style.left = "".concat(Math.max(5, labelLeft), "px");
    selectedLabel.style.top = "".concat(labelTop, "px");
    console.log("Selected highlight positioned at:", {
      left: selectedBox.style.left,
      top: selectedBox.style.top,
      width: selectedBox.style.width,
      height: selectedBox.style.height
    });
  }
  function getElementSelector(element) {
    if (!(element instanceof Element)) throw new Error('Argument must be a DOM element');
    var segments = [];
    var current = element;
    while (current !== document.documentElement) {
      var selector = '';
      // 优先检查唯一ID
      if (current.id && document.querySelectorAll("#".concat(current.id)).length === 1) {
        segments.unshift("#".concat(current.id));
        break; // ID唯一，无需继续向上
      }

      // 生成类名选择器（取第一个有效类名）
      var classes = Array.from(current.classList).filter(function (c) {
        return !c.startsWith('js-');
      });
      var className = classes.length > 0 ? ".".concat(classes[0]) : '';

      // 生成位置索引（nth-child）
      var tag = current.tagName.toLowerCase();
      if (!className) {
        var siblings = Array.from(current.parentNode.children);
        var index = siblings.findIndex(function (el) {
          return el === current;
        }) + 1;
        selector = "".concat(tag, ":nth-child(").concat(index, ")");
      } else {
        selector = className;
      }
      segments.unshift(selector);
      current = current.parentElement;
    }

    // 处理根元素
    if (current === document.documentElement) {
      segments.unshift('html');
    }
    return segments.join(' > ');
  }

  // 获取元素文本内容
  function getElementText(element) {
    var _element$textContent;
    if (element.tagName === "INPUT") {
      return element.value || element.placeholder || "";
    }
    if (element.tagName === "TEXTAREA") {
      return element.value || element.placeholder || "";
    }
    var text = ((_element$textContent = element.textContent) === null || _element$textContent === void 0 ? void 0 : _element$textContent.trim()) || "";
    return text.length > 50 ? text.substring(0, 50) + "..." : text;
  }

  // 获取元素属性信息
  function getElementAttributes(element) {
    var attrs = {};
    for (var i = 0; i < element.attributes.length; i++) {
      var attr = element.attributes[i];
      attrs[attr.name] = attr.value;
    }
    return attrs;
  }

  // 鼠标悬停事件处理
  function handleMouseOver(e) {
    if (!highlightEnabled) return;
    var target = e.target;
    if (!target || target === overlay || target === highlightBox || target === tagLabel || target === selectedBox || target === selectedLabel) {
      return;
    }

    // 避免高亮 html 和 body 元素
    if (target === document.documentElement || target === document.body) {
      return;
    }

    // 如果是已选中的元素，不显示悬停高亮
    if (target === selectedElement) {
      highlightBox.style.display = "none";
      tagLabel.style.display = "none";
      return;
    }
    var rect = target.getBoundingClientRect();
    var selector = getElementSelector(target);
    var text = getElementText(target);
    var attributes = getElementAttributes(target);

    // 更新悬停高亮框位置
    highlightBox.style.display = "block";
    highlightBox.style.left = "".concat(rect.left - 2, "px");
    highlightBox.style.top = "".concat(rect.top - 2, "px");
    highlightBox.style.width = "".concat(rect.width + 4, "px");
    highlightBox.style.height = "".concat(rect.height + 4, "px");

    // 更新标签位置和内容
    tagLabel.style.display = "block";
    tagLabel.textContent = "<".concat(target.tagName.toLowerCase(), ">");

    // 计算标签位置，确保不超出视窗
    var labelTop = rect.top - 22;
    var labelLeft = rect.left;

    // 如果标签会超出顶部，显示在元素下方
    if (labelTop < 0) {
      labelTop = rect.bottom + 5;
    }

    // 如果标签会超出右侧，向左调整
    if (labelLeft + tagLabel.offsetWidth > window.innerWidth) {
      labelLeft = window.innerWidth - tagLabel.offsetWidth - 5;
    }
    tagLabel.style.left = "".concat(Math.max(0, labelLeft), "px");
    tagLabel.style.top = "".concat(labelTop, "px");

    // 发送消息到父窗口
    var elementInfo = {
      tagName: target.tagName.toLowerCase(),
      rect: {
        left: rect.left,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.width,
        height: rect.height,
        x: rect.x,
        y: rect.y
      },
      selector: selector,
      text: text,
      attributes: attributes,
      url: window.location.href,
      path: window.location.pathname,
      timestamp: Date.now()
    };
    try {
      window.parent.postMessage({
        type: "iframe-element-hover",
        data: elementInfo,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("无法发送消息到父窗口:", error);
    }
  }

  // 鼠标离开事件处理
  function handleMouseOut(e) {
    if (!highlightEnabled) return;
    var relatedTarget = e.relatedTarget;

    // 如果鼠标移动到高亮相关元素上，不隐藏高亮
    if (relatedTarget && (relatedTarget === highlightBox || relatedTarget === tagLabel || relatedTarget === overlay || relatedTarget === selectedBox || relatedTarget === selectedLabel)) {
      return;
    }
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    try {
      window.parent.postMessage({
        type: "iframe-element-hover",
        data: null,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("无法发送消息到父窗口:", error);
    }
  }

  // 点击事件处理
  function handleClick(e) {
    var target = e.target;
    if (!target || target === overlay || target === highlightBox || target === tagLabel || target === selectedBox || target === selectedLabel) {
      return;
    }

    // 避免处理 html 和 body 元素
    if (target === document.documentElement || target === document.body) {
      return;
    }

    // 检查是否是交互元素，这些元素需要保留默认行为
    var isInteractiveElement = ['input', 'textarea', 'select', 'button', 'a'].includes(target.tagName.toLowerCase());

    // 如果高亮功能启用，对于非交互元素阻止默认行为和事件传播
    if (highlightEnabled) {
      e.preventDefault();
      e.stopPropagation();
    }
    var rect = target.getBoundingClientRect();
    var selector = getElementSelector(target);
    var text = getElementText(target);
    var attributes = getElementAttributes(target);
    console.log("Element clicked:", {
      tagName: target.tagName,
      selector: selector,
      rect: rect
    });

    // 立即更新选中高亮
    updateSelectedHighlight(target);

    // 隐藏悬停高亮，因为现在是选中状态
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    var elementInfo = {
      tagName: target.tagName.toLowerCase(),
      rect: {
        left: rect.left,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.width,
        height: rect.height,
        x: rect.x,
        y: rect.y
      },
      selector: selector,
      text: text,
      attributes: attributes,
      url: window.location.href,
      path: window.location.pathname,
      timestamp: Date.now()
    };
    try {
      window.parent.postMessage({
        type: "iframe-element-click",
        data: elementInfo,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("无法发送消息到父窗口:", error);
    }
  }

  // 监听来自父窗口的消息
  function handleParentMessage(event) {
    console.log("Received message from parent:", event.data);
    if (event.data.type === "iframe-highlight-toggle") {
      var enabled = event.data.enabled;
      console.log("Highlight toggle:", enabled);
      if (enabled) {
        enableHighlight();
      } else {
        disableHighlight();
      }
    } else if (event.data.type === "enable-iframe-highlight") {
      console.log("Enable iframe highlight");
      enableHighlight();
    } else if (event.data.type === "disable-iframe-highlight") {
      console.log("Disable iframe highlight");
      disableHighlight();
    } else if (event.data.type === "toggle-iframe-highlight") {
      var _enabled = event.data.enabled !== undefined ? event.data.enabled : !highlightEnabled;
      console.log("Toggle iframe highlight to:", _enabled);
      if (_enabled) {
        enableHighlight();
      } else {
        disableHighlight();
      }
    } else if (event.data.type === "update-selected-element") {
      var selector = event.data.selector;
      console.log("Update selected element with selector:", selector);
      if (selector) {
        try {
          var element = document.querySelector(selector);
          console.log("Found element by selector:", element);
          updateSelectedHighlight(element);
        } catch (error) {
          console.warn("Failed to select element:", error);
          updateSelectedHighlight(null);
        }
      } else {
        updateSelectedHighlight(null);
      }
    } else if (event.data.type === "clear-selected-element") {
      console.log("Clear selected element");
      updateSelectedHighlight(null);
    }
  }

  // 启用高亮功能
  function enableHighlight() {
    console.log("Enabling highlight");
    document.addEventListener("mouseover", handleMouseOver, true);
    document.addEventListener("mouseout", handleMouseOut, true);
    document.addEventListener("click", handleClick, true);
    highlightEnabled = true;
    overlay.style.display = "block";
  }

  // 禁用高亮功能
  function disableHighlight() {
    console.log("Disabling highlight");
    highlightEnabled = false;
    // 保持事件监听器，但通过 highlightEnabled 变量控制行为
    // 这样可以保留选中状态的显示
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    // 不隐藏 selectedBox 和 selectedLabel，保留选中状态
  }

  // 完全禁用高亮功能（移除所有监听器）
  function fullyDisableHighlight() {
    console.log("Fully disabling highlight");
    highlightEnabled = false;
    document.removeEventListener("mouseover", handleMouseOver, true);
    document.removeEventListener("mouseout", handleMouseOut, true);
    document.removeEventListener("click", handleClick, true);
    overlay.style.display = "none";
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    selectedBox.style.display = "none";
    selectedLabel.style.display = "none";
  }

  // 添加事件监听
  enableHighlight();
  window.addEventListener("message", handleParentMessage);

  // 暴露全局函数供外部调用
  window.__iframeHighlightControl = {
    enable: enableHighlight,
    disable: disableHighlight,
    fullyDisable: fullyDisableHighlight,
    isEnabled: function isEnabled() {
      return highlightEnabled;
    },
    getSelectedElement: function getSelectedElement() {
      return selectedElement;
    },
    updateSelected: updateSelectedHighlight,
    // 通过消息发送开关控制
    sendToggleMessage: function sendToggleMessage(enabled) {
      window.parent.postMessage({
        type: 'iframe-highlight-status',
        enabled: enabled || highlightEnabled,
        source: 'iframe-highlight-injector'
      }, '*');
    }
  };

  // 通知父窗口脚本已加载
  try {
    window.parent.postMessage({
      type: "iframe-highlight-ready",
      data: {
        url: window.location.href,
        userAgent: navigator.userAgent,
        timestamp: Date.now()
      },
      source: "iframe-highlight-injector"
    }, "*");
  } catch (error) {
    console.warn("无法发送就绪消息到父窗口:", error);
  }

  // 清理函数
  window.__iframeHighlightCleanup = function () {
    fullyDisableHighlight();
    window.removeEventListener("message", handleParentMessage);
    if (overlay.parentElement) {
      overlay.parentElement.removeChild(overlay);
    }
    delete window.__iframeHighlightInitialized;
    delete window.__iframeHighlightCleanup;
  };
})();

</script>
</body>
</html>
