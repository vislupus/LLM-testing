<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js Epic Space Battle</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #000;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            pointer-events: none;
            text-shadow: 0 0 5px black;
        }
    </style>
    <!-- Babylon.js Core -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <!-- Babylon.js GUI -->
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
</head>
<body>
    <div id="ui">
        <h1>Fleets Engaging</h1>
        <h3>Blue Alliance vs Red Federation</h3>
    </div>
    <canvas id="renderCanvas"></canvas>

    <script>
        window.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('renderCanvas');
            const engine = new BABYLON.Engine(canvas, true);

            // --- Configuration ---
            const CONFIG = {
                fleetSize: 10, // 1 Flagship + 9 Escorts
                escortHP: 100,
                flagshipHP: 500,
                projectileSpeed: 80,
                fireRateNormal: 3000, // ms
                chainReactionDist: 15, // Units
                worldSize: 300
            };

            // Global references
            let ships = [];
            let projectiles = [];
            let explosionSystems = [];
            
            const createScene = function() {
                const scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color3(0.02, 0.02, 0.05);
                
                // Glow layer for engines and lasers
                const glowLayer = new BABYLON.GlowLayer("glow", scene);
                glowLayer.intensity = 1.2;

                // --- Camera ---
                const camera = new BABYLON.ArcRotateCamera("Camera", Math.PI / 2, Math.PI / 2.5, 150, BABYLON.Vector3.Zero(), scene);
                camera.attachControl(canvas, true);
                camera.lowerRadiusLimit = 20;
                camera.upperRadiusLimit = 400;

                // --- Environment ---
                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
                light.intensity = 0.3;
                
                // Sun/Directional light
                const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-1, -0.5, -1), scene);
                sun.intensity = 1.5;

                // Starfield (Procedural Particle System)
                const starSystem = new BABYLON.ParticleSystem("stars", 2000, scene);
                starSystem.particleTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/flare.png", scene);
                starSystem.emitter = new BABYLON.Vector3(0, 0, 0);
                starSystem.minEmitBox = new BABYLON.Vector3(-200, -200, -200);
                starSystem.maxEmitBox = new BABYLON.Vector3(200, 200, 200);
                starSystem.color1 = new BABYLON.Color4(1, 1, 1, 1);
                starSystem.color2 = new BABYLON.Color4(0.5, 0.5, 1, 1);
                starSystem.minSize = 0.5;
                starSystem.maxSize = 2.0;
                starSystem.minLifeTime = 9999;
                starSystem.maxLifeTime = 9999;
                starSystem.emitRate = 2000;
                starSystem.start();

                // UI Texture
                const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

                // --- Ship Factory ---
                
                // Materials
                const blueMat = new BABYLON.StandardMaterial("blueMat", scene);
                blueMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.8);
                blueMat.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.4);

                const redMat = new BABYLON.StandardMaterial("redMat", scene);
                redMat.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
                redMat.emissiveColor = new BABYLON.Color3(0.4, 0.1, 0.1);

                const darkMat = new BABYLON.StandardMaterial("darkMat", scene);
                darkMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);

                function createShipMesh(isFlagship, teamColor) {
                    const root = new BABYLON.TransformNode("shipRoot", scene);
                    
                    let body;
                    if (isFlagship) {
                        // Flagship Design
                        const mainHull = BABYLON.MeshBuilder.CreateBox("hull", {width: 4, height: 3, depth: 12}, scene);
                        const wingL = BABYLON.MeshBuilder.CreateBox("wingL", {width: 2, height: 1, depth: 8}, scene);
                        wingL.position.x = -3.5;
                        const wingR = BABYLON.MeshBuilder.CreateBox("wingR", {width: 2, height: 1, depth: 8}, scene);
                        wingR.position.x = 3.5;
                        
                        body = BABYLON.Mesh.MergeMeshes([mainHull, wingL, wingR], true, true, undefined, false, true);
                    } else {
                        // Escort Design
                        const hull = BABYLON.MeshBuilder.CreateCylinder("hull", {height: 6, diameterTop: 0, diameterBottom: 2, tessellation: 6}, scene);
                        hull.rotation.x = Math.PI / 2;
                        const wings = BABYLON.MeshBuilder.CreateBox("wings", {width: 4, height: 0.2, depth: 2}, scene);
                        body = BABYLON.Mesh.MergeMeshes([hull, wings], true, true, undefined, false, true);
                    }

                    body.material = teamColor === "blue" ? blueMat : redMat;
                    body.parent = root;

                    // Engine Glow
                    const engineLight = new BABYLON.PointLight("engineLight", new BABYLON.Vector3(0, 0, -3), scene);
                    engineLight.diffuse = teamColor === "blue" ? new BABYLON.Color3(0, 1, 1) : new BABYLON.Color3(1, 0.5, 0);
                    engineLight.intensity = 2;
                    engineLight.parent = root;

                    return root;
                }

                // --- Projectile System ---
                function fireProjectile(owner, targetPos) {
                    const startPos = owner.mesh.position.clone();
                    // Offset slightly forward
                    startPos.addInPlace(owner.mesh.forward.scale(5));

                    const projectileMesh = BABYLON.MeshBuilder.CreateSphere("proj", {diameter: 0.8}, scene);
                    projectileMesh.position = startPos;
                    
                    const mat = new BABYLON.StandardMaterial("pMat", scene);
                    mat.emissiveColor = owner.team === "blue" ? new BABYLON.Color3(0.5, 0.5, 1) : new BABYLON.Color3(1, 0.2, 0.2);
                    mat.disableLighting = true;
                    projectileMesh.material = mat;

                    // Trail
                    const trail = new BABYLON.TrailMesh("trail", projectileMesh, scene, 0.5, 20, true);
                    const trailMat = new BABYLON.StandardMaterial("trailMat", scene);
                    trailMat.emissiveColor = mat.emissiveColor;
                    trailMat.alpha = 0.6;
                    trail.material = trailMat;

                    // Calc direction
                    const direction = targetPos.subtract(startPos).normalize();

                    projectiles.push({
                        mesh: projectileMesh,
                        direction: direction,
                        speed: CONFIG.projectileSpeed,
                        team: owner.team,
                        damage: 25,
                        life: 100 // frames
                    });
                }

                // --- Explosion System ---
                function createExplosion(position, scale = 1) {
                    // 1. Fire Core
                    const fireSystem = new BABYLON.ParticleSystem("fire", 200, scene);
                    fireSystem.particleTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/flare.png", scene);
                    fireSystem.emitter = position;
                    fireSystem.minEmitBox = new BABYLON.Vector3(-1, -1, -1);
                    fireSystem.maxEmitBox = new BABYLON.Vector3(1, 1, 1);
                    fireSystem.color1 = new BABYLON.Color4(1, 0.5, 0, 1);
                    fireSystem.color2 = new BABYLON.Color4(1, 0, 0, 1);
                    fireSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0);
                    fireSystem.minSize = 1 * scale;
                    fireSystem.maxSize = 4 * scale;
                    fireSystem.minLifeTime = 0.2;
                    fireSystem.maxLifeTime = 0.6;
                    fireSystem.emitRate = 500;
                    fireSystem.targetStopDuration = 0.5;
                    fireSystem.start();

                    // 2. Debris
                    const debrisCount = 10 * scale;
                    for(let i=0; i<debrisCount; i++) {
                        const debris = BABYLON.MeshBuilder.CreatePolyhedron("d", {type: 1, size: 0.5 * scale}, scene);
                        debris.position = position.clone();
                        debris.material = darkMat;
                        const dir = new BABYLON.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
                        
                        // Simple physics simulation for debris
                        scene.onBeforeRenderObservable.add(() => {
                            if(debris.scaling.x <= 0) return;
                            debris.position.addInPlace(dir.scale(0.5));
                            debris.rotation.addInPlace(dir);
                            debris.scaling.scaleInPlace(0.95); // shrink
                            if(debris.scaling.x < 0.1) debris.dispose();
                        });
                    }

                    // 3. Shockwave
                    const shockwave = BABYLON.MeshBuilder.CreateTorus("shock", {diameter: 1, thickness: 0.5}, scene);
                    shockwave.position = position;
                    shockwave.rotation.x = Math.PI/2;
                    const shockMat = new BABYLON.StandardMaterial("sm", scene);
                    shockMat.emissiveColor = new BABYLON.Color3(1, 1, 0.8);
                    shockMat.alpha = 0.8;
                    shockwave.material = shockMat;

                    let shockScale = 1;
                    const observer = scene.onBeforeRenderObservable.add(() => {
                        shockScale += 1.5;
                        shockwave.scaling = new BABYLON.Vector3(shockScale*scale, shockScale*scale, shockScale*scale);
                        shockMat.alpha -= 0.05;
                        if(shockMat.alpha <= 0) {
                            shockwave.dispose();
                            scene.onBeforeRenderObservable.remove(observer);
                        }
                    });

                    // Chain Reaction Check
                    ships.forEach(s => {
                        if (!s.dead && s.mesh) {
                            const dist = BABYLON.Vector3.Distance(position, s.mesh.position);
                            // Flagships explode bigger, Escorts smaller. 
                            // Check if ship is within blast radius (roughly one ship width ~ 10 units)
                            if (dist < CONFIG.chainReactionDist * scale) {
                                // Add random delay for dramatic effect
                                setTimeout(() => {
                                    if(!s.dead) s.takeDamage(9999); 
                                }, Math.random() * 500);
                            }
                        }
                    });
                }

                // --- Logic Class ---
                class Ship {
                    constructor(team, isFlagship, startPos) {
                        this.team = team;
                        this.isFlagship = isFlagship;
                        this.hp = isFlagship ? CONFIG.flagshipHP : CONFIG.escortHP;
                        this.maxHp = this.hp;
                        this.mesh = createShipMesh(isFlagship, team);
                        this.mesh.position = startPos;
                        this.dead = false;
                        
                        // Movement vars
                        this.velocity = new BABYLON.Vector3(0, 0, 0);
                        this.speed = isFlagship ? 0.2 : 0.4;
                        this.turnSpeed = isFlagship ? 0.01 : 0.03;

                        // Combat vars
                        this.lastFireTime = 0;
                        this.fireInterval = CONFIG.fireRateNormal + (Math.random() * 1000);

                        // UI
                        this.createHealthBar();
                    }

                    createHealthBar() {
                        this.uiRect = new BABYLON.GUI.Rectangle();
                        this.uiRect.width = "60px";
                        this.uiRect.height = "10px";
                        this.uiRect.cornerRadius = 5;
                        this.uiRect.color = "white";
                        this.uiRect.thickness = 1;
                        this.uiRect.background = "black";
                        advancedTexture.addControl(this.uiRect);
                        this.uiRect.linkWithMesh(this.mesh); 
                        this.uiRect.linkOffsetY = -30;

                        this.healthBar = new BABYLON.GUI.Rectangle();
                        this.healthBar.width = "100%";
                        this.healthBar.height = "100%";
                        this.healthBar.background = this.team === "blue" ? "cyan" : "orange";
                        this.uiRect.addControl(this.healthBar);
                    }

                    updateHealthUI() {
                        const pct = Math.max(0, this.hp / this.maxHp);
                        this.healthBar.width = pct;
                        if(pct <= 0) this.uiRect.dispose();
                    }

                    takeDamage(amount) {
                        if(this.dead) return;
                        this.hp -= amount;
                        this.updateHealthUI();
                        if(this.hp <= 0) {
                            this.die();
                        }
                    }

                    die() {
                        this.dead = true;
                        this.uiRect.dispose();
                        createExplosion(this.mesh.position, this.isFlagship ? 3 : 1);
                        this.mesh.dispose();
                        this.mesh = null;
                    }

                    update() {
                        if (this.dead) return;

                        // AI: Find nearest enemy
                        let target = null;
                        let minDst = 9999;
                        
                        ships.forEach(other => {
                            if(other.team !== this.team && !other.dead && other.mesh) {
                                const d = BABYLON.Vector3.Distance(this.mesh.position, other.mesh.position);
                                if(d < minDst) {
                                    minDst = d;
                                    target = other;
                                }
                            }
                        });

                        // Maneuver
                        if(target) {
                            // Look at target
                            const targetPos = target.mesh.position;
                            const directionToTarget = targetPos.subtract(this.mesh.position).normalize();
                            
                            // Separation logic (avoid crashing into friends)
                            let separation = new BABYLON.Vector3.Zero();
                            ships.forEach(other => {
                                if(other !== this && !other.dead && other.mesh) {
                                    const d = BABYLON.Vector3.Distance(this.mesh.position, other.mesh.position);
                                    if(d < 15) {
                                        const push = this.mesh.position.subtract(other.mesh.position).normalize().scale(15/d);
                                        separation.addInPlace(push);
                                    }
                                }
                            });

                            const desiredDir = directionToTarget.add(separation).normalize();
                            
                            // Smooth turn
                            const currentDir = this.mesh.forward;
                            const nextDir = BABYLON.Vector3.Lerp(currentDir, desiredDir, this.turnSpeed);
                            this.mesh.lookAt(this.mesh.position.add(nextDir));
                            
                            // Move
                            this.mesh.position.addInPlace(this.mesh.forward.scale(this.speed));

                            // Fire logic
                            const now = Date.now();
                            // Range check (< 150) and facing roughly towards enemy
                            if (minDst < 150 && BABYLON.Vector3.Dot(this.mesh.forward, directionToTarget) > 0.8) {
                                if (now - this.lastFireTime > this.fireInterval) {
                                    if (this.isFlagship) {
                                        // Double shot
                                        fireProjectile(this, target.mesh.position);
                                        setTimeout(() => { if(!this.dead) fireProjectile(this, target.mesh.position); }, 200);
                                    } else {
                                        fireProjectile(this, target.mesh.position);
                                    }
                                    this.lastFireTime = now;
                                }
                            }
                        } else {
                            // No enemies, patrol forward
                            this.mesh.position.addInPlace(this.mesh.forward.scale(this.speed * 0.5));
                        }

                        // Boundary containment (Keep them in the box)
                        if (this.mesh.position.length() > CONFIG.worldSize) {
                            this.mesh.lookAt(BABYLON.Vector3.Zero());
                        }
                    }
                }

                // --- Setup Fleets ---
                function spawnFleet(team, centerZ) {
                    // Flagship
                    ships.push(new Ship(team, true, new BABYLON.Vector3(0, 0, centerZ)));

                    // Escorts in V formation
                    const offsets = [
                        [-15, 10], [15, 10],
                        [-30, 20], [30, 20],
                        [-45, 30], [45, 30],
                        [0, 20],   [0, -20],
                        [-20, -10]
                    ];

                    for(let i=0; i<9; i++) {
                        const x = offsets[i] ? offsets[i][0] : (Math.random()*40 - 20);
                        const z = centerZ + (team === "blue" ? -1 : 1) * (offsets[i] ? offsets[i][1] : 20);
                        const y = (Math.random() * 20) - 10;
                        ships.push(new Ship(team, false, new BABYLON.Vector3(x, y, z)));
                    }
                }

                spawnFleet("blue", -80);
                spawnFleet("red", 80);

                // Orient fleets initially
                ships.forEach(s => {
                    if(s.team === "blue") s.mesh.lookAt(new BABYLON.Vector3(0,0,100));
                    else s.mesh.lookAt(new BABYLON.Vector3(0,0,-100));
                });


                // --- Game Loop ---
                scene.registerBeforeRender(() => {
                    // Update Ships
                    ships.forEach(s => s.update());

                    // Check Win Condition (console only or simple alert visual could be added, but keeping cinematic)
                    
                    // Update Projectiles
                    for (let i = projectiles.length - 1; i >= 0; i--) {
                        const p = projectiles[i];
                        p.mesh.position.addInPlace(p.direction.scale(p.speed * scene.getEngine().getDeltaTime() / 1000));
                        p.life--;

                        let hit = false;
                        // Collision Check
                        for (let s of ships) {
                            if (!s.dead && s.team !== p.team && s.mesh) {
                                // Hitbox size
                                const threshold = s.isFlagship ? 5 : 3;
                                if (BABYLON.Vector3.Distance(p.mesh.position, s.mesh.position) < threshold) {
                                    s.takeDamage(p.damage);
                                    // Small spark on hit
                                    const spark = BABYLON.MeshBuilder.CreatePlane("spark", {size: 2}, scene);
                                    spark.position = p.mesh.position;
                                    spark.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
                                    spark.material = new BABYLON.StandardMaterial("spk", scene);
                                    spark.material.emissiveColor = new BABYLON.Color3(1,1,1);
                                    setTimeout(() => spark.dispose(), 50);
                                    
                                    hit = true;
                                    break;
                                }
                            }
                        }

                        if (hit || p.life <= 0) {
                            p.mesh.dispose(); // Trail handles its own disposal usually or persists briefly
                            projectiles.splice(i, 1);
                        }
                    }
                });

                return scene;
            };

            const scene = createScene();

            engine.runRenderLoop(function() {
                scene.render();
            });

            window.addEventListener('resize', function() {
                engine.resize();
            });
        });
    </script>
</body>
</html>