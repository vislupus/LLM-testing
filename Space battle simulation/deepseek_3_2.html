<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Space Fleet Battle</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Orbitron', 'Arial', sans-serif;
        }

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            padding: 15px 30px;
            background: linear-gradient(90deg, rgba(0, 20, 60, 0.9), rgba(60, 0, 20, 0.9));
            border-bottom: 3px solid #00ffff;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            position: relative;
        }

        .title-container {
            flex: 1;
        }

        .title {
            font-size: 32px;
            font-weight: 900;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        .subtitle {
            font-size: 14px;
            color: #a0a0ff;
            opacity: 0.9;
            letter-spacing: 1px;
        }

        /* Fleet Stats */
        .fleet-stats {
            display: flex;
            gap: 30px;
        }

        .fleet-stat {
            text-align: center;
            padding: 10px 20px;
            border-radius: 10px;
            min-width: 150px;
            border: 2px solid;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
        }

        .fleet-stat.blue {
            border-color: #00aaff;
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.5);
        }

        .fleet-stat.red {
            border-color: #ff5555;
            box-shadow: 0 0 15px rgba(255, 85, 85, 0.5);
        }

        .fleet-name {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .fleet-name.blue {
            color: #00aaff;
        }

        .fleet-name.red {
            color: #ff5555;
        }

        .ship-count {
            font-size: 28px;
            font-weight: 900;
        }

        .ship-count.blue {
            color: #00ffff;
        }

        .ship-count.red {
            color: #ff5555;
        }

        /* Canvas */
        #renderCanvas {
            flex: 1;
            width: 100%;
            height: calc(100vh - 120px);
            display: block;
            touch-action: none;
        }

        /* Controls */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ffff;
            backdrop-filter: blur(5px);
            max-width: 300px;
            z-index: 10;
        }

        .controls-title {
            color: #00ffff;
            font-size: 18px;
            margin-bottom: 10px;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
            color: #a0a0ff;
        }

        .key {
            background: rgba(0, 170, 255, 0.3);
            color: #00ffff;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
            border: 1px solid #00aaff;
        }

        /* Battle Status */
        .battle-status {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ff00ff;
            backdrop-filter: blur(5px);
            max-width: 300px;
            z-index: 10;
        }

        .status-title {
            color: #ff00ff;
            font-size: 18px;
            margin-bottom: 10px;
            text-align: center;
        }

        .status-item {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
        }

        .status-label {
            color: #a0a0ff;
        }

        .status-value {
            color: #00ffff;
            font-weight: bold;
        }

        /* Camera Controls */
        .camera-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .camera-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            color: #00ffff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.3s;
        }

        .camera-btn:hover {
            background: #00ffff;
            color: #000;
            transform: scale(1.1);
            box-shadow: 0 0 20px #00ffff;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s ease;
        }

        .loading-title {
            font-size: 48px;
            color: transparent;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            background-clip: text;
            margin-bottom: 20px;
            text-align: center;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .loading-bar-container {
            width: 400px;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #00ffff;
            margin-bottom: 20px;
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            width: 0%;
            transition: width 0.3s ease;
        }

        .loading-text {
            font-size: 16px;
            color: #a0a0ff;
            text-align: center;
        }

        /* Explosion Alert */
        .explosion-alert {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #ff5555;
            font-weight: 900;
            text-shadow: 0 0 20px #ff0000;
            opacity: 0;
            pointer-events: none;
            z-index: 999;
            transition: opacity 0.5s;
        }

        /* Chain Reaction Alert */
        .chain-alert {
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: #ffaa00;
            font-weight: 900;
            text-shadow: 0 0 20px #ffaa00;
            opacity: 0;
            pointer-events: none;
            z-index: 999;
            transition: opacity 0.5s;
        }

        /* Footer */
        .footer {
            padding: 10px;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            font-size: 12px;
            color: #666;
            border-top: 1px solid #222;
            position: absolute;
            bottom: 0;
            width: 100%;
            z-index: 5;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .header {
                padding: 10px;
                flex-direction: column;
                gap: 10px;
            }
            
            .fleet-stats {
                width: 100%;
                justify-content: space-around;
            }
            
            .fleet-stat {
                min-width: 120px;
                padding: 8px 15px;
            }
            
            .controls, .battle-status {
                max-width: 250px;
            }
            
            .loading-title {
                font-size: 32px;
            }
            
            .loading-bar-container {
                width: 300px;
            }
        }

        @media (max-width: 768px) {
            .title {
                font-size: 24px;
            }
            
            .fleet-stat {
                min-width: 100px;
                padding: 5px 10px;
            }
            
            .fleet-name {
                font-size: 14px;
            }
            
            .ship-count {
                font-size: 20px;
            }
            
            .controls, .battle-status {
                max-width: 200px;
                padding: 10px;
            }
            
            .camera-btn {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
        }
    </style>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-title">SPACE FLEET BATTLE</div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div class="loading-text" id="loadingText">Initializing warp drives...</div>
    </div>

    <!-- Explosion Alerts -->
    <div class="explosion-alert" id="explosionAlert">SHIP DESTROYED!</div>
    <div class="chain-alert" id="chainAlert">CHAIN REACTION!</div>

    <!-- Header -->
    <div class="header">
        <div class="title-container">
            <div class="title">FLEET BATTLE: BLUE vs RED</div>
            <div class="subtitle">3D Space Combat Simulation • Chain Reaction Explosions • Cinematic Visuals</div>
        </div>
        <div class="fleet-stats">
            <div class="fleet-stat blue">
                <div class="fleet-name blue">BLUE FLEET</div>
                <div class="ship-count blue" id="blueCount">10</div>
            </div>
            <div class="fleet-stat red">
                <div class="fleet-name red">RED FLEET</div>
                <div class="ship-count red" id="redCount">10</div>
            </div>
        </div>
    </div>

    <!-- Canvas -->
    <canvas id="renderCanvas"></canvas>

    <!-- Controls -->
    <div class="controls">
        <div class="controls-title">
            <i class="fas fa-gamepad"></i>
            CONTROLS
        </div>
        <div class="control-item">
            <span>Orbit Camera:</span>
            <div class="key">Drag Mouse</div>
        </div>
        <div class="control-item">
            <span>Zoom:</span>
            <div class="key">Mouse Wheel</div>
        </div>
        <div class="control-item">
            <span>Pan Camera:</span>
            <div class="key">Right Drag</div>
        </div>
        <div class="control-item">
            <span>Reset View:</span>
            <div class="key">R Key</div>
        </div>
        <div class="control-item">
            <span>Pause Battle:</span>
            <div class="key">P Key</div>
        </div>
        <div class="control-item">
            <span>Slow Motion:</span>
            <div class="key">S Key</div>
        </div>
    </div>

    <!-- Battle Status -->
    <div class="battle-status">
        <div class="status-title">BATTLE STATUS</div>
        <div class="status-item">
            <span class="status-label">Battle Time:</span>
            <span class="status-value" id="battleTime">00:00</span>
        </div>
        <div class="status-item">
            <span class="status-label">Projectiles Fired:</span>
            <span class="status-value" id="projectileCount">0</span>
        </div>
        <div class="status-item">
            <span class="status-label">Explosions:</span>
            <span class="status-value" id="explosionCount">0</span>
        </div>
        <div class="status-item">
            <span class="status-label">Chain Reactions:</span>
            <span class="status-value" id="chainCount">0</span>
        </div>
        <div class="status-item">
            <span class="status-label">Damage Inflicted:</span>
            <span class="status-value" id="damageCount">0</span>
        </div>
    </div>

    <!-- Camera Controls -->
    <div class="camera-controls">
        <button class="camera-btn" id="cameraDefault" title="Default View">
            <i class="fas fa-satellite"></i>
        </button>
        <button class="camera-btn" id="cameraBlueFlagship" title="Focus Blue Flagship">
            <i class="fas fa-ship" style="color: #00aaff;"></i>
        </button>
        <button class="camera-btn" id="cameraRedFlagship" title="Focus Red Flagship">
            <i class="fas fa-ship" style="color: #ff5555;"></i>
        </button>
        <button class="camera-btn" id="cameraFollow" title="Follow Projectile">
            <i class="fas fa-bullseye"></i>
        </button>
    </div>

    <!-- Footer -->
    <div class="footer">
        3D Space Battle Simulation • Babylon.js • Chain Reaction Explosions • 
        <i class="fas fa-rocket"></i> Watch ships explode in spectacular chain reactions!
    </div>

    <script>
        // =====================
        // SPACE BATTLE ENGINE
        // =====================
        
        // Global variables
        let scene, engine, camera;
        let battle = {
            blueFleet: [],
            redFleet: [],
            projectiles: [],
            explosions: [],
            debris: [],
            stats: {
                startTime: Date.now(),
                projectilesFired: 0,
                explosions: 0,
                chainReactions: 0,
                damageInflicted: 0,
                blueShips: 10,
                redShips: 10
            },
            paused: false,
            slowMotion: false,
            battleTime: 0
        };

        // Ship classes
        class Ship {
            constructor(type, fleet, position, isFlagship = false) {
                this.type = type; // 'blue' or 'red'
                this.fleet = fleet;
                this.position = position;
                this.isFlagship = isFlagship;
                this.health = isFlagship ? 300 : 100;
                this.maxHealth = this.health;
                this.speed = isFlagship ? 0.3 : 0.5;
                this.turnSpeed = isFlagship ? 0.02 : 0.03;
                this.size = isFlagship ? 6 : 3;
                this.mesh = null;
                this.healthBar = null;
                this.engineGlow = null;
                this.engineTrail = null;
                this.target = null;
                this.direction = new BABYLON.Vector3(
                    Math.random() - 0.5,
                    Math.random() - 0.5,
                    Math.random() - 0.5
                ).normalize();
                this.rotation = BABYLON.Vector3.Zero();
                this.lastFireTime = 0;
                this.fireRate = 3000; // ms
                this.isDestroyed = false;
                this.id = Math.random().toString(36).substr(2, 9);
            }
        }

        // Projectile class
        class Projectile {
            constructor(type, position, direction, damage = 20) {
                this.type = type; // 'blue' or 'red'
                this.position = position.clone();
                this.direction = direction.clone().normalize();
                this.speed = 2;
                this.damage = damage;
                this.mesh = null;
                this.trail = null;
                this.lifetime = 5000; // ms
                this.createdTime = Date.now();
                this.id = Math.random().toString(36).substr(2, 9);
            }
        }

        // Initialize Babylon.js
        const initEngine = () => {
            updateLoading("Initializing space engine...", 10);
            
            const canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, { 
                preserveDrawingBuffer: true, 
                stencil: true,
                antialias: true
            });
            scene = new BABYLON.Scene(engine);
            
            updateLoading("Creating cosmic environment...", 20);
            
            // Create camera
            createCamera();
            
            // Create lighting
            createLighting();
            
            // Create space environment
            createSpaceEnvironment();
            
            // Create fleets
            createFleets();
            
            // Setup UI controls
            setupControls();
            
            updateLoading("Arming weapons systems...", 90);
            
            // Start render loop
            engine.runRenderLoop(() => {
                if (!battle.paused) {
                    const deltaTime = battle.slowMotion ? engine.getDeltaTime() * 0.3 : engine.getDeltaTime();
                    updateBattle(deltaTime);
                }
                scene.render();
            });
            
            // Handle resize
            window.addEventListener('resize', () => {
                engine.resize();
            });
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loadingScreen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    updateLoading("Battle ready! Engage!", 100);
                }, 1000);
            }, 2000);
        };

        // Create camera
        const createCamera = () => {
            // Arc rotate camera for orbiting around battle
            camera = new BABYLON.ArcRotateCamera("camera", 
                -Math.PI / 4, Math.PI / 3, 200, 
                BABYLON.Vector3.Zero(), scene);
            
            camera.attachControl(engine.getRenderingCanvas(), true);
            camera.lowerRadiusLimit = 50;
            camera.upperRadiusLimit = 1000;
            camera.wheelPrecision = 30;
            camera.panningSensibility = 50;
            camera.inertia = 0.9;
            camera.panningInertia = 0.9;
            
            // Add post-processing for cinematic effects
            const fx = new BABYLON.DefaultRenderingPipeline("fx", true, scene, [camera]);
            fx.samples = 4;
            fx.bloomEnabled = true;
            fx.bloomThreshold = 0.4;
            fx.bloomWeight = 0.5;
            fx.bloomKernel = 64;
            fx.bloomScale = 0.8;
            fx.glowLayerEnabled = true;
            fx.chromaticAberrationEnabled = true;
            fx.chromaticAberration.aberrationAmount = 10;
        };

        // Create lighting
        const createLighting = () => {
            // Ambient light for space
            const ambient = new BABYLON.HemisphericLight("ambient", 
                new BABYLON.Vector3(0, 1, 0), scene);
            ambient.intensity = 0.1;
            ambient.diffuse = new BABYLON.Color3(0.1, 0.2, 0.4);
            
            // Directional light for sun
            const sun = new BABYLON.DirectionalLight("sun", 
                new BABYLON.Vector3(-1, -0.5, -0.5), scene);
            sun.intensity = 0.5;
            sun.diffuse = new BABYLON.Color3(1, 0.9, 0.8);
            sun.position = new BABYLON.Vector3(100, 100, 100);
        };

        // Create space environment
        const createSpaceEnvironment = () => {
            // Create starfield using particle system
            createStarfield();
            
            // Create nebula background
            createNebula();
            
            // Add some distant galaxies/star clusters
            createDistantGalaxies();
        };

        // Create starfield
        const createStarfield = () => {
            const starCount = 2000;
            const starSize = 0.1;
            
            // Create star material
            const starMaterial = new BABYLON.StandardMaterial("starMaterial", scene);
            starMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1);
            starMaterial.disableLighting = true;
            
            // Create stars as small spheres
            for (let i = 0; i < starCount; i++) {
                const star = BABYLON.MeshBuilder.CreateSphere(`star_${i}`, {
                    diameter: starSize * (0.5 + Math.random())
                }, scene);
                
                // Random position in a sphere around origin
                const radius = 500 + Math.random() * 1000;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                star.position.x = radius * Math.sin(phi) * Math.cos(theta);
                star.position.y = radius * Math.sin(phi) * Math.sin(theta);
                star.position.z = radius * Math.cos(phi);
                
                star.material = starMaterial;
                
                // Make some stars twinkle
                if (Math.random() > 0.7) {
                    scene.registerBeforeRender(() => {
                        const scale = 0.8 + 0.4 * Math.sin(Date.now() * 0.001 + i);
                        star.scaling.set(scale, scale, scale);
                    });
                }
            }
        };

        // Create nebula
        const createNebula = () => {
            // Create a large sphere with transparent nebula texture
            const nebula = BABYLON.MeshBuilder.CreateSphere("nebula", {
                diameter: 3000,
                segments: 64
            }, scene);
            
            // Create shader material for nebula
            const nebulaMaterial = new BABYLON.ShaderMaterial("nebulaShader", scene, {
                vertexSource: `
                    precision highp float;
                    attribute vec3 position;
                    uniform mat4 worldViewProjection;
                    varying vec3 vPosition;
                    void main(void) {
                        gl_Position = worldViewProjection * vec4(position, 1.0);
                        vPosition = position;
                    }
                `,
                fragmentSource: `
                    precision highp float;
                    varying vec3 vPosition;
                    uniform float time;
                    
                    void main(void) {
                        // Create nebula-like patterns
                        vec3 pos = vPosition * 0.01;
                        float n1 = sin(pos.x * 2.0 + time * 0.1) * cos(pos.y * 3.0) * sin(pos.z * 1.5);
                        float n2 = cos(pos.x * 1.5 + time * 0.05) * sin(pos.y * 2.5) * cos(pos.z * 2.0);
                        float n3 = sin(pos.x * 3.0 + time * 0.02) * cos(pos.y * 1.0) * sin(pos.z * 2.5);
                        
                        float noise = (n1 + n2 + n3) / 3.0;
                        
                        // Create colorful nebula
                        vec3 color1 = vec3(0.3, 0.1, 0.5); // Purple
                        vec3 color2 = vec3(0.1, 0.2, 0.6); // Blue
                        vec3 color3 = vec3(0.6, 0.1, 0.2); // Red
                        
                        vec3 finalColor = mix(color1, color2, noise * 0.5 + 0.5);
                        finalColor = mix(finalColor, color3, noise * noise);
                        
                        float alpha = 0.05 + noise * 0.1;
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `
            }, {
                attributes: ["position"],
                uniforms: ["worldViewProjection", "time"]
            });
            
            nebulaMaterial.setFloat("time", 0);
            nebula.material = nebulaMaterial;
            nebula.position.y = -200;
            
            // Update time uniform for animation
            scene.registerBeforeRender(() => {
                nebulaMaterial.setFloat("time", Date.now() * 0.001);
            });
        };

        // Create distant galaxies
        const createDistantGalaxies = () => {
            // Create a few distant galaxy sprites
            for (let i = 0; i < 5; i++) {
                const galaxy = BABYLON.MeshBuilder.CreatePlane(`galaxy_${i}`, {
                    width: 100,
                    height: 100
                }, scene);
                
                // Position far away
                galaxy.position.x = (Math.random() - 0.5) * 2000;
                galaxy.position.y = (Math.random() - 0.5) * 1000;
                galaxy.position.z = 1000 + Math.random() * 1000;
                
                // Create galaxy material
                const galaxyMaterial = new BABYLON.StandardMaterial(`galaxyMat_${i}`, scene);
                galaxyMaterial.emissiveColor = new BABYLON.Color3(
                    0.2 + Math.random() * 0.3,
                    0.1 + Math.random() * 0.2,
                    0.3 + Math.random() * 0.4
                );
                galaxyMaterial.alpha = 0.1 + Math.random() * 0.2;
                galaxyMaterial.disableLighting = true;
                
                galaxy.material = galaxyMaterial;
                
                // Make galaxies face camera (billboard)
                galaxy.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
            }
        };

        // Create fleets
        const createFleets = () => {
            updateLoading("Deploying Blue Fleet...", 40);
            
            // Create Blue Fleet
            createFleet('blue', new BABYLON.Vector3(-100, 0, 0));
            
            updateLoading("Deploying Red Fleet...", 60);
            
            // Create Red Fleet
            createFleet('red', new BABYLON.Vector3(100, 0, 0));
            
            updateLoading("Forming battle formations...", 80);
        };

        // Create a fleet
        const createFleet = (type, centerPosition) => {
            const fleet = type === 'blue' ? battle.blueFleet : battle.redFleet;
            const color = type === 'blue' ? 
                new BABYLON.Color3(0.2, 0.5, 1.0) : 
                new BABYLON.Color3(1.0, 0.2, 0.2);
            
            // Create flagship
            const flagship = createShip(type, centerPosition, true);
            fleet.push(flagship);
            
            // Create 9 escort ships in formation around flagship
            const formationRadius = 40;
            for (let i = 0; i < 9; i++) {
                const angle = (i / 9) * Math.PI * 2;
                const offset = new BABYLON.Vector3(
                    Math.cos(angle) * formationRadius,
                    (Math.random() - 0.5) * 20,
                    Math.sin(angle) * formationRadius
                );
                
                const shipPosition = centerPosition.add(offset);
                const ship = createShip(type, shipPosition, false);
                fleet.push(ship);
            }
        };

        // Create a ship
        const createShip = (type, position, isFlagship) => {
            const ship = new Ship(type, type === 'blue' ? battle.blueFleet : battle.redFleet, 
                                position, isFlagship);
            
            // Create ship mesh based on type
            createShipMesh(ship);
            
            // Create health bar
            createHealthBar(ship);
            
            // Create engine effects
            createEngineEffects(ship);
            
            return ship;
        };

        // Create ship mesh
        const createShipMesh = (ship) => {
            let mesh;
            
            if (ship.isFlagship) {
                // Flagship - more detailed
                mesh = createFlagshipMesh(ship);
            } else {
                // Escort ship - simpler design
                mesh = createEscortMesh(ship);
            }
            
            // Position and scale
            mesh.position = ship.position;
            mesh.scaling.set(ship.size, ship.size, ship.size);
            
            // Set material color based on type
            const material = new BABYLON.StandardMaterial(`shipMat_${ship.id}`, scene);
            material.diffuseColor = ship.type === 'blue' ? 
                new BABYLON.Color3(0.2, 0.5, 1.0) : 
                new BABYLON.Color3(1.0, 0.2, 0.2);
            material.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            material.emissiveColor = material.diffuseColor.scale(0.3);
            
            // Add glow layer
            const gl = new BABYLON.GlowLayer("glow", scene);
            gl.intensity = 0.5;
            
            mesh.material = material;
            ship.mesh = mesh;
            
            return mesh;
        };

        // Create flagship mesh
        const createFlagshipMesh = (ship) => {
            // Create main hull
            const hull = BABYLON.MeshBuilder.CreateCylinder(`hull_${ship.id}`, {
                height: 4,
                diameter: 2,
                tessellation: 8
            }, scene);
            
            // Create command tower
            const tower = BABYLON.MeshBuilder.CreateBox(`tower_${ship.id}`, {
                width: 1.5,
                height: 2,
                depth: 1.5
            }, scene);
            tower.parent = hull;
            tower.position.y = 1.5;
            
            // Create wings/engines
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const wing = BABYLON.MeshBuilder.CreateBox(`wing_${ship.id}_${i}`, {
                    width: 0.5,
                    height: 0.3,
                    depth: 3
                }, scene);
                wing.parent = hull;
                wing.position.x = Math.cos(angle) * 1.5;
                wing.position.z = Math.sin(angle) * 1.5;
                wing.position.y = 0;
                wing.rotation.y = angle;
            }
            
            // Create weapon turrets
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const turret = BABYLON.MeshBuilder.CreateSphere(`turret_${ship.id}_${i}`, {
                    diameter: 0.8
                }, scene);
                turret.parent = hull;
                turret.position.x = Math.cos(angle) * 1.2;
                turret.position.z = Math.sin(angle) * 1.2;
                turret.position.y = 0.5;
                
                // Add gun barrels
                const barrel = BABYLON.MeshBuilder.CreateCylinder(`barrel_${ship.id}_${i}`, {
                    height: 2,
                    diameter: 0.2
                }, scene);
                barrel.parent = turret;
                barrel.position.z = 1;
                barrel.rotation.x = Math.PI / 2;
            }
            
            return hull;
        };

        // Create escort mesh
        const createEscortMesh = (ship) => {
            // Simple fighter design
            const hull = BABYLON.MeshBuilder.CreateBox(`hull_${ship.id}`, {
                width: 2,
                height: 0.8,
                depth: 4
            }, scene);
            
            // Add wings
            const wing1 = BABYLON.MeshBuilder.CreateBox(`wing1_${ship.id}`, {
                width: 4,
                height: 0.2,
                depth: 1
            }, scene);
            wing1.parent = hull;
            wing1.position.y = 0;
            wing1.position.x = 1.5;
            
            const wing2 = BABYLON.MeshBuilder.CreateBox(`wing2_${ship.id}`, {
                width: 4,
                height: 0.2,
                depth: 1
            }, scene);
            wing2.parent = hull;
            wing2.position.y = 0;
            wing2.position.x = -1.5;
            
            // Add cockpit
            const cockpit = BABYLON.MeshBuilder.CreateSphere(`cockpit_${ship.id}`, {
                diameter: 0.8
            }, scene);
            cockpit.parent = hull;
            cockpit.position.y = 0.4;
            cockpit.position.z = -1;
            
            return hull;
        };

        // Create health bar
        const createHealthBar = (ship) => {
            // Create health bar container
            const container = BABYLON.MeshBuilder.CreatePlane(`healthContainer_${ship.id}`, {
                width: 3,
                height: 0.3
            }, scene);
            
            container.parent = ship.mesh;
            container.position.y = ship.size + 1;
            container.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
            
            // Create health bar background
            const backgroundMaterial = new BABYLON.StandardMaterial(`healthBgMat_${ship.id}`, scene);
            backgroundMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            backgroundMaterial.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            container.material = backgroundMaterial;
            
            // Create health bar fill
            const fill = BABYLON.MeshBuilder.CreatePlane(`healthFill_${ship.id}`, {
                width: 2.8,
                height: 0.2
            }, scene);
            
            fill.parent = container;
            fill.position.z = -0.01; // Slightly in front
            
            const fillMaterial = new BABYLON.StandardMaterial(`healthFillMat_${ship.id}`, scene);
            fillMaterial.diffuseColor = new BABYLON.Color3(0, 1, 0);
            fillMaterial.emissiveColor = new BABYLON.Color3(0, 0.5, 0);
            fill.material = fillMaterial;
            
            ship.healthBar = {
                container: container,
                fill: fill,
                material: fillMaterial,
                fullWidth: 2.8
            };
            
            // Update health bar color based on health
            updateHealthBar(ship);
        };

        // Update health bar
        const updateHealthBar = (ship) => {
            if (!ship.healthBar || ship.isDestroyed) return;
            
            const healthPercent = ship.health / ship.maxHealth;
            
            // Update width
            ship.healthBar.fill.scaling.x = healthPercent;
            ship.healthBar.fill.position.x = -(ship.healthBar.fullWidth * (1 - healthPercent)) / 2;
            
            // Update color (green -> yellow -> red)
            if (healthPercent > 0.5) {
                const greenAmount = (healthPercent - 0.5) * 2;
                ship.healthBar.material.diffuseColor = new BABYLON.Color3(1 - greenAmount, 1, 0);
                ship.healthBar.material.emissiveColor = new BABYLON.Color3((1 - greenAmount) * 0.5, 0.5, 0);
            } else {
                const redAmount = 1 - (healthPercent * 2);
                ship.healthBar.material.diffuseColor = new BABYLON.Color3(1, redAmount, 0);
                ship.healthBar.material.emissiveColor = new BABYLON.Color3(0.5, redAmount * 0.5, 0);
            }
        };

        // Create engine effects
        const createEngineEffects = (ship) => {
            // Create engine glow
            const engineGlow = new BABYLON.PointLight(`engineGlow_${ship.id}`, 
                new BABYLON.Vector3(0, 0, -ship.size), scene);
            
            engineGlow.diffuse = ship.type === 'blue' ? 
                new BABYLON.Color3(0, 0.8, 1) : 
                new BABYLON.Color3(1, 0.2, 0.1);
            engineGlow.intensity = 2;
            engineGlow.range = 10;
            
            engineGlow.parent = ship.mesh;
            ship.engineGlow = engineGlow;
            
            // Create engine trail particles
            const trailSystem = new BABYLON.ParticleSystem(`trail_${ship.id}`, 100, scene);
            trailSystem.particleTexture = new BABYLON.Texture("https://i.imgur.com/8Qq2Xqg.png", scene);
            trailSystem.emitter = ship.mesh.position.clone();
            trailSystem.minEmitBox = new BABYLON.Vector3(0, 0, 0);
            trailSystem.maxEmitBox = new BABYLON.Vector3(0, 0, 0);
            
            trailSystem.color1 = ship.type === 'blue' ? 
                new BABYLON.Color4(0, 0.8, 1, 0.8) : 
                new BABYLON.Color4(1, 0.2, 0.1, 0.8);
            trailSystem.color2 = ship.type === 'blue' ? 
                new BABYLON.Color4(0.2, 0.5, 1, 0.5) : 
                new BABYLON.Color4(1, 0.5, 0.2, 0.5);
            trailSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0);
            
            trailSystem.minSize = 0.5;
            trailSystem.maxSize = 1.5;
            trailSystem.minLifeTime = 0.5;
            trailSystem.maxLifeTime = 1.5;
            trailSystem.emitRate = 50;
            trailSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            
            trailSystem.direction1 = new BABYLON.Vector3(0, 0, -1);
            trailSystem.direction2 = new BABYLON.Vector3(0, 0, -1);
            trailSystem.minEmitPower = 3;
            trailSystem.maxEmitPower = 5;
            trailSystem.updateSpeed = 0.01;
            
            trailSystem.start();
            ship.engineTrail = trailSystem;
            
            // Update trail position
            scene.registerBeforeRender(() => {
                if (ship.isDestroyed) {
                    trailSystem.stop();
                    return;
                }
                
                // Position trail at engine location
                const trailPosition = ship.mesh.position.clone();
                const forward = ship.mesh.forward.scale(-ship.size * 0.8);
                trailPosition.addInPlace(forward);
                trailSystem.emitter = trailPosition;
                
                // Adjust trail direction based on ship movement
                trailSystem.direction1 = ship.direction.scale(-1);
                trailSystem.direction2 = ship.direction.scale(-1);
            });
        };

        // Update battle
        const updateBattle = (deltaTime) => {
            // Update battle time
            battle.battleTime += deltaTime / 1000;
            
            // Update ships
            updateShips(deltaTime);
            
            // Update projectiles
            updateProjectiles(deltaTime);
            
            // Update explosions
            updateExplosions(deltaTime);
            
            // Update UI
            updateUI();
        };

        // Update ships
        const updateShips = (deltaTime) => {
            // Update blue fleet
            battle.blueFleet.forEach(ship => {
                if (ship.isDestroyed) return;
                updateShip(ship, deltaTime);
            });
            
            // Update red fleet
            battle.redFleet.forEach(ship => {
                if (ship.isDestroyed) return;
                updateShip(ship, deltaTime);
            });
        };

        // Update individual ship
        const updateShip = (ship, deltaTime) => {
            // Find target
            if (!ship.target || ship.target.isDestroyed) {
                findTarget(ship);
            }
            
            // Move ship
            moveShip(ship, deltaTime);
            
            // Try to fire at target
            tryFire(ship);
            
            // Update health bar
            updateHealthBar(ship);
        };

        // Find target for ship
        const findTarget = (ship) => {
            const enemyFleet = ship.type === 'blue' ? battle.redFleet : battle.blueFleet;
            const aliveEnemies = enemyFleet.filter(enemy => !enemy.isDestroyed);
            
            if (aliveEnemies.length > 0) {
                // Prioritize flagship if available
                const flagship = aliveEnemies.find(enemy => enemy.isFlagship);
                ship.target = flagship || aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
            }
        };

        // Move ship
        const moveShip = (ship, deltaTime) => {
            if (!ship.mesh) return;
            
            // Basic AI movement
            if (ship.target && !ship.target.isDestroyed) {
                // Calculate direction to target
                const toTarget = ship.target.mesh.position.subtract(ship.mesh.position);
                const distance = toTarget.length();
                
                // Move toward or away from target based on distance
                if (distance > 100) {
                    // Too far, move toward
                    ship.direction = toTarget.normalize();
                } else if (distance < 30) {
                    // Too close, move away
                    ship.direction = toTarget.scale(-1).normalize();
                } else {
                    // Maintain distance, maneuver
                    const maneuver = new BABYLON.Vector3(
                        Math.sin(Date.now() * 0.001 + ship.id.charCodeAt(0)) * 0.5,
                        Math.cos(Date.now() * 0.002 + ship.id.charCodeAt(1)) * 0.5,
                        Math.sin(Date.now() * 0.003 + ship.id.charCodeAt(2)) * 0.5
                    );
                    ship.direction = toTarget.add(maneuver).normalize();
                }
            } else {
                // No target, random movement
                const randomTurn = new BABYLON.Vector3(
                    (Math.random() - 0.5) * ship.turnSpeed,
                    (Math.random() - 0.5) * ship.turnSpeed,
                    (Math.random() - 0.5) * ship.turnSpeed
                );
                ship.direction = ship.direction.add(randomTurn).normalize();
            }
            
            // Apply movement
            const movement = ship.direction.scale(ship.speed * deltaTime * 0.1);
            ship.mesh.position.addInPlace(movement);
            
            // Rotate ship to face movement direction
            const targetRotation = Math.atan2(ship.direction.x, ship.direction.z);
            ship.mesh.rotation.y = BABYLON.Scalar.Lerp(ship.mesh.rotation.y, targetRotation, ship.turnSpeed);
            
            // Add some pitch based on vertical movement
            ship.mesh.rotation.x = ship.direction.y * 0.5;
        };

        // Try to fire at target
        const tryFire = (ship) => {
            if (!ship.target || ship.target.isDestroyed) return;
            
            const currentTime = Date.now();
            if (currentTime - ship.lastFireTime >= ship.fireRate) {
                // Calculate direction to target
                const toTarget = ship.target.mesh.position.subtract(ship.mesh.position);
                const distance = toTarget.length();
                
                // Only fire if within range
                if (distance < 200) {
                    fireProjectile(ship);
                    ship.lastFireTime = currentTime;
                }
            }
        };

        // Fire projectile
        const fireProjectile = (ship) => {
            const projectileCount = ship.isFlagship ? 2 : 1;
            
            for (let i = 0; i < projectileCount; i++) {
                // Calculate fire direction (slightly randomized for spread)
                const spread = (Math.random() - 0.5) * 0.1;
                const fireDirection = ship.mesh.forward.scale(-1);
                fireDirection.y += spread;
                fireDirection.normalize();
                
                // Calculate fire position (from ship's front)
                const firePosition = ship.mesh.position.clone();
                const forwardOffset = ship.mesh.forward.scale(-ship.size * 0.8);
                firePosition.addInPlace(forwardOffset);
                
                // Create projectile
                const projectile = new Projectile(ship.type, firePosition, fireDirection);
                createProjectileMesh(projectile);
                battle.projectiles.push(projectile);
                battle.stats.projectilesFired++;
            }
        };

        // Create projectile mesh
        const createProjectileMesh = (projectile) => {
            // Create projectile mesh (small sphere)
            const mesh = BABYLON.MeshBuilder.CreateSphere(`projectile_${projectile.id}`, {
                diameter: 0.5
            }, scene);
            
            mesh.position = projectile.position;
            
            // Create projectile material
            const material = new BABYLON.StandardMaterial(`projectileMat_${projectile.id}`, scene);
            material.diffuseColor = projectile.type === 'blue' ? 
                new BABYLON.Color3(0, 0.8, 1) : 
                new BABYLON.Color3(1, 0.2, 0.1);
            material.emissiveColor = material.diffuseColor.scale(2);
            material.specularColor = new BABYLON.Color3(1, 1, 1);
            
            mesh.material = material;
            
            // Add glow effect
            const gl = new BABYLON.GlowLayer("glow", scene);
            gl.intensity = 1.5;
            
            // Create trail
            const trailSystem = new BABYLON.ParticleSystem(`projectileTrail_${projectile.id}`, 50, scene);
            trailSystem.particleTexture = new BABYLON.Texture("https://i.imgur.com/8Qq2Xqg.png", scene);
            trailSystem.emitter = mesh.position;
            trailSystem.minEmitBox = new BABYLON.Vector3(0, 0, 0);
            trailSystem.maxEmitBox = new BABYLON.Vector3(0, 0, 0);
            
            trailSystem.color1 = projectile.type === 'blue' ? 
                new BABYLON.Color4(0, 0.8, 1, 0.8) : 
                new BABYLON.Color4(1, 0.2, 0.1, 0.8);
            trailSystem.color2 = projectile.type === 'blue' ? 
                new BABYLON.Color4(0.5, 0.8, 1, 0.5) : 
                new BABYLON.Color4(1, 0.5, 0.3, 0.5);
            trailSystem.colorDead = new BABYLON.Color4(0, 0, 0, 0);
            
            trailSystem.minSize = 0.2;
            trailSystem.maxSize = 0.5;
            trailSystem.minLifeTime = 0.3;
            trailSystem.maxLifeTime = 0.6;
            trailSystem.emitRate = 100;
            trailSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            
            trailSystem.direction1 = new BABYLON.Vector3(0, 0, 0);
            trailSystem.direction2 = new BABYLON.Vector3(0, 0, 0);
            trailSystem.minEmitPower = 0;
            trailSystem.maxEmitPower = 0;
            trailSystem.updateSpeed = 0.01;
            
            trailSystem.start();
            
            projectile.mesh = mesh;
            projectile.trail = trailSystem;
        };

        // Update projectiles
        const updateProjectiles = (deltaTime) => {
            for (let i = battle.projectiles.length - 1; i >= 0; i--) {
                const projectile = battle.projectiles[i];
                
                // Check lifetime
                if (Date.now() - projectile.createdTime > projectile.lifetime) {
                    removeProjectile(projectile, i);
                    continue;
                }
                
                // Update position
                const movement = projectile.direction.scale(projectile.speed * deltaTime * 0.1);
                projectile.mesh.position.addInPlace(movement);
                projectile.position = projectile.mesh.position.clone();
                
                // Update trail position
                if (projectile.trail) {
                    projectile.trail.emitter = projectile.position;
                }
                
                // Check collisions
                checkProjectileCollision(projectile, i);
            }
        };

        // Check projectile collision
        const checkProjectileCollision = (projectile, projectileIndex) => {
            // Check against enemy ships
            const enemyFleet = projectile.type === 'blue' ? battle.redFleet : battle.blueFleet;
            
            for (const ship of enemyFleet) {
                if (ship.isDestroyed) continue;
                
                const distance = BABYLON.Vector3.Distance(projectile.position, ship.mesh.position);
                
                if (distance < ship.size * 2) {
                    // Hit!
                    ship.health -= projectile.damage;
                    battle.stats.damageInflicted += projectile.damage;
                    
                    // Show hit effect
                    createHitEffect(projectile.position, projectile.type);
                    
                    // Remove projectile
                    removeProjectile(projectile, projectileIndex);
                    
                    // Check if ship is destroyed
                    if (ship.health <= 0 && !ship.isDestroyed) {
                        destroyShip(ship);
                    }
                    
                    break;
                }
            }
        };

        // Create hit effect
        const createHitEffect = (position, type) => {
            // Create small explosion at hit location
            const hitExplosion = new BABYLON.ParticleSystem(`hit_${Date.now()}`, 100, scene);
            hitExplosion.particleTexture = new BABYLON.Texture("https://i.imgur.com/8Qq2Xqg.png", scene);
            hitExplosion.emitter = position;
            
            hitExplosion.color1 = type === 'blue' ? 
                new BABYLON.Color4(0, 0.8, 1, 1) : 
                new BABYLON.Color4(1, 0.2, 0.1, 1);
            hitExplosion.color2 = new BABYLON.Color4(1, 1, 0.8, 0.8);
            hitExplosion.colorDead = new BABYLON.Color4(0, 0, 0, 0);
            
            hitExplosion.minSize = 0.2;
            hitExplosion.maxSize = 0.5;
            hitExplosion.minLifeTime = 0.2;
            hitExplosion.maxLifeTime = 0.5;
            hitExplosion.emitRate = 500;
            hitExplosion.manualEmitCount = 50;
            hitExplosion.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            
            hitExplosion.direction1 = new BABYLON.Vector3(-1, -1, -1);
            hitExplosion.direction2 = new BABYLON.Vector3(1, 1, 1);
            hitExplosion.minEmitPower = 1;
            hitExplosion.maxEmitPower = 3;
            hitExplosion.updateSpeed = 0.01;
            
            hitExplosion.start();
            
            // Auto-remove after short time
            setTimeout(() => {
                hitExplosion.stop();
                setTimeout(() => hitExplosion.dispose(), 1000);
            }, 100);
        };

        // Remove projectile
        const removeProjectile = (projectile, index) => {
            if (projectile.mesh) projectile.mesh.dispose();
            if (projectile.trail) {
                projectile.trail.stop();
                setTimeout(() => projectile.trail.dispose(), 1000);
            }
            battle.projectiles.splice(index, 1);
        };

        // Destroy ship
        const destroyShip = (ship) => {
            ship.isDestroyed = true;
            battle.stats.explosions++;
            
            // Update fleet counts
            if (ship.type === 'blue') {
                battle.stats.blueShips--;
            } else {
                battle.stats.redShips--;
            }
            
            // Create explosion
            createExplosion(ship.mesh.position, ship.size, ship.type);
            
            // Check for chain reaction
            checkChainReaction(ship.mesh.position, ship.size);
            
            // Remove ship
            removeShip(ship);
            
            // Show explosion alert
            showExplosionAlert();
        };

        // Create explosion
        const createExplosion = (position, size, type) => {
            // Main explosion particle system
            const explosion = new BABYLON.ParticleSystem(`explosion_${Date.now()}`, 5000, scene);
            explosion.particleTexture = new BABYLON.Texture("https://i.imgur.com/8Qq2Xqg.png", scene);
            explosion.emitter = position;
            
            // Explosion colors based on ship type
            explosion.color1 = type === 'blue' ? 
                new BABYLON.Color4(0, 0.8, 1, 1) : 
                new BABYLON.Color4(1, 0.2, 0.1, 1);
            explosion.color2 = new BABYLON.Color4(1, 0.8, 0, 1);
            explosion.colorDead = new BABYLON.Color4(0.5, 0, 0, 0);
            
            explosion.minSize = 0.5;
            explosion.maxSize = size * 2;
            explosion.minLifeTime = 0.5;
            explosion.maxLifeTime = 2;
            explosion.emitRate = 5000;
            explosion.manualEmitCount = 500;
            explosion.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            
            explosion.direction1 = new BABYLON.Vector3(-5, -5, -5);
            explosion.direction2 = new BABYLON.Vector3(5, 5, 5);
            explosion.minEmitPower = 2;
            explosion.maxEmitPower = 10;
            explosion.updateSpeed = 0.01;
            
            explosion.start();
            
            // Shockwave sphere
            const shockwave = BABYLON.MeshBuilder.CreateSphere(`shockwave_${Date.now()}`, {
                diameter: 1,
                segments: 16
            }, scene);
            shockwave.position = position.clone();
            
            const shockwaveMat = new BABYLON.StandardMaterial(`shockwaveMat_${Date.now()}`, scene);
            shockwaveMat.diffuseColor = new BABYLON.Color3(1, 0.8, 0);
            shockwaveMat.alpha = 0.5;
            shockwaveMat.emissiveColor = new BABYLON.Color3(1, 0.5, 0);
            shockwave.material = shockwaveMat;
            
            // Animate shockwave expansion
            let scale = 1;
            scene.registerBeforeRender(() => {
                scale += 2;
                shockwave.scaling.set(scale, scale, scale);
                shockwaveMat.alpha -= 0.02;
                
                if (shockwaveMat.alpha <= 0) {
                    shockwave.dispose();
                }
            });
            
            // Sparks particle system
            const sparks = new BABYLON.ParticleSystem(`sparks_${Date.now()}`, 1000, scene);
            sparks.particleTexture = new BABYLON.Texture("https://i.imgur.com/8Qq2Xqg.png", scene);
            sparks.emitter = position;
            
            sparks.color1 = new BABYLON.Color4(1, 1, 0.5, 1);
            sparks.color2 = new BABYLON.Color4(1, 0.5, 0, 1);
            sparks.colorDead = new BABYLON.Color4(0.2, 0, 0, 0);
            
            sparks.minSize = 0.1;
            sparks.maxSize = 0.3;
            sparks.minLifeTime = 0.5;
            sparks.maxLifeTime = 2;
            sparks.emitRate = 2000;
            sparks.manualEmitCount = 200;
            sparks.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            
            sparks.direction1 = new BABYLON.Vector3(-3, -3, -3);
            sparks.direction2 = new BABYLON.Vector3(3, 3, 3);
            sparks.minEmitPower = 1;
            sparks.maxEmitPower = 5;
            sparks.updateSpeed = 0.01;
            
            sparks.start();
            
            // Debris
            createDebris(position, size * 5);
            
            // Auto-remove explosion effects
            setTimeout(() => {
                explosion.stop();
                sparks.stop();
                setTimeout(() => {
                    explosion.dispose();
                    sparks.dispose();
                }, 2000);
            }, 500);
            
            // Add to explosions list
            battle.explosions.push({
                position: position,
                size: size,
                time: Date.now()
            });
        };

        // Create debris
        const createDebris = (position, count) => {
            for (let i = 0; i < count; i++) {
                const debris = BABYLON.MeshBuilder.CreateBox(`debris_${Date.now()}_${i}`, {
                    size: 0.2 + Math.random() * 0.5
                }, scene);
                
                debris.position = position.clone();
                
                const debrisMat = new BABYLON.StandardMaterial(`debrisMat_${Date.now()}_${i}`, scene);
                debrisMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                debrisMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                debris.material = debrisMat;
                
                // Random velocity
                const velocity = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5
                );
                
                // Random rotation
                const rotationVelocity = new BABYLON.Vector3(
                    Math.random() * 0.1,
                    Math.random() * 0.1,
                    Math.random() * 0.1
                );
                
                // Add to scene and update
                battle.debris.push({
                    mesh: debris,
                    velocity: velocity,
                    rotationVelocity: rotationVelocity,
                    created: Date.now()
                });
            }
        };

        // Check for chain reaction
        const checkChainReaction = (explosionPosition, explosionSize) => {
            const chainRadius = explosionSize * 3; // About one ship width
            
            // Check blue fleet
            battle.blueFleet.forEach(ship => {
                if (!ship.isDestroyed) {
                    const distance = BABYLON.Vector3.Distance(explosionPosition, ship.mesh.position);
                    if (distance < chainRadius) {
                        // Chain reaction!
                        ship.health = 0;
                        destroyShip(ship);
                        battle.stats.chainReactions++;
                        showChainAlert();
                    }
                }
            });
            
            // Check red fleet
            battle.redFleet.forEach(ship => {
                if (!ship.isDestroyed) {
                    const distance = BABYLON.Vector3.Distance(explosionPosition, ship.mesh.position);
                    if (distance < chainRadius) {
                        // Chain reaction!
                        ship.health = 0;
                        destroyShip(ship);
                        battle.stats.chainReactions++;
                        showChainAlert();
                    }
                }
            });
        };

        // Remove ship
        const removeShip = (ship) => {
            // Dispose of mesh
            if (ship.mesh) ship.mesh.dispose();
            
            // Dispose of health bar
            if (ship.healthBar) {
                ship.healthBar.container.dispose();
                ship.healthBar.fill.dispose();
            }
            
            // Dispose of engine effects
            if (ship.engineGlow) ship.engineGlow.dispose();
            if (ship.engineTrail) {
                ship.engineTrail.stop();
                setTimeout(() => ship.engineTrail.dispose(), 1000);
            }
        };

        // Update explosions
        const updateExplosions = (deltaTime) => {
            // Update debris
            for (let i = battle.debris.length - 1; i >= 0; i--) {
                const debris = battle.debris[i];
                
                // Remove old debris
                if (Date.now() - debris.created > 5000) {
                    debris.mesh.dispose();
                    battle.debris.splice(i, 1);
                    continue;
                }
                
                // Update position
                debris.mesh.position.addInPlace(debris.velocity.scale(deltaTime * 0.001));
                
                // Update rotation
                debris.mesh.rotation.x += debris.rotationVelocity.x;
                debris.mesh.rotation.y += debris.rotationVelocity.y;
                debris.mesh.rotation.z += debris.rotationVelocity.z;
                
                // Apply gravity (slight pull toward center)
                const toCenter = BABYLON.Vector3.Zero().subtract(debris.mesh.position).normalize().scale(0.01);
                debris.velocity.addInPlace(toCenter);
            }
        };

        // Show explosion alert
        const showExplosionAlert = () => {
            const alert = document.getElementById('explosionAlert');
            alert.style.opacity = '1';
            
            setTimeout(() => {
                alert.style.opacity = '0';
            }, 1000);
        };

        // Show chain reaction alert
        const showChainAlert = () => {
            const alert = document.getElementById('chainAlert');
            alert.style.opacity = '1';
            
            setTimeout(() => {
                alert.style.opacity = '0';
            }, 1500);
        };

        // Update UI
        const updateUI = () => {
            // Update fleet counts
            document.getElementById('blueCount').textContent = battle.stats.blueShips;
            document.getElementById('redCount').textContent = battle.stats.redShips;
            
            // Format battle time
            const minutes = Math.floor(battle.battleTime / 60);
            const seconds = Math.floor(battle.battleTime % 60);
            document.getElementById('battleTime').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Update stats
            document.getElementById('projectileCount').textContent = battle.stats.projectilesFired;
            document.getElementById('explosionCount').textContent = battle.stats.explosions;
            document.getElementById('chainCount').textContent = battle.stats.chainReactions;
            document.getElementById('damageCount').textContent = battle.stats.damageInflicted;
            
            // Check for battle end
            if (battle.stats.blueShips <= 0 || battle.stats.redShips <= 0) {
                endBattle();
            }
        };

        // End battle
        const endBattle = () => {
            if (battle.ended) return;
            battle.ended = true;
            
            const winner = battle.stats.blueShips > 0 ? 'BLUE FLEET' : 'RED FLEET';
            const winnerColor = battle.stats.blueShips > 0 ? '#00aaff' : '#ff5555';
            
            // Create victory message
            const victoryMessage = document.createElement('div');
            victoryMessage.style.position = 'fixed';
            victoryMessage.style.top = '50%';
            victoryMessage.style.left = '50%';
            victoryMessage.style.transform = 'translate(-50%, -50%)';
            victoryMessage.style.fontSize = '64px';
            victoryMessage.style.fontWeight = '900';
            victoryMessage.style.color = winnerColor;
            victoryMessage.style.textShadow = `0 0 30px ${winnerColor}`;
            victoryMessage.style.textAlign = 'center';
            victoryMessage.style.zIndex = '1000';
            victoryMessage.innerHTML = `${winner} VICTORY!<br><span style="font-size: 24px;">Battle Complete</span>`;
            victoryMessage.id = 'victoryMessage';
            
            document.body.appendChild(victoryMessage);
            
            // Pause battle
            battle.paused = true;
        };

        // Setup controls
        const setupControls = () => {
            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'r':
                        // Reset camera
                        camera.alpha = -Math.PI / 4;
                        camera.beta = Math.PI / 3;
                        camera.radius = 200;
                        camera.target = BABYLON.Vector3.Zero();
                        break;
                        
                    case 'p':
                        // Pause battle
                        battle.paused = !battle.paused;
                        break;
                        
                    case 's':
                        // Slow motion
                        battle.slowMotion = !battle.slowMotion;
                        break;
                        
                    case ' ':
                        // Fire test projectile
                        if (battle.blueFleet.length > 0 && !battle.blueFleet[0].isDestroyed) {
                            fireProjectile(battle.blueFleet[0]);
                        }
                        break;
                }
            });
            
            // Camera controls
            document.getElementById('cameraDefault').addEventListener('click', () => {
                camera.alpha = -Math.PI / 4;
                camera.beta = Math.PI / 3;
                camera.radius = 200;
                camera.target = BABYLON.Vector3.Zero();
            });
            
            document.getElementById('cameraBlueFlagship').addEventListener('click', () => {
                const flagship = battle.blueFleet.find(ship => ship.isFlagship && !ship.isDestroyed);
                if (flagship) {
                    camera.target = flagship.mesh.position;
                    camera.radius = 50;
                }
            });
            
            document.getElementById('cameraRedFlagship').addEventListener('click', () => {
                const flagship = battle.redFleet.find(ship => ship.isFlagship && !ship.isDestroyed);
                if (flagship) {
                    camera.target = flagship.mesh.position;
                    camera.radius = 50;
                }
            });
            
            document.getElementById('cameraFollow').addEventListener('click', () => {
                if (battle.projectiles.length > 0) {
                    const projectile = battle.projectiles[Math.floor(Math.random() * battle.projectiles.length)];
                    camera.target = projectile.mesh.position;
                    camera.radius = 20;
                }
            });
        };

        // Update loading progress
        const updateLoading = (text, progress) => {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingBar').style.width = `${progress}%`;
        };

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', () => {
            initEngine();
        });
    </script>
</body>
</html>