<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Osogovo Terrain Diorama - Babylon.js</title>
  <style>
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #9fc7ff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
      display: block;
    }
  </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<!-- Babylon.js CDN -->
<script src="https://cdn.babylonjs.com/babylon.js"></script>

<script>
  window.addEventListener("DOMContentLoaded", function () {
    var canvas = document.getElementById("renderCanvas");
    var engine = new BABYLON.Engine(canvas, true, {
      preserveDrawingBuffer: true,
      stencil: true
    });

    function createScene() {
      var scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0.78, 0.9, 1.0, 1.0);

      // Camera
      var camera = new BABYLON.ArcRotateCamera(
        "camera",
        BABYLON.Tools.ToRadians(-135),
        BABYLON.Tools.ToRadians(60),
        350,
        new BABYLON.Vector3(0, 40, 0),
        scene
      );
      camera.attachControl(canvas, true);
      camera.lowerRadiusLimit = 120;
      camera.upperRadiusLimit = 600;
      camera.wheelDeltaPercentage = 0.01;
      camera.lowerBetaLimit = BABYLON.Tools.ToRadians(20);
      camera.upperBetaLimit = BABYLON.Tools.ToRadians(85);

      // Lights
      var hemiLight = new BABYLON.HemisphericLight(
        "hemiLight",
        new BABYLON.Vector3(0, 1, 0),
        scene
      );
      hemiLight.intensity = 0.7;
      hemiLight.groundColor = new BABYLON.Color3(0.65, 0.7, 0.75);

      var dirLight = new BABYLON.DirectionalLight(
        "dirLight",
        new BABYLON.Vector3(-0.6, -1.0, -0.4),
        scene
      );
      dirLight.position = new BABYLON.Vector3(150, 200, 100);
      dirLight.intensity = 1.0;

      var shadowGenerator = new BABYLON.ShadowGenerator(2048, dirLight);
      shadowGenerator.useBlurExponentialShadowMap = true;
      shadowGenerator.blurKernel = 32;

      // Sizes
      var groundSize = 200;          // X/Z size of terrain
      var pedestalDepth = 40;        // Depth of diorama box
      var bottomY = -pedestalDepth;  // Y of the closed bottom

      // Box / wall material
      var pedMat = new BABYLON.StandardMaterial("pedMat", scene);
      pedMat.diffuseColor = new BABYLON.Color3(0.82, 0.82, 0.86);
      pedMat.specularColor = new BABYLON.Color3(0.15, 0.15, 0.2);
      pedMat.emissiveColor = new BABYLON.Color3(0.02, 0.02, 0.03);
      pedMat.backFaceCulling = false;

      // Terrain material
      var terrainMaterial = new BABYLON.StandardMaterial("terrainMat", scene);
      terrainMaterial.diffuseTexture = new BABYLON.Texture("Osogovo_map.jpg", scene);
      terrainMaterial.diffuseTexture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;
      terrainMaterial.diffuseTexture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
      terrainMaterial.specularColor = new BABYLON.Color3(0.18, 0.18, 0.18);
      terrainMaterial.emissiveColor = new BABYLON.Color3(0.02, 0.02, 0.02);
      terrainMaterial.backFaceCulling = true;

      // Marker material
      var markerMat = new BABYLON.StandardMaterial("markerMat", scene);
      markerMat.diffuseColor = new BABYLON.Color3(1.0, 0.3, 0.2);
      markerMat.emissiveColor = new BABYLON.Color3(0.3, 0.08, 0.05);
      markerMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

      // Terrain params
      var minHeight = 0;
      var maxHeight = 40;
      var subdivisions = 200;

      // Helper: billboard label
      function createLabelPlane(name, text, scene) {
        var texWidth = 512;
        var texHeight = 256;

        var dynamicTexture = new BABYLON.DynamicTexture(
          name + "Texture",
          { width: texWidth, height: texHeight },
          scene,
          false
        );
        dynamicTexture.hasAlpha = true;

        var ctx = dynamicTexture.getContext();
        var bg = "rgba(0,0,0,0.6)";
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, texWidth, texHeight);

        var fontSize = 60;
        var font = "bold " + fontSize + "px Arial";
        dynamicTexture.drawText(
          text,
          40,
          texHeight / 2 + fontSize / 3,
          font,
          "white",
          bg,
          true
        );

        var mat = new BABYLON.StandardMaterial(name + "Mat", scene);
        mat.diffuseTexture = dynamicTexture;
        mat.emissiveColor = new BABYLON.Color3(1, 1, 1);
        mat.specularColor = new BABYLON.Color3(0, 0, 0);
        mat.backFaceCulling = false;
        mat.alpha = 0.96;

        var plane = BABYLON.MeshBuilder.CreatePlane(name, {
          width: 24,
          height: 12
        }, scene);
        plane.material = mat;
        plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

        return plane;
      }

      // Helper: create box walls & bottom from terrain edges
      function buildDioramaBoxFromTerrain(mesh, positions) {
        var n = subdivisions + 1;

        function edgeVertices(which) {
          var verts = [];
          var idx;
          var i;

          if (which === "south") { // z = -size/2
            for (i = 0; i < n; i++) {
              idx = i * 3;
              verts.push(new BABYLON.Vector3(
                positions[idx],
                positions[idx + 1],
                positions[idx + 2]
              ));
            }
          } else if (which === "north") { // z = +size/2
            var rowStart = (n - 1) * n;
            for (i = 0; i < n; i++) {
              idx = (rowStart + i) * 3;
              verts.push(new BABYLON.Vector3(
                positions[idx],
                positions[idx + 1],
                positions[idx + 2]
              ));
            }
          } else if (which === "west") { // x = -size/2
            for (i = 0; i < n; i++) {
              idx = (i * n) * 3;
              verts.push(new BABYLON.Vector3(
                positions[idx],
                positions[idx + 1],
                positions[idx + 2]
              ));
            }
          } else if (which === "east") { // x = +size/2
            for (i = 0; i < n; i++) {
              idx = (i * n + (n - 1)) * 3;
              verts.push(new BABYLON.Vector3(
                positions[idx],
                positions[idx + 1],
                positions[idx + 2]
              ));
            }
          }
          return verts;
        }

        function createWall(name, which) {
          var top = edgeVertices(which);
          var bottom = top.map(function (v) {
            return new BABYLON.Vector3(v.x, bottomY, v.z);
          });

          var wall = BABYLON.MeshBuilder.CreateRibbon(name, {
            pathArray: [top, bottom],
            closeArray: false,
            closePath: false,
            sideOrientation: BABYLON.Mesh.DOUBLESIDE
          }, scene);
          wall.material = pedMat;
          wall.receiveShadows = true;
          shadowGenerator.addShadowCaster(wall);
        }

        createWall("wallSouth", "south");
        createWall("wallNorth", "north");
        createWall("wallWest", "west");
        createWall("wallEast", "east");

        // Bottom â€“ flat and closed
        var bottom = BABYLON.MeshBuilder.CreateGround("bottom", {
          width: groundSize,
          height: groundSize,
          subdivisions: 1
        }, scene);
        bottom.position.y = bottomY;
        bottom.material = pedMat;
        bottom.receiveShadows = false;
      }

      // --- Create terrain from height map (this is the "lid") ---
      var ground = BABYLON.MeshBuilder.CreateGroundFromHeightMap(
        "osogovoTerrain",
        "Osogovo Height Map (Merged).png",
        {
          width: groundSize,
          height: groundSize,
          subdivisions: subdivisions,
          minHeight: minHeight,
          maxHeight: maxHeight,
          onReady: function (mesh) {
            mesh.material = terrainMaterial;
            mesh.position.y = 0;
            mesh.receiveShadows = true;
            shadowGenerator.addShadowCaster(mesh);

            var positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            if (!positions) return;

            // --- Find several of the highest peaks ---
            var verts = [];
            for (var i = 0; i < positions.length; i += 3) {
              verts.push({
                x: positions[i],
                y: positions[i + 1],
                z: positions[i + 2]
              });
            }

            verts.sort(function (a, b) {
              return b.y - a.y;
            });

            var peakPositions = [];
            var minPeakDistance = 25;

            for (var v = 0; v < verts.length && peakPositions.length < 3; v++) {
              var candidate = verts[v];
              var tooClose = false;
              for (var p = 0; p < peakPositions.length; p++) {
                var dx = candidate.x - peakPositions[p].x;
                var dz = candidate.z - peakPositions[p].z;
                var dist = Math.sqrt(dx * dx + dz * dz);
                if (dist < minPeakDistance) {
                  tooClose = true;
                  break;
                }
              }
              if (!tooClose) {
                peakPositions.push(candidate);
              }
            }

            var peakLabels = ["Peak 1", "Peak 2", "Peak 3"];

            peakPositions.forEach(function (p, idx) {
              // Marker
              var marker = BABYLON.MeshBuilder.CreateSphere("marker" + idx, {
                diameter: 4,
                segments: 8
              }, scene);
              marker.position = new BABYLON.Vector3(p.x, p.y + 1.5, p.z);
              marker.material = markerMat;
              shadowGenerator.addShadowCaster(marker);

              // Label
              var labelPlane = createLabelPlane("label" + idx, peakLabels[idx], scene);
              labelPlane.position = new BABYLON.Vector3(p.x, p.y + 10, p.z);
            });

            // Build diorama box (walls + bottom) from the terrain edges
            buildDioramaBoxFromTerrain(mesh, positions);

            // Frame camera around terrain
            var bounds = mesh.getBoundingInfo().boundingBox;
            var radius = bounds.extendSizeWorld.length() * 1.4;
            camera.radius = radius;
            camera.target = bounds.centerWorld.clone();
          }
        },
        scene
      );

      return scene;
    }

    var scene = createScene();

    engine.runRenderLoop(function () {
      if (scene.activeCamera) {
        scene.render();
      }
    });

    window.addEventListener("resize", function () {
      engine.resize();
    });
  });
</script>
</body>
</html>
