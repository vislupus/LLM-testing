<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Osogovo Terrain 3D Map</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
        }

        #renderCanvas {
            width: 100%;
            height: 100vh;
            display: block;
            touch-action: none;
        }

        /* Title Overlay */
        .title-overlay {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }

        .title-text {
            font-size: 2rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px rgba(247, 183, 49, 0.5), 0 2px 4px rgba(0, 0, 0, 0.5);
            letter-spacing: 2px;
        }

        .subtitle-text {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 5px;
        }

        /* Controls Hint */
        .controls-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            padding: 12px 25px;
            border-radius: 25px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85rem;
            pointer-events: none;
            z-index: 100;
        }

        /* Info Panel */
        .info-panel {
            position: fixed;
            top: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 20px;
            border-radius: 15px;
            color: #fff;
            font-size: 0.85rem;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 220px;
        }

        .info-title {
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .info-item {
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-icon {
            font-size: 1.1rem;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-title {
            font-size: 1.8rem;
            color: #4ecdc4;
            margin-bottom: 30px;
        }

        .loading-bar-container {
            width: 300px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #e94560, #f7b731, #20bf6b);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .loading-text {
            margin-top: 15px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
        }

        /* Legend */
        .legend {
            position: fixed;
            bottom: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 12px;
            color: #fff;
            font-size: 0.8rem;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #f7b731;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-title">üèîÔ∏è Osogovo Terrain Map</div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loadingBar" style="width: 0%"></div>
        </div>
        <div class="loading-text" id="loadingText">Initializing...</div>
    </div>

    <!-- Main Canvas -->
    <canvas id="renderCanvas"></canvas>

    <!-- Title Overlay -->
    <div class="title-overlay">
        <div class="title-text">üèîÔ∏è Osogovo Terrain</div>
        <div class="subtitle-text">Interactive 3D Height Map Visualization</div>
    </div>

    <!-- Controls Hint -->
    <div class="controls-hint">
        üñ±Ô∏è Drag to Rotate &nbsp;|&nbsp; Scroll to Zoom &nbsp;|&nbsp; Right-click Drag to Pan
    </div>

    <!-- Info Panel -->
    <div class="info-panel">
        <div class="info-title">üìç Terrain Info</div>
        <div class="info-item"><span class="info-icon">üìê</span> <span id="terrainSize">Size: 100√ó100 units</span></div>
        <div class="info-item"><span class="info-icon">‚õ∞Ô∏è</span> <span id="peakCount">Peaks: 3 marked</span></div>
        <div class="info-item"><span class="info-icon">üé®</span> <span id="textureStatus">Texture: Loading...</span></div>
    </div>

    <!-- Legend -->
    <div class="legend">
        <div class="legend-title">Elevation Legend</div>
        <div class="legend-item">
            <div class="legend-color" style="background: #2d5016;"></div>
            <span>Lowlands (Valleys)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #8b7355;"></div>
            <span>Mid-elevation</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #c0c0c0;"></div>
            <span>High Peaks</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ffffff;"></div>
            <span>Snow Caps</span>
        </div>
    </div>

    <!-- Babylon.js -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <script>
        // ==================== CONFIGURATION ====================
        const CONFIG = {
            terrain: {
                width: 100,
                height: 100,
                subdivisions: 128,
                maxHeight: 30,
                pedestalHeight: 15,
                pedestalDepth: 8
            },
            markers: [
                { name: "Peak Alpha", description: "Highest Point", color: "#e94560" },
                { name: "Peak Beta", description: "Eastern Summit", color: "#4ecdc4" },
                { name: "Peak Gamma", description: "Western Ridge", color: "#f7b731" }
            ],
            lighting: {
                hemisphericIntensity: 0.6,
                directionalIntensity: 0.8,
                shadowGeneratorSize: 2048
            }
        };

        // ==================== GAME STATE ====================
        let gameState = {
            heightMapLoaded: false,
            textureLoaded: false,
            imagesPath: './',
            terrainMesh: null,
            markers: [],
            peakPositions: []
        };

        // ==================== MAIN SETUP ====================
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
        let scene, camera;

        // Loading progress
        const updateLoading = (progress, text) => {
            document.getElementById('loadingBar').style.width = `${progress}%`;
            document.getElementById('loadingText').textContent = text;
        };

        // ==================== CREATE SCENE ====================
        const createScene = async () => {
            updateLoading(5, 'Creating scene...');

            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.6, 0.75, 0.85, 1);
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
            scene.fogDensity = 0.002;
            scene.fogColor = new BABYLON.Color3(0.65, 0.78, 0.88);

            // Camera
            camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 4, Math.PI / 3, 120, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 40;
            camera.upperRadiusLimit = 250;
            camera.lowerBetaLimit = 0.1;
            camera.upperBetaLimit = Math.PI / 2.05;
            camera.wheelPrecision = 15;
            camera.panningSensibility = 80;
            camera.minZ = 0.1;

            updateLoading(10, 'Setting up lighting...');

            // Lighting
            const hemisphericLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0.3, 1, 0.2), scene);
            hemisphericLight.intensity = CONFIG.lighting.hemisphericIntensity;
            hemisphericLight.diffuse = new BABYLON.Color3(0.95, 0.95, 1);
            hemisphericLight.groundColor = new BABYLON.Color3(0.4, 0.45, 0.5);

            const directionalLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-0.5, -1, -0.3), scene);
            directionalLight.position = new BABYLON.Vector3(60, 100, 40);
            directionalLight.intensity = CONFIG.lighting.directionalIntensity;
            directionalLight.diffuse = new BABYLON.Color3(1, 0.98, 0.92);

            // Shadows
            const shadowGenerator = new BABYLON.ShadowGenerator(CONFIG.lighting.shadowGeneratorSize, directionalLight);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;
            shadowGenerator.bias = 0.001;

            // Glow layer
            const glowLayer = new BABYLON.GlowLayer("glow", scene);
            glowLayer.intensity = 0.25;

            updateLoading(15, 'Creating terrain...');

            // Create terrain with pedestal
            const terrainData = await createTerrainWithPedestal(shadowGenerator);

            updateLoading(60, 'Finding peaks and placing markers...');

            // Find peaks and place markers
            await findAndMarkPeaks(terrainData, shadowGenerator);

            updateLoading(85, 'Finalizing scene...');

            // Create ambient elements
            createAmbientElements();

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
            }, 500);

            return scene;
        };

        // ==================== TERRAIN WITH PEDESTAL ====================
        async function createTerrainWithPedestal(shadowGenerator) {
            const { width, height, subdivisions, maxHeight, pedestalHeight, pedestalDepth } = CONFIG.terrain;

            // Create ground mesh for terrain
            const ground = BABYLON.MeshBuilder.CreateGround("terrain", {
                width: width,
                height: height,
                subdivisions: subdivisions,
                updatable: true
            }, scene);

            // Try to load height map
            let heightData = null;
            let texture = null;
            let terrainMaterial = null;

            try {
                // Try to load height map
                const heightMapResult = await loadHeightMap();
                if (heightMapResult.success) {
                    heightData = heightDataFromImage(heightMapResult.image);
                    gameState.heightMapLoaded = true;
                    updateLoading(25, 'Height map loaded...');
                } else {
                    heightData = generateProceduralHeight(subdivisions + 1);
                    updateLoading(25, 'Using procedural terrain...');
                }

                // Try to load texture
                const textureResult = await loadTexture();
                if (textureResult.success) {
                    texture = textureResult.texture;
                    gameState.textureLoaded = true;
                    updateLoading(45, 'Texture loaded...');
                }

                // Apply height data to terrain
                applyHeightData(ground, heightData, maxHeight);

                // Create terrain material
                terrainMaterial = createTerrainMaterial(texture);

            } catch (error) {
                console.log('Error loading images, using procedural terrain:', error);
                heightData = generateProceduralHeight(subdivisions + 1);
                applyHeightData(ground, heightData, maxHeight);
                terrainMaterial = createTerrainMaterial(null);
            }

            ground.material = terrainMaterial;
            ground.receiveShadows = true;
            shadowGenerator.addShadowCaster(ground);

            // Find terrain bounds
            const positions = ground.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            let minY = Infinity, maxY = -Infinity;
            for (let i = 1; i < positions.length; i += 3) {
                if (positions[i] < minY) minY = positions[i];
                if (positions[i] > maxY) maxY = positions[i];
            }

            // Create pedestal box
            createPedestal(ground.position.y + minY - pedestalHeight, pedestalHeight, pedestalDepth, shadowGenerator);

            // Update UI
            document.getElementById('terrainSize').textContent = `Size: ${width}√ó${height} units`;
            document.getElementById('textureStatus').textContent = `Texture: ${gameState.textureLoaded ? 'Loaded' : 'Procedural'}`;

            return { ground, heightData, positions, minY, maxY };
        }

        // ==================== HEIGHT MAP LOADING ====================
        async function loadHeightMap() {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';

                img.onload = () => {
                    resolve({ success: true, image: img });
                };

                img.onerror = () => {
                    resolve({ success: false });
                };

                // Try common image paths
                const possiblePaths = [
                    `${gameState.imagesPath}Osogovo Height Map (Merged).png`,
                    `${gameState.imagesPath}Osogovo_Height_Map_Merged.png`,
                    `${gameState.imagesPath}height_map.png`,
                    './Osogovo Height Map (Merged).png'
                ];

                // Try first path
                img.src = possiblePaths[0];
            });
        }

        // ==================== TEXTURE LOADING ====================
        async function loadTexture() {
            return new Promise((resolve) => {
                const texture = new BABYLON.Texture(
                    `${gameState.imagesPath}Osogovo_map.jpg`,
                    scene,
                    false,  // noMipmap
                    true,   // invertY
                    BABYLON.Texture.TRILINEAR_SAMPLINGMODE,
                    () => resolve({ success: true, texture }),  // onLoad
                    () => resolve({ success: false })           // onError
                );

                // Fallback if direct loading fails
                setTimeout(() => resolve({ success: false }), 3000);
            });
        }

        // ==================== HEIGHT DATA FROM IMAGE ====================
        function heightDataFromImage(image) {
            const size = CONFIG.terrain.subdivisions + 1;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            ctx.drawImage(image, 0, 0, size, size);
            const imageData = ctx.getImageData(0, 0, size, size);
            const data = imageData.data;

            const heightData = [];
            for (let y = 0; y < size; y++) {
                const row = [];
                for (let x = 0; x < size; x++) {
                    const i = (y * size + x) * 4;
                    // Use red channel for height
                    const height = data[i] / 255;
                    row.push(height);
                }
                heightData.push(row);
            }

            return heightData;
        }

        // ==================== PROCEDURAL HEIGHT GENERATION ====================
        function generateProceduralHeight(size) {
            const heightData = [];

            // Generate multiple octaves of noise
            for (let y = 0; y < size; y++) {
                const row = [];
                for (let x = 0; x < size; x++) {
                    const nx = x / size - 0.5;
                    const ny = y / size - 0.5;

                    // Multi-octave noise
                    let height = 0;
                    height += noise(nx * 2, ny * 2) * 0.5;
                    height += noise(nx * 4, ny * 4) * 0.25;
                    height += noise(nx * 8, ny * 8) * 0.125;
                    height += noise(nx * 16, ny * 16) * 0.0625;

                    // Add some ridge features
                    const ridge = Math.pow(1 - Math.abs(noise(nx * 3 + 100, ny * 3 + 100)), 2);
                    height += ridge * 0.3;

                    // Create valley in center
                    const distFromCenter = Math.sqrt(nx * nx + ny * ny);
                    const valley = Math.pow(distFromCenter, 2);
                    height -= valley * 0.2;

                    // Add peaks
                    const peakDist = Math.sqrt(Math.pow(nx - 0.3, 2) + Math.pow(ny - 0.2, 2));
                    height += Math.max(0, 1 - peakDist * 3) * 0.4;

                    const peakDist2 = Math.sqrt(Math.pow(nx + 0.25, 2) + Math.pow(ny + 0.15, 2));
                    height += Math.max(0, 1 - peakDist2 * 4) * 0.3;

                    row.push(Math.max(0, Math.min(1, (height + 0.5))));
                }
                heightData.push(row);
            }

            return heightData;
        }

        // Simple noise function
        function noise(x, y) {
            const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return (n - Math.floor(n)) * 2 - 1;
        }

        // ==================== APPLY HEIGHT DATA ====================
        function applyHeightData(ground, heightData, maxHeight) {
            const positions = ground.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            const size = heightData.length;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const i = (y * size + x) * 3;
                    if (i + 1 < positions.length) {
                        positions[i + 1] = heightData[y][x] * maxHeight;
                    }
                }
            }

            ground.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);

            // Update normals for proper lighting
            BABYLON.VertexData.ComputeNormals(positions, ground.getIndices(), ground.getVerticesData(BABYLON.VertexBuffer.NormalKind));
        }

        // ==================== TERRAIN MATERIAL ====================
        function createTerrainMaterial(texture) {
            const material = new BABYLON.StandardMaterial("terrainMat", scene);

            if (texture) {
                material.diffuseTexture = texture;
                material.diffuseTexture.uScale = 1;
                material.diffuseTexture.vScale = 1;
            } else {
                // Use procedural terrain material when no texture is available
                return createProceduralTerrainMaterial();
            }

            material.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            material.specularPower = 32;

            return material;
        }

        function createProceduralTerrainMaterial() {
            const material = new BABYLON.StandardMaterial("proceduralTerrain", scene);

            // Create gradient texture based on height
            const gradientTexture = new BABYLON.DynamicTexture("gradientTex", { width: 256, height: 256 }, scene);
            const ctx = gradientTexture.getContext();

            const gradient = ctx.createLinearGradient(0, 256, 0, 0);
            gradient.addColorStop(0, '#2d5016');    // Dark green (low)
            gradient.addColorStop(0.3, '#5a7247');  // Green
            gradient.addColorStop(0.5, '#8b7355');  // Brown/rocky
            gradient.addColorStop(0.7, '#a0926d');  // Light brown
            gradient.addColorStop(0.85, '#c0c0c0'); // Gray
            gradient.addColorStop(1, '#ffffff');    // White (high)

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
            gradientTexture.update();

            material.diffuseTexture = gradientTexture;
            material.diffuseTexture.uScale = 3;
            material.diffuseTexture.vScale = 3;

            // Use height for color modulation via emissive
            material.specularColor = new BABYLON.Color3(0.15, 0.15, 0.15);
            material.specularPower = 16;

            return material;
        }

        // ==================== PEDESTAL ====================
        function createPedestal(bottomY, pedestalHeight, pedestalDepth, shadowGenerator) {
            const { width, height } = CONFIG.terrain;
            const pedestalGroup = new BABYLON.TransformNode("pedestal", scene);

            // Calculate dimensions
            const halfWidth = width / 2 + pedestalDepth;
            const halfHeight = height / 2 + pedestalDepth;

            // Pedestal material
            const pedestalMat = new BABYLON.StandardMaterial("pedestalMat", scene);
            pedestalMat.diffuseColor = new BABYLON.Color3(0.35, 0.35, 0.38);
            pedestalMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            pedestalMat.specularPower = 32;

            // Base platform
            const base = BABYLON.MeshBuilder.CreateBox("pedestalBase", {
                width: width + pedestalDepth * 2 + 2,
                height: 1,
                depth: height + pedestalDepth * 2 + 2
            }, scene);
            base.position.y = bottomY + 0.5;
            base.material = pedestalMat;
            base.parent = pedestalGroup;
            shadowGenerator.addShadowCaster(base);
            base.receiveShadows = true;

            // Corner pillars
            const pillarPositions = [
                { x: -halfWidth - 1, z: -halfHeight - 1 },
                { x: halfWidth + 1, z: -halfHeight - 1 },
                { x: -halfWidth - 1, z: halfHeight + 1 },
                { x: halfWidth + 1, z: halfHeight + 1 }
            ];

            pillarPositions.forEach((pos, i) => {
                const pillar = BABYLON.MeshBuilder.CreateCylinder("pillar" + i, {
                    height: pedestalHeight - 1,
                    diameter: 2,
                    tessellation: 8
                }, scene);
                pillar.position = new BABYLON.Vector3(pos.x, bottomY + pedestalHeight / 2, pos.z);
                pillar.material = pedestalMat;
                pillar.parent = pedestalGroup;
                shadowGenerator.addShadowCaster(pillar);

                // Pillar base
                const pillarBase = BABYLON.MeshBuilder.CreateCylinder("pillarBase" + i, {
                    height: 1,
                    diameterTop: 2.5,
                    diameterBottom: 3,
                    tessellation: 8
                }, scene);
                pillarBase.position = new BABYLON.Vector3(pos.x, bottomY + 0.5, pos.z);
                pillarBase.material = pedestalMat;
                pillarBase.parent = pedestalGroup;

                // Pillar capital
                const pillarCapital = BABYLON.MeshBuilder.CreateCylinder("pillarCapital" + i, {
                    height: 0.8,
                    diameterTop: 3,
                    diameterBottom: 2.5,
                    tessellation: 8
                }, scene);
                pillarCapital.position = new BABYLON.Vector3(pos.x, bottomY + pedestalHeight, pos.z);
                pillarCapital.material = pedestalMat;
                pillarCapital.parent = pedestalGroup;
            });

            // Front panel with decorative elements
            const frontPanel = BABYLON.MeshBuilder.CreateBox("frontPanel", {
                width: width + 2,
                height: pedestalHeight - 2,
                depth: 1
            }, scene);
            frontPanel.position = new BABYLON.Vector3(0, bottomY + pedestalHeight / 2, halfHeight + pedestalDepth);
            frontPanel.material = pedestalMat;
            frontPanel.parent = pedestalGroup;
            shadowGenerator.addShadowCaster(frontPanel);

            // Decorative trim
            const trimMat = new BABYLON.StandardMaterial("trimMat", scene);
            trimMat.diffuseColor = new BABYLON.Color3(0.45, 0.4, 0.35);
            trimMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);

            // Top trim
            const topTrim = BABYLON.MeshBuilder.CreateBox("topTrim", {
                width: width + pedestalDepth * 2 + 3,
                height: 0.5,
                depth: 1
            }, scene);
            topTrim.position = new BABYLON.Vector3(0, bottomY + pedestalHeight - 0.5, halfHeight + pedestalDepth + 0.5);
            topTrim.material = trimMat;
            topTrim.parent = pedestalGroup;

            // Bottom trim
            const bottomTrim = BABYLON.MeshBuilder.CreateBox("bottomTrim", {
                width: width + pedestalDepth * 2 + 3,
                height: 0.8,
                depth: 1.5
            }, scene);
            bottomTrim.position = new BABYLON.Vector3(0, bottomY + 1, halfHeight + pedestalDepth + 0.5);
            bottomTrim.material = trimMat;
            bottomTrim.parent = pedestalGroup;

            // Side walls (visual depth)
            const sideWallMat = new BABYLON.StandardMaterial("sideWallMat", scene);
            sideWallMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.33);

            // Left wall
            const leftWall = BABYLON.MeshBuilder.CreateBox("leftWall", {
                width: 1,
                height: pedestalHeight - 1,
                depth: height + pedestalDepth * 2
            }, scene);
            leftWall.position = new BABYLON.Vector3(-halfWidth - pedestalDepth, bottomY + pedestalHeight / 2, 0);
            leftWall.material = sideWallMat;
            leftWall.parent = pedestalGroup;

            // Right wall
            const rightWall = BABYLON.MeshBuilder.CreateBox("rightWall", {
                width: 1,
                height: pedestalHeight - 1,
                depth: height + pedestalDepth * 2
            }, scene);
            rightWall.position = new BABYLON.Vector3(halfWidth + pedestalDepth, bottomY + pedestalHeight / 2, 0);
            rightWall.material = sideWallMat;
            rightWall.parent = pedestalGroup;
        }

        // ==================== PEAK DETECTION AND MARKERS ====================
        async function findAndMarkPeaks(terrainData, shadowGenerator) {
            const { ground, positions } = terrainData;
            const heightData = gameState.heightData;

            if (!heightData) {
                // Use procedural peaks if no height data
                const proceduralPeaks = [
                    { x: 0.3, y: 0.2, height: 1 },
                    { x: -0.25, y: 0.15, height: 0.9 },
                    { x: 0.1, y: -0.3, height: 0.85 }
                ];

                proceduralPeaks.forEach((peak, i) => {
                    placePeakMarker(peak.x, peak.y, peak.height, CONFIG.markers[i], shadowGenerator, positions);
                });
            } else {
                // Find actual peaks from height data
                const peaks = findPeaks(heightData);

                // Take top 3 peaks
                const topPeaks = peaks.slice(0, 3);

                topPeaks.forEach((peak, i) => {
                    const markerConfig = CONFIG.markers[i] || CONFIG.markers[0];
                    placePeakMarker(peak.x, peak.y, peak.height, markerConfig, shadowGenerator, positions);
                });
            }

            document.getElementById('peakCount').textContent = `Peaks: ${gameState.markers.length} marked`;
        }

        function findPeaks(heightData) {
            const size = heightData.length;
            const peaks = [];
            const minDistance = size * 0.15; // Minimum distance between peaks

            // Find local maxima
            for (let y = 3; y < size - 3; y++) {
                for (let x = 3; x < size - 3; x++) {
                    const height = heightData[y][x];

                    // Skip if too low
                    if (height < 0.6) continue;

                    // Check if local maximum
                    let isMax = true;
                    for (let dy = -2; dy <= 2 && isMax; dy++) {
                        for (let dx = -2; dx <= 2 && isMax; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            if (heightData[y + dy][x + dx] > height) {
                                isMax = false;
                            }
                        }
                    }

                    if (isMax) {
                        // Check distance from other peaks
                        let tooClose = false;
                        for (const peak of peaks) {
                            const dist = Math.sqrt(Math.pow(peak.x - x, 2) + Math.pow(peak.y - y, 2));
                            if (dist < minDistance) {
                                tooClose = true;
                                break;
                            }
                        }

                        if (!tooClose) {
                            peaks.push({ x, y, height });
                        }
                    }
                }
            }

            // Sort by height and return
            peaks.sort((a, b) => b.height - a.height);
            return peaks.slice(0, 10); // Return more peaks, we'll take top 3
        }

        function placePeakMarker(x, y, height, config, shadowGenerator, positions) {
            const size = CONFIG.terrain.subdivisions + 1;

            // Convert grid coordinates to world coordinates
            const worldX = (x / size - 0.5) * CONFIG.terrain.width;
            const worldZ = (y / size - 0.5) * CONFIG.terrain.height;
            const worldY = height * CONFIG.terrain.maxHeight + 2;

            // Create marker group
            const markerGroup = new BABYLON.TransformNode(`marker_${config.name}`, scene);

            // Marker base (cone)
            const markerBase = BABYLON.MeshBuilder.CreateCylinder("markerBase", {
                height: 1,
                diameterTop: 0,
                diameterBottom: 2,
                tessellation: 16
            }, scene);
            markerBase.position.y = 0.5;
            markerBase.material = createMarkerMaterial(config.color);
            markerBase.parent = markerGroup;
            shadowGenerator.addShadowCaster(markerBase);

            // Marker ring
            const markerRing = BABYLON.MeshBuilder.CreateTorus("markerRing", {
                diameter: 2.5,
                thickness: 0.15,
                tessellation: 24
            }, scene);
            markerRing.position.y = 1;
            markerRing.material = createMarkerMaterial(config.color);
            markerRing.parent = markerGroup;

            // Billboard text label
            const labelPlane = BABYLON.MeshBuilder.CreatePlane("labelPlane", {
                width: 8,
                height: 2
            }, scene);
            labelPlane.position.y = 3;
            labelPlane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

            // Create dynamic texture for label
            const labelTexture = new BABYLON.DynamicTexture("labelTexture", { width: 256, height: 64 }, scene);
            const ctx = labelTexture.getContext();

            // Draw label background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.roundRect(0, 0, 256, 64, 10);
            ctx.fill();

            // Draw border
            ctx.strokeStyle = config.color;
            ctx.lineWidth = 3;
            ctx.roundRect(0, 0, 256, 64, 10);
            ctx.stroke();

            // Draw text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 18px Segoe UI';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(config.name, 128, 22);

            ctx.font = '12px Segoe UI';
            ctx.fillStyle = config.color;
            ctx.fillText(config.description, 128, 45);

            labelTexture.update();

            const labelMat = new BABYLON.StandardMaterial("labelMat", scene);
            labelMat.diffuseTexture = labelTexture;
            labelMat.diffuseTexture.hasAlpha = true;
            labelMat.useAlphaFromDiffuseTexture = true;
            labelMat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            labelMat.specularColor = new BABYLON.Color3(0, 0, 0);
            labelMat.backFaceCulling = false;

            labelPlane.material = labelMat;
            labelPlane.parent = markerGroup;

            // Add glow effect to marker
            const markerGlow = new BABYLON.HighlightLayer("markerGlow" + config.name, scene);
            markerGlow.addMesh(markerBase, BABYLON.Color3.FromHexString(config.color));
            markerGlow.addMesh(markerRing, BABYLON.Color3.FromHexString(config.color));

            // Animate marker
            let time = 0;
            scene.registerBeforeRender(() => {
                time += 0.03;
                markerBase.position.y = 0.5 + Math.sin(time) * 0.1;
                markerRing.position.y = 1 + Math.sin(time + 1) * 0.1;
                markerRing.scaling.x = 1 + Math.sin(time * 0.5) * 0.05;
                markerRing.scaling.z = 1 + Math.sin(time * 0.5) * 0.05;
            });

            // Position the entire marker
            markerGroup.position = new BABYLON.Vector3(worldX, worldY, worldZ);

            gameState.markers.push({
                group: markerGroup,
                config: config,
                position: new BABYLON.Vector3(worldX, worldY, worldZ)
            });
        }

        function createMarkerMaterial(color) {
            const mat = new BABYLON.StandardMaterial("markerMat_" + color, scene);
            mat.diffuseColor = BABYLON.Color3.FromHexString(color);
            mat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            mat.specularPower = 32;
            mat.emissiveColor = BABYLON.Color3.FromHexString(color).scale(0.3);
            return mat;
        }

        // ==================== AMBIENT ELEMENTS ====================
        function createAmbientElements() {
            // Sun
            const sun = BABYLON.MeshBuilder.CreateSphere("sun", { diameter: 15 }, scene);
            sun.position = new BABYLON.Vector3(80, 100, 60);
            const sunMat = new BABYLON.StandardMaterial("sunMat", scene);
            sunMat.emissiveColor = new BABYLON.Color3(1, 0.95, 0.8);
            sunMat.disableLighting = true;
            sun.material = sunMat;

            // Background mountains (silhouette)
            createBackgroundMountains();

            // Clouds
            createClouds();

            // Birds
            createBirds();
        }

        function createBackgroundMountains() {
            const mountainMat = new BABYLON.StandardMaterial("mountainMat", scene);
            mountainMat.diffuseColor = new BABYLON.Color3(0.4, 0.45, 0.5);
            mountainMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const numMountains = 8;
            for (let i = 0; i < numMountains; i++) {
                const angle = (i / numMountains) * Math.PI * 2;
                const distance = 150 + Math.random() * 50;

                const mountain = BABYLON.MeshBuilder.CreateCylinder("mountain" + i, {
                    height: 40 + Math.random() * 30,
                    diameterTop: 0,
                    diameterBottom: 30 + Math.random() * 40,
                    tessellation: 8
                }, scene);

                mountain.position = new BABYLON.Vector3(
                    Math.cos(angle) * distance,
                    -20,
                    Math.sin(angle) * distance
                );
                mountain.material = mountainMat;
                mountain.scaling.y = 1 + Math.random() * 0.5;
            }
        }

        function createClouds() {
            for (let i = 0; i < 6; i++) {
                const cloudGroup = new BABYLON.TransformNode("cloud" + i, scene);
                const cloudParts = 3 + Math.floor(Math.random() * 3);

                for (let j = 0; j < cloudParts; j++) {
                    const puff = BABYLON.MeshBuilder.CreateSphere("cloudPuff" + i + "_" + j, {
                        diameter: 8 + Math.random() * 10,
                        segments: 8
                    }, scene);

                    const mat = new BABYLON.StandardMaterial("cloudMat" + i + "_" + j, scene);
                    mat.diffuseColor = new BABYLON.Color3(1, 1, 1);
                    mat.specularColor = new BABYLON.Color3(0, 0, 0);
                    mat.emissiveColor = new BABYLON.Color3(0.95, 0.98, 1);
                    puff.material = mat;

                    puff.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 10
                    );
                    puff.scaling = new BABYLON.Vector3(1, 0.6, 1);
                    puff.parent = cloudGroup;
                }

                cloudGroup.position = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 200,
                    60 + Math.random() * 30,
                    (Math.random() - 0.5) * 150
                );

                // Slow drift
                scene.registerBeforeRender(() => {
                    cloudGroup.position.x += 0.008;
                    if (cloudGroup.position.x > 120) {
                        cloudGroup.position.x = -120;
                    }
                });
            }
        }

        function createBirds() {
            for (let i = 0; i < 5; i++) {
                const bird = BABYLON.MeshBuilder.CreateSphere("bird" + i, {
                    diameter: 0.4
                }, scene);
                const birdMat = new BABYLON.StandardMaterial("birdMat" + i, scene);
                birdMat.diffuseColor = new BABYLON.Color3(0.15, 0.15, 0.2);
                bird.material = birdMat;

                const startX = -50 + Math.random() * 100;
                const startZ = -50 + Math.random() * 100;
                bird.position = new BABYLON.Vector3(startX, 35 + Math.random() * 15, startZ);

                // Bird animation
                let angle = Math.random() * Math.PI * 2;
                scene.registerBeforeRender(() => {
                    angle += 0.015;
                    bird.position.x = startX + Math.cos(angle) * 8;
                    bird.position.z = startZ + Math.sin(angle) * 5;
                    bird.position.y = 35 + Math.sin(angle * 1.5) * 3;
                });
            }
        }

        // ==================== CANVAS ROUNDRECT POLYFILL ====================
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.beginPath();
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };
        }

        // ==================== INITIALIZATION ====================
        createScene().then(() => {
            engine.runRenderLoop(() => {
                scene.render();
            });

            window.addEventListener('resize', () => {
                engine.resize();
            });

            console.log('Osogovo Terrain Map loaded successfully!');
        });
    </script>
</body>
</html>