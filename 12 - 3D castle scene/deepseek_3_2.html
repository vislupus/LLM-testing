<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Medieval Floating Island Diorama</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'MedievalSharp', cursive, sans-serif;
        }

        @import url('https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap');

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
            filter: contrast(1.1) saturate(1.1);
        }

        /* Title Overlay */
        .title-overlay {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }

        .title {
            font-size: 48px;
            color: #ffd700;
            text-shadow: 3px 3px 0 #8b4513, 6px 6px 0 rgba(0, 0, 0, 0.3);
            letter-spacing: 2px;
            margin-bottom: 10px;
            animation: float 6s ease-in-out infinite;
        }

        .subtitle {
            font-size: 20px;
            color: #fff;
            text-shadow: 2px 2px 0 #8b4513;
            opacity: 0.9;
        }

        /* Controls Panel */
        .controls-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            border: 3px solid #d4af37;
            backdrop-filter: blur(10px);
            max-width: 300px;
            z-index: 10;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .controls-title {
            color: #ffd700;
            font-size: 22px;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 2px solid #d4af37;
            padding-bottom: 5px;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .key {
            background: #d4af37;
            color: #000;
            padding: 2px 10px;
            border-radius: 5px;
            font-weight: bold;
            min-width: 80px;
            text-align: center;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s ease;
        }

        .loading-title {
            font-size: 48px;
            color: #ffd700;
            margin-bottom: 30px;
            text-shadow: 2px 2px 0 #8b4513;
        }

        .loading-bar {
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #d4af37;
            margin-bottom: 20px;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #d4af37, #ffd700);
            width: 0%;
            transition: width 0.3s ease;
        }

        .loading-text {
            font-size: 18px;
            color: #fff;
        }

        /* Info Panel */
        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            border: 3px solid #d4af37;
            backdrop-filter: blur(10px);
            max-width: 300px;
            z-index: 10;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            opacity: 0.9;
        }

        .info-title {
            color: #ffd700;
            font-size: 22px;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 2px solid #d4af37;
            padding-bottom: 5px;
        }

        .info-text {
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .info-highlight {
            color: #ffd700;
            font-weight: bold;
        }

        /* Floating Clouds */
        .cloud {
            position: absolute;
            background: white;
            border-radius: 50%;
            opacity: 0.1;
            z-index: 1;
        }

        /* Animations */
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .title {
                font-size: 32px;
            }
            
            .controls-panel, .info-panel {
                max-width: 250px;
                padding: 15px;
            }
            
            .controls-title, .info-title {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-title">Floating Island</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
        <div class="loading-text" id="loadingText">Loading magical world...</div>
    </div>

    <!-- Canvas -->
    <canvas id="renderCanvas"></canvas>

    <!-- Title -->
    <div class="title-overlay">
        <div class="title">AERENDEL</div>
        <div class="subtitle">The Floating Kingdom</div>
    </div>

    <!-- Controls -->
    <div class="controls-panel">
        <div class="controls-title">CONTROLS</div>
        <div class="control-item">
            <span>Orbit Camera:</span>
            <div class="key">Drag Mouse</div>
        </div>
        <div class="control-item">
            <span>Zoom:</span>
            <div class="key">Mouse Wheel</div>
        </div>
        <div class="control-item">
            <span>Pan Camera:</span>
            <div class="key">Right Drag</div>
        </div>
        <div class="control-item">
            <span>Reset View:</span>
            <div class="key">R Key</div>
        </div>
        <div class="control-item">
            <span>Toggle Fog:</span>
            <div class="key">F Key</div>
        </div>
    </div>

    <!-- Info Panel -->
    <div class="info-panel">
        <div class="info-title">ISLAND FEATURES</div>
        <div class="info-text">
            <span class="info-highlight">• Stone Castle:</span> Central fortress with towers
        </div>
        <div class="info-text">
            <span class="info-highlight">• Village:</span> Tavern, houses, market stalls
        </div>
        <div class="info-text">
            <span class="info-highlight">• Watermill:</span> Riverside mill with working wheel
        </div>
        <div class="info-text">
            <span class="info-highlight">• Watchtower:</span> Ruined tower at the edge
        </div>
        <div class="info-text">
            <span class="info-highlight">• Waterfalls:</span> Cascading from island's cliffs
        </div>
        <div class="info-text">
            <span class="info-highlight">• Bridges:</span> Wooden bridges over the river
        </div>
    </div>

    <!-- Background Clouds -->
    <div id="clouds"></div>

    <script>
        // Create background clouds
        for (let i = 0; i < 15; i++) {
            const cloud = document.createElement('div');
            cloud.className = 'cloud';
            const size = 50 + Math.random() * 150;
            cloud.style.width = `${size}px`;
            cloud.style.height = `${size * 0.5}px`;
            cloud.style.left = `${Math.random() * 100}%`;
            cloud.style.top = `${Math.random() * 100}%`;
            cloud.style.opacity = 0.05 + Math.random() * 0.1;
            document.getElementById('clouds').appendChild(cloud);
        }

        // Game Variables
        let assetsLoading = 0;
        let assetsLoaded = 0;
        let scene, engine, camera, skybox;
        let fogEnabled = true;

        // Initialize Babylon.js
        const initEngine = () => {
            const canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
            scene = new BABYLON.Scene(engine);
            
            // Enhanced anti-aliasing
            engine.setHardwareScalingLevel(1);
            
            // Create camera
            createCamera();
            
            // Create lighting
            createLighting();
            
            // Create skybox
            createSkybox();
            
            // Create island
            createFloatingIsland();
            
            // Create castle
            createCastle();
            
            // Create village
            createVillage();
            
            // Create watchtower
            createWatchtower();
            
            // Create river and waterfalls
            createWaterFeatures();
            
            // Create bridges
            createBridges();
            
            // Create trees and foliage
            createFoliage();
            
            // Create atmospheric effects
            createAtmosphere();
            
            // Setup controls
            setupControls();
            
            // Setup loading progress
            setupLoading();
            
            // Start render loop
            engine.runRenderLoop(() => {
                scene.render();
                
                // Animate water wheel
                if (window.waterWheel) {
                    window.waterWheel.rotation.y += 0.01;
                }
                
                // Animate waterfalls
                if (window.waterfallMaterial) {
                    window.waterfallMaterial.waterOffset += 0.05;
                }
                
                // Subtle floating animation for island
                if (window.islandBase) {
                    const time = Date.now() * 0.001;
                    window.islandBase.position.y = Math.sin(time * 0.5) * 0.3;
                }
            });
            
            // Handle resize
            window.addEventListener('resize', () => {
                engine.resize();
            });
        };

        // Create camera
        const createCamera = () => {
            // Arc rotate camera for orbiting
            camera = new BABYLON.ArcRotateCamera("camera", 
                -Math.PI / 2.5, Math.PI / 3, 120, 
                new BABYLON.Vector3(0, 15, 0), scene);
            
            camera.attachControl(engine.getRenderingCanvas(), true);
            camera.lowerRadiusLimit = 50;
            camera.upperRadiusLimit = 300;
            camera.wheelPrecision = 50;
            camera.panningSensibility = 1000;
            
            // Add post-processing for stylized look
            const fx = new BABYLON.DefaultRenderingPipeline("fx", true, scene, [camera]);
            fx.samples = 4;
            fx.bloomEnabled = true;
            fx.bloomThreshold = 0.8;
            fx.bloomWeight = 0.3;
            fx.bloomKernel = 32;
            fx.bloomScale = 0.5;
            fx.chromaticAberrationEnabled = true;
            fx.chromaticAberration.aberrationAmount = 5;
            fx.chromaticAberration.radialIntensity = 0.5;
        };

        // Create lighting
        const createLighting = () => {
            // Hemispheric light for ambient
            const hemiLight = new BABYLON.HemisphericLight("hemiLight", 
                new BABYLON.Vector3(0, 1, 0), scene);
            hemiLight.intensity = 0.7;
            hemiLight.groundColor = new BABYLON.Color3(0.3, 0.6, 0.9);
            hemiLight.diffuse = new BABYLON.Color3(0.9, 0.8, 0.7);
            
            // Directional light for sun
            const sun = new BABYLON.DirectionalLight("sun", 
                new BABYLON.Vector3(-1, -1, -0.5), scene);
            sun.intensity = 0.9;
            sun.position = new BABYLON.Vector3(50, 100, 50);
            sun.diffuse = new BABYLON.Color3(1, 0.95, 0.85);
            
            // Add shadows
            sun.shadowEnabled = true;
            const shadowGenerator = new BABYLON.ShadowGenerator(1024, sun);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;
            
            window.shadowGenerator = shadowGenerator;
        };

        // Create skybox
        const createSkybox = () => {
            const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 2000 }, scene);
            const skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
            skyboxMaterial.backFaceCulling = false;
            
            // Create gradient sky
            const skyColors = [
                new BABYLON.Color3(0.4, 0.6, 1.0),   // Top color
                new BABYLON.Color3(0.7, 0.8, 1.0),   // Middle
                new BABYLON.Color3(0.9, 0.95, 1.0)   // Bottom
            ];
            
            skyboxMaterial.diffuseColor = skyColors[2];
            skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            skybox.material = skyboxMaterial;
        };

        // Create floating island
        const createFloatingIsland = () => {
            assetsLoading++;
            
            // Island base (main landmass)
            const island = BABYLON.MeshBuilder.CreateSphere("islandBase", {
                diameter: 100,
                segments: 64
            }, scene);
            
            // Scale to make it more island-shaped
            island.scaling.y = 0.3;
            island.position.y = -5;
            
            // Create island material
            const islandMat = new BABYLON.StandardMaterial("islandMat", scene);
            islandMat.diffuseColor = new BABYLON.Color3(0.3, 0.7, 0.3); // Green grass
            islandMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            islandMat.specularPower = 64;
            
            // Add texture for grass
            const grassTexture = new BABYLON.Texture("https://i.imgur.com/ZLqKjYp.png", scene);
            grassTexture.uScale = 20;
            grassTexture.vScale = 20;
            islandMat.diffuseTexture = grassTexture;
            islandMat.bumpTexture = grassTexture;
            
            island.material = islandMat;
            window.shadowGenerator?.addShadowCaster(island);
            window.islandBase = island;
            
            // Create island sides/cliffs
            createCliffs();
            
            assetsLoaded++;
            updateLoading();
        };

        // Create cliffs around island
        const createCliffs = () => {
            // Create multiple rock formations around the island
            for (let i = 0; i < 24; i++) {
                const angle = (i / 24) * Math.PI * 2;
                const distance = 48 + Math.random() * 4;
                
                const cliff = BABYLON.MeshBuilder.CreateCylinder("cliff" + i, {
                    height: 15 + Math.random() * 10,
                    diameterTop: 3 + Math.random() * 4,
                    diameterBottom: 5 + Math.random() * 6,
                    tessellation: 16
                }, scene);
                
                cliff.position.x = Math.cos(angle) * distance;
                cliff.position.z = Math.sin(angle) * distance;
                cliff.position.y = -2;
                
                // Random rotation for natural look
                cliff.rotation.x = Math.random() * 0.2;
                cliff.rotation.z = Math.random() * 0.2;
                
                // Cliff material
                const cliffMat = new BABYLON.StandardMaterial("cliffMat" + i, scene);
                cliffMat.diffuseColor = new BABYLON.Color3(0.5, 0.4, 0.3);
                cliffMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                
                // Add rock texture
                const rockTexture = new BABYLON.Texture("https://i.imgur.com/6F3wR4a.png", scene);
                rockTexture.uScale = 2;
                rockTexture.vScale = 2;
                cliffMat.diffuseTexture = rockTexture;
                
                cliff.material = cliffMat;
                window.shadowGenerator?.addShadowCaster(cliff);
            }
        };

        // Create central castle
        const createCastle = () => {
            assetsLoading += 5; // Multiple castle parts
            
            // Castle base/keep
            const keep = BABYLON.MeshBuilder.CreateBox("keep", {
                width: 25,
                height: 20,
                depth: 25
            }, scene);
            keep.position.y = 15;
            
            // Castle material
            const castleMat = new BABYLON.StandardMaterial("castleMat", scene);
            castleMat.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);
            castleMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            
            // Stone texture
            const stoneTexture = new BABYLON.Texture("https://i.imgur.com/M7aZJ3S.png", scene);
            stoneTexture.uScale = 4;
            stoneTexture.vScale = 4;
            castleMat.diffuseTexture = stoneTexture;
            
            keep.material = castleMat;
            window.shadowGenerator?.addShadowCaster(keep);
            
            // Castle towers
            const towerPositions = [
                { x: -12, z: -12 },
                { x: 12, z: -12 },
                { x: -12, z: 12 },
                { x: 12, z: 12 }
            ];
            
            towerPositions.forEach((pos, i) => {
                const tower = BABYLON.MeshBuilder.CreateCylinder("tower" + i, {
                    height: 35,
                    diameter: 8,
                    tessellation: 16
                }, scene);
                
                tower.position.set(pos.x, 17.5, pos.z);
                tower.material = castleMat;
                window.shadowGenerator?.addShadowCaster(tower);
                
                // Tower tops (cone shaped)
                const towerTop = BABYLON.MeshBuilder.CreateCylinder("towerTop" + i, {
                    height: 8,
                    diameterTop: 0,
                    diameterBottom: 10,
                    tessellation: 16
                }, scene);
                
                towerTop.position.set(pos.x, 35 + 4, pos.z);
                const roofMat = new BABYLON.StandardMaterial("roofMat" + i, scene);
                roofMat.diffuseColor = new BABYLON.Color3(0.4, 0.2, 0.1);
                towerTop.material = roofMat;
            });
            
            // Main tower (bigger)
            const mainTower = BABYLON.MeshBuilder.CreateCylinder("mainTower", {
                height: 45,
                diameter: 12,
                tessellation: 20
            }, scene);
            
            mainTower.position.set(0, 22.5, 0);
            mainTower.material = castleMat;
            window.shadowGenerator?.addShadowCaster(mainTower);
            
            // Main tower top
            const mainTowerTop = BABYLON.MeshBuilder.CreateCylinder("mainTowerTop", {
                height: 12,
                diameterTop: 0,
                diameterBottom: 14,
                tessellation: 20
            }, scene);
            
            mainTowerTop.position.set(0, 45 + 6, 0);
            const mainRoofMat = new BABYLON.StandardMaterial("mainRoofMat", scene);
            mainRoofMat.diffuseColor = new BABYLON.Color3(0.6, 0.3, 0.15);
            mainTowerTop.material = mainRoofMat;
            
            // Castle walls
            createCastleWalls();
            
            assetsLoaded += 5;
            updateLoading();
        };

        // Create castle walls
        const createCastleWalls = () => {
            // Create surrounding walls
            const wallSegments = 16;
            for (let i = 0; i < wallSegments; i++) {
                const angle = (i / wallSegments) * Math.PI * 2;
                const distance = 30;
                
                const wall = BABYLON.MeshBuilder.CreateBox("wall" + i, {
                    width: 5,
                    height: 10,
                    depth: (Math.PI * 2 * distance) / wallSegments
                }, scene);
                
                wall.position.x = Math.cos(angle) * distance;
                wall.position.z = Math.sin(angle) * distance;
                wall.position.y = 5;
                wall.rotation.y = -angle;
                
                const wallMat = new BABYLON.StandardMaterial("wallMat" + i, scene);
                wallMat.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.6);
                wall.material = wallMat;
                window.shadowGenerator?.addShadowCaster(wall);
            }
        };

        // Create village
        const createVillage = () => {
            assetsLoading += 10; // Multiple village buildings
            
            // Village houses positions (in a semicircle around castle)
            const housePositions = [];
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 1.5 + Math.PI * 0.25;
                const distance = 40 + Math.random() * 10;
                housePositions.push({
                    x: Math.cos(angle) * distance,
                    z: Math.sin(angle) * distance,
                    rotation: angle + Math.PI / 2
                });
            }
            
            // Create houses
            housePositions.forEach((pos, i) => {
                createHouse(pos.x, pos.z, pos.rotation, i);
            });
            
            // Create tavern (bigger house)
            createTavern(35, 25, Math.PI / 4);
            
            // Create market stalls
            createMarketStalls();
            
            // Create watermill
            createWatermill(45, -15, -Math.PI / 4);
            
            assetsLoaded += 10;
            updateLoading();
        };

        // Create a house
        const createHouse = (x, z, rotation, index) => {
            // House base
            const house = BABYLON.MeshBuilder.CreateBox("house" + index, {
                width: 8,
                height: 6,
                depth: 10
            }, scene);
            
            house.position.set(x, 3, z);
            house.rotation.y = rotation;
            
            // House roof
            const roof = BABYLON.MeshBuilder.CreateCylinder("roof" + index, {
                height: 5,
                diameterTop: 0,
                diameterBottom: 10,
                tessellation: 4
            }, scene);
            
            roof.position.set(x, 6 + 2.5, z);
            roof.rotation.y = rotation + Math.PI / 4;
            roof.scaling.x = 1.2;
            
            // Materials
            const houseMat = new BABYLON.StandardMaterial("houseMat" + index, scene);
            houseMat.diffuseColor = new BABYLON.Color3(
                0.6 + Math.random() * 0.3,
                0.4 + Math.random() * 0.3,
                0.3 + Math.random() * 0.3
            );
            
            const roofMat = new BABYLON.StandardMaterial("roofMat" + index, scene);
            roofMat.diffuseColor = new BABYLON.Color3(0.4, 0.2, 0.1);
            
            house.material = houseMat;
            roof.material = roofMat;
            
            window.shadowGenerator?.addShadowCaster(house);
            window.shadowGenerator?.addShadowCaster(roof);
            
            // Add chimney
            const chimney = BABYLON.MeshBuilder.CreateBox("chimney" + index, {
                width: 1.5,
                height: 3,
                depth: 1.5
            }, scene);
            
            chimney.position.set(x + 2, 7.5, z + 3);
            chimney.material = new BABYLON.StandardMaterial("chimneyMat", scene);
            chimney.material.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            
            // Add smoke particle system
            const smoke = new BABYLON.ParticleSystem("smoke", 100, scene);
            smoke.particleTexture = new BABYLON.Texture("https://i.imgur.com/8Qq2Xqg.png", scene);
            smoke.emitter = chimney.position.clone();
            smoke.emitter.y += 1.5;
            smoke.minSize = 0.5;
            smoke.maxSize = 2;
            smoke.minLifeTime = 2;
            smoke.maxLifeTime = 4;
            smoke.emitRate = 5;
            smoke.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;
            smoke.direction1 = new BABYLON.Vector3(-0.5, 1, -0.5);
            smoke.direction2 = new BABYLON.Vector3(0.5, 2, 0.5);
            smoke.color1 = new BABYLON.Color4(0.8, 0.8, 0.8, 0.3);
            smoke.color2 = new BABYLON.Color4(0.9, 0.9, 0.9, 0);
            smoke.minAngularSpeed = 0;
            smoke.maxAngularSpeed = Math.PI;
            smoke.start();
        };

        // Create tavern
        const createTavern = (x, z, rotation) => {
            // Tavern base (larger than regular houses)
            const tavern = BABYLON.MeshBuilder.CreateBox("tavern", {
                width: 15,
                height: 8,
                depth: 20
            }, scene);
            
            tavern.position.set(x, 4, z);
            tavern.rotation.y = rotation;
            
            // Tavern roof
            const tavernRoof = BABYLON.MeshBuilder.CreateCylinder("tavernRoof", {
                height: 7,
                diameterTop: 0,
                diameterBottom: 20,
                tessellation: 4
            }, scene);
            
            tavernRoof.position.set(x, 8 + 3.5, z);
            tavernRoof.rotation.y = rotation + Math.PI / 4;
            tavernRoof.scaling.x = 1.3;
            
            // Materials
            const tavernMat = new BABYLON.StandardMaterial("tavernMat", scene);
            tavernMat.diffuseColor = new BABYLON.Color3(0.8, 0.6, 0.4);
            
            const tavernRoofMat = new BABYLON.StandardMaterial("tavernRoofMat", scene);
            tavernRoofMat.diffuseColor = new BABYLON.Color3(0.5, 0.25, 0.1);
            
            tavern.material = tavernMat;
            tavernRoof.material = tavernRoofMat;
            
            // Add sign
            const sign = BABYLON.MeshBuilder.CreateBox("sign", {
                width: 6,
                height: 0.5,
                depth: 4
            }, scene);
            
            sign.position.set(x + 8, 6, z);
            sign.rotation.y = rotation;
            sign.material = new BABYLON.StandardMaterial("signMat", scene);
            sign.material.diffuseColor = new BABYLON.Color3(0.7, 0.5, 0.3);
            
            window.shadowGenerator?.addShadowCaster(tavern);
            window.shadowGenerator?.addShadowCaster(tavernRoof);
        };

        // Create market stalls
        const createMarketStalls = () => {
            // Create several market stalls in a cluster
            const stallPositions = [
                { x: 25, z: -20 },
                { x: 30, z: -18 },
                { x: 28, z: -15 },
                { x: 23, z: -17 }
            ];
            
            stallPositions.forEach((pos, i) => {
                // Stall base
                const stall = BABYLON.MeshBuilder.CreateBox("stall" + i, {
                    width: 4,
                    height: 3,
                    depth: 6
                }, scene);
                
                stall.position.set(pos.x, 1.5, pos.z);
                stall.rotation.y = Math.random() * Math.PI * 2;
                
                // Stall roof (cloth-like)
                const roof = BABYLON.MeshBuilder.CreateCylinder("stallRoof" + i, {
                    height: 2,
                    diameterTop: 0,
                    diameterBottom: 6,
                    tessellation: 6
                }, scene);
                
                roof.position.set(pos.x, 3 + 1, pos.z);
                
                // Materials
                const stallMat = new BABYLON.StandardMaterial("stallMat" + i, scene);
                stallMat.diffuseColor = new BABYLON.Color3(0.7, 0.5, 0.3);
                
                const roofMat = new BABYLON.StandardMaterial("stallRoofMat" + i, scene);
                const colors = [
                    new BABYLON.Color3(0.8, 0.2, 0.2), // Red
                    new BABYLON.Color3(0.2, 0.8, 0.2), // Green
                    new BABYLON.Color3(0.2, 0.2, 0.8), // Blue
                    new BABYLON.Color3(0.8, 0.8, 0.2)  // Yellow
                ];
                roofMat.diffuseColor = colors[i % colors.length];
                
                stall.material = stallMat;
                roof.material = roofMat;
            });
        };

        // Create watermill
        const createWatermill = (x, z, rotation) => {
            // Mill building
            const mill = BABYLON.MeshBuilder.CreateBox("mill", {
                width: 10,
                height: 12,
                depth: 8
            }, scene);
            
            mill.position.set(x, 6, z);
            mill.rotation.y = rotation;
            
            // Mill roof
            const millRoof = BABYLON.MeshBuilder.CreateCylinder("millRoof", {
                height: 4,
                diameterTop: 0,
                diameterBottom: 12,
                tessellation: 4
            }, scene);
            
            millRoof.position.set(x, 12 + 2, z);
            millRoof.rotation.y = rotation + Math.PI / 4;
            
            // Water wheel
            const wheel = BABYLON.MeshBuilder.CreateCylinder("waterWheel", {
                height: 1,
                diameter: 12,
                tessellation: 16
            }, scene);
            
            wheel.position.set(x + 8, 0, z);
            wheel.rotation.x = Math.PI / 2;
            
            // Add paddles to wheel
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const paddle = BABYLON.MeshBuilder.CreateBox("paddle" + i, {
                    width: 1,
                    height: 10,
                    depth: 0.5
                }, scene);
                
                paddle.position.set(
                    x + 8 + Math.cos(angle) * 6,
                    Math.sin(angle) * 6,
                    z
                );
                paddle.rotation.z = angle;
                paddle.parent = wheel;
            }
            
            // Materials
            const millMat = new BABYLON.StandardMaterial("millMat", scene);
            millMat.diffuseColor = new BABYLON.Color3(0.7, 0.6, 0.4);
            
            const wheelMat = new BABYLON.StandardMaterial("wheelMat", scene);
            wheelMat.diffuseColor = new BABYLON.Color3(0.4, 0.3, 0.2);
            
            mill.material = millMat;
            millRoof.material = new BABYLON.StandardMaterial("millRoofMat", scene);
            millRoof.material.diffuseColor = new BABYLON.Color3(0.5, 0.25, 0.1);
            wheel.material = wheelMat;
            
            window.waterWheel = wheel;
            window.shadowGenerator?.addShadowCaster(mill);
            window.shadowGenerator?.addShadowCaster(millRoof);
        };

        // Create watchtower
        const createWatchtower = () => {
            assetsLoading++;
            
            const watchtower = BABYLON.MeshBuilder.CreateCylinder("watchtower", {
                height: 25,
                diameter: 6,
                tessellation: 16
            }, scene);
            
            watchtower.position.set(60, 12.5, 0);
            
            // Make it look ruined
            watchtower.scaling.x = 0.8 + Math.random() * 0.4;
            watchtower.scaling.z = 0.8 + Math.random() * 0.4;
            
            // Ruined top
            const towerTop = BABYLON.MeshBuilder.CreateCylinder("towerTop", {
                height: 5,
                diameterTop: 0,
                diameterBottom: 8,
                tessellation: 8
            }, scene);
            
            towerTop.position.set(60, 25 + 2.5, 0);
            towerTop.scaling.x = 0.7 + Math.random() * 0.6;
            towerTop.scaling.z = 0.7 + Math.random() * 0.6;
            
            // Materials with damaged look
            const ruinedMat = new BABYLON.StandardMaterial("ruinedMat", scene);
            ruinedMat.diffuseColor = new BABYLON.Color3(0.5, 0.4, 0.3);
            
            watchtower.material = ruinedMat;
            towerTop.material = ruinedMat;
            
            // Add vines/overgrowth
            for (let i = 0; i < 10; i++) {
                const vine = BABYLON.MeshBuilder.CreateCylinder("vine" + i, {
                    height: 15 + Math.random() * 10,
                    diameter: 0.5,
                    tessellation: 8
                }, scene);
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 2.5 + Math.random() * 2;
                
                vine.position.set(
                    60 + Math.cos(angle) * distance,
                    7.5,
                    Math.sin(angle) * distance
                );
                
                vine.rotation.x = Math.random() * 0.5;
                vine.rotation.z = Math.random() * 0.5;
                
                const vineMat = new BABYLON.StandardMaterial("vineMat", scene);
                vineMat.diffuseColor = new BABYLON.Color3(0.3, 0.6, 0.3);
                vine.material = vineMat;
            }
            
            assetsLoaded++;
            updateLoading();
        };

        // Create water features
        const createWaterFeatures = () => {
            assetsLoading += 2;
            
            // Create river (circular around castle)
            const river = BABYLON.MeshBuilder.CreateTorus("river", {
                diameter: 70,
                thickness: 8,
                tessellation: 64
            }, scene);
            
            river.position.y = -1;
            river.rotation.x = Math.PI / 2;
            
            // River material (turquoise water)
            const waterMat = new BABYLON.StandardMaterial("waterMat", scene);
            waterMat.diffuseColor = new BABYLON.Color3(0.3, 0.8, 0.9);
            waterMat.alpha = 0.7;
            waterMat.specularPower = 128;
            
            // Add water animation
            scene.registerBeforeRender(() => {
                waterMat.diffuseColor = new BABYLON.Color3(
                    0.3 + Math.sin(Date.now() * 0.001) * 0.1,
                    0.8 + Math.cos(Date.now() * 0.001) * 0.1,
                    0.9
                );
            });
            
            river.material = waterMat;
            
            // Create waterfalls at cliff edges
            createWaterfalls();
            
            assetsLoaded += 2;
            updateLoading();
        };

        // Create waterfalls
        const createWaterfalls = () => {
            // Create several waterfalls around the island
            const waterfallPositions = [
                { x: 45, z: 45 },
                { x: -45, z: 45 },
                { x: 45, z: -45 },
                { x: -45, z: -45 }
            ];
            
            // Custom shader material for waterfalls
            const waterfallMaterial = new BABYLON.ShaderMaterial("waterfall", scene, {
                vertex: "waterfall",
                fragment: "waterfall",
            }, {
                attributes: ["position", "normal", "uv"],
                uniforms: ["worldViewProjection", "time"]
            });
            
            waterfallMaterial.setFloat("waterOffset", 0);
            window.waterfallMaterial = waterfallMaterial;
            
            waterfallPositions.forEach((pos, i) => {
                const waterfall = BABYLON.MeshBuilder.CreatePlane("waterfall" + i, {
                    width: 10,
                    height: 30
                }, scene);
                
                waterfall.position.set(pos.x, 15, pos.z);
                waterfall.rotation.y = Math.atan2(-pos.x, -pos.z);
                waterfall.material = waterfallMaterial;
                
                // Add mist particles at bottom
                const mist = new BABYLON.ParticleSystem("mist" + i, 200, scene);
                mist.particleTexture = new BABYLON.Texture("https://i.imgur.com/8Qq2Xqg.png", scene);
                mist.emitter = new BABYLON.Vector3(pos.x, -10, pos.z);
                mist.minSize = 1;
                mist.maxSize = 3;
                mist.minLifeTime = 1;
                mist.maxLifeTime = 3;
                mist.emitRate = 50;
                mist.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;
                mist.direction1 = new BABYLON.Vector3(-2, 2, -2);
                mist.direction2 = new BABYLON.Vector3(2, 4, 2);
                mist.color1 = new BABYLON.Color4(1, 1, 1, 0.3);
                mist.color2 = new BABYLON.Color4(1, 1, 1, 0);
                mist.start();
            });
        };

        // Create bridges
        const createBridges = () => {
            assetsLoading++;
            
            // Create several wooden bridges across the river
            const bridgeAngles = [0, Math.PI/2, Math.PI, -Math.PI/2];
            
            bridgeAngles.forEach((angle, i) => {
                const bridgeLength = 15;
                const bridgeWidth = 4;
                
                const bridge = BABYLON.MeshBuilder.CreateBox("bridge" + i, {
                    width: bridgeWidth,
                    height: 1,
                    depth: bridgeLength
                }, scene);
                
                const distance = 35;
                bridge.position.set(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );
                bridge.rotation.y = angle + Math.PI/2;
                
                // Bridge material
                const bridgeMat = new BABYLON.StandardMaterial("bridgeMat", scene);
                bridgeMat.diffuseColor = new BABYLON.Color3(0.5, 0.3, 0.2);
                
                // Add wood texture
                const woodTexture = new BABYLON.Texture("https://i.imgur.com/5N3vJ8Y.png", scene);
                woodTexture.uScale = 3;
                woodTexture.vScale = 1;
                bridgeMat.diffuseTexture = woodTexture;
                
                bridge.material = bridgeMat;
                window.shadowGenerator?.addShadowCaster(bridge);
                
                // Add bridge railings
                const railing1 = BABYLON.MeshBuilder.CreateBox("railing1" + i, {
                    width: 0.5,
                    height: 2,
                    depth: bridgeLength
                }, scene);
                
                const railing2 = BABYLON.MeshBuilder.CreateBox("railing2" + i, {
                    width: 0.5,
                    height: 2,
                    depth: bridgeLength
                }, scene);
                
                const offset = bridgeWidth/2 + 0.25;
                railing1.position.set(
                    Math.cos(angle) * distance + Math.cos(angle + Math.PI/2) * offset,
                    1,
                    Math.sin(angle) * distance + Math.sin(angle + Math.PI/2) * offset
                );
                railing1.rotation.y = angle + Math.PI/2;
                
                railing2.position.set(
                    Math.cos(angle) * distance - Math.cos(angle + Math.PI/2) * offset,
                    1,
                    Math.sin(angle) * distance - Math.sin(angle + Math.PI/2) * offset
                );
                railing2.rotation.y = angle + Math.PI/2;
                
                railing1.material = bridgeMat;
                railing2.material = bridgeMat;
            });
            
            assetsLoaded++;
            updateLoading();
        };

        // Create foliage
        const createFoliage = () => {
            assetsLoading += 2;
            
            // Create pine trees around the island
            for (let i = 0; i < 40; i++) {
                // Random position on island (avoid center)
                let x, z;
                let attempts = 0;
                
                do {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 20 + Math.random() * 35;
                    x = Math.cos(angle) * distance;
                    z = Math.sin(angle) * distance;
                    attempts++;
                } while ((Math.abs(x) < 25 && Math.abs(z) < 25) && attempts < 10);
                
                createTree(x, z);
            }
            
            // Add grass/flowers
            createGroundFoliage();
            
            assetsLoaded += 2;
            updateLoading();
        };

        // Create a tree
        const createTree = (x, z) => {
            // Tree trunk
            const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk", {
                height: 8 + Math.random() * 4,
                diameter: 1 + Math.random() * 0.5,
                tessellation: 8
            }, scene);
            
            trunk.position.set(x, 4, z);
            
            // Tree foliage (pine-like)
            const foliageHeight = 6 + Math.random() * 4;
            for (let level = 0; level < 3; level++) {
                const foliage = BABYLON.MeshBuilder.CreateCylinder("foliage", {
                    height: foliageHeight / 3,
                    diameterTop: 0,
                    diameterBottom: 4 + level * 2,
                    tessellation: 8
                }, scene);
                
                foliage.position.set(x, 8 + level * (foliageHeight / 3), z);
                foliage.scaling.x = 0.8 + Math.random() * 0.4;
                foliage.scaling.z = 0.8 + Math.random() * 0.4;
                
                const foliageMat = new BABYLON.StandardMaterial("foliageMat", scene);
                foliageMat.diffuseColor = new BABYLON.Color3(
                    0.2 + Math.random() * 0.1,
                    0.5 + Math.random() * 0.2,
                    0.2 + Math.random() * 0.1
                );
                foliage.material = foliageMat;
                window.shadowGenerator?.addShadowCaster(foliage);
            }
            
            const trunkMat = new BABYLON.StandardMaterial("trunkMat", scene);
            trunkMat.diffuseColor = new BABYLON.Color3(0.4, 0.3, 0.2);
            trunk.material = trunkMat;
            window.shadowGenerator?.addShadowCaster(trunk);
        };

        // Create ground foliage
        const createGroundFoliage = () => {
            // Add small flowers and grass
            for (let i = 0; i < 100; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 15 + Math.random() * 40;
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                
                // Skip if too close to buildings
                if (Math.abs(x) < 30 && Math.abs(z) < 30) continue;
                
                const flower = BABYLON.MeshBuilder.CreateSphere("flower" + i, {
                    diameter: 0.5 + Math.random() * 0.5,
                    segments: 8
                }, scene);
                
                flower.position.set(x, 0.25, z);
                
                const flowerMat = new BABYLON.StandardMaterial("flowerMat", scene);
                const colors = [
                    new BABYLON.Color3(1, 0, 0),    // Red
                    new BABYLON.Color3(0, 1, 0),    // Green
                    new BABYLON.Color3(0, 0, 1),    // Blue
                    new BABYLON.Color3(1, 1, 0),    // Yellow
                    new BABYLON.Color3(1, 0, 1)     // Magenta
                ];
                flowerMat.diffuseColor = colors[Math.floor(Math.random() * colors.length)];
                flower.material = flowerMat;
            }
        };

        // Create atmosphere
        const createAtmosphere = () => {
            // Add fog for depth
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
            scene.fogDensity = 0.01;
            scene.fogColor = new BABYLON.Color3(0.7, 0.8, 1.0);
            
            // Add ambient sounds (simulated with visual effects)
            // Birds flying around
            for (let i = 0; i < 10; i++) {
                createBird();
            }
        };

        // Create flying bird
        const createBird = () => {
            const bird = BABYLON.MeshBuilder.CreateSphere("bird", {
                diameter: 0.5,
                segments: 4
            }, scene);
            
            // Random starting position
            const angle = Math.random() * Math.PI * 2;
            const distance = 80 + Math.random() * 40;
            const height = 30 + Math.random() * 30;
            
            bird.position.set(
                Math.cos(angle) * distance,
                height,
                Math.sin(angle) * distance
            );
            
            const birdMat = new BABYLON.StandardMaterial("birdMat", scene);
            birdMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            bird.material = birdMat;
            
            // Animate bird flying
            const speed = 0.5 + Math.random() * 0.5;
            scene.registerBeforeRender(() => {
                bird.position.x += Math.sin(Date.now() * 0.001 * speed) * 0.1;
                bird.position.z += Math.cos(Date.now() * 0.001 * speed) * 0.1;
                bird.position.y += Math.sin(Date.now() * 0.002 * speed) * 0.05;
            });
        };

        // Setup controls
        const setupControls = () => {
            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'r':
                        // Reset camera
                        camera.alpha = -Math.PI / 2.5;
                        camera.beta = Math.PI / 3;
                        camera.radius = 120;
                        camera.target = new BABYLON.Vector3(0, 15, 0);
                        break;
                        
                    case 'f':
                        // Toggle fog
                        fogEnabled = !fogEnabled;
                        scene.fogMode = fogEnabled ? BABYLON.Scene.FOGMODE_EXP2 : BABYLON.Scene.FOGMODE_NONE;
                        break;
                        
                    case ' ':
                        // Screenshot
                        BABYLON.Tools.CreateScreenshot(engine, camera, { precision: 2 });
                        break;
                }
            });
        };

        // Setup loading
        const setupLoading = () => {
            assetsLoading = 1; // Minimum loading count
        };

        // Update loading progress
        const updateLoading = () => {
            const progress = (assetsLoaded / assetsLoading) * 100;
            document.getElementById('loadingProgress').style.width = `${progress}%`;
            
            // Update loading text based on progress
            const texts = [
                "Creating magical world...",
                "Building floating island...",
                "Constructing stone castle...",
                "Planting lush forests...",
                "Carving turquoise river...",
                "Adding village details...",
                "Finalizing atmosphere..."
            ];
            
            const textIndex = Math.min(texts.length - 1, Math.floor(progress / (100 / texts.length)));
            document.getElementById('loadingText').textContent = texts[textIndex];
            
            // Hide loading screen when done
            if (progress >= 100) {
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                    }, 1000);
                }, 500);
            }
        };

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', () => {
            initEngine();
        });
    </script>
</body>
</html>