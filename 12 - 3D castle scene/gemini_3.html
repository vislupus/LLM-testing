<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Medieval Floating Island Diorama</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            /* Nice radial gradient background */
            background: radial-gradient(circle at center, #89f7fe 0%, #66a6ff 100%);
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
        }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
    </style>
    <!-- Babylon.js CDN -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
    <div id="loading">Building World...</div>
    <canvas id="renderCanvas"></canvas>

    <script>
        window.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('renderCanvas');
            const engine = new BABYLON.Engine(canvas, true, { stencil: true });

            const createScene = function() {
                const scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color4(0,0,0,0); // Transparent for CSS background

                // --- 1. Camera & Lighting ---
                const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI/2.5, Math.PI/3, 75, new BABYLON.Vector3(0, 5, 0), scene);
                camera.attachControl(canvas, true);
                camera.lowerRadiusLimit = 30;
                camera.upperRadiusLimit = 150;
                camera.wheelPrecision = 50;
                
                // Auto-rotate for diorama display feel
                camera.useAutoRotationBehavior = true;
                camera.autoRotationBehavior.idleRotationSpeed = 0.08;

                // Hemisphere Light (Ambient)
                const hemiLight = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
                hemiLight.intensity = 0.6;
                hemiLight.groundColor = new BABYLON.Color3(0.2, 0.15, 0.1);

                // Directional Light (Sun + Shadows)
                const dirLight = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.5, -1, -0.4), scene);
                dirLight.position = new BABYLON.Vector3(40, 60, 40);
                dirLight.intensity = 1.3;

                // Shadows
                const shadowGen = new BABYLON.ShadowGenerator(2048, dirLight);
                shadowGen.useBlurExponentialShadowMap = true;
                shadowGen.blurKernel = 32; // Soft shadows
                shadowGen.bias = 0.0005;
                
                // --- 2. Materials Palette ---
                const createMat = (name, colorHex) => {
                    const mat = new BABYLON.StandardMaterial(name, scene);
                    mat.diffuseColor = BABYLON.Color3.FromHexString(colorHex);
                    mat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1); // Matte finish
                    return mat;
                };

                const mats = {
                    grass: createMat("grass", "#6ebd4b"),
                    cliff: createMat("cliff", "#5c524b"),
                    water: createMat("water", "#2be3d3"), // Bright turquoise
                    stone: createMat("stone", "#9ea3a8"),
                    stoneDark: createMat("stoneDark", "#565a5e"),
                    wood: createMat("wood", "#6d4c41"),
                    woodDark: createMat("woodDark", "#3e2723"),
                    roofRed: createMat("roofRed", "#c0392b"),
                    roofBlue: createMat("roofBlue", "#2980b9"),
                    roofBrown: createMat("roofBrown", "#795548"),
                    sand: createMat("sand", "#e6cca3"),
                    leaves: createMat("leaves", "#2d6a4f"),
                    white: createMat("white", "#ecf0f1"),
                    stripeRed: createMat("stripeRed", "#e74c3c")
                };
                
                // Make water shiny/transparent
                mats.water.alpha = 0.9;
                mats.water.specularColor = new BABYLON.Color3(0.8, 0.8, 0.8);

                // --- 3. Terrain Generation (CSG) ---
                const islandRadius = 25;
                const islandHeight = 12;

                // River Path
                const riverPath = [];
                for(let z = -islandRadius - 2; z <= islandRadius + 2; z++) {
                    // Sine wave path
                    riverPath.push(new BABYLON.Vector3(Math.sin(z * 0.2) * 8 + 8, 0, z));
                }

                // Base Cylinders
                const groundCyl = BABYLON.MeshBuilder.CreateCylinder("g", {diameter: islandRadius*2, height: 4, tessellation: 64}, scene);
                groundCyl.position.y = 2;
                const cliffCyl = BABYLON.MeshBuilder.CreateCylinder("c", {diameter: islandRadius*2, height: islandHeight, tessellation: 64}, scene);
                cliffCyl.position.y = -islandHeight/2 + 2;

                // River Cutter Tube
                const cutter = BABYLON.MeshBuilder.CreateTube("cut", {path: riverPath, radius: 3.5, sideOrientation: BABYLON.Mesh.DOUBLESIDE, cap: BABYLON.Mesh.CAP_ALL}, scene);
                cutter.position.y = 3;

                // CSG Operations
                const gCSG = BABYLON.CSG.FromMesh(groundCyl);
                const cCSG = BABYLON.CSG.FromMesh(cliffCyl);
                const cutCSG = BABYLON.CSG.FromMesh(cutter);

                const finalGrass = gCSG.subtract(cutCSG).toMesh("grass", mats.grass, scene);
                const finalCliff = cCSG.subtract(cutCSG).toMesh("cliff", mats.cliff, scene);
                
                finalGrass.receiveShadows = true;
                finalCliff.receiveShadows = true;
                shadowGen.addShadowCaster(finalGrass);
                shadowGen.addShadowCaster(finalCliff);

                // Cleanup primitives
                groundCyl.dispose(); cliffCyl.dispose(); cutter.dispose();

                // Add Water Mesh
                const riverMesh = BABYLON.MeshBuilder.CreateTube("river", {path: riverPath, radius: 3.2, sideOrientation: BABYLON.Mesh.DOUBLESIDE, cap: BABYLON.Mesh.CAP_ALL}, scene);
                riverMesh.position.y = 1.2;
                riverMesh.scaling.y = 0.1; // Flatten
                riverMesh.material = mats.water;

                // --- 4. Helper Builders ---

                // CASTLE Builder
                const createCastle = (x, z) => {
                    const root = new BABYLON.TransformNode("castleRoot", scene);
                    root.position.set(x, 4, z);

                    // Main Keep
                    const keep = BABYLON.MeshBuilder.CreateBox("keep", {width: 6, depth: 6, height: 8}, scene);
                    keep.position.y = 4;
                    keep.material = mats.stone;
                    keep.parent = root;
                    shadowGen.addShadowCaster(keep);

                    // Central Tower
                    const mainTower = BABYLON.MeshBuilder.CreateCylinder("mt", {diameter: 4, height: 12, tessellation: 16}, scene);
                    mainTower.position.y = 6;
                    mainTower.material = mats.stone;
                    mainTower.parent = root;
                    shadowGen.addShadowCaster(mainTower);

                    const mainRoof = BABYLON.MeshBuilder.CreateCylinder("mr", {diameterTop: 0, diameterBottom: 5, height: 4, tessellation: 16}, scene);
                    mainRoof.position.y = 14;
                    mainRoof.material = mats.roofBlue;
                    mainRoof.parent = root;
                    shadowGen.addShadowCaster(mainRoof);

                    // Corner Towers
                    const corners = [[-3,-3], [3,-3], [-3,3], [3,3]];
                    corners.forEach(c => {
                        const t = BABYLON.MeshBuilder.CreateCylinder("ct", {diameter: 2, height: 10, tessellation: 16}, scene);
                        t.position.set(c[0], 5, c[1]);
                        t.material = mats.stone;
                        t.parent = root;
                        shadowGen.addShadowCaster(t);

                        const tr = BABYLON.MeshBuilder.CreateCylinder("ctr", {diameterTop: 0, diameterBottom: 2.5, height: 2.5, tessellation: 16}, scene);
                        tr.position.set(c[0], 11, c[1]);
                        tr.material = mats.roofBlue;
                        tr.parent = root;
                        shadowGen.addShadowCaster(tr);
                    });
                    
                    // Gate
                    const gate = BABYLON.MeshBuilder.CreateBox("gate", {width: 2, height: 3, depth: 0.5}, scene);
                    gate.position.set(0, 1.5, -3);
                    gate.material = mats.woodDark;
                    gate.parent = root;
                };

                // HOUSE Builder
                const createHouse = (x, y, z, scale, rotation, roofMat, hasChimney=false) => {
                    const root = new BABYLON.TransformNode("house", scene);
                    root.position.set(x, y, z);
                    root.rotation.y = rotation;
                    root.scaling.setAll(scale);

                    const body = BABYLON.MeshBuilder.CreateBox("b", {width: 2, height: 1.5, depth: 1.5}, scene);
                    body.position.y = 0.75;
                    body.material = mats.wood;
                    body.parent = root;
                    shadowGen.addShadowCaster(body);

                    const roof = BABYLON.MeshBuilder.CreateCylinder("r", {diameter: 2.2, height: 2.5, tessellation: 3}, scene);
                    roof.rotation.z = Math.PI/2;
                    roof.position.y = 1.8;
                    roof.material = roofMat;
                    roof.parent = root;
                    shadowGen.addShadowCaster(roof);

                    if(hasChimney) {
                        const chim = BABYLON.MeshBuilder.CreateBox("chim", {width: 0.4, height: 1, depth: 0.4}, scene);
                        chim.position.set(0.5, 2.2, 0.5);
                        chim.material = mats.stoneDark;
                        chim.parent = root;
                    }
                    return root;
                };

                // TREE Builder
                const createTree = (x, z, scale) => {
                    const root = new BABYLON.TransformNode("tree", scene);
                    root.position.set(x, 4, z);
                    root.scaling.setAll(scale);

                    const trunk = BABYLON.MeshBuilder.CreateCylinder("t", {diameter: 0.4, height: 1.5}, scene);
                    trunk.position.y = 0.75;
                    trunk.material = mats.woodDark;
                    trunk.parent = root;
                    shadowGen.addShadowCaster(trunk);

                    for(let i=0; i<3; i++) {
                        const leaves = BABYLON.MeshBuilder.CreateCylinder("l", {diameterTop: 0, diameterBottom: 2.5 - i*0.5, height: 2 - i*0.2, tessellation: 12}, scene);
                        leaves.position.y = 2 + i*1.2;
                        leaves.material = mats.leaves;
                        leaves.parent = root;
                        shadowGen.addShadowCaster(leaves);
                    }
                };

                // MARKET STALL Builder
                const createStall = (x, z, rot) => {
                    const root = new BABYLON.TransformNode("stall", scene);
                    root.position.set(x, 4, z);
                    root.rotation.y = rot;

                    const table = BABYLON.MeshBuilder.CreateBox("table", {width: 1.5, height: 0.8, depth: 0.8}, scene);
                    table.position.y = 0.4;
                    table.material = mats.wood;
                    table.parent = root;
                    shadowGen.addShadowCaster(table);

                    const top = BABYLON.MeshBuilder.CreateBox("top", {width: 1.6, height: 0.1, depth: 1}, scene);
                    top.position.set(0, 1.5, 0);
                    top.rotation.x = Math.PI/8;
                    top.material = mats.stripeRed;
                    top.parent = root;
                    shadowGen.addShadowCaster(top);

                    const pole1 = BABYLON.MeshBuilder.CreateCylinder("p1", {diameter:0.1, height: 1.5}, scene);
                    pole1.position.set(0.7, 0.75, 0.3);
                    pole1.parent = root;
                    const pole2 = pole1.clone();
                    pole2.position.set(-0.7, 0.75, 0.3);
                    pole2.parent = root;
                }

                // --- 5. Scene Population ---

                // Castle at Center
                createCastle(-5, -2); // Slightly offset because river is at x positive

                // Village Area (Left/Back side)
                createHouse(-12, 4, 2, 1.2, Math.PI/4, mats.roofRed, true);
                createHouse(-14, 4, -3, 1.0, -Math.PI/6, mats.roofBrown);
                createHouse(-8, 4, 6, 1.1, Math.PI, mats.roofRed);
                
                // Tavern (Large)
                const tavern = createHouse(-9, 4, -9, 1.5, Math.PI/3, mats.roofBrown, true);
                // Tavern sign
                const signPost = BABYLON.MeshBuilder.CreateCylinder("sp", {diameter:0.1, height: 2}, scene);
                signPost.position.set(-8, 4, -7);
                const signBoard = BABYLON.MeshBuilder.CreateBox("sb", {width: 0.8, height: 0.5, depth: 0.1}, scene);
                signBoard.position.set(-8, 5.5, -7);
                signBoard.material = mats.white;
                shadowGen.addShadowCaster(signPost);
                shadowGen.addShadowCaster(signBoard);

                // Market Area
                createStall(-6, 9, Math.PI/2);
                createStall(-6, 7, Math.PI/2);
                createStall(-4, 8, -Math.PI/2);

                // Water Mill (Near River)
                const millPos = new BABYLON.Vector3(4, 4, 0);
                const mill = createHouse(millPos.x, millPos.y, millPos.z, 1.3, 0, mats.roofRed);
                // Wheel
                const wheelAxis = new BABYLON.TransformNode("wheelAxis", scene);
                wheelAxis.position.set(millPos.x + 1.5, millPos.y + 0.5, millPos.z);
                const wheel = BABYLON.MeshBuilder.CreateCylinder("wheel", {diameter: 2.5, height: 0.2, tessellation: 24}, scene);
                wheel.rotation.z = Math.PI/2;
                wheel.material = mats.woodDark;
                wheel.parent = wheelAxis;
                shadowGen.addShadowCaster(wheel);
                // Wheel Paddles
                for(let i=0; i<8; i++) {
                    const paddle = BABYLON.MeshBuilder.CreateBox("pad", {width: 0.5, height: 0.1, depth: 0.8}, scene);
                    paddle.rotation.x = (Math.PI*2 / 8) * i;
                    paddle.position.y = Math.sin(paddle.rotation.x) * 1.2;
                    paddle.position.z = Math.cos(paddle.rotation.x) * 1.2;
                    paddle.material = mats.wood;
                    paddle.parent = wheelAxis;
                }
                // Animate Wheel
                scene.registerBeforeRender(() => {
                    wheelAxis.rotation.x += 0.01;
                });

                // Bridges
                const createBridge = (pathIndex) => {
                    const p = riverPath[pathIndex];
                    const b = BABYLON.MeshBuilder.CreateBox("bridge", {width: 7, height: 0.2, depth: 2}, scene);
                    b.position.set(p.x, 4.1, p.z);
                    b.rotation.y = Math.PI/12; // Approximate flow tangent
                    b.material = mats.wood;
                    shadowGen.addShadowCaster(b);
                    
                    // Rails
                    const r1 = BABYLON.MeshBuilder.CreateBox("r1", {width: 7, height: 0.1, depth: 0.1}, scene);
                    r1.position.y = 0.5; r1.position.z = 0.9; r1.parent = b;
                    const r2 = r1.clone();
                    r2.position.z = -0.9; r2.parent = b;
                    r1.material = mats.woodDark; r2.material = mats.woodDark;
                };
                createBridge(15);
                createBridge(40);

                // Ruined Watchtower (Cliff Edge)
                const ruinPos = new BABYLON.Vector3(2, 4, -15);
                const ruinBase = BABYLON.MeshBuilder.CreateCylinder("ruin", {diameter: 2.5, height: 4, tessellation: 16}, scene);
                ruinBase.position = ruinPos;
                // Use CSG to "break" it
                const breakBox = BABYLON.MeshBuilder.CreateBox("bb", {size: 3}, scene);
                breakBox.position = ruinPos.add(new BABYLON.Vector3(1, 2, 0));
                breakBox.rotation = new BABYLON.Vector3(Math.PI/4, Math.PI/4, 0);
                
                const rCSG = BABYLON.CSG.FromMesh(ruinBase).subtract(BABYLON.CSG.FromMesh(breakBox));
                const ruinMesh = rCSG.toMesh("ruinFinal", mats.stoneDark, scene);
                ruinMesh.receiveShadows = true;
                shadowGen.addShadowCaster(ruinMesh);
                ruinBase.dispose(); breakBox.dispose();
                // Rubble
                for(let i=0; i<6; i++) {
                    const rub = BABYLON.MeshBuilder.CreatePolyhedron("rub", {type: 1, size: 0.3}, scene);
                    rub.position = ruinPos.add(new BABYLON.Vector3((Math.random()-0.5)*3, -1.8, (Math.random()-0.5)*3));
                    rub.material = mats.stoneDark;
                    shadowGen.addShadowCaster(rub);
                }

                // Scattering Trees
                for(let i=0; i<60; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * (islandRadius - 2);
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;

                    // Check collisions with river
                    let safe = true;
                    for(let p of riverPath) {
                        if(BABYLON.Vector3.Distance(new BABYLON.Vector3(x,0,z), new BABYLON.Vector3(p.x,0,p.z)) < 5) safe = false;
                    }
                    // Check center castle area
                    if(x > -8 && x < 0 && z > -6 && z < 6) safe = false;
                    
                    if(safe) {
                        createTree(x, z, 0.7 + Math.random()*0.5);
                    }
                }

                // Waterfalls (Particles)
                const createWaterfall = (pos) => {
                    const ps = new BABYLON.ParticleSystem("wf", 1000, scene);
                    ps.particleTexture = new BABYLON.Texture("https://cdn.babylonjs.com/assets/flare.png", scene);
                    ps.emitter = pos;
                    ps.minEmitBox = new BABYLON.Vector3(-2, 0, -0.5);
                    ps.maxEmitBox = new BABYLON.Vector3(2, 0, 0.5);
                    ps.color1 = new BABYLON.Color4(0.8, 1, 1, 1);
                    ps.color2 = new BABYLON.Color4(0.2, 0.8, 1, 1);
                    ps.colorDead = new BABYLON.Color4(0, 0, 0.2, 0);
                    ps.minSize = 0.5; ps.maxSize = 1.0;
                    ps.minLifeTime = 1.0; ps.maxLifeTime = 1.5;
                    ps.emitRate = 500;
                    ps.gravity = new BABYLON.Vector3(0, -9.8, 0);
                    ps.start();
                };
                
                const startP = riverPath[0];
                const endP = riverPath[riverPath.length-1];
                createWaterfall(new BABYLON.Vector3(startP.x, 2, startP.z));
                createWaterfall(new BABYLON.Vector3(endP.x, 2, endP.z));


                // --- 6. Post Processing (The "Beautiful" Look) ---
                const pipeline = new BABYLON.DefaultRenderingPipeline("pipeline", true, scene, [camera]);
                pipeline.samples = 4; // Anti-aliasing
                pipeline.fxaaEnabled = true;
                
                // Color grading/Tone mapping
                pipeline.imageProcessing.toneMappingEnabled = true;
                pipeline.imageProcessing.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_ACES;
                pipeline.imageProcessing.contrast = 1.2;
                pipeline.imageProcessing.exposure = 1.1;
                pipeline.imageProcessing.vignetteEnabled = true;
                pipeline.imageProcessing.vignetteWeight = 1.5;

                // Bloom for the bright parts
                pipeline.bloomEnabled = true;
                pipeline.bloomThreshold = 0.8;
                pipeline.bloomWeight = 0.3;
                pipeline.bloomKernel = 64;

                // Remove loader
                document.getElementById("loading").style.opacity = 0;
                setTimeout(()=> document.getElementById("loading").style.display = 'none', 500);

                return scene;
            };

            const scene = createScene();

            engine.runRenderLoop(function() {
                scene.render();
            });

            window.addEventListener('resize', function() {
                engine.resize();
            });
        });
    </script>
</body>
</html>