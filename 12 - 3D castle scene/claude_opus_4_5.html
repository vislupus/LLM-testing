<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Floating Island Castle Diorama</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: linear-gradient(180deg, #87CEEB 0%, #4A90B8 50%, #2C5F7C 100%);
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
            outline: none;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            opacity: 0.8;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="info">ğŸ° Drag to rotate â€¢ Scroll to zoom</div>

    <script>
    (function() {
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true, { 
            preserveDrawingBuffer: true, 
            stencil: true,
            antialias: true
        });

        function createScene() {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

            // Aliases
            const V3 = BABYLON.Vector3;
            const C3 = BABYLON.Color3;
            const MB = BABYLON.MeshBuilder;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CAMERA
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const camera = new BABYLON.ArcRotateCamera(
                "camera", -Math.PI / 3, Math.PI / 2.6, 85,
                new V3(0, 6, 0), scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 35;
            camera.upperRadiusLimit = 150;
            camera.wheelPrecision = 30;
            camera.pinchPrecision = 40;
            camera.panningSensibility = 0;
            camera.inertia = 0.9;
            camera.useAutoRotationBehavior = true;
            camera.autoRotationBehavior.idleRotationSpeed = 0.08;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LIGHTING
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const hemi = new BABYLON.HemisphericLight("hemi", new V3(0.2, 1, 0.3), scene);
            hemi.intensity = 0.75;
            hemi.groundColor = new C3(0.35, 0.28, 0.25);
            hemi.specular = new C3(0.1, 0.1, 0.1);

            const sun = new BABYLON.DirectionalLight("sun", new V3(-0.4, -0.9, -0.5), scene);
            sun.position = new V3(40, 70, 50);
            sun.intensity = 1.1;

            const fillLight = new BABYLON.PointLight("fill", new V3(-30, 25, 20), scene);
            fillLight.intensity = 0.25;
            fillLight.diffuse = new C3(0.8, 0.85, 1.0);

            // Shadows
            const shadowGen = new BABYLON.ShadowGenerator(2048, sun);
            shadowGen.useBlurExponentialShadowMap = true;
            shadowGen.blurKernel = 48;
            shadowGen.bias = 0.0001;
            shadowGen.normalBias = 0.002;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // POST PROCESSING (Miniature Look)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const pipeline = new BABYLON.DefaultRenderingPipeline("pipe", true, scene, [camera]);
            pipeline.samples = 4;
            pipeline.fxaaEnabled = true;
            pipeline.bloomEnabled = true;
            pipeline.bloomThreshold = 0.85;
            pipeline.bloomWeight = 0.4;
            pipeline.bloomKernel = 64;
            pipeline.imageProcessing.toneMappingEnabled = true;
            pipeline.imageProcessing.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_ACES;
            pipeline.imageProcessing.exposure = 1.15;
            pipeline.imageProcessing.contrast = 1.25;
            pipeline.imageProcessing.vignetteEnabled = true;
            pipeline.imageProcessing.vignetteWeight = 1.5;
            pipeline.imageProcessing.vignetteColor = new BABYLON.Color4(0, 0, 0, 0);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // MATERIALS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function makeMat(name, diffuse, specular) {
                const m = new BABYLON.StandardMaterial(name, scene);
                m.diffuseColor = diffuse;
                m.specularColor = specular || new C3(0.08, 0.08, 0.08);
                m.specularPower = 16;
                return m;
            }

            const mats = {
                grass:      makeMat("grass", new C3(0.28, 0.72, 0.32)),
                grassDark:  makeMat("grassDark", new C3(0.22, 0.58, 0.26)),
                cliff:      makeMat("cliff", new C3(0.48, 0.42, 0.38)),
                cliffDark:  makeMat("cliffDark", new C3(0.35, 0.30, 0.28)),
                stone:      makeMat("stone", new C3(0.72, 0.72, 0.78)),
                stoneDark:  makeMat("stoneDark", new C3(0.52, 0.52, 0.58)),
                wood:       makeMat("wood", new C3(0.48, 0.30, 0.18)),
                woodLight:  makeMat("woodLight", new C3(0.72, 0.52, 0.32)),
                woodDark:   makeMat("woodDark", new C3(0.32, 0.20, 0.12)),
                roofRed:    makeMat("roofRed", new C3(0.78, 0.22, 0.18)),
                roofBrown:  makeMat("roofBrown", new C3(0.52, 0.32, 0.18)),
                roofBlue:   makeMat("roofBlue", new C3(0.25, 0.35, 0.55)),
                roofGray:   makeMat("roofGray", new C3(0.55, 0.55, 0.60)),
                foliage:    makeMat("foliage", new C3(0.15, 0.48, 0.28)),
                foliageLt:  makeMat("foliageLt", new C3(0.22, 0.58, 0.32)),
                water:      makeMat("water", new C3(0.0, 0.75, 0.85), new C3(0.6, 0.7, 0.8)),
                canopyYellow: makeMat("canopyY", new C3(0.95, 0.75, 0.25)),
                canopyRed:    makeMat("canopyR", new C3(0.85, 0.25, 0.20)),
                canopyPurple: makeMat("canopyP", new C3(0.55, 0.30, 0.70)),
            };
            mats.water.alpha = 0.88;
            mats.water.backFaceCulling = false;

            // Sea material
            const seaMat = makeMat("sea", new C3(0.08, 0.38, 0.62), new C3(0.15, 0.20, 0.25));
            seaMat.alpha = 0.95;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ISLAND ROOT (for animation)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const islandRoot = new BABYLON.TransformNode("islandRoot", scene);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SEA PLANE
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const sea = MB.CreateGround("sea", { width: 400, height: 400, subdivisions: 2 }, scene);
            sea.position.y = -18;
            sea.material = seaMat;
            sea.receiveShadows = true;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ISLAND GEOMETRY
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const islandRadius = 28;
            const grassHeight = 3;
            const cliffHeight = 16;
            const groundTopY = 5;

            // Grass top layer
            const grassLayer = MB.CreateCylinder("grassLayer", {
                height: grassHeight,
                diameterTop: islandRadius * 2,
                diameterBottom: islandRadius * 2 - 1,
                tessellation: 72
            }, scene);
            grassLayer.position.y = groundTopY - grassHeight / 2;
            grassLayer.material = mats.grass;
            grassLayer.parent = islandRoot;
            grassLayer.receiveShadows = true;
            shadowGen.addShadowCaster(grassLayer);

            // Rocky cliffs (tapered cone)
            const cliffLayer = MB.CreateCylinder("cliffLayer", {
                height: cliffHeight,
                diameterTop: islandRadius * 2 - 1,
                diameterBottom: islandRadius * 0.9,
                tessellation: 72
            }, scene);
            cliffLayer.position.y = groundTopY - grassHeight / 2 - cliffHeight / 2 - 0.5;
            cliffLayer.material = mats.cliff;
            cliffLayer.parent = islandRoot;
            cliffLayer.receiveShadows = true;
            shadowGen.addShadowCaster(cliffLayer);

            // Add noise to cliff geometry
            (function perturbCliff(mesh) {
                const positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
                const topY = cliffHeight / 2;
                for (let i = 0; i < positions.length; i += 3) {
                    const y = positions[i + 1];
                    if (y < topY - 0.5) {
                        const x = positions[i];
                        const z = positions[i + 2];
                        const r = Math.sqrt(x * x + z * z) || 1;
                        const depthFactor = 1 - (y + cliffHeight / 2) / cliffHeight;
                        const noise = (Math.random() - 0.5) * 3 * depthFactor;
                        const yNoise = (Math.random() - 0.5) * 1.5 * depthFactor;
                        positions[i] += (x / r) * noise;
                        positions[i + 1] += yNoise;
                        positions[i + 2] += (z / r) * noise;
                    }
                }
                mesh.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
                mesh.convertToFlatShadedMesh();
            })(cliffLayer);

            // Bottom cap
            const bottomCap = MB.CreateCylinder("bottomCap", {
                height: 2,
                diameterTop: islandRadius * 0.9,
                diameterBottom: islandRadius * 0.3,
                tessellation: 48
            }, scene);
            bottomCap.position.y = groundTopY - grassHeight / 2 - cliffHeight - 1.5;
            bottomCap.material = mats.cliffDark;
            bottomCap.parent = islandRoot;
            bottomCap.convertToFlatShadedMesh();
            shadowGen.addShadowCaster(bottomCap);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RIVER PATH
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const riverY = groundTopY + 0.3;
            const riverPath = [];
            const riverSegments = 100;
            const riverLength = 50;

            for (let i = 0; i < riverSegments; i++) {
                const t = i / (riverSegments - 1);
                const z = -riverLength / 2 + t * riverLength;
                const x = Math.sin(z * 0.18) * 10 + Math.sin(z * 0.35) * 3;
                riverPath.push(new V3(x, riverY, z));
            }

            // River trench (darker grass)
            const riverTrench = MB.CreateTube("riverTrench", {
                path: riverPath,
                radius: 3.5,
                tessellation: 24,
                cap: BABYLON.Mesh.CAP_ALL
            }, scene);
            riverTrench.material = mats.grassDark;
            riverTrench.parent = islandRoot;
            riverTrench.position.y = -0.8;
            riverTrench.scaling.y = 0.4;
            riverTrench.receiveShadows = true;

            // River water
            const riverWater = MB.CreateTube("riverWater", {
                path: riverPath,
                radius: 2.8,
                tessellation: 24,
                cap: BABYLON.Mesh.CAP_ALL
            }, scene);
            riverWater.material = mats.water;
            riverWater.parent = islandRoot;
            riverWater.position.y = -0.5;
            riverWater.scaling.y = 0.25;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CASTLE PLATEAU
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const plateauHeight = 2;
            const plateau = MB.CreateCylinder("plateau", {
                height: plateauHeight,
                diameter: 20,
                tessellation: 48
            }, scene);
            plateau.position.y = groundTopY + plateauHeight / 2;
            plateau.material = mats.grassDark;
            plateau.parent = islandRoot;
            plateau.convertToFlatShadedMesh();
            plateau.receiveShadows = true;
            shadowGen.addShadowCaster(plateau);

            const castleBaseY = groundTopY + plateauHeight;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CASTLE
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const castleRoot = new BABYLON.TransformNode("castleRoot", scene);
            castleRoot.parent = islandRoot;
            castleRoot.position.y = castleBaseY;

            // Main Keep
            const keepH = 10;
            const keep = MB.CreateBox("keep", { width: 7, depth: 7, height: keepH }, scene);
            keep.position.y = keepH / 2;
            keep.material = mats.stone;
            keep.parent = castleRoot;
            keep.convertToFlatShadedMesh();
            keep.receiveShadows = true;
            shadowGen.addShadowCaster(keep);

            // Keep battlements
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const bx = Math.cos(angle) * 4;
                const bz = Math.sin(angle) * 4;
                const battlement = MB.CreateBox("battlement", { width: 0.8, depth: 0.8, height: 0.7 }, scene);
                battlement.position = new V3(bx, keepH + 0.35, bz);
                battlement.material = mats.stoneDark;
                battlement.parent = castleRoot;
                shadowGen.addShadowCaster(battlement);
            }

            // Central tall tower
            const mainTowerH = 8;
            const mainTower = MB.CreateCylinder("mainTower", {
                height: mainTowerH,
                diameter: 3.5,
                tessellation: 32
            }, scene);
            mainTower.position.y = keepH + mainTowerH / 2;
            mainTower.material = mats.stoneDark;
            mainTower.parent = castleRoot;
            mainTower.convertToFlatShadedMesh();
            shadowGen.addShadowCaster(mainTower);

            // Main tower roof
            const mainTowerRoof = MB.CreateCylinder("mainTowerRoof", {
                height: 3.5,
                diameterTop: 0,
                diameterBottom: 4.5,
                tessellation: 32
            }, scene);
            mainTowerRoof.position.y = keepH + mainTowerH + 1.75;
            mainTowerRoof.material = mats.roofBlue;
            mainTowerRoof.parent = castleRoot;
            mainTowerRoof.convertToFlatShadedMesh();
            shadowGen.addShadowCaster(mainTowerRoof);

            // Corner towers
            const cornerPositions = [
                new V3(5.5, 0, 5.5),
                new V3(-5.5, 0, 5.5),
                new V3(5.5, 0, -5.5),
                new V3(-5.5, 0, -5.5)
            ];

            cornerPositions.forEach((pos, idx) => {
                const towerH = 5.5;
                const tower = MB.CreateCylinder("cornerTower" + idx, {
                    height: towerH,
                    diameter: 2.5,
                    tessellation: 24
                }, scene);
                tower.position = pos.add(new V3(0, towerH / 2 + 0.5, 0));
                tower.material = mats.stone;
                tower.parent = castleRoot;
                tower.convertToFlatShadedMesh();
                shadowGen.addShadowCaster(tower);

                const roof = MB.CreateCylinder("cornerRoof" + idx, {
                    height: 2.5,
                    diameterTop: 0,
                    diameterBottom: 3.2,
                    tessellation: 24
                }, scene);
                roof.position = pos.add(new V3(0, towerH + 1.75, 0));
                roof.material = mats.roofGray;
                roof.parent = castleRoot;
                roof.convertToFlatShadedMesh();
                shadowGen.addShadowCaster(roof);
            });

            // Curtain walls
            const wallH = 4.5;
            const wallPositions = [
                { pos: new V3(0, wallH / 2 + 0.5, 5.5), rot: 0, len: 11 },
                { pos: new V3(0, wallH / 2 + 0.5, -5.5), rot: 0, len: 11 },
                { pos: new V3(5.5, wallH / 2 + 0.5, 0), rot: Math.PI / 2, len: 11 },
                { pos: new V3(-5.5, wallH / 2 + 0.5, 0), rot: Math.PI / 2, len: 11 }
            ];

            wallPositions.forEach((w, idx) => {
                const wall = MB.CreateBox("wall" + idx, { width: w.len, height: wallH, depth: 1 }, scene);
                wall.position = w.pos;
                wall.rotation.y = w.rot;
                wall.material = mats.stoneDark;
                wall.parent = castleRoot;
                wall.convertToFlatShadedMesh();
                shadowGen.addShadowCaster(wall);
            });

            // Gatehouse
            const gateH = 5;
            const gatehouse = MB.CreateBox("gatehouse", { width: 4.5, height: gateH, depth: 2.5 }, scene);
            gatehouse.position = new V3(0, gateH / 2, -6.5);
            gatehouse.material = mats.stone;
            gatehouse.parent = castleRoot;
            gatehouse.convertToFlatShadedMesh();
            shadowGen.addShadowCaster(gatehouse);

            // Gate arch (dark opening)
            const gateArch = MB.CreateBox("gateArch", { width: 2, height: 3, depth: 2.6 }, scene);
            gateArch.position = new V3(0, 1.5, -6.5);
            gateArch.material = mats.woodDark;
            gateArch.parent = castleRoot;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // VILLAGE BUILDINGS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const buildingPositions = [];

            function registerBuilding(x, z, radius) {
                buildingPositions.push({ x, z, r: radius || 4 });
            }

            function createHouse(pos, roofMat, scale, rotY) {
                const root = new BABYLON.TransformNode("house", scene);
                root.parent = islandRoot;
                root.position = new V3(pos.x, groundTopY, pos.z);
                root.scaling.scaleInPlace(scale || 1);
                root.rotation.y = rotY || 0;

                const bodyH = 2;
                const body = MB.CreateBox("houseBody", { width: 3.2, height: bodyH, depth: 2.6 }, scene);
                body.position.y = bodyH / 2;
                body.material = mats.wood;
                body.parent = root;
                body.convertToFlatShadedMesh();
                body.receiveShadows = true;
                shadowGen.addShadowCaster(body);

                const roofH = 2.2;
                const roof = MB.CreateCylinder("houseRoof", {
                    height: 3.6,
                    diameterTop: 2.8,
                    diameterBottom: 2.8,
                    tessellation: 4
                }, scene);
                roof.position.y = bodyH + 0.5;
                roof.rotation.z = Math.PI / 2;
                roof.rotation.y = Math.PI / 4;
                roof.material = roofMat;
                roof.parent = root;
                roof.convertToFlatShadedMesh();
                shadowGen.addShadowCaster(roof);

                // Chimney
                const chimney = MB.CreateBox("chimney", { width: 0.4, height: 1.2, depth: 0.4 }, scene);
                chimney.position = new V3(0.8, bodyH + 1.4, 0.5);
                chimney.material = mats.stoneDark;
                chimney.parent = root;
                shadowGen.addShadowCaster(chimney);

                registerBuilding(pos.x, pos.z, 3.5 * (scale || 1));
                return root;
            }

            function createTavern(pos, rotY) {
                const root = new BABYLON.TransformNode("tavern", scene);
                root.parent = islandRoot;
                root.position = new V3(pos.x, groundTopY, pos.z);
                root.rotation.y = rotY || 0;

                // Main building
                const bodyH = 2.8;
                const body = MB.CreateBox("tavernBody", { width: 5.5, height: bodyH, depth: 4 }, scene);
                body.position.y = bodyH / 2;
                body.material = mats.wood;
                body.parent = root;
                body.convertToFlatShadedMesh();
                body.receiveShadows = true;
                shadowGen.addShadowCaster(body);

                // Second floor overhang
                const overhang = MB.CreateBox("overhang", { width: 5.8, height: 1.2, depth: 4.3 }, scene);
                overhang.position.y = bodyH + 0.6;
                overhang.material = mats.woodLight;
                overhang.parent = root;
                overhang.convertToFlatShadedMesh();
                shadowGen.addShadowCaster(overhang);

                // Roof
                const roof = MB.CreateCylinder("tavernRoof", {
                    height: 6,
                    diameterTop: 4.5,
                    diameterBottom: 4.5,
                    tessellation: 4
                }, scene);
                roof.position.y = bodyH + 2.5;
                roof.rotation.z = Math.PI / 2;
                roof.rotation.y = Math.PI / 4;
                roof.material = mats.roofRed;
                roof.parent = root;
                roof.convertToFlatShadedMesh();
                shadowGen.addShadowCaster(roof);

                // Sign post
                const signPost = MB.CreateCylinder("signPost", { height: 2.5, diameter: 0.12, tessellation: 8 }, scene);
                signPost.position = new V3(3.2, 1.25, 2.2);
                signPost.material = mats.woodDark;
                signPost.parent = root;
                shadowGen.addShadowCaster(signPost);

                const signBoard = MB.CreateBox("signBoard", { width: 1.2, height: 0.8, depth: 0.1 }, scene);
                signBoard.position = new V3(3.2, 2.2, 2.2);
                signBoard.material = mats.woodLight;
                signBoard.parent = root;
                shadowGen.addShadowCaster(signBoard);

                // Barrels
                for (let i = 0; i < 3; i++) {
                    const barrel = MB.CreateCylinder("barrel", { height: 0.8, diameter: 0.5, tessellation: 12 }, scene);
                    barrel.position = new V3(-3 + i * 0.6, 0.4, 2.3);
                    barrel.material = mats.woodDark;
                    barrel.parent = root;
                    shadowGen.addShadowCaster(barrel);
                }

                registerBuilding(pos.x, pos.z, 5);
                return root;
            }

            function createMarketStall(pos, canopyMat, rotY) {
                const root = new BABYLON.TransformNode("stall", scene);
                root.parent = islandRoot;
                root.position = new V3(pos.x, groundTopY, pos.z);
                root.rotation.y = rotY || 0;

                // Table
                const table = MB.CreateBox("table", { width: 2.8, height: 0.15, depth: 1.4 }, scene);
                table.position.y = 0.9;
                table.material = mats.woodLight;
                table.parent = root;
                table.receiveShadows = true;
                shadowGen.addShadowCaster(table);

                // Legs
                const legPositions = [
                    new V3(-1.2, 0.45, 0.55),
                    new V3(1.2, 0.45, 0.55),
                    new V3(-1.2, 0.45, -0.55),
                    new V3(1.2, 0.45, -0.55)
                ];
                legPositions.forEach((lp, i) => {
                    const leg = MB.CreateBox("leg" + i, { width: 0.12, height: 0.9, depth: 0.12 }, scene);
                    leg.position = lp;
                    leg.material = mats.wood;
                    leg.parent = root;
                    shadowGen.addShadowCaster(leg);
                });

                // Canopy posts
                const postH = 1.8;
                const postPositions = [
                    new V3(-1.3, postH / 2 + 0.9, 0.6),
                    new V3(1.3, postH / 2 + 0.9, 0.6),
                    new V3(-1.3, postH / 2 + 0.9, -0.6),
                    new V3(1.3, postH / 2 + 0.9, -0.6)
                ];
                postPositions.forEach((pp, i) => {
                    const post = MB.CreateCylinder("stallPost" + i, { height: postH, diameter: 0.1, tessellation: 8 }, scene);
                    post.position = pp;
                    post.material = mats.wood;
                    post.parent = root;
                    shadowGen.addShadowCaster(post);
                });

                // Canopy
                const canopy = MB.CreateBox("canopy", { width: 3, height: 0.08, depth: 1.6 }, scene);
                canopy.position.y = postH + 0.95;
                canopy.material = canopyMat;
                canopy.parent = root;
                shadowGen.addShadowCaster(canopy);

                // Goods on table
                for (let i = 0; i < 4; i++) {
                    const good = MB.CreateBox("good" + i, { width: 0.5, height: 0.3, depth: 0.4 }, scene);
                    good.position = new V3(-1 + i * 0.7, 1.15, 0);
                    good.material = i % 2 === 0 ? mats.canopyYellow : mats.roofBrown;
                    good.parent = root;
                    shadowGen.addShadowCaster(good);
                }

                registerBuilding(pos.x, pos.z, 2.5);
                return root;
            }

            function createMill(pos, rotY) {
                const root = new BABYLON.TransformNode("mill", scene);
                root.parent = islandRoot;
                root.position = new V3(pos.x, groundTopY, pos.z);
                root.rotation.y = rotY || 0;

                // Building
                const bodyH = 3;
                const body = MB.CreateBox("millBody", { width: 3.5, height: bodyH, depth: 3 }, scene);
                body.position.y = bodyH / 2;
                body.material = mats.wood;
                body.parent = root;
                body.convertToFlatShadedMesh();
                body.receiveShadows = true;
                shadowGen.addShadowCaster(body);

                // Roof
                const roof = MB.CreateCylinder("millRoof", {
                    height: 4,
                    diameterTop: 3.2,
                    diameterBottom: 3.2,
                    tessellation: 4
                }, scene);
                roof.position.y = bodyH + 0.8;
                roof.rotation.z = Math.PI / 2;
                roof.rotation.y = Math.PI / 4;
                roof.material = mats.roofBrown;
                roof.parent = root;
                roof.convertToFlatShadedMesh();
                shadowGen.addShadowCaster(roof);

                // Wheel frame
                const wheelRoot = new BABYLON.TransformNode("wheelRoot", scene);
                wheelRoot.parent = root;
                wheelRoot.position = new V3(-2, 1.5, 0);

                const wheel = MB.CreateTorus("wheel", { diameter: 3, thickness: 0.25, tessellation: 32 }, scene);
                wheel.rotation.x = Math.PI / 2;
                wheel.material = mats.woodDark;
                wheel.parent = wheelRoot;
                wheel.convertToFlatShadedMesh();
                shadowGen.addShadowCaster(wheel);

                // Paddles
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2;
                    const paddle = MB.CreateBox("paddle" + i, { width: 0.12, height: 1.2, depth: 0.5 }, scene);
                    paddle.position = new V3(Math.cos(angle) * 1.3, Math.sin(angle) * 1.3, 0);
                    paddle.rotation.z = angle;
                    paddle.material = mats.woodLight;
                    paddle.parent = wheelRoot;
                    shadowGen.addShadowCaster(paddle);
                }

                // Animate wheel
                scene.onBeforeRenderObservable.add(() => {
                    wheelRoot.rotation.z += 0.008;
                });

                registerBuilding(pos.x, pos.z, 4);
                return root;
            }

            // Place village buildings
            createTavern(new V3(-14, 0, 3), Math.PI / 8);
            createHouse(new V3(-16, 0, -5), mats.roofRed, 1.0, -Math.PI / 6);
            createHouse(new V3(-12, 0, 10), mats.roofBrown, 1.1, Math.PI / 4);
            createHouse(new V3(-6, 0, 14), mats.roofRed, 0.95, Math.PI / 3);
            createHouse(new V3(4, 0, 15), mats.roofBrown, 1.05, -Math.PI / 5);
            createHouse(new V3(12, 0, 11), mats.roofRed, 1.0, -Math.PI / 4);
            createHouse(new V3(16, 0, 3), mats.roofBrown, 0.9, Math.PI / 6);
            createHouse(new V3(14, 0, -8), mats.roofRed, 1.0, Math.PI / 2);

            createMarketStall(new V3(-10, 0, 5), mats.canopyYellow, 0);
            createMarketStall(new V3(-8, 0, 0), mats.canopyRed, Math.PI / 3);
            createMarketStall(new V3(-11, 0, -3), mats.canopyPurple, -Math.PI / 4);

            // Mill along river
            createMill(new V3(8, 0, -10), Math.PI / 2);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RUINED WATCHTOWER
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function createRuin(pos) {
                const root = new BABYLON.TransformNode("ruin", scene);
                root.parent = islandRoot;
                root.position = new V3(pos.x, groundTopY, pos.z);

                // Base
                const baseH = 5;
                const base = MB.CreateCylinder("ruinBase", {
                    height: baseH,
                    diameterTop: 2.8,
                    diameterBottom: 3.2,
                    tessellation: 24
                }, scene);
                base.position.y = baseH / 2;
                base.material = mats.stoneDark;
                base.parent = root;
                base.convertToFlatShadedMesh();
                base.receiveShadows = true;
                shadowGen.addShadowCaster(base);

                // Broken top (irregular geometry)
                const positions = base.getVerticesData(BABYLON.VertexBuffer.PositionKind);
                for (let i = 0; i < positions.length; i += 3) {
                    const y = positions[i + 1];
                    if (y > baseH / 2 - 0.5) {
                        positions[i + 1] -= Math.random() * 2.5;
                    }
                }
                base.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);

                // Rubble
                for (let i = 0; i < 8; i++) {
                    const rock = MB.CreatePolyhedron("rubble" + i, { type: 1, size: 0.35 + Math.random() * 0.3 }, scene);
                    rock.position = new V3((Math.random() - 0.5) * 4, 0.3, (Math.random() - 0.5) * 4);
                    rock.rotation = new V3(Math.random(), Math.random(), Math.random());
                    rock.material = mats.stone;
                    rock.parent = root;
                    rock.convertToFlatShadedMesh();
                    shadowGen.addShadowCaster(rock);
                }

                registerBuilding(pos.x, pos.z, 4);
                return root;
            }

            createRuin(new V3(-20, 0, -14));

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BRIDGES
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function createBridge(segmentIndex) {
                const i = Math.min(Math.max(segmentIndex, 1), riverPath.length - 2);
                const p0 = riverPath[i - 1];
                const p1 = riverPath[i + 1];
                const mid = riverPath[i];
                const dir = p1.subtract(p0).normalize();
                const angle = Math.atan2(dir.z, dir.x) + Math.PI / 2;

                const root = new BABYLON.TransformNode("bridge", scene);
                root.parent = islandRoot;
                root.position = new V3(mid.x, riverY + 1, mid.z);
                root.rotation.y = angle;

                // Deck
                const deck = MB.CreateBox("deck", { width: 6, height: 0.3, depth: 2 }, scene);
                deck.material = mats.woodLight;
                deck.parent = root;
                deck.convertToFlatShadedMesh();
                deck.receiveShadows = true;
                shadowGen.addShadowCaster(deck);

                // Rails
                const railH = 0.8;
                for (let side of [-0.85, 0.85]) {
                    const rail = MB.CreateBox("rail", { width: 5.5, height: 0.12, depth: 0.1 }, scene);
                    rail.position = new V3(0, railH / 2 + 0.15, side);
                    rail.material = mats.wood;
                    rail.parent = root;
                    shadowGen.addShadowCaster(rail);

                    // Posts
                    for (let px of [-2.4, 0, 2.4]) {
                        const post = MB.CreateCylinder("post", { height: railH, diameter: 0.12, tessellation: 8 }, scene);
                        post.position = new V3(px, railH / 2 + 0.15, side);
                        post.material = mats.wood;
                        post.parent = root;
                        shadowGen.addShadowCaster(post);
                    }
                }
            }

            createBridge(Math.floor(riverSegments * 0.28));
            createBridge(Math.floor(riverSegments * 0.58));
            createBridge(Math.floor(riverSegments * 0.78));

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PINE TREES
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function createPineTree(pos, scale) {
                const root = new BABYLON.TransformNode("tree", scene);
                root.parent = islandRoot;
                root.position = new V3(pos.x, groundTopY, pos.z);
                root.scaling.scaleInPlace(scale);
                root.rotation.y = Math.random() * Math.PI * 2;

                // Trunk
                const trunkH = 1.8;
                const trunk = MB.CreateCylinder("trunk", { height: trunkH, diameter: 0.45, tessellation: 12 }, scene);
                trunk.position.y = trunkH / 2;
                trunk.material = mats.woodDark;
                trunk.parent = root;
                trunk.convertToFlatShadedMesh();
                trunk.receiveShadows = true;
                shadowGen.addShadowCaster(trunk);

                // Foliage cones
                const layers = 4;
                for (let i = 0; i < layers; i++) {
                    const h = 1.6 - i * 0.15;
                    const d = 2.2 - i * 0.35;
                    const cone = MB.CreateCylinder("foliage" + i, {
                        height: h,
                        diameterTop: 0,
                        diameterBottom: d,
                        tessellation: 16
                    }, scene);
                    cone.position.y = trunkH + 0.5 + i * 0.75;
                    cone.material = i % 2 === 0 ? mats.foliage : mats.foliageLt;
                    cone.parent = root;
                    cone.convertToFlatShadedMesh();
                    cone.receiveShadows = true;
                    shadowGen.addShadowCaster(cone);
                }
            }

            function isPositionClear(x, z) {
                // Avoid plateau center
                if (Math.sqrt(x * x + z * z) < 11) return false;

                // Avoid buildings
                for (const b of buildingPositions) {
                    const dx = x - b.x;
                    const dz = z - b.z;
                    if (Math.sqrt(dx * dx + dz * dz) < b.r + 2) return false;
                }

                // Avoid river
                for (let i = 0; i < riverPath.length; i += 5) {
                    const p = riverPath[i];
                    const dx = x - p.x;
                    const dz = z - p.z;
                    if (Math.sqrt(dx * dx + dz * dz) < 5) return false;
                }

                return true;
            }

            // Scatter trees
            for (let i = 0; i < 80; i++) {
                const r = 10 + Math.random() * (islandRadius - 6);
                const theta = Math.random() * Math.PI * 2;
                const x = Math.cos(theta) * r;
                const z = Math.sin(theta) * r;

                if (!isPositionClear(x, z)) continue;

                const scale = 0.7 + Math.random() * 0.6;
                createPineTree(new V3(x, 0, z), scale);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // WATERFALLS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function createWaterfall(pathIdx) {
                const p = riverPath[pathIdx];

                const emitter = new BABYLON.TransformNode("waterfallEmitter", scene);
                emitter.parent = islandRoot;
                emitter.position = new V3(p.x, p.y - 1, p.z);

                const ps = new BABYLON.ParticleSystem("waterfall", 2000, scene);
                ps.particleTexture = new BABYLON.Texture("https://cdn.babylonjs.com/assets/flare.png", scene);
                ps.emitter = emitter;

                ps.minEmitBox = new V3(-1.5, 0, -0.8);
                ps.maxEmitBox = new V3(1.5, 0, 0.8);

                ps.color1 = new BABYLON.Color4(0.95, 0.98, 1.0, 1.0);
                ps.color2 = new BABYLON.Color4(0.4, 0.75, 0.95, 1.0);
                ps.colorDead = new BABYLON.Color4(0.1, 0.3, 0.5, 0);

                ps.minSize = 0.2;
                ps.maxSize = 0.7;
                ps.minLifeTime = 1.3;
                ps.maxLifeTime = 1.8;
                ps.emitRate = 500;

                ps.gravity = new V3(0, -12, 0);
                ps.direction1 = new V3(-0.3, -1, -0.3);
                ps.direction2 = new V3(0.3, -0.8, 0.3);

                ps.minEmitPower = 4;
                ps.maxEmitPower = 7;
                ps.updateSpeed = 0.015;

                ps.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;

                ps.start();
            }

            createWaterfall(3);
            createWaterfall(riverPath.length - 4);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FLOATING ANIMATION
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let time = 0;
            scene.onBeforeRenderObservable.add(() => {
                const dt = engine.getDeltaTime() * 0.001;
                time += dt;

                // Gentle bob
                islandRoot.position.y = Math.sin(time * 0.5) * 0.6;

                // Slow rotation
                islandRoot.rotation.y = time * 0.06;
            });

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // DECORATIVE ROCKS ON EDGES
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            for (let i = 0; i < 25; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = islandRadius - 2 + Math.random() * 3;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;

                const rock = MB.CreatePolyhedron("edgeRock", {
                    type: Math.floor(Math.random() * 3),
                    size: 0.4 + Math.random() * 0.6
                }, scene);
                rock.position = new V3(x, groundTopY + 0.3, z);
                rock.rotation = new V3(Math.random(), Math.random(), Math.random());
                rock.material = mats.cliff;
                rock.parent = islandRoot;
                rock.convertToFlatShadedMesh();
                rock.receiveShadows = true;
                shadowGen.addShadowCaster(rock);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SMALL BUSHES/FLOWERS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            for (let i = 0; i < 40; i++) {
                const r = 9 + Math.random() * (islandRadius - 5);
                const angle = Math.random() * Math.PI * 2;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;

                if (!isPositionClear(x, z)) continue;

                const bush = MB.CreateSphere("bush", { diameter: 0.8 + Math.random() * 0.5, segments: 8 }, scene);
                bush.position = new V3(x, groundTopY + 0.3, z);
                bush.material = Math.random() > 0.7 ? mats.canopyYellow : mats.foliageLt;
                bush.parent = islandRoot;
                bush.scaling.y = 0.6;
                bush.convertToFlatShadedMesh();
                bush.receiveShadows = true;
                shadowGen.addShadowCaster(bush);
            }

            return scene;
        }

        const scene = createScene();

        engine.runRenderLoop(() => scene.render());

        window.addEventListener('resize', () => engine.resize());
    })();
    </script>
</body>
</html>