<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floating Island Kingdom</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: linear-gradient(to bottom, #dbeaff 0%, #b8d4f0 100%);
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 24px;
            color: #4a5568;
            font-weight: 300;
            letter-spacing: 2px;
            pointer-events: none;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <div id="loading">Building Kingdom...</div>
    <canvas id="renderCanvas"></canvas>
    
    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
        
        const createScene = function () {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.86, 0.92, 1.0, 1);
            
            // Fog for depth and tabletop feel
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
            scene.fogDensity = 0.01;
            scene.fogColor = new BABYLON.Color3(0.86, 0.92, 1.0);
            
            // Camera - ArcRotate for diorama viewing
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 80, new BABYLON.Vector3(0, 5, 0), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 30;
            camera.upperRadiusLimit = 150;
            camera.wheelPrecision = 50;
            camera.alpha = -Math.PI / 3;
            camera.beta = Math.PI / 3;
            
            // Soft Lighting Setup
            const hemiLight = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
            hemiLight.intensity = 0.6;
            hemiLight.diffuse = new BABYLON.Color3(1, 0.95, 0.85);
            hemiLight.groundColor = new BABYLON.Color3(0.6, 0.7, 0.8);
            
            const sunLight = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-1, -2, -1), scene);
            sunLight.position = new BABYLON.Vector3(50, 100, 50);
            sunLight.intensity = 0.8;
            sunLight.shadowMinZ = 1;
            sunLight.shadowMaxZ = 200;
            
            // Shadows
            const shadowGenerator = new BABYLON.ShadowGenerator(2048, sunLight);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;
            shadowGenerator.bias = 0.0001;
            
            // Glow Layer for stylized look
            const gl = new BABYLON.GlowLayer("glow", scene);
            gl.intensity = 0.4;
            
            // Material Library
            const matLib = {
                grass: new BABYLON.StandardMaterial("grass", scene),
                stone: new BABYLON.StandardMaterial("stone", scene),
                wood: new BABYLON.StandardMaterial("wood", scene),
                roof: new BABYLON.StandardMaterial("roof", scene),
                water: new BABYLON.StandardMaterial("water", scene),
                cliff: new BABYLON.StandardMaterial("cliff", scene),
                gold: new BABYLON.StandardMaterial("gold", scene),
                leaves: new BABYLON.StandardMaterial("leaves", scene)
            };
            
            // Vibrant Stylized Colors
            matLib.grass.diffuseColor = new BABYLON.Color3(0.4, 0.7, 0.3);
            matLib.grass.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            matLib.grass.roughness = 0.8;
            
            matLib.stone.diffuseColor = new BABYLON.Color3(0.65, 0.65, 0.7);
            matLib.stone.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            
            matLib.wood.diffuseColor = new BABYLON.Color3(0.6, 0.4, 0.25);
            matLib.wood.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);
            
            matLib.roof.diffuseColor = new BABYLON.Color3(0.8, 0.35, 0.25);
            matLib.roof.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            
            matLib.water.diffuseColor = new BABYLON.Color3(0.2, 0.8, 0.9);
            matLib.water.specularColor = new BABYLON.Color3(0.8, 0.9, 1);
            matLib.water.emissiveColor = new BABYLON.Color3(0.05, 0.2, 0.25);
            matLib.water.alpha = 0.8;
            
            matLib.cliff.diffuseColor = new BABYLON.Color3(0.45, 0.45, 0.5);
            matLib.cliff.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            
            matLib.gold.diffuseColor = new BABYLON.Color3(1, 0.8, 0.2);
            matLib.gold.specularColor = new BABYLON.Color3(1, 0.9, 0.3);
            matLib.gold.emissiveColor = new BABYLON.Color3(0.2, 0.15, 0.05);
            
            matLib.leaves.diffuseColor = new BABYLON.Color3(0.15, 0.4, 0.2);
            matLib.leaves.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);
            
            // Create Floating Island Base
            const createIsland = () => {
                // Top grassy platform
                const topPlatform = BABYLON.MeshBuilder.CreateCylinder("islandTop", {
                    diameter: 75,
                    height: 8,
                    tessellation: 64
                }, scene);
                topPlatform.position.y = -4;
                topPlatform.material = matLib.grass;
                topPlatform.receiveShadows = true;
                shadowGenerator.addShadowCaster(topPlatform);
                
                // Rocky underside - irregular using multiple spheres/cylinders
                const rockGroup = new BABYLON.TransformNode("rocks");
                
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    const radius = 30 + Math.random() * 5;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    const h = 15 + Math.random() * 25;
                    const d = 8 + Math.random() * 12;
                    
                    const rock = BABYLON.MeshBuilder.CreateCylinder("rock"+i, {
                        diameterTop: 0,
                        diameterBottom: d,
                        height: h,
                        tessellation: 10
                    }, scene);
                    rock.position = new BABYLON.Vector3(x, -h/2, z);
                    rock.material = matLib.cliff;
                    rock.parent = rockGroup;
                    shadowGenerator.addShadowCaster(rock);
                }
                
                // Central stalactite
                const stalactite = BABYLON.MeshBuilder.CreateCylinder("stala", {
                    diameterTop: 5,
                    diameterBottom: 15,
                    height: 40,
                    tessellation: 8
                }, scene);
                stalactite.position.y = -25;
                stalactite.material = matLib.cliff;
                shadowGenerator.addShadowCaster(stalactite);
                
                return topPlatform;
            };
            
            const islandBase = createIsland();
            
            // Castle Builder
            const createCastle = () => {
                const castleGroup = new BABYLON.TransformNode("castle");
                
                // Main Keep - Larger central tower
                const keep = BABYLON.MeshBuilder.CreateCylinder("keep", {
                    diameter: 14,
                    height: 20,
                    tessellation: 8
                }, scene);
                keep.position.y = 8;
                keep.material = matLib.stone;
                keep.parent = castleGroup;
                shadowGenerator.addShadowCaster(keep);
                
                // Keep roof
                const keepRoof = BABYLON.MeshBuilder.CreateCylinder("keepRoof", {
                    diameterTop: 0,
                    diameterBottom: 16,
                    height: 8,
                    tessellation: 8
                }, scene);
                keepRoof.position.y = 22;
                keepRoof.material = matLib.roof;
                keepRoof.parent = castleGroup;
                
                // Gold flag on keep
                const flagpole = BABYLON.MeshBuilder.CreateCylinder("pole", {diameter: 0.3, height: 12}, scene);
                flagpole.position.y = 28;
                flagpole.material = matLib.wood;
                flagpole.parent = castleGroup;
                
                const flag = BABYLON.MeshBuilder.CreateBox("flag", {width: 4, height: 3, depth: 0.1}, scene);
                flag.position = new BABYLON.Vector3(2, 30, 0);
                flag.material = matLib.gold;
                flag.parent = castleGroup;
                
                // Corner Towers
                const towerPos = [
                    {x: 12, z: 12},
                    {x: -12, z: 12},
                    {x: 12, z: -12},
                    {x: -12, z: -12}
                ];
                
                towerPos.forEach((pos, i) => {
                    const tower = BABYLON.MeshBuilder.CreateCylinder("tower"+i, {
                        diameter: 8,
                        height: 15,
                        tessellation: 8
                    }, scene);
                    tower.position = new BABYLON.Vector3(pos.x, 7.5, pos.z);
                    tower.material = matLib.stone;
                    tower.parent = castleGroup;
                    shadowGenerator.addShadowCaster(tower);
                    
                    // Tower roof
                    const roof = BABYLON.MeshBuilder.CreateCylinder("roof"+i, {
                        diameterTop: 0,
                        diameterBottom: 9,
                        height: 6,
                        tessellation: 8
                    }, scene);
                    roof.position = new BABYLON.Vector3(pos.x, 18.5, pos.z);
                    roof.material = matLib.roof;
                    roof.parent = castleGroup;
                    
                    // Crenellations
                    for (let j = 0; j < 8; j++) {
                        const angle = (j / 8) * Math.PI * 2;
                        const cx = pos.x + Math.cos(angle) * 4;
                        const cz = pos.z + Math.sin(angle) * 4;
                        const cren = BABYLON.MeshBuilder.CreateBox("cren"+i+j, {size: 1.5}, scene);
                        cren.position = new BABYLON.Vector3(cx, 15.75, cz);
                        cren.material = matLib.stone;
                        cren.parent = castleGroup;
                    }
                });
                
                // Walls connecting towers
                for (let i = 0; i < 4; i++) {
                    const next = (i + 1) % 4;
                    const p1 = towerPos[i];
                    const p2 = towerPos[next];
                    const mid = new BABYLON.Vector3((p1.x + p2.x) / 2, 6, (p1.z + p2.z) / 2);
                    const dist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2));
                    
                    const wall = BABYLON.MeshBuilder.CreateBox("wall"+i, {
                        width: dist - 6,
                        height: 10,
                        depth: 2
                    }, scene);
                    wall.position = mid;
                    wall.lookAt(new BABYLON.Vector3(p2.x, 6, p2.z));
                    wall.material = matLib.stone;
                    wall.parent = castleGroup;
                    shadowGenerator.addShadowCaster(wall);
                }
                
                // Gatehouse
                const gate = BABYLON.MeshBuilder.CreateBox("gate", {width: 8, height: 10, depth: 4}, scene);
                gate.position = new BABYLON.Vector3(0, 5, 14);
                gate.material = matLib.stone;
                gate.parent = castleGroup;
                
                const arch = BABYLON.MeshBuilder.CreateCylinder("arch", {
                    diameter: 5,
                    height: 4,
                    tessellation: 16
                }, scene);
                arch.rotation.z = Math.PI / 2;
                arch.position = new BABYLON.Vector3(0, 3, 15);
                arch.scaling.y = 0.3;
                arch.material = matLib.stone;
                arch.parent = castleGroup;
            };
            
            createCastle();
            
            // Village Builder
            const createVillage = () => {
                const housePositions = [
                    {x: -25, z: 15, rot: 0.5, size: 1},
                    {x: -30, z: 5, rot: 0.8, size: 0.8},
                    {x: -22, z: -8, rot: -0.3, size: 0.9},
                    {x: 25, z: 18, rot: -0.5, size: 1},
                    {x: 28, z: 8, rot: -0.2, size: 0.85},
                    {x: 22, z: -5, rot: 0.4, size: 0.9},
                    {x: 5, z: 28, rot: 0, size: 1.1}, // Tavern
                    {x: 30, z: -20, rot: -1, size: 0.7} // Ruined
                ];
                
                housePositions.forEach((pos, i) => {
                    const scale = pos.size;
                    const houseGroup = new BABYLON.TransformNode("house"+i);
                    houseGroup.position = new BABYLON.Vector3(pos.x, 0, pos.z);
                    houseGroup.rotation.y = pos.rot;
                    
                    // House body
                    const body = BABYLON.MeshBuilder.CreateBox("hBody"+i, {
                        width: 6 * scale,
                        height: 5 * scale,
                        depth: 5 * scale
                    }, scene);
                    body.position.y = 2.5 * scale;
                    body.material = matLib.wood;
                    body.parent = houseGroup;
                    shadowGenerator.addShadowCaster(body);
                    
                    // Roof
                    const roof = BABYLON.MeshBuilder.CreateCylinder("hRoof"+i, {
                        diameterTop: 0,
                        diameterBottom: 8 * scale,
                        height: 4 * scale,
                        tessellation: 4
                    }, scene);
                    roof.rotation.y = Math.PI / 4;
                    roof.position.y = 7 * scale;
                    roof.material = matLib.roof;
                    roof.parent = houseGroup;
                    
                    // Door
                    const door = BABYLON.MeshBuilder.CreateBox("door"+i, {
                        width: 2 * scale,
                        height: 3 * scale,
                        depth: 0.2
                    }, scene);
                    door.position = new BABYLON.Vector3(0, 1.5 * scale, 2.5 * scale);
                    door.material = matLib.wood;
                    door.parent = houseGroup;
                });
                
                // Market stalls
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI + Math.PI;
                    const dist = 20;
                    const sx = Math.cos(angle) * dist;
                    const sz = Math.sin(angle) * dist;
                    
                    const stall = BABYLON.MeshBuilder.CreateBox("stall"+i, {width: 3, height: 3, depth: 2}, scene);
                    stall.position = new BABYLON.Vector3(sx + 10, 1.5, sz + 10);
                    stall.material = matLib.wood;
                    stall.rotation.y = angle;
                    shadowGenerator.addShadowCaster(stall);
                    
                    // Awning
                    const awning = BABYLON.MeshBuilder.CreateCylinder("awning"+i, {
                        diameterTop: 0,
                        diameterBottom: 4,
                        height: 2,
                        tessellation: 3
                    }, scene);
                    awning.rotation.z = Math.PI;
                    awning.rotation.y = angle;
                    awning.position = new BABYLON.Vector3(sx + 10, 3, sz + 10);
                    awning.material = new BABYLON.StandardMaterial("awningMat", scene);
                    awning.material.diffuseColor = new BABYLON.Color3(
                        0.5 + Math.random() * 0.5,
                        0.5 + Math.random() * 0.5,
                        0.3
                    );
                }
                
                // Watermill by river
                const millBase = BABYLON.MeshBuilder.CreateBox("millBase", {width: 8, height: 8, depth: 6}, scene);
                millBase.position = new BABYLON.Vector3(-5, 4, -25);
                millBase.material = matLib.wood;
                shadowGenerator.addShadowCaster(millBase);
                
                const millRoof = BABYLON.MeshBuilder.CreateCylinder("millRoof", {
                    diameterTop: 0,
                    diameterBottom: 10,
                    height: 5,
                    tessellation: 3
                }, scene);
                millRoof.rotation.y = Math.PI / 6;
                millRoof.position = new BABYLON.Vector3(-5, 10.5, -25);
                millRoof.material = matLib.roof;
                
                // Water wheel
                const wheel = BABYLON.MeshBuilder.CreateCylinder("wheel", {
                    diameter: 6,
                    height: 1,
                    tessellation: 16
                }, scene);
                wheel.rotation.x = Math.PI / 2;
                wheel.position = new BABYLON.Vector3(-2, 4, -25);
                wheel.material = matLib.wood;
                
                // Wheel animation
                scene.registerBeforeRender(() => {
                    wheel.rotation.y += 0.02;
                });
            };
            
            createVillage();
            
            // Ruined Watchtower at edge
            const createRuinedTower = () => {
                const ruinGroup = new BABYLON.TransformNode("ruin");
                ruinGroup.position = new BABYLON.Vector3(0, 0, -32);
                
                // Broken base
                const base = BABYLON.MeshBuilder.CreateCylinder("ruinBase", {
                    diameter: 10,
                    height: 8,
                    tessellation: 8
                }, scene);
                base.position.y = 4;
                base.material = matLib.stone;
                base.parent = ruinGroup;
                shadowGenerator.addShadowCaster(base);
                
                // Broken top (jagged)
                for (let i = 0; i < 5; i++) {
                    const chunk = BABYLON.MeshBuilder.CreateBox("chunk"+i, {
                        width: 2 + Math.random() * 2,
                        height: 2 + Math.random() * 4,
                        depth: 2 + Math.random() * 2
                    }, scene);
                    chunk.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 8,
                        8 + Math.random() * 3,
                        (Math.random() - 0.5) * 8
                    );
                    chunk.rotation = new BABYLON.Vector3(Math.random(), Math.random(), Math.random());
                    chunk.material = matLib.stone;
                    chunk.parent = ruinGroup;
                    shadowGenerator.addShadowCaster(chunk);
                }
                
                // Scattered stones
                for (let i = 0; i < 15; i++) {
                    const stone = BABYLON.MeshBuilder.CreatePolyhedron("stone"+i, {type: 1, size: 0.5 + Math.random()}, scene);
                    stone.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 15,
                        0.5,
                        (Math.random() - 0.5) * 15 - 32
                    );
                    stone.material = matLib.stone;
                    stone.parent = ruinGroup;
                }
            };
            
            createRuinedTower();
            
            // River with Bridges
            const createRiver = () => {
                // Curved river using tube
                const riverPath = [
                    new BABYLON.Vector3(-35, 0.2, -10),
                    new BABYLON.Vector3(-15, 0.2, -5),
                    new BABYLON.Vector3(0, 0.2, 0),
                    new BABYLON.Vector3(15, 0.2, 8),
                    new BABYLON.Vector3(35, 0.2, 5)
                ];
                
                const river = BABYLON.MeshBuilder.CreateTube("river", {
                    path: riverPath,
                    radius: 6,
                    sideOrientation: BABYLON.Mesh.DOUBLESIDE
                }, scene);
                river.material = matLib.water;
                
                // Riverbed (bottom of river)
                const riverBed = BABYLON.MeshBuilder.CreateTube("riverBed", {
                    path: riverPath,
                    radius: 5.8,
                    sideOrientation: BABYLON.Mesh.DOUBLESIDE
                }, scene);
                riverBed.position.y = -0.5;
                const bedMat = new BABYLON.StandardMaterial("bed", scene);
                bedMat.diffuseColor = new BABYLON.Color3(0.3, 0.5, 0.6);
                riverBed.material = bedMat;
                
                // Bridges
                const bridgePositions = [
                    {pos: new BABYLON.Vector3(-15, 1, -5), rot: 0.3},
                    {pos: new BABYLON.Vector3(15, 1, 8), rot: -0.4}
                ];
                
                bridgePositions.forEach((b, i) => {
                    const bridge = BABYLON.MeshBuilder.CreateBox("bridge"+i, {
                        width: 8,
                        height: 0.5,
                        depth: 4
                    }, scene);
                    bridge.position = b.pos;
                    bridge.rotation.y = b.rot;
                    bridge.material = matLib.wood;
                    shadowGenerator.addShadowCaster(bridge);
                    
                    // Railings
                    for (let j = 0; j < 2; j++) {
                        const rail = BABYLON.MeshBuilder.CreateBox("rail"+i+j, {
                            width: 8,
                            height: 1,
                            depth: 0.2
                        }, scene);
                        rail.position = new BABYLON.Vector3(b.pos.x, b.pos.y + 0.75, b.pos.z + (j === 0 ? -1.8 : 1.8));
                        rail.rotation.y = b.rot;
                        rail.material = matLib.wood;
                    }
                });
                
                // Waterfall at edge
                const createWaterfall = (x, z) => {
                    const particleSystem = new BABYLON.ParticleSystem("particles", 2000, scene);
                    particleSystem.emitter = new BABYLON.Vector3(x, 0, z);
                    particleSystem.particleTexture = new BABYLON.Texture("https://cdn.babylonjs.com/textures/flare.png", scene);
                    
                    particleSystem.minEmitBox = new BABYLON.Vector3(-2, 0, 0);
                    particleSystem.maxEmitBox = new BABYLON.Vector3(2, 0, 0);
                    
                    particleSystem.color1 = new BABYLON.Color4(0.2, 0.8, 0.9, 0.8);
                    particleSystem.color2 = new BABYLON.Color4(0.1, 0.6, 0.8, 0.5);
                    particleSystem.colorDead = new BABYLON.Color4(0.8, 0.9, 1, 0);
                    
                    particleSystem.minSize = 0.5;
                    particleSystem.maxSize = 1.5;
                    particleSystem.minLifeTime = 0.5;
                    particleSystem.maxLifeTime = 2;
                    particleSystem.emitRate = 500;
                    particleSystem.gravity = new BABYLON.Vector3(0, -20, 0);
                    particleSystem.direction1 = new BABYLON.Vector3(0, -10, 0);
                    particleSystem.direction2 = new BABYLON.Vector3(0, -15, 0);
                    
                    particleSystem.start();
                };
                
                createWaterfall(35, 5);
                createWaterfall(-35, -10);
            };
            
            createRiver();
            
            // Vegetation - Pine Trees
            const createTrees = () => {
                const treePositions = [
                    {x: -30, z: -25}, {x: -25, z: -28}, {x: -33, z: -15},
                    {x: 28, z: -25}, {x: 32, z: -20}, {x: 25, z: -30},
                    {x: -28, z: 25}, {x: 30, z: 28}, {x: 33, z: 22},
                    {x: -20, z: 28}, {x: 20, z: 30}, {x: 0, z: -28}
                ];
                
                treePositions.forEach((pos, i) => {
                    const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk"+i, {
                        diameter: 1.5,
                        height: 4,
                        tessellation: 8
                    }, scene);
                    trunk.position = new BABYLON.Vector3(pos.x, 2, pos.z);
                    trunk.material = matLib.wood;
                    shadowGenerator.addShadowCaster(trunk);
                    
                    // Pine layers
                    for (let j = 0; j < 3; j++) {
                        const cone = BABYLON.MeshBuilder.CreateCylinder("cone"+i+j, {
                            diameterTop: 0,
                            diameterBottom: 6 - j * 1.5,
                            height: 5,
                            tessellation: 8
                        }, scene);
                        cone.position = new BABYLON.Vector3(pos.x, 5 + j * 3, pos.z);
                        cone.material = matLib.leaves;
                        shadowGenerator.addShadowCaster(cone);
                    }
                });
                
                // Bushes/Grass patches
                for (let i = 0; i < 30; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 15 + Math.random() * 25;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    const bush = BABYLON.MeshBuilder.CreateSphere("bush"+i, {
                        diameter: 2 + Math.random() * 2,
                        segments: 4
                    }, scene);
                    bush.position = new BABYLON.Vector3(x, 1, z);
                    bush.scaling.y = 0.6;
                    bush.material = matLib.leaves;
                }
            };
            
            createTrees();
            
            // Floating animation for entire island
            let alpha = 0;
            scene.registerBeforeRender(() => {
                alpha += 0.005;
                const yOffset = Math.sin(alpha) * 0.5;
                camera.target.y = yOffset;
                
                // Adjust all mesh positions for floating effect
                scene.meshes.forEach(mesh => {
                    if (mesh.name !== "skyBox" && mesh.parent === null) {
                        mesh.position.y += (Math.sin(alpha) - Math.sin(alpha - 0.005)) * 0.5;
                    }
                });
            });
            
            // Skybox using color
            const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size: 1000}, scene);
            const skyMat = new BABYLON.StandardMaterial("sky", scene);
            skyMat.backFaceCulling = false;
            skyMat.emissiveColor = new BABYLON.Color3(0.86, 0.92, 1.0);
            skyMat.disableLighting = true;
            skybox.material = skyMat;
            
            // Post-processing for stylized look
            const pipeline = new BABYLON.DefaultRenderingPipeline("default", true, scene, [camera]);
            pipeline.fxaaEnabled = true;
            pipeline.bloomEnabled = true;
            pipeline.bloomThreshold = 0.7;
            pipeline.bloomWeight = 0.3;
            pipeline.bloomKernel = 64;
            pipeline.bloomScale = 0.5;
            
            // Color correction for vibrant stylized look
            const colorCurve = new BABYLON.ColorCurves();
            colorCurve.globalSaturation = 20;
            colorCurve.globalDensity = 5;
            colorCurve.highlightsHue = 10;
            colorCurve.highlightsSaturation = 10;
            colorCurve.shadowsHue = 120;
            colorCurve.shadowsSaturation = 20;
            pipeline.imageProcessing.colorCurves = colorCurve;
            pipeline.imageProcessing.contrast = 1.1;
            pipeline.imageProcessing.exposure = 1.1;
            
            document.getElementById("loading").style.opacity = 0;
            
            return scene;
        };
        
        const scene = createScene();
        
        engine.runRenderLoop(function () {
            scene.render();
        });
        
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>