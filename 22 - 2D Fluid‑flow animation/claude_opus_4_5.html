<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Von KÃ¡rmÃ¡n Vortex Street Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0c0c1e 0%, #1a1a3a 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            padding: 15px;
            color: #fff;
        }
        
        h1 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-weight: 500;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
            font-size: 24px;
        }
        
        #main-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        #canvas-wrapper {
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 212, 255, 0.3);
        }
        
        #controls {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 16px;
            min-width: 280px;
            max-width: 300px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .control-section {
            margin-bottom: 18px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .control-section h3 {
            color: #00d4ff;
            font-size: 13px;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: 600;
        }
        
        .control-row {
            margin-bottom: 10px;
        }
        
        .control-row label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
        }
        
        .control-row label span {
            color: #ff6b9d;
            font-weight: 600;
            font-family: 'Consolas', monospace;
        }
        
        input[type="range"] {
            width: 100%;
            height: 5px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00d4ff, #00a8cc);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 212, 255, 0.4);
        }
        
        select {
            width: 100%;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.4);
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            outline: none;
        }
        
        select:focus {
            border-color: #00d4ff;
        }
        
        .button-row {
            display: flex;
            gap: 8px;
        }
        
        button {
            flex: 1;
            padding: 10px 12px;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #00d4ff, #00a8cc);
            color: #000;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #ff6b9d, #e55a8a);
            color: #fff;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-box .value {
            font-size: 16px;
            font-weight: 700;
            color: #00d4ff;
            font-family: 'Consolas', monospace;
        }
        
        .stat-box .label {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
            margin-top: 3px;
        }
        
        .help-text {
            font-size: 11px;
            color: #888;
            line-height: 1.6;
        }
        
        .key {
            display: inline-block;
            background: rgba(0, 0, 0, 0.4);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', monospace;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin: 0 2px;
        }
        
        .legend {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 10px;
        }
        
        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <h1>ðŸŒŠ Von KÃ¡rmÃ¡n Vortex Street Simulation</h1>
    
    <div id="main-container">
        <div id="canvas-wrapper"></div>
        
        <div id="controls">
            <div class="control-section">
                <h3>Flow Properties</h3>
                <div class="control-row">
                    <label>Flow Speed: <span id="speedVal">0.12</span></label>
                    <input type="range" id="flowSpeed" min="0.05" max="0.25" step="0.01" value="0.12">
                </div>
                <div class="control-row">
                    <label>Viscosity: <span id="viscVal">0.02</span></label>
                    <input type="range" id="viscosity" min="0.005" max="0.1" step="0.005" value="0.02">
                </div>
            </div>
            
            <div class="control-section">
                <h3>Obstacle</h3>
                <div class="control-row">
                    <label>Shape:</label>
                    <select id="obstacleShape">
                        <option value="circle">Circle</option>
                        <option value="ellipse">Ellipse</option>
                        <option value="rectangle">Rectangle</option>
                        <option value="triangle">Triangle</option>
                        <option value="diamond">Diamond</option>
                    </select>
                </div>
                <div class="control-row">
                    <label>Size: <span id="sizeVal">25</span></label>
                    <input type="range" id="obstacleSize" min="10" max="50" step="1" value="25">
                </div>
                <div class="control-row">
                    <label>Aspect Ratio: <span id="aspectVal">1.0</span></label>
                    <input type="range" id="aspectRatio" min="0.3" max="3" step="0.1" value="1.0">
                </div>
                <div class="control-row">
                    <label>Rotation: <span id="rotVal">0</span>Â°</label>
                    <input type="range" id="rotation" min="0" max="360" step="5" value="0">
                </div>
            </div>
            
            <div class="control-section">
                <h3>Visualization</h3>
                <div class="control-row">
                    <label>Display Mode:</label>
                    <select id="vizMode">
                        <option value="vorticity">Vorticity</option>
                        <option value="velocity">Velocity Magnitude</option>
                        <option value="streamlines">Streamlines</option>
                        <option value="pressure">Pressure</option>
                    </select>
                </div>
                <div class="control-row">
                    <label>Show Vectors:</label>
                    <select id="showVectors">
                        <option value="none">None</option>
                        <option value="sparse">Sparse</option>
                        <option value="dense">Dense</option>
                    </select>
                </div>
                <div class="legend" id="legend"></div>
            </div>
            
            <div class="control-section">
                <h3>Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="value" id="reynoldsNum">--</div>
                        <div class="label">Reynolds #</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="strouhalNum">--</div>
                        <div class="label">Strouhal #</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="fpsDisplay">60</div>
                        <div class="label">FPS</div>
                    </div>
                    <div class="stat-box">
                        <div class="value" id="vortexCount">0</div>
                        <div class="label">Vortices</div>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Actions</h3>
                <div class="button-row">
                    <button class="btn-primary" onclick="resetSimulation()">Reset</button>
                    <button class="btn-secondary" onclick="togglePause()">Pause</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Controls</h3>
                <div class="help-text">
                    <span class="key">Drag</span> Move obstacle<br>
                    <span class="key">Scroll</span> Resize obstacle<br>
                    <span class="key">R</span> Rotate obstacle<br>
                    <span class="key">Space</span> Pause/Resume<br>
                    <span class="key">1-5</span> Change shape
                </div>
            </div>
        </div>
    </div>

    <script>
        // Lattice Boltzmann D2Q9 simulation
        const SCALE = 2;
        let NX, NY;
        let canvasWidth, canvasHeight;
        
        // D2Q9 lattice velocities
        const ex = [0, 1, 0, -1, 0, 1, -1, -1, 1];
        const ey = [0, 0, 1, 0, -1, 1, 1, -1, -1];
        const weights = [4/9, 1/9, 1/9, 1/9, 1/9, 1/36, 1/36, 1/36, 1/36];
        const opposite = [0, 3, 4, 1, 2, 7, 8, 5, 6];
        
        // Distribution functions
        let f, fTemp;
        let rho, ux, uy;
        let obstacle;
        let vorticity;
        
        // Simulation parameters
        let omega = 1.7;           // Relaxation parameter
        let inletVelocity = 0.12;  // Inlet flow speed
        let viscosity = 0.02;
        let paused = false;
        
        // Obstacle parameters
        let obstacleX, obstacleY;
        let obstacleSize = 25;
        let obstacleAspect = 1.0;
        let obstacleRotation = 0;
        let obstacleShape = 'circle';
        
        // Visualization
        let vizMode = 'vorticity';
        let showVectors = 'none';
        let bufferGraphics;
        
        // Drag state
        let isDragging = false;
        let dragOffsetX, dragOffsetY;
        
        // Vortex tracking
        let vortexHistory = [];
        
        function setup() {
            canvasWidth = min(900, windowWidth - 360);
            canvasHeight = min(450, windowHeight - 150);
            canvasWidth = max(600, canvasWidth);
            canvasHeight = max(300, canvasHeight);
            
            const canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('canvas-wrapper');
            
            NX = floor(canvasWidth / SCALE);
            NY = floor(canvasHeight / SCALE);
            
            obstacleX = floor(NX * 0.25);
            obstacleY = floor(NY * 0.5);
            
            initializeLattice();
            
            bufferGraphics = createGraphics(NX, NY);
            bufferGraphics.pixelDensity(1);
            
            setupControls();
            updateLegend();
        }
        
        function initializeLattice() {
            const size = NX * NY * 9;
            f = new Float32Array(size);
            fTemp = new Float32Array(size);
            
            rho = new Float32Array(NX * NY);
            ux = new Float32Array(NX * NY);
            uy = new Float32Array(NX * NY);
            obstacle = new Uint8Array(NX * NY);
            vorticity = new Float32Array(NX * NY);
            
            // Initialize equilibrium with inlet velocity
            for (let y = 0; y < NY; y++) {
                for (let x = 0; x < NX; x++) {
                    const idx = x + y * NX;
                    rho[idx] = 1.0;
                    ux[idx] = inletVelocity;
                    uy[idx] = 0;
                    
                    for (let i = 0; i < 9; i++) {
                        const fidx = idx * 9 + i;
                        f[fidx] = equilibrium(i, 1.0, inletVelocity, 0);
                    }
                }
            }
            
            updateObstacle();
            updateOmega();
        }
        
        function equilibrium(i, rho, ux, uy) {
            const eu = ex[i] * ux + ey[i] * uy;
            const usq = ux * ux + uy * uy;
            return weights[i] * rho * (1 + 3 * eu + 4.5 * eu * eu - 1.5 * usq);
        }
        
        function updateOmega() {
            // omega = 1 / (3 * viscosity + 0.5)
            omega = 1.0 / (3.0 * viscosity + 0.5);
            omega = constrain(omega, 1.0, 1.99);
            
            // Update Reynolds number display
            const Re = inletVelocity * obstacleSize * 2 / viscosity;
            document.getElementById('reynoldsNum').textContent = Re.toFixed(0);
            
            // Strouhal number for vortex shedding (theoretical ~0.2 for cylinder)
            const St = 0.198 * (1 - 19.7 / Re);
            document.getElementById('strouhalNum').textContent = Re > 50 ? St.toFixed(3) : '--';
        }
        
        function updateObstacle() {
            obstacle.fill(0);
            
            const cosR = cos(radians(obstacleRotation));
            const sinR = sin(radians(obstacleRotation));
            
            for (let y = 0; y < NY; y++) {
                for (let x = 0; x < NX; x++) {
                    // Transform to obstacle-local coordinates
                    let dx = x - obstacleX;
                    let dy = y - obstacleY;
                    
                    // Rotate
                    let rx = dx * cosR + dy * sinR;
                    let ry = -dx * sinR + dy * cosR;
                    
                    // Scale for aspect ratio
                    rx /= obstacleAspect;
                    
                    const idx = x + y * NX;
                    
                    switch(obstacleShape) {
                        case 'circle':
                            if (rx * rx + ry * ry < obstacleSize * obstacleSize) {
                                obstacle[idx] = 1;
                            }
                            break;
                        case 'ellipse':
                            if (rx * rx / (obstacleSize * obstacleSize) + 
                                ry * ry / (obstacleSize * obstacleSize * 0.5) < 1) {
                                obstacle[idx] = 1;
                            }
                            break;
                        case 'rectangle':
                            if (abs(rx) < obstacleSize && abs(ry) < obstacleSize * 0.6) {
                                obstacle[idx] = 1;
                            }
                            break;
                        case 'triangle':
                            const triSize = obstacleSize * 1.2;
                            if (rx > -triSize && rx < triSize * 0.5 && 
                                abs(ry) < (triSize - rx) * 0.6) {
                                obstacle[idx] = 1;
                            }
                            break;
                        case 'diamond':
                            if (abs(rx) / obstacleSize + abs(ry) / (obstacleSize * 0.7) < 1) {
                                obstacle[idx] = 1;
                            }
                            break;
                    }
                }
            }
            
            // Add tube walls
            for (let x = 0; x < NX; x++) {
                for (let w = 0; w < 2; w++) {
                    obstacle[x + w * NX] = 1;
                    obstacle[x + (NY - 1 - w) * NX] = 1;
                }
            }
        }
        
        function collideAndStream() {
            // Collision step with BGK
            for (let y = 1; y < NY - 1; y++) {
                for (let x = 0; x < NX; x++) {
                    const idx = x + y * NX;
                    
                    if (obstacle[idx]) continue;
                    
                    // Compute macroscopic quantities
                    let r = 0, vx = 0, vy = 0;
                    for (let i = 0; i < 9; i++) {
                        const fi = f[idx * 9 + i];
                        r += fi;
                        vx += ex[i] * fi;
                        vy += ey[i] * fi;
                    }
                    
                    vx /= r;
                    vy /= r;
                    
                    rho[idx] = r;
                    ux[idx] = vx;
                    uy[idx] = vy;
                    
                    // Collision
                    for (let i = 0; i < 9; i++) {
                        const feq = equilibrium(i, r, vx, vy);
                        f[idx * 9 + i] += omega * (feq - f[idx * 9 + i]);
                    }
                }
            }
            
            // Streaming step
            for (let y = 1; y < NY - 1; y++) {
                for (let x = 0; x < NX; x++) {
                    const idx = x + y * NX;
                    
                    for (let i = 0; i < 9; i++) {
                        let xn = x - ex[i];
                        let yn = y - ey[i];
                        
                        // Periodic in x for outlet
                        if (xn < 0) xn = NX - 1;
                        if (xn >= NX) xn = 0;
                        
                        const idxN = xn + yn * NX;
                        
                        if (obstacle[idxN]) {
                            // Bounce-back for obstacles
                            fTemp[idx * 9 + i] = f[idx * 9 + opposite[i]];
                        } else {
                            fTemp[idx * 9 + i] = f[idxN * 9 + i];
                        }
                    }
                }
            }
            
            // Swap buffers
            [f, fTemp] = [fTemp, f];
            
            // Inlet boundary condition (Zou-He)
            for (let y = 1; y < NY - 1; y++) {
                const idx = y * NX;
                const r = 1.0;
                
                rho[idx] = r;
                ux[idx] = inletVelocity;
                uy[idx] = 0;
                
                for (let i = 0; i < 9; i++) {
                    f[idx * 9 + i] = equilibrium(i, r, inletVelocity, 0);
                }
            }
            
            // Outlet boundary condition (copy from neighbor)
            for (let y = 1; y < NY - 1; y++) {
                const idx = (NX - 1) + y * NX;
                const idxN = (NX - 2) + y * NX;
                
                for (let i = 0; i < 9; i++) {
                    f[idx * 9 + i] = f[idxN * 9 + i];
                }
                
                rho[idx] = rho[idxN];
                ux[idx] = ux[idxN];
                uy[idx] = uy[idxN];
            }
        }
        
        function computeVorticity() {
            let maxVort = 0;
            let vortexCount = 0;
            
            for (let y = 1; y < NY - 1; y++) {
                for (let x = 1; x < NX - 1; x++) {
                    const idx = x + y * NX;
                    
                    if (obstacle[idx]) {
                        vorticity[idx] = 0;
                        continue;
                    }
                    
                    // Curl of velocity field
                    const duyDx = (uy[idx + 1] - uy[idx - 1]) * 0.5;
                    const duxDy = (ux[idx + NX] - ux[idx - NX]) * 0.5;
                    
                    vorticity[idx] = duyDx - duxDy;
                    maxVort = max(maxVort, abs(vorticity[idx]));
                    
                    // Count significant vortices
                    if (abs(vorticity[idx]) > 0.01) vortexCount++;
                }
            }
            
            document.getElementById('vortexCount').textContent = floor(vortexCount / 100);
        }
        
        function getColor(value, mode) {
            let r, g, b;
            
            if (mode === 'vorticity') {
                // Blue for negative (clockwise), Red for positive (counter-clockwise)
                const v = constrain(value * 50, -1, 1);
                if (v < 0) {
                    r = 0;
                    g = floor(-v * 150);
                    b = floor(-v * 255);
                } else {
                    r = floor(v * 255);
                    g = floor(v * 100);
                    b = 0;
                }
            } else if (mode === 'velocity') {
                // Velocity magnitude
                const mag = sqrt(value) * 5;
                const t = constrain(mag, 0, 1);
                // Blue -> Cyan -> Green -> Yellow -> Red
                if (t < 0.25) {
                    r = 0; g = floor(t * 4 * 255); b = 255;
                } else if (t < 0.5) {
                    r = 0; g = 255; b = floor((0.5 - t) * 4 * 255);
                } else if (t < 0.75) {
                    r = floor((t - 0.5) * 4 * 255); g = 255; b = 0;
                } else {
                    r = 255; g = floor((1 - t) * 4 * 255); b = 0;
                }
            } else if (mode === 'pressure') {
                // Pressure (density deviation)
                const p = constrain((value - 1) * 10 + 0.5, 0, 1);
                r = floor(p * 255);
                g = floor((1 - abs(p - 0.5) * 2) * 200);
                b = floor((1 - p) * 255);
            } else {
                // Streamlines mode - use vorticity
                const v = constrain(value * 50, -1, 1);
                if (v < 0) {
                    r = 50; g = 50 - floor(v * 50); b = 100 - floor(v * 155);
                } else {
                    r = 100 + floor(v * 155); g = 50 + floor(v * 50); b = 50;
                }
            }
            
            return [r, g, b];
        }
        
        function render() {
            bufferGraphics.loadPixels();
            
            for (let y = 0; y < NY; y++) {
                for (let x = 0; x < NX; x++) {
                    const idx = x + y * NX;
                    const pIdx = (x + y * NX) * 4;
                    
                    if (obstacle[idx]) {
                        bufferGraphics.pixels[pIdx] = 60;
                        bufferGraphics.pixels[pIdx + 1] = 60;
                        bufferGraphics.pixels[pIdx + 2] = 80;
                        bufferGraphics.pixels[pIdx + 3] = 255;
                        continue;
                    }
                    
                    let value;
                    if (vizMode === 'vorticity' || vizMode === 'streamlines') {
                        value = vorticity[idx];
                    } else if (vizMode === 'velocity') {
                        value = ux[idx] * ux[idx] + uy[idx] * uy[idx];
                    } else {
                        value = rho[idx];
                    }
                    
                    const [r, g, b] = getColor(value, vizMode);
                    
                    bufferGraphics.pixels[pIdx] = r;
                    bufferGraphics.pixels[pIdx + 1] = g;
                    bufferGraphics.pixels[pIdx + 2] = b;
                    bufferGraphics.pixels[pIdx + 3] = 255;
                }
            }
            
            bufferGraphics.updatePixels();
            
            // Draw to canvas
            image(bufferGraphics, 0, 0, width, height);
            
            // Draw obstacle outline
            stroke(255, 200);
            strokeWeight(2);
            noFill();
            push();
            translate(obstacleX * SCALE, obstacleY * SCALE);
            rotate(radians(obstacleRotation));
            
            switch(obstacleShape) {
                case 'circle':
                    ellipse(0, 0, obstacleSize * 2 * SCALE * obstacleAspect, obstacleSize * 2 * SCALE);
                    break;
                case 'ellipse':
                    ellipse(0, 0, obstacleSize * 2 * SCALE * obstacleAspect, obstacleSize * SCALE);
                    break;
                case 'rectangle':
                    rectMode(CENTER);
                    rect(0, 0, obstacleSize * 2 * SCALE * obstacleAspect, obstacleSize * 1.2 * SCALE);
                    break;
                case 'triangle':
                    const ts = obstacleSize * 1.2 * SCALE;
                    triangle(-ts * obstacleAspect, ts * 0.6, 
                             -ts * obstacleAspect, -ts * 0.6, 
                             ts * 0.5 * obstacleAspect, 0);
                    break;
                case 'diamond':
                    beginShape();
                    vertex(-obstacleSize * SCALE * obstacleAspect, 0);
                    vertex(0, -obstacleSize * 0.7 * SCALE);
                    vertex(obstacleSize * SCALE * obstacleAspect, 0);
                    vertex(0, obstacleSize * 0.7 * SCALE);
                    endShape(CLOSE);
                    break;
            }
            pop();
            
            // Draw velocity vectors
            if (showVectors !== 'none') {
                stroke(255, 150);
                strokeWeight(1);
                
                const step = showVectors === 'sparse' ? 20 : 10;
                const scale = 50;
                
                for (let y = step; y < NY - step; y += step) {
                    for (let x = step; x < NX - step; x += step) {
                        const idx = x + y * NX;
                        if (obstacle[idx]) continue;
                        
                        const vx = ux[idx];
                        const vy = uy[idx];
                        const mag = sqrt(vx * vx + vy * vy);
                        
                        if (mag > 0.001) {
                            const sx = x * SCALE;
                            const sy = y * SCALE;
                            const ex = sx + vx * scale * SCALE;
                            const ey = sy + vy * scale * SCALE;
                            
                            line(sx, sy, ex, ey);
                            
                            // Arrowhead
                            const angle = atan2(vy, vx);
                            const arrowSize = 3;
                            line(ex, ey, 
                                 ex - arrowSize * cos(angle - 0.5), 
                                 ey - arrowSize * sin(angle - 0.5));
                            line(ex, ey, 
                                 ex - arrowSize * cos(angle + 0.5), 
                                 ey - arrowSize * sin(angle + 0.5));
                        }
                    }
                }
            }
            
            // Draw streamlines for that mode
            if (vizMode === 'streamlines') {
                stroke(255, 100);
                strokeWeight(1);
                noFill();
                
                for (let sy = 20; sy < NY - 20; sy += 15) {
                    beginShape();
                    let x = 5;
                    let y = sy;
                    
                    for (let i = 0; i < 200; i++) {
                        const idx = floor(x) + floor(y) * NX;
                        if (x >= NX - 1 || obstacle[idx]) break;
                        
                        vertex(x * SCALE, y * SCALE);
                        
                        const vx = ux[idx];
                        const vy = uy[idx];
                        const mag = sqrt(vx * vx + vy * vy);
                        
                        if (mag < 0.001) break;
                        
                        x += vx / mag * 2;
                        y += vy / mag * 2;
                        
                        if (y < 2 || y > NY - 2) break;
                    }
                    endShape();
                }
            }
            
            // Flow direction indicator
            fill(255);
            noStroke();
            textSize(14);
            textAlign(LEFT, TOP);
            text('â†’ Flow', 10, 10);
        }
        
        function draw() {
            if (!paused) {
                // Multiple steps per frame for faster simulation
                for (let i = 0; i < 5; i++) {
                    collideAndStream();
                }
                computeVorticity();
            }
            
            render();
            
            // Update FPS
            if (frameCount % 10 === 0) {
                document.getElementById('fpsDisplay').textContent = floor(frameRate());
            }
        }
        
        function mousePressed() {
            const mx = mouseX / SCALE;
            const my = mouseY / SCALE;
            
            const dx = mx - obstacleX;
            const dy = my - obstacleY;
            
            if (sqrt(dx * dx + dy * dy) < obstacleSize * 1.5) {
                isDragging = true;
                dragOffsetX = dx;
                dragOffsetY = dy;
            }
        }
        
        function mouseDragged() {
            if (isDragging) {
                obstacleX = constrain(mouseX / SCALE - dragOffsetX, obstacleSize + 10, NX - obstacleSize - 10);
                obstacleY = constrain(mouseY / SCALE - dragOffsetY, obstacleSize + 5, NY - obstacleSize - 5);
                updateObstacle();
            }
        }
        
        function mouseReleased() {
            isDragging = false;
        }
        
        function mouseWheel(event) {
            if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {
                obstacleSize = constrain(obstacleSize - event.delta * 0.05, 10, 50);
                document.getElementById('obstacleSize').value = obstacleSize;
                document.getElementById('sizeVal').textContent = floor(obstacleSize);
                updateObstacle();
                updateOmega();
                return false;
            }
        }
        
        function keyPressed() {
            switch(key) {
                case ' ':
                    togglePause();
                    return false;
                case 'r':
                case 'R':
                    obstacleRotation = (obstacleRotation + 15) % 360;
                    document.getElementById('rotation').value = obstacleRotation;
                    document.getElementById('rotVal').textContent = obstacleRotation;
                    updateObstacle();
                    break;
                case '1':
                    obstacleShape = 'circle';
                    document.getElementById('obstacleShape').value = 'circle';
                    updateObstacle();
                    break;
                case '2':
                    obstacleShape = 'ellipse';
                    document.getElementById('obstacleShape').value = 'ellipse';
                    updateObstacle();
                    break;
                case '3':
                    obstacleShape = 'rectangle';
                    document.getElementById('obstacleShape').value = 'rectangle';
                    updateObstacle();
                    break;
                case '4':
                    obstacleShape = 'triangle';
                    document.getElementById('obstacleShape').value = 'triangle';
                    updateObstacle();
                    break;
                case '5':
                    obstacleShape = 'diamond';
                    document.getElementById('obstacleShape').value = 'diamond';
                    updateObstacle();
                    break;
            }
        }
        
        function setupControls() {
            document.getElementById('flowSpeed').addEventListener('input', function() {
                inletVelocity = parseFloat(this.value);
                document.getElementById('speedVal').textContent = inletVelocity.toFixed(2);
                updateOmega();
            });
            
            document.getElementById('viscosity').addEventListener('input', function() {
                viscosity = parseFloat(this.value);
                document.getElementById('viscVal').textContent = viscosity.toFixed(3);
                updateOmega();
            });
            
            document.getElementById('obstacleShape').addEventListener('change', function() {
                obstacleShape = this.value;
                updateObstacle();
            });
            
            document.getElementById('obstacleSize').addEventListener('input', function() {
                obstacleSize = parseFloat(this.value);
                document.getElementById('sizeVal').textContent = floor(obstacleSize);
                updateObstacle();
                updateOmega();
            });
            
            document.getElementById('aspectRatio').addEventListener('input', function() {
                obstacleAspect = parseFloat(this.value);
                document.getElementById('aspectVal').textContent = obstacleAspect.toFixed(1);
                updateObstacle();
            });
            
            document.getElementById('rotation').addEventListener('input', function() {
                obstacleRotation = parseFloat(this.value);
                document.getElementById('rotVal').textContent = floor(obstacleRotation);
                updateObstacle();
            });
            
            document.getElementById('vizMode').addEventListener('change', function() {
                vizMode = this.value;
                updateLegend();
            });
            
            document.getElementById('showVectors').addEventListener('change', function() {
                showVectors = this.value;
            });
        }
        
        function updateLegend() {
            const legend = document.getElementById('legend');
            
            if (vizMode === 'vorticity') {
                legend.innerHTML = `
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #0066ff, #000, #ff3300);"></div>
                        <span>CW â†” CCW</span>
                    </div>
                `;
            } else if (vizMode === 'velocity') {
                legend.innerHTML = `
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #0000ff, #00ffff, #00ff00, #ffff00, #ff0000);"></div>
                        <span>Low â†’ High</span>
                    </div>
                `;
            } else if (vizMode === 'pressure') {
                legend.innerHTML = `
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #0000ff, #ff00ff, #ff0000);"></div>
                        <span>Low â†’ High</span>
                    </div>
                `;
            } else {
                legend.innerHTML = `
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(90deg, #334488, #222, #884433);"></div>
                        <span>Streamlines</span>
                    </div>
                `;
            }
        }
        
        function resetSimulation() {
            initializeLattice();
        }
        
        function togglePause() {
            paused = !paused;
            document.querySelector('.btn-secondary').textContent = paused ? 'Resume' : 'Pause';
        }
    </script>
</body>
</html>