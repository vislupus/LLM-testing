<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Von KÃ¡rmÃ¡n Vortex Street - Interactive Fluid Dynamics</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0a0a0f, #1a1a2e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        
        #canvas-container {
            position: relative;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            color: #e0e0ff;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            max-width: 320px;
            transition: transform 0.3s ease;
            z-index: 100;
        }
        
        .controls.hidden {
            transform: translateX(-350px);
        }
        
        .controls h3 {
            margin: 0 0 15px 0;
            color: #64b5f6;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(100, 180, 255, 0.5);
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 13px;
            color: #b0c4ff;
        }
        
        .slider {
            width: 100%;
            height: 5px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #64b5f6;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 180, 255, 0.6);
        }
        
        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #64b5f6;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 180, 255, 0.6);
        }
        
        .shape-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        
        .shape-btn {
            padding: 8px;
            background: #333;
            color: #b0c4ff;
            border: 2px solid #555;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .shape-btn:hover {
            background: #444;
            border-color: #64b5f6;
        }
        
        .shape-btn.active {
            background: #64b5f6;
            color: #000;
            border-color: #64b5f6;
        }
        
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn {
            flex: 1;
            padding: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .visualization-modes {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        
        .viz-btn {
            flex: 1;
            padding: 8px;
            background: #333;
            color: #b0c4ff;
            border: 2px solid #555;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
        }
        
        .viz-btn.active {
            background: #4fc3f7;
            color: #000;
            border-color: #4fc3f7;
        }
        
        .toggle-btn {
            position: absolute;
            top: 20px;
            left: 350px;
            background: rgba(20, 20, 35, 0.95);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            z-index: 101;
        }
        
        .toggle-btn.shifted {
            left: 20px;
        }
        
        .info-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(20, 20, 35, 0.95);
            padding: 15px;
            border-radius: 12px;
            color: #e0e0ff;
            font-size: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            max-width: 250px;
            z-index: 100;
        }
        
        .info-panel h4 {
            margin: 0 0 10px 0;
            color: #64b5f6;
            font-size: 14px;
        }
        
        .info-panel div {
            margin: 5px 0;
        }
        
        .reynolds-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 35, 0.95);
            padding: 12px 18px;
            border-radius: 8px;
            color: #4fc3f7;
            font-weight: bold;
            font-size: 16px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(79, 195, 247, 0.5);
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div class="controls" id="controls">
            <h3>ðŸŒŠ Vortex Street Controls</h3>
            
            <div class="control-group">
                <label>Flow Speed: <span id="flowSpeedValue">2.0</span></label>
                <input type="range" class="slider" id="flowSpeed" min="0.5" max="5.0" step="0.1" value="2.0">
            </div>
            
            <div class="control-group">
                <label>Viscosity: <span id="viscosityValue">0.0001</span></label>
                <input type="range" class="slider" id="viscosity" min="0.00001" max="0.001" step="0.00001" value="0.0001">
            </div>
            
            <div class="control-group">
                <label>Obstacle Size: <span id="sizeValue">30</span></label>
                <input type="range" class="slider" id="obstacleSize" min="10" max="60" step="2" value="30">
            </div>
            
            <div class="control-group">
                <label>Rotation: <span id="rotationValue">0Â°</span></label>
                <input type="range" class="slider" id="rotation" min="0" max="360" step="5" value="0">
            </div>
            
            <div class="control-group">
                <label>Obstacle Shape</label>
                <div class="shape-buttons">
                    <button class="shape-btn active" data-shape="circle">Circle</button>
                    <button class="shape-btn" data-shape="ellipse">Ellipse</button>
                    <button class="shape-btn" data-shape="square">Square</button>
                    <button class="shape-btn" data-shape="rectangle">Rectangle</button>
                    <button class="shape-btn" data-shape="triangle">Triangle</button>
                    <button class="shape-btn" data-shape="airfoil">Airfoil</button>
                </div>
            </div>
            
            <div class="control-group">
                <label>Visualization</label>
                <div class="visualization-modes">
                    <button class="viz-btn active" data-viz="vorticity">Vorticity</button>
                    <button class="viz-btn" data-viz="velocity">Velocity</button>
                    <button class="viz-btn" data-viz="streamlines">Streamlines</button>
                </div>
            </div>
            
            <div class="action-buttons">
                <button class="btn" onclick="fluidSim.reset()">Reset Flow</button>
                <button class="btn" onclick="fluidSim.togglePause()">Pause</button>
            </div>
        </div>
        
        <button class="toggle-btn" id="toggleBtn" onclick="toggleControls()">â—€</button>
        
        <div class="reynolds-display">
            Re: <span id="reynolds">200</span>
        </div>
        
        <div class="info-panel">
            <h4>ðŸŽ® Instructions</h4>
            <div>â€¢ <strong>Drag</strong> obstacle to move</div>
            <div>â€¢ <strong>Scroll</strong> to resize obstacle</div>
            <div>â€¢ <strong>Q/E</strong> to rotate</div>
            <div>â€¢ <strong>Space</strong> pause/resume</div>
            <div>â€¢ <strong>R</strong> reset simulation</div>
        </div>
    </div>

    <script>
        class FluidSimulation {
            constructor() {
                this.gridSize = 200;
                this.scale = 4;
                this.dt = 0.016;
                
                // Velocity fields
                this.u = [];
                this.v = [];
                this.uPrev = [];
                this.vPrev = [];
                
                // Pressure and divergence
                this.p = [];
                this.div = [];
                
                // Obstacle properties
                this.obstacleX = 100;
                this.obstacleY = 100;
                this.obstacleSize = 30;
                this.obstacleRotation = 0;
                this.obstacleShape = 'circle';
                this.obstacleMask = [];
                
                // Simulation parameters
                this.flowSpeed = 2.0;
                this.viscosity = 0.0001;
                this.paused = false;
                this.visualizationMode = 'vorticity';
                
                this.init();
            }
            
            init() {
                const N = this.gridSize;
                
                // Initialize arrays
                for (let i = 0; i < N; i++) {
                    this.u[i] = [];
                    this.v[i] = [];
                    this.uPrev[i] = [];
                    this.vPrev[i] = [];
                    this.p[i] = [];
                    this.div[i] = [];
                    this.obstacleMask[i] = [];
                    
                    for (let j = 0; j < N; j++) {
                        this.u[i][j] = this.flowSpeed;
                        this.v[i][j] = 0;
                        this.uPrev[i][j] = this.flowSpeed;
                        this.vPrev[i][j] = 0;
                        this.p[i][j] = 0;
                        this.div[i][j] = 0;
                        this.obstacleMask[i][j] = false;
                    }
                }
                
                this.updateObstacleMask();
            }
            
            updateObstacleMask() {
                const N = this.gridSize;
                
                // Clear mask
                for (let i = 0; i < N; i++) {
                    for (let j = 0; j < N; j++) {
                        this.obstacleMask[i][j] = false;
                    }
                }
                
                const cx = this.obstacleX;
                const cy = this.obstacleY;
                const size = this.obstacleSize;
                const rot = this.obstacleRotation * Math.PI / 180;
                
                for (let i = 0; i < N; i++) {
                    for (let j = 0; j < N; j++) {
                        // Transform to obstacle-local coordinates
                        const dx = i - cx;
                        const dy = j - cy;
                        const localX = dx * Math.cos(-rot) - dy * Math.sin(-rot);
                        const localY = dx * Math.sin(-rot) + dy * Math.cos(-rot);
                        
                        let inside = false;
                        
                        switch(this.obstacleShape) {
                            case 'circle':
                                inside = (localX * localX + localY * localY) < (size * size);
                                break;
                            case 'ellipse':
                                inside = (localX * localX / (size * size) + localY * localY / (size * size * 0.4)) < 1;
                                break;
                            case 'square':
                                inside = (Math.abs(localX) < size && Math.abs(localY) < size);
                                break;
                            case 'rectangle':
                                inside = (Math.abs(localX) < size * 1.5 && Math.abs(localY) < size * 0.6);
                                break;
                            case 'triangle':
                                inside = (Math.abs(localX) < size && localY > -size && localY < size - Math.abs(localX));
                                break;
                            case 'airfoil':
                                const t = Math.abs(localX) / size;
                                const thickness = 0.12 * size * (1 - t * t);
                                inside = Math.abs(localY) < thickness && localX > -size && localX < size;
                                break;
                        }
                        
                        this.obstacleMask[i][j] = inside;
                    }
                }
            }
            
            step() {
                if (this.paused) return;
                
                const N = this.gridSize;
                const visc = this.viscosity;
                
                // Add inflow boundary condition
                for (let j = 0; j < N; j++) {
                    this.u[0][j] = this.flowSpeed;
                    this.v[0][j] = 0;
                }
                
                // Velocity step
                this.diffuse(1, this.uPrev, this.u, visc);
                this.diffuse(2, this.vPrev, this.v, visc);
                
                this.project(this.uPrev, this.vPrev, this.p, this.div);
                
                this.advect(1, this.u, this.uPrev, this.uPrev, this.vPrev);
                this.advect(2, this.v, this.vPrev, this.uPrev, this.vPrev);
                
                this.project(this.u, this.v, this.p, this.div);
                
                // Apply obstacle boundary conditions
                this.applyObstacleBoundary();
            }
            
            diffuse(b, x, x0, diff) {
                const N = this.gridSize;
                const a = this.dt * diff * N * N;
                
                for (let k = 0; k < 20; k++) {
                    for (let i = 1; i < N - 1; i++) {
                        for (let j = 1; j < N - 1; j++) {
                            if (this.obstacleMask[i][j]) continue;
                            
                            x[i][j] = (x0[i][j] + a * (
                                x[i+1][j] + x[i-1][j] +
                                x[i][j+1] + x[i][j-1]
                            )) / (1 + 4 * a);
                        }
                    }
                    this.setBounds(b, x);
                }
            }
            
            project(u, v, p, div) {
                const N = this.gridSize;
                const h = 1.0 / N;
                
                for (let i = 1; i < N - 1; i++) {
                    for (let j = 1; j < N - 1; j++) {
                        if (this.obstacleMask[i][j]) continue;
                        
                        div[i][j] = -0.5 * h * (
                            u[i+1][j] - u[i-1][j] +
                            v[i][j+1] - v[i][j-1]
                        );
                        p[i][j] = 0;
                    }
                }
                
                this.setBounds(0, div);
                this.setBounds(0, p);
                
                for (let k = 0; k < 20; k++) {
                    for (let i = 1; i < N - 1; i++) {
                        for (let j = 1; j < N - 1; j++) {
                            if (this.obstacleMask[i][j]) continue;
                            
                            p[i][j] = (div[i][j] + 
                                p[i+1][j] + p[i-1][j] +
                                p[i][j+1] + p[i][j-1]) / 4;
                        }
                    }
                    this.setBounds(0, p);
                }
                
                for (let i = 1; i < N - 1; i++) {
                    for (let j = 1; j < N - 1; j++) {
                        if (this.obstacleMask[i][j]) continue;
                        
                        u[i][j] -= 0.5 * (p[i+1][j] - p[i-1][j]) / h;
                        v[i][j] -= 0.5 * (p[i][j+1] - p[i][j-1]) / h;
                    }
                }
                
                this.setBounds(1, u);
                this.setBounds(2, v);
            }
            
            advect(b, d, d0, u, v) {
                const N = this.gridSize;
                const dt0 = this.dt * N;
                
                for (let i = 1; i < N - 1; i++) {
                    for (let j = 1; j < N - 1; j++) {
                        if (this.obstacleMask[i][j]) {
                            d[i][j] = 0;
                            continue;
                        }
                        
                        let x = i - dt0 * u[i][j];
                        let y = j - dt0 * v[i][j];
                        
                        x = constrain(x, 0.5, N - 1.5);
                        y = constrain(y, 0.5, N - 1.5);
                        
                        const i0 = Math.floor(x);
                        const i1 = i0 + 1;
                        const j0 = Math.floor(y);
                        const j1 = j0 + 1;
                        
                        const s1 = x - i0;
                        const s0 = 1 - s1;
                        const t1 = y - j0;
                        const t0 = 1 - t1;
                        
                        d[i][j] = s0 * (t0 * d0[i0][j0] + t1 * d0[i0][j1]) +
                                 s1 * (t0 * d0[i1][j0] + t1 * d0[i1][j1]);
                    }
                }
                
                this.setBounds(b, d);
            }
            
            applyObstacleBoundary() {
                const N = this.gridSize;
                
                for (let i = 1; i < N - 1; i++) {
                    for (let j = 1; j < N - 1; j++) {
                        if (this.obstacleMask[i][j]) {
                            this.u[i][j] = 0;
                            this.v[i][j] = 0;
                        }
                    }
                }
            }
            
            setBounds(b, x) {
                const N = this.gridSize;
                
                for (let i = 1; i < N - 1; i++) {
                    x[i][0] = b === 2 ? -x[i][1] : x[i][1];
                    x[i][N-1] = b === 2 ? -x[i][N-2] : x[i][N-2];
                }
                
                for (let j = 1; j < N - 1; j++) {
                    x[0][j] = b === 1 ? -x[1][j] : x[1][j];
                    x[N-1][j] = b === 1 ? -x[N-2][j] : x[N-2][j];
                }
                
                x[0][0] = 0.5 * (x[1][0] + x[0][1]);
                x[0][N-1] = 0.5 * (x[1][N-1] + x[0][N-2]);
                x[N-1][0] = 0.5 * (x[N-2][0] + x[N-1][1]);
                x[N-1][N-1] = 0.5 * (x[N-2][N-1] + x[N-1][N-2]);
            }
            
            render() {
                const cellSize = this.scale;
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        let r, g, b, a = 255;
                        
                        if (this.obstacleMask[i][j]) {
                            // Obstacle - dark gray
                            fill(40, 40, 50);
                            noStroke();
                            rect(i * cellSize, j * cellSize, cellSize, cellSize);
                        } else {
                            switch(this.visualizationMode) {
                                case 'vorticity':
                                    const vort = this.calculateVorticity(i, j);
                                    const intensity = constrain(abs(vort) * 50, 0, 1);
                                    
                                    if (vort > 0) {
                                        // Positive vorticity - red
                                        r = 255;
                                        g = 100 - intensity * 50;
                                        b = 100 - intensity * 50;
                                    } else {
                                        // Negative vorticity - blue
                                        r = 100 - intensity * 50;
                                        g = 100 - intensity * 50;
                                        b = 255;
                                    }
                                    
                                    fill(r, g, b, intensity * 200);
                                    noStroke();
                                    rect(i * cellSize, j * cellSize, cellSize, cellSize);
                                    break;
                                    
                                case 'velocity':
                                    const velMag = Math.sqrt(
                                        this.u[i][j] * this.u[i][j] + 
                                        this.v[i][j] * this.v[i][j]
                                    );
                                    const velIntensity = constrain(velMag / 5, 0, 1);
                                    
                                    // Velocity magnitude - green to yellow
                                    r = velIntensity * 255;
                                    g = 255;
                                    b = 50;
                                    
                                    fill(r, g, b, velIntensity * 200);
                                    noStroke();
                                    rect(i * cellSize, j * cellSize, cellSize, cellSize);
                                    break;
                                    
                                case 'streamlines':
                                    // Background
                                    fill(20, 20, 30);
                                    noStroke();
                                    rect(i * cellSize, j * cellSize, cellSize, cellSize);
                                    break;
                            }
                        }
                    }
                }
                
                // Draw streamlines if selected
                if (this.visualizationMode === 'streamlines') {
                    this.drawStreamlines();
                }
                
                // Draw velocity vectors (sparse)
                if (this.visualizationMode === 'velocity') {
                    stroke(255, 255, 255, 100);
                    strokeWeight(1);
                    for (let i = 0; i < this.gridSize; i += 8) {
                        for (let j = 0; j < this.gridSize; j += 8) {
                            if (!this.obstacleMask[i][j]) {
                                const x = i * cellSize;
                                const y = j * cellSize;
                                const vx = this.u[i][j] * 5;
                                const vy = this.v[i][j] * 5;
                                
                                line(x, y, x + vx, y + vy);
                                
                                // Arrowhead
                                push();
                                translate(x + vx, y + vy);
                                rotate(atan2(vy, vx));
                                line(0, 0, -3, -2);
                                line(0, 0, -3, 2);
                                pop();
                            }
                        }
                    }
                }
            }
            
            calculateVorticity(i, j) {
                if (i <= 0 || i >= this.gridSize - 1 || j <= 0 || j >= this.gridSize - 1) {
                    return 0;
                }
                
                const dvx_dy = (this.u[i][j+1] - this.u[i][j-1]) / 2;
                const dvy_dx = (this.v[i+1][j] - this.v[i-1][j]) / 2;
                
                return dvy_dx - dvx_dy;
            }
            
            drawStreamlines() {
                const cellSize = this.scale;
                const numStreamlines = 20;
                
                stroke(100, 200, 255, 150);
                strokeWeight(1);
                noFill();
                
                for (let s = 0; s < numStreamlines; s++) {
                    const startY = (s + 1) * this.gridSize / (numStreamlines + 1);
                    let x = 5;
                    let y = startY;
                    
                    beginShape();
                    for (let step = 0; step < 100; step++) {
                        vertex(x * cellSize, y * cellSize);
                        
                        const i = Math.floor(x);
                        const j = Math.floor(y);
                        
                        if (i < 0 || i >= this.gridSize - 1 || j < 0 || j >= this.gridSize - 1) break;
                        if (this.obstacleMask[i][j]) break;
                        
                        const vx = this.u[i][j];
                        const vy = this.v[i][j];
                        const velMag = Math.sqrt(vx * vx + vy * vy);
                        
                        if (velMag < 0.1) break;
                        
                        x += vx * 0.5;
                        y += vy * 0.5;
                    }
                    endShape();
                }
            }
            
            reset() {
                this.init();
            }
            
            togglePause() {
                this.paused = !this.paused;
            }
            
            setObstaclePosition(x, y) {
                this.obstacleX = Math.floor(x / this.scale);
                this.obstacleY = Math.floor(y / this.scale);
                this.obstacleX = constrain(this.obstacleX, 20, this.gridSize - 20);
                this.obstacleY = constrain(this.obstacleY, 20, this.gridSize - 20);
                this.updateObstacleMask();
            }
            
            setObstacleSize(size) {
                this.obstacleSize = size;
                this.updateObstacleMask();
            }
            
            setObstacleRotation(angle) {
                this.obstacleRotation = angle;
                this.updateObstacleMask();
            }
            
            setObstacleShape(shape) {
                this.obstacleShape = shape;
                this.updateObstacleMask();
            }
            
            calculateReynolds() {
                const characteristicLength = this.obstacleSize * 2 / this.gridSize;
                const velocity = this.flowSpeed;
                const kinematicViscosity = this.viscosity;
                return Math.round(velocity * characteristicLength / kinematicViscosity);
            }
        }
        
        let fluidSim;
        let isDragging = false;
        
        function setup() {
            const canvas = createCanvas(800, 800);
            canvas.parent('canvas-container');
            
            fluidSim = new FluidSimulation();
            
            setupControls();
        }
        
        function draw() {
            background(10, 10, 15);
            
            // Update simulation
            for (let i = 0; i < 3; i++) {
                fluidSim.step();
            }
            
            // Render
            fluidSim.render();
            
            // Update Reynolds number display
            document.getElementById('reynolds').textContent = fluidSim.calculateReynolds();
        }
        
        function mousePressed() {
            const gridX = Math.floor(mouseX / fluidSim.scale);
            const gridY = Math.floor(mouseY / fluidSim.scale);
            
            // Check if clicking on obstacle
            if (fluidSim.obstacleMask[gridX] && fluidSim.obstacleMask[gridX][gridY]) {
                isDragging = true;
            }
        }
        
        function mouseDragged() {
            if (isDragging) {
                fluidSim.setObstaclePosition(mouseX, mouseY);
            }
        }
        
        function mouseReleased() {
            isDragging = false;
        }
        
        function mouseWheel(event) {
            fluidSim.setObstacleSize(constrain(fluidSim.obstacleSize - event.delta * 0.05, 10, 60));
            document.getElementById('obstacleSize').value = fluidSim.obstacleSize;
            document.getElementById('sizeValue').textContent = Math.round(fluidSim.obstacleSize);
            return false;
        }
        
        function keyPressed() {
            if (key === ' ') {
                fluidSim.togglePause();
            } else if (key === 'r' || key === 'R') {
                fluidSim.reset();
            } else if (key === 'q' || key === 'Q') {
                fluidSim.setObstacleRotation(fluidSim.obstacleRotation - 5);
                document.getElementById('rotation').value = fluidSim.obstacleRotation;
                document.getElementById('rotationValue').textContent = fluidSim.obstacleRotation + 'Â°';
            } else if (key === 'e' || key === 'E') {
                fluidSim.setObstacleRotation(fluidSim.obstacleRotation + 5);
                document.getElementById('rotation').value = fluidSim.obstacleRotation;
                document.getElementById('rotationValue').textContent = fluidSim.obstacleRotation + 'Â°';
            }
        }
        
        function setupControls() {
            // Flow speed
            document.getElementById('flowSpeed').addEventListener('input', (e) => {
                fluidSim.flowSpeed = parseFloat(e.target.value);
                document.getElementById('flowSpeedValue').textContent = e.target.value;
            });
            
            // Viscosity
            document.getElementById('viscosity').addEventListener('input', (e) => {
                fluidSim.viscosity = parseFloat(e.target.value);
                document.getElementById('viscosityValue').textContent = e.target.value;
            });
            
            // Obstacle size
            document.getElementById('obstacleSize').addEventListener('input', (e) => {
                fluidSim.setObstacleSize(parseInt(e.target.value));
                document.getElementById('sizeValue').textContent = e.target.value;
            });
            
            // Rotation
            document.getElementById('rotation').addEventListener('input', (e) => {
                fluidSim.setObstacleRotation(parseInt(e.target.value));
                document.getElementById('rotationValue').textContent = e.target.value + 'Â°';
            });
            
            // Shape buttons
            document.querySelectorAll('.shape-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    fluidSim.setObstacleShape(btn.dataset.shape);
                });
            });
            
            // Visualization buttons
            document.querySelectorAll('.viz-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.viz-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    fluidSim.visualizationMode = btn.dataset.viz;
                });
            });
        }
        
        function toggleControls() {
            const controls = document.getElementById('controls');
            const toggleBtn = document.getElementById('toggleBtn');
            controls.classList.toggle('hidden');
            toggleBtn.classList.toggle('shifted');
            toggleBtn.textContent = controls.classList.contains('hidden') ? 'â–¶' : 'â—€';
        }
    </script>
</body>
</html>