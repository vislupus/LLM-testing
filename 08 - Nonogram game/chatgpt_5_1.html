<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>SVG.js Nonogram 20Ã—20</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.2.0/svg.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: #f5f7fb;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
            color: #333;
        }
        #gameContainer {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.08);
            padding: 16px;
        }
        #message {
            margin-top: 10px;
            font-weight: 600;
            color: #2e7d32;
            min-height: 1.2em;
        }
        #instructions {
            margin-top: 8px;
            font-size: 13px;
            color: #555;
        }
        a {
            color: #1976d2;
        }
    </style>
</head>
<body>
    <h1>Nonogram Puzzle (20Ã—20)</h1>
    <div id="gameContainer"></div>
    <div id="message"></div>
    <div id="instructions">
        Left-click: <b>fill</b> a cell &nbsp;â€¢&nbsp;
        Right-click: <b>mark with X</b> (or toggle off).<br/>
        Fill all correct cells to reveal a hidden picture.
    </div>

    <script>
        // =========================
        // Basic configuration
        // =========================
        const GRID_SIZE = 20;          // 20Ã—20 puzzle
        const CELL_SIZE = 24;          // Size of a cell in pixels
        const LEFT_CLUE_WIDTH = 110;   // Space for row clues
        const TOP_CLUE_HEIGHT = 90;    // Space for column clues

        let draw;                      // SVG.js root
        let solutionPattern;           // 20Ã—20 boolean matrix of the correct picture
        let cellState;                 // 0 = empty, 1 = filled, 2 = X mark (player state)
        let cellRects = [];            // SVG rects for cells
        let cellXMarks = [];           // SVG groups for "X" marks
        let rowClues = [];
        let colClues = [];
        let puzzleSolved = false;

        // Disable the default context menu so right-click works nicely
        document.addEventListener('contextmenu', e => e.preventDefault());

        // Initialize after page load
        window.addEventListener('load', initNonogram);

        function initNonogram() {
            // Create SVG canvas
            const width = LEFT_CLUE_WIDTH + GRID_SIZE * CELL_SIZE + 10;
            const height = TOP_CLUE_HEIGHT + GRID_SIZE * CELL_SIZE + 10;
            draw = SVG().addTo('#gameContainer').size(width, height);

            // Build solution pattern (predefined by algorithm) and clues
            solutionPattern = buildSmileyPattern(GRID_SIZE, GRID_SIZE);
            ({ rowClues, colClues } = computeClues(solutionPattern));

            // Initialize player state
            cellState = Array.from({ length: GRID_SIZE }, () =>
                Array(GRID_SIZE).fill(0)
            );

            // Draw everything
            drawBackground(width, height);
            drawGridAndCells();
            drawClues();
        }

        // =========================
        // Solution Pattern (Smiley)
        // =========================
        // Creates a simple round "smiley" face pattern in the 20x20 grid.
        function buildSmileyPattern(rows, cols) {
            const pattern = Array.from({ length: rows }, () =>
                Array(cols).fill(0)
            );

            // Center of the face
            const centerR = (rows - 1) / 2;
            const centerC = (cols - 1) / 2;
            const radius = 7; // in cells

            // 1. Draw a filled circle
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const dr = r - centerR;
                    const dc = c - centerC;
                    const dist = Math.sqrt(dr*dr + dc*dc);
                    if (dist <= radius) {
                        pattern[r][c] = 1;
                    }
                }
            }

            // 2. Cut out eyes (small blank squares)
            // Choose approximate positions
            const eyeRow = 6;
            const leftEyeCol = 7;
            const rightEyeCol = 12;
            for (let r = eyeRow - 1; r <= eyeRow + 1; r++) {
                for (let c = leftEyeCol - 1; c <= leftEyeCol + 1; c++) {
                    if (r >= 0 && r < rows && c >= 0 && c < cols) {
                        pattern[r][c] = 0;
                    }
                }
                for (let c = rightEyeCol - 1; c <= rightEyeCol + 1; c++) {
                    if (r >= 0 && r < rows && c >= 0 && c < cols) {
                        pattern[r][c] = 0;
                    }
                }
            }

            // 3. Mouth: carve a smile line
            const mouthRow1 = 13;
            const mouthRow2 = 14;
            for (let c = 6; c <= 13; c++) {
                if (mouthRow1 >= 0 && mouthRow1 < rows) {
                    pattern[mouthRow1][c] = 0;
                }
            }
            for (let c = 7; c <= 12; c++) {
                if (mouthRow2 >= 0 && mouthRow2 < rows) {
                    pattern[mouthRow2][c] = 0;
                }
            }

            return pattern;
        }

        // =========================
        // Compute Nonogram Clues
        // =========================
        function computeClues(pattern) {
            const rows = pattern.length;
            const cols = pattern[0].length;

            const rowClues = [];
            const colClues = [];

            // Row clues
            for (let r = 0; r < rows; r++) {
                const line = pattern[r];
                const clues = [];
                let run = 0;
                for (let c = 0; c < cols; c++) {
                    if (line[c] === 1) {
                        run++;
                    } else if (run > 0) {
                        clues.push(run);
                        run = 0;
                    }
                }
                if (run > 0) clues.push(run);
                if (clues.length === 0) clues.push(0);
                rowClues.push(clues);
            }

            // Column clues
            for (let c = 0; c < cols; c++) {
                const clues = [];
                let run = 0;
                for (let r = 0; r < rows; r++) {
                    if (pattern[r][c] === 1) {
                        run++;
                    } else if (run > 0) {
                        clues.push(run);
                        run = 0;
                    }
                }
                if (run > 0) clues.push(run);
                if (clues.length === 0) clues.push(0);
                colClues.push(clues);
            }

            return { rowClues, colClues };
        }

        // =========================
        // Drawing functions
        // =========================
        function drawBackground(w, h) {
            draw.rect(w, h).fill('#ffffff').radius(10).stroke({ color: '#d0d4e4', width: 1 });
        }

        function drawGridAndCells() {
            const offsetX = LEFT_CLUE_WIDTH;
            const offsetY = TOP_CLUE_HEIGHT;

            // Initialize storage
            for (let r = 0; r < GRID_SIZE; r++) {
                cellRects[r] = [];
                cellXMarks[r] = [];
            }

            // Draw grid background
            draw.rect(GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE)
                .move(offsetX, offsetY)
                .fill('#fafbff')
                .stroke({ color: '#c5cae9', width: 1 });

            // Draw each cell and attach interaction handlers
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const x = offsetX + c * CELL_SIZE;
                    const y = offsetY + r * CELL_SIZE;

                    // Cell rect
                    const rect = draw.rect(CELL_SIZE - 1, CELL_SIZE - 1)
                        .move(x + 0.5, y + 0.5)
                        .fill('#ffffff')
                        .stroke({ color: '#b0bec5', width: 1 });

                    // Thicker lines every 5 cells
                    if (c % 5 === 0) {
                        rect.stroke({ color: '#90a4ae', width: 1.5 });
                    }
                    if (r % 5 === 0) {
                        rect.stroke({ color: '#90a4ae', width: 1.5 });
                    }

                    // X mark group (two lines), hidden by default
                    const xGroup = draw.group().move(x, y).hide();
                    const margin = 4;
                    xGroup.line(margin, margin, CELL_SIZE - margin, CELL_SIZE - margin)
                          .stroke({ color: '#c62828', width: 2, linecap: 'round' });
                    xGroup.line(CELL_SIZE - margin, margin, margin, CELL_SIZE - margin)
                          .stroke({ color: '#c62828', width: 2, linecap: 'round' });

                    // Store references
                    cellRects[r][c] = rect;
                    cellXMarks[r][c] = xGroup;

                    // Mouse interaction: left-click fill / unfill
                    rect.on('click', (e) => {
                        if (puzzleSolved) return;
                        handleLeftClick(r, c);
                    });

                    // Right-click: mark / unmark X
                    rect.on('contextmenu', (e) => {
                        e.preventDefault();
                        if (puzzleSolved) return;
                        handleRightClick(r, c);
                    });
                }
            }
        }

        function drawClues() {
            const offsetX = LEFT_CLUE_WIDTH;
            const offsetY = TOP_CLUE_HEIGHT;

            // Row clues on the left
            for (let r = 0; r < GRID_SIZE; r++) {
                const txt = rowClues[r].join(' ');
                draw.text(txt)
                    .font({ size: 12, family: 'system-ui', anchor: 'end' })
                    .fill('#37474f')
                    .move(offsetX - 8, offsetY + r * CELL_SIZE + CELL_SIZE * 0.7);
            }

            // Column clues on the top
            for (let c = 0; c < GRID_SIZE; c++) {
                const clues = colClues[c];
                const x = offsetX + c * CELL_SIZE + CELL_SIZE / 2;
                // We place numbers from bottom to top
                const lineHeight = 12;
                const totalHeight = clues.length * lineHeight;
                const baseY = offsetY - 5;

                for (let i = 0; i < clues.length; i++) {
                    const val = clues[clues.length - 1 - i]; // reverse order: bottom-most first
                    const y = baseY - (i * lineHeight);
                    draw.text(String(val))
                        .font({ size: 11, family: 'system-ui', anchor: 'middle' })
                        .fill('#37474f')
                        .move(x, y - 8);
                }
            }
        }

        // =========================
        // Interaction handlers
        // =========================
        function handleLeftClick(r, c) {
            const current = cellState[r][c];
            // Toggle between empty and filled (ignore X state, clear it)
            if (current === 1) {
                // Set to empty
                cellState[r][c] = 0;
                cellRects[r][c].fill('#ffffff');
            } else {
                // Set to filled
                cellState[r][c] = 1;
                cellRects[r][c].fill('#263238');
                cellXMarks[r][c].hide();
            }
            checkSolved();
        }

        function handleRightClick(r, c) {
            const current = cellState[r][c];
            if (current === 2) {
                // X -> empty
                cellState[r][c] = 0;
                cellXMarks[r][c].hide();
                cellRects[r][c].fill('#ffffff');
            } else {
                // anything else -> X (and ensure not filled)
                cellState[r][c] = 2;
                cellXMarks[r][c].show();
                cellRects[r][c].fill('#ffffff');
            }
            checkSolved();
        }

        // =========================
        // Solution checking
        // =========================
        function checkSolved() {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const shouldBeFilled = solutionPattern[r][c] === 1;
                    const isFilled = cellState[r][c] === 1;

                    // If any required filled cell is not filled, or any empty cell is filled -> not solved
                    if (shouldBeFilled && !isFilled) {
                        setMessage('');
                        return false;
                    }
                    if (!shouldBeFilled && isFilled) {
                        setMessage('');
                        return false;
                    }
                }
            }

            // If we reach here, puzzle is solved
            puzzleSolved = true;
            setMessage('ðŸŽ‰ Congratulations! You solved the nonogram and revealed a smiley! ðŸŽ‰');
            // Optional: highlight solution
            highlightSolution();
            return true;
        }

        function highlightSolution() {
            // Slight highlight of all correct filled cells
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (solutionPattern[r][c] === 1) {
                        cellRects[r][c].fill('#212121');
                    }
                }
            }
        }

        function setMessage(text) {
            document.getElementById('message').textContent = text;
        }
    </script>
</body>
</html>