<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nonogram Puzzle - 20Ã—20</title>
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2/dist/svg.min.js"></script>
    <style>
        /* ========== Page Styling ========== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #1e3a5f 0%, #0d1b2a 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            color: #fff;
        }
        
        /* Title styling */
        h1 {
            color: #4cc9f0;
            font-size: 2.2em;
            margin-bottom: 10px;
            text-shadow: 0 2px 10px rgba(76, 201, 240, 0.3);
        }
        
        /* Instructions */
        .instructions {
            color: #a0c4e8;
            font-size: 1.1em;
            margin-bottom: 20px;
            text-align: center;
            max-width: 700px;
            line-height: 1.6;
        }
        
        .instructions strong {
            color: #4cc9f0;
        }
        
        /* Game container */
        #game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.4);
        }
        
        /* SVG canvas */
        #puzzle-svg {
            display: block;
            cursor: pointer;
            user-select: none;
        }
        
        /* Button container */
        .button-container {
            display: flex;
            gap: 15px;
            margin-top: 25px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            padding: 14px 28px;
            font-size: 1.1em;
            font-family: inherit;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        #check-btn {
            background: linear-gradient(135deg, #4cc9f0, #4361ee);
            color: white;
            box-shadow: 0 4px 15px rgba(76, 201, 240, 0.4);
        }
        
        #reset-btn {
            background: linear-gradient(135deg, #f72585, #b5179e);
            color: white;
            box-shadow: 0 4px 15px rgba(247, 37, 133, 0.4);
        }
        
        #hint-btn {
            background: linear-gradient(135deg, #7209b7, #560bad);
            color: white;
            box-shadow: 0 4px 15px rgba(114, 9, 183, 0.4);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        /* Status message */
        #status {
            font-size: 1.3em;
            margin-top: 20px;
            padding: 12px 30px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #status.success {
            background: linear-gradient(135deg, #06d6a0, #118ab2);
            animation: pulse 1s ease infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        /* Legend */
        .legend {
            display: flex;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #a0c4e8;
            font-size: 1em;
        }
        
        .legend-box {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            border: 2px solid #4cc9f0;
        }
        
        .legend-box.filled {
            background: #1e3a5f;
        }
        
        .legend-box.marked {
            background: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #f72585;
            font-weight: bold;
            font-size: 1.2em;
        }
        
        .legend-box.empty {
            background: #fff;
        }
        
        /* Progress bar */
        .progress-container {
            width: 100%;
            max-width: 500px;
            margin-top: 20px;
        }
        
        .progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            color: #a0c4e8;
        }
        
        .progress-bar {
            height: 12px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4cc9f0, #06d6a0);
            border-radius: 6px;
            transition: width 0.3s ease;
        }
        
        /* Prevent context menu on right-click */
        #puzzle-svg {
            -webkit-touch-callout: none;
        }
    </style>
</head>
<body>
    <h1>ðŸ§© Nonogram Puzzle</h1>
    
    <div class="instructions">
        <strong>Left-click</strong> to fill a cell | 
        <strong>Right-click</strong> to mark with âœ• | 
        <strong>Middle-click</strong> to clear<br>
        Match the numbers in each row and column to reveal the hidden picture!
    </div>
    
    <div id="game-container">
        <div id="puzzle-svg"></div>
    </div>
    
    <div class="button-container">
        <button id="check-btn">âœ“ Check Solution</button>
        <button id="hint-btn">ðŸ’¡ Reveal Hint</button>
        <button id="reset-btn">â†º Reset Puzzle</button>
    </div>
    
    <div class="progress-container">
        <div class="progress-label">
            <span>Progress</span>
            <span id="progress-percent">0%</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
        </div>
    </div>
    
    <div id="status">Fill in the cells to reveal the hidden picture!</div>
    
    <div class="legend">
        <div class="legend-item">
            <div class="legend-box filled"></div>
            <span>Filled (Left-click)</span>
        </div>
        <div class="legend-item">
            <div class="legend-box marked">âœ•</div>
            <span>Marked (Right-click)</span>
        </div>
        <div class="legend-item">
            <div class="legend-box empty"></div>
            <span>Empty</span>
        </div>
    </div>

    <script>
        // ============================================================
        // PUZZLE CONFIGURATION
        // ============================================================
        
        const GRID_SIZE = 20;       // 20x20 grid
        const CELL_SIZE = 26;       // Size of each cell in pixels
        const CLUE_CELL_SIZE = 18;  // Size for clue numbers
        const MAX_CLUES = 6;        // Maximum clue numbers per row/column
        
        // Calculate clue area sizes
        const CLUE_AREA_WIDTH = MAX_CLUES * CLUE_CELL_SIZE + 10;
        const CLUE_AREA_HEIGHT = MAX_CLUES * CLUE_CELL_SIZE + 10;
        
        // ============================================================
        // PREDEFINED PUZZLE PATTERN (20x20)
        // 1 = filled, 0 = empty
        // This creates a heart shape pattern
        // ============================================================
        
        const SOLUTION = [
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,0],
            [0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
            [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
            [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
            [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
        ];
        
        // ============================================================
        // GAME STATE
        // ============================================================
        
        let draw;                           // SVG.js instance
        let playerGrid = [];                // Player's current state
        let cellElements = [];              // SVG elements for cells
        let rowClues = [];                  // Clues for each row
        let colClues = [];                  // Clues for each column
        let isSolved = false;               // Puzzle solved flag
        
        // Cell states: 0 = empty, 1 = filled, 2 = marked with X
        const EMPTY = 0;
        const FILLED = 1;
        const MARKED = 2;
        
        // ============================================================
        // CLUE GENERATION
        // ============================================================
        
        /**
         * Generate clues from a row or column of the solution
         * Returns array of consecutive filled cell counts
         */
        function generateClues(line) {
            const clues = [];
            let count = 0;
            
            for (let i = 0; i < line.length; i++) {
                if (line[i] === 1) {
                    count++;
                } else {
                    if (count > 0) {
                        clues.push(count);
                        count = 0;
                    }
                }
            }
            
            // Don't forget the last group
            if (count > 0) {
                clues.push(count);
            }
            
            // Return [0] for empty lines
            return clues.length > 0 ? clues : [0];
        }
        
        /**
         * Generate all row and column clues from the solution
         */
        function generateAllClues() {
            // Row clues
            rowClues = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                rowClues.push(generateClues(SOLUTION[y]));
            }
            
            // Column clues
            colClues = [];
            for (let x = 0; x < GRID_SIZE; x++) {
                const column = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                    column.push(SOLUTION[y][x]);
                }
                colClues.push(generateClues(column));
            }
        }
        
        // ============================================================
        // DRAWING FUNCTIONS
        // ============================================================
        
        /**
         * Initialize the game board
         */
        function initializeGame() {
            // Clear existing content
            document.getElementById('puzzle-svg').innerHTML = '';
            
            // Initialize player grid
            playerGrid = Array(GRID_SIZE).fill(null).map(() => 
                Array(GRID_SIZE).fill(EMPTY)
            );
            cellElements = Array(GRID_SIZE).fill(null).map(() => 
                Array(GRID_SIZE).fill(null)
            );
            
            isSolved = false;
            
            // Generate clues
            generateAllClues();
            
            // Calculate SVG size
            const svgWidth = CLUE_AREA_WIDTH + GRID_SIZE * CELL_SIZE + 20;
            const svgHeight = CLUE_AREA_HEIGHT + GRID_SIZE * CELL_SIZE + 20;
            
            // Create SVG canvas
            draw = SVG().addTo('#puzzle-svg').size(svgWidth, svgHeight);
            
            // Draw background
            draw.rect(svgWidth, svgHeight).fill('#f8f9fa').radius(10);
            
            // Draw clue areas
            drawClueAreas();
            
            // Draw the grid
            drawGrid();
            
            // Draw clue numbers
            drawClues();
            
            // Update progress
            updateProgress();
            updateStatus('Fill in the cells to reveal the hidden picture!');
        }
        
        /**
         * Draw the clue area backgrounds
         */
        function drawClueAreas() {
            // Row clues background (left side)
            draw.rect(CLUE_AREA_WIDTH, GRID_SIZE * CELL_SIZE)
                .move(5, CLUE_AREA_HEIGHT + 5)
                .fill('#e9ecef')
                .radius(5);
            
            // Column clues background (top)
            draw.rect(GRID_SIZE * CELL_SIZE, CLUE_AREA_HEIGHT)
                .move(CLUE_AREA_WIDTH + 5, 5)
                .fill('#e9ecef')
                .radius(5);
        }
        
        /**
         * Draw the main puzzle grid
         */
        function drawGrid() {
            const offsetX = CLUE_AREA_WIDTH + 5;
            const offsetY = CLUE_AREA_HEIGHT + 5;
            
            // Draw cells
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cellX = offsetX + x * CELL_SIZE;
                    const cellY = offsetY + y * CELL_SIZE;
                    
                    // Create cell group
                    const cellGroup = draw.group();
                    
                    // Cell background
                    const rect = cellGroup.rect(CELL_SIZE - 1, CELL_SIZE - 1)
                        .move(cellX, cellY)
                        .fill('#ffffff')
                        .stroke({ color: '#adb5bd', width: 1 })
                        .radius(2);
                    
                    // Store reference
                    cellElements[y][x] = {
                        group: cellGroup,
                        rect: rect,
                        content: null
                    };
                    
                    // Add click handlers
                    rect.click(function(event) {
                        handleCellClick(x, y, event);
                    });
                    
                    // Right-click handler
                    rect.node.addEventListener('contextmenu', function(event) {
                        event.preventDefault();
                        handleRightClick(x, y);
                    });
                    
                    // Middle-click handler
                    rect.node.addEventListener('mousedown', function(event) {
                        if (event.button === 1) {
                            event.preventDefault();
                            clearCell(x, y);
                        }
                    });
                }
            }
            
            // Draw major grid lines (every 5 cells)
            for (let i = 0; i <= GRID_SIZE; i += 5) {
                // Vertical lines
                draw.line(
                    offsetX + i * CELL_SIZE, offsetY,
                    offsetX + i * CELL_SIZE, offsetY + GRID_SIZE * CELL_SIZE
                ).stroke({ color: '#495057', width: 2 });
                
                // Horizontal lines
                draw.line(
                    offsetX, offsetY + i * CELL_SIZE,
                    offsetX + GRID_SIZE * CELL_SIZE, offsetY + i * CELL_SIZE
                ).stroke({ color: '#495057', width: 2 });
            }
        }
        
        /**
         * Draw all clue numbers
         */
        function drawClues() {
            const gridOffsetX = CLUE_AREA_WIDTH + 5;
            const gridOffsetY = CLUE_AREA_HEIGHT + 5;
            
            // Draw row clues (left side)
            for (let y = 0; y < GRID_SIZE; y++) {
                const clues = rowClues[y];
                const cellY = gridOffsetY + y * CELL_SIZE + CELL_SIZE / 2;
                
                for (let i = 0; i < clues.length; i++) {
                    const clueX = CLUE_AREA_WIDTH - (clues.length - i) * CLUE_CELL_SIZE + CLUE_CELL_SIZE / 2;
                    
                    draw.text(String(clues[i]))
                        .font({
                            family: 'Segoe UI, sans-serif',
                            size: 12,
                            anchor: 'middle',
                            weight: 'bold'
                        })
                        .fill('#1e3a5f')
                        .center(clueX, cellY);
                }
            }
            
            // Draw column clues (top)
            for (let x = 0; x < GRID_SIZE; x++) {
                const clues = colClues[x];
                const cellX = gridOffsetX + x * CELL_SIZE + CELL_SIZE / 2;
                
                for (let i = 0; i < clues.length; i++) {
                    const clueY = CLUE_AREA_HEIGHT - (clues.length - i) * CLUE_CELL_SIZE + CLUE_CELL_SIZE / 2 + 5;
                    
                    draw.text(String(clues[i]))
                        .font({
                            family: 'Segoe UI, sans-serif',
                            size: 12,
                            anchor: 'middle',
                            weight: 'bold'
                        })
                        .fill('#1e3a5f')
                        .center(cellX, clueY);
                }
            }
        }
        
        // ============================================================
        // CELL INTERACTION
        // ============================================================
        
        /**
         * Handle left-click on a cell (fill/unfill)
         */
        function handleCellClick(x, y, event) {
            if (isSolved) return;
            
            if (playerGrid[y][x] === FILLED) {
                // Unfill if already filled
                clearCell(x, y);
            } else {
                // Fill the cell
                fillCell(x, y);
            }
            
            updateProgress();
        }
        
        /**
         * Handle right-click on a cell (mark with X)
         */
        function handleRightClick(x, y) {
            if (isSolved) return;
            
            if (playerGrid[y][x] === MARKED) {
                // Unmark if already marked
                clearCell(x, y);
            } else {
                // Mark the cell with X
                markCell(x, y);
            }
            
            updateProgress();
        }
        
        /**
         * Fill a cell (color it)
         */
        function fillCell(x, y) {
            const cell = cellElements[y][x];
            
            // Remove existing content
            if (cell.content) {
                cell.content.remove();
            }
            
            // Change cell color
            cell.rect.fill('#1e3a5f');
            
            // Update state
            playerGrid[y][x] = FILLED;
            cell.content = null;
            
            // Add subtle animation
            cell.rect.animate(100).attr({ opacity: 0.8 }).animate(100).attr({ opacity: 1 });
        }
        
        /**
         * Mark a cell with X
         */
        function markCell(x, y) {
            const cell = cellElements[y][x];
            const offsetX = CLUE_AREA_WIDTH + 5;
            const offsetY = CLUE_AREA_HEIGHT + 5;
            
            // Clear the cell first
            cell.rect.fill('#ffffff');
            
            // Remove existing content
            if (cell.content) {
                cell.content.remove();
            }
            
            // Add X mark
            const centerX = offsetX + x * CELL_SIZE + CELL_SIZE / 2;
            const centerY = offsetY + y * CELL_SIZE + CELL_SIZE / 2;
            
            const xMark = cell.group.text('âœ•')
                .font({
                    family: 'sans-serif',
                    size: 16,
                    anchor: 'middle',
                    weight: 'bold'
                })
                .fill('#f72585')
                .center(centerX, centerY);
            
            // Update state
            playerGrid[y][x] = MARKED;
            cell.content = xMark;
            
            // Animation
            xMark.scale(0).animate(150).scale(1);
        }
        
        /**
         * Clear a cell (make it empty)
         */
        function clearCell(x, y) {
            const cell = cellElements[y][x];
            
            // Reset color
            cell.rect.fill('#ffffff');
            
            // Remove content
            if (cell.content) {
                cell.content.remove();
                cell.content = null;
            }
            
            // Update state
            playerGrid[y][x] = EMPTY;
        }
        
        // ============================================================
        // SOLUTION CHECKING
        // ============================================================
        
        /**
         * Check if the player's solution matches the puzzle solution
         */
        function checkSolution() {
            let correct = true;
            let errors = 0;
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const shouldBeFilled = SOLUTION[y][x] === 1;
                    const isFilled = playerGrid[y][x] === FILLED;
                    
                    if (shouldBeFilled !== isFilled) {
                        correct = false;
                        errors++;
                    }
                }
            }
            
            if (correct) {
                isSolved = true;
                showVictory();
            } else {
                updateStatus(`Not quite right! ${errors} cell${errors > 1 ? 's' : ''} need to be changed. Keep trying! ðŸ’ª`);
            }
        }
        
        /**
         * Show victory animation and message
         */
        function showVictory() {
            const statusEl = document.getElementById('status');
            statusEl.textContent = 'ðŸŽ‰ Congratulations! You solved the puzzle! ðŸŽ‰';
            statusEl.classList.add('success');
            
            // Add celebratory animation to the grid
            const offsetX = CLUE_AREA_WIDTH + 5;
            const offsetY = CLUE_AREA_HEIGHT + 5;
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (SOLUTION[y][x] === 1) {
                        const cell = cellElements[y][x];
                        const delay = (x + y) * 20;
                        
                        cell.rect.delay(delay).animate(300, '<>').fill('#f72585')
                            .animate(300, '<>').fill('#4cc9f0')
                            .animate(300, '<>').fill('#1e3a5f');
                    }
                }
            }
            
            // Update progress to 100%
            document.getElementById('progress-fill').style.width = '100%';
            document.getElementById('progress-percent').textContent = '100%';
        }
        
        // ============================================================
        // HELPER FUNCTIONS
        // ============================================================
        
        /**
         * Reveal a random correct cell as a hint
         */
        function revealHint() {
            if (isSolved) return;
            
            // Find cells that should be filled but aren't
            const wrongCells = [];
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (SOLUTION[y][x] === 1 && playerGrid[y][x] !== FILLED) {
                        wrongCells.push({ x, y });
                    }
                }
            }
            
            if (wrongCells.length === 0) {
                updateStatus('All filled cells are correct! Check for extras or missing cells.');
                return;
            }
            
            // Pick a random cell to reveal
            const randomIndex = Math.floor(Math.random() * wrongCells.length);
            const hintCell = wrongCells[randomIndex];
            
            // Fill the cell
            fillCell(hintCell.x, hintCell.y);
            
            // Highlight the hinted cell
            const cell = cellElements[hintCell.y][hintCell.x];
            cell.rect.animate(200).fill('#4cc9f0')
                .animate(200).fill('#06d6a0')
                .animate(200).fill('#1e3a5f');
            
            updateProgress();
            updateStatus(`ðŸ’¡ Hint revealed at row ${hintCell.y + 1}, column ${hintCell.x + 1}!`);
        }
        
        /**
         * Update progress bar
         */
        function updateProgress() {
            let correctFilled = 0;
            let totalToFill = 0;
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (SOLUTION[y][x] === 1) {
                        totalToFill++;
                        if (playerGrid[y][x] === FILLED) {
                            correctFilled++;
                        }
                    }
                }
            }
            
            const percentage = Math.round((correctFilled / totalToFill) * 100);
            document.getElementById('progress-fill').style.width = percentage + '%';
            document.getElementById('progress-percent').textContent = percentage + '%';
        }
        
        /**
         * Update status message
         */
        function updateStatus(message) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.classList.remove('success');
        }
        
        /**
         * Reset the puzzle to initial state
         */
        function resetPuzzle() {
            if (confirm('Are you sure you want to reset the puzzle? All progress will be lost.')) {
                initializeGame();
            }
        }
        
        // ============================================================
        // EVENT LISTENERS
        // ============================================================
        
        // Button click handlers
        document.getElementById('check-btn').addEventListener('click', checkSolution);
        document.getElementById('reset-btn').addEventListener('click', resetPuzzle);
        document.getElementById('hint-btn').addEventListener('click', revealHint);
        
        // Prevent context menu on the game container
        document.getElementById('game-container').addEventListener('contextmenu', function(e) {
            e.preventDefault();
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.key === 'c' || e.key === 'C') {
                checkSolution();
            } else if (e.key === 'h' || e.key === 'H') {
                revealHint();
            } else if (e.key === 'r' || e.key === 'R') {
                resetPuzzle();
            }
        });
        
        // ============================================================
        // INITIALIZE GAME ON PAGE LOAD
        // ============================================================
        
        window.addEventListener('load', initializeGame);
    </script>
</body>
</html>