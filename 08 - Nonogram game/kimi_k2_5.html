<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nonogram Puzzle - 20x20</title>
    <!-- Include SVG.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2.0/dist/svg.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .instructions {
            color: #666;
            margin-bottom: 20px;
            font-size: 0.95em;
            text-align: center;
            max-width: 600px;
        }

        #game-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
            position: relative;
        }

        #puzzle-svg {
            display: block;
            margin: 0 auto;
            user-select: none;
        }

        /* Prevent text selection during rapid clicking */
        svg text {
            user-select: none;
            pointer-events: none;
        }

        #success-message {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(76, 175, 80, 0.95);
            color: white;
            padding: 30px 50px;
            border-radius: 12px;
            font-size: 24px;
            font-weight: bold;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            text-align: center;
            z-index: 100;
        }

        #reset-btn {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }

        #reset-btn:hover {
            background: #1976D2;
        }

        .legend {
            margin-top: 15px;
            display: flex;
            gap: 20px;
            justify-content: center;
            font-size: 14px;
            color: #555;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .box {
            width: 20px;
            height: 20px;
            border: 1px solid #999;
        }

        .box.filled {
            background: #333;
        }

        .box.x-mark {
            position: relative;
        }

        .box.x-mark::before,
        .box.x-mark::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 2px;
            background: #f44336;
            top: 50%;
            left: 0;
        }

        .box.x-mark::before { transform: rotate(45deg); }
        .box.x-mark::after { transform: rotate(-45deg); }
    </style>
</head>
<body>
    <h1>Nonogram Puzzle</h1>
    <p class="instructions">
        Left-click to fill a cell. Right-click to mark with X (for cells you know should be empty). 
        Complete the picture to solve the puzzle!
    </p>
    
    <div id="game-container">
        <div id="success-message">
            ðŸŽ‰ Puzzle Solved!<br>
            <span style="font-size: 16px; font-weight: normal;">Great job!</span>
        </div>
        <div id="puzzle-svg"></div>
        <button id="reset-btn" onclick="game.reset()">Reset Puzzle</button>
        
        <div class="legend">
            <div class="legend-item">
                <div class="box filled"></div>
                <span>Left Click: Fill</span>
            </div>
            <div class="legend-item">
                <div class="box x-mark"></div>
                <span>Right Click: Mark X</span>
            </div>
        </div>
    </div>

    <script>
        /**
         * Nonogram Game Logic
         * 20x20 grid with a heart pattern
         */
        class NonogramGame {
            constructor() {
                this.size = 20;
                this.cellSize = 25;
                this.clueAreaSize = 80; // Space for clue numbers
                
                // Heart pattern (1 = filled, 0 = empty)
                this.solution = this.generateHeartPattern();
                
                // State: 0 = empty, 1 = filled, 2 = X mark
                this.playerState = Array(this.size).fill().map(() => Array(this.size).fill(0));
                
                // Calculate clues
                this.rowClues = this.calculateClues(this.solution);
                this.colClues = this.calculateClues(this.transpose(this.solution));
                
                // Colors
                this.colors = {
                    grid: '#999999',
                    filled: '#333333',
                    xMark: '#f44336',
                    highlight: '#e3f2fd',
                    text: '#333333'
                };
                
                this.draw = null;
                this.cellElements = []; // Store references to cell rectangles
                
                this.init();
            }
            
            generateHeartPattern() {
                const grid = Array(this.size).fill().map(() => Array(this.size).fill(0));
                
                // Fill heart shape
                const fillRow = (row, start, end) => {
                    for (let i = start; i <= end; i++) grid[row][i] = 1;
                };
                
                // Top rounds of heart
                fillRow(2, 8, 11);     // 4 cells
                fillRow(3, 7, 12);     // 6 cells
                fillRow(4, 6, 13);     // 8 cells
                fillRow(5, 5, 14);     // 10 cells
                fillRow(6, 4, 15);     // 12 cells
                fillRow(7, 3, 16);     // 14 cells
                fillRow(8, 2, 17);     // 16 cells
                fillRow(9, 0, 19);     // 20 cells (full)
                fillRow(10, 0, 19);    // 20 cells (full)
                fillRow(11, 2, 17);    // 16 cells
                fillRow(12, 4, 15);    // 12 cells
                fillRow(13, 6, 13);    // 8 cells
                fillRow(14, 8, 11);    // 4 cells
                
                return grid;
            }
            
            transpose(matrix) {
                return matrix[0].map((_, i) => matrix.map(row => row[i]));
            }
            
            calculateClues(grid) {
                return grid.map(row => {
                    const clues = [];
                    let count = 0;
                    
                    for (let cell of row) {
                        if (cell === 1) {
                            count++;
                        } else {
                            if (count > 0) {
                                clues.push(count);
                                count = 0;
                            }
                        }
                    }
                    if (count > 0) clues.push(count);
                    
                    // Return [0] if empty row (shouldn't happen in valid puzzles usually, but good for safety)
                    return clues.length > 0 ? clues : [0];
                });
            }
            
            init() {
                // Create SVG canvas with sufficient viewBox
                const totalWidth = this.size * this.cellSize + this.clueAreaSize;
                const totalHeight = this.size * this.cellSize + this.clueAreaSize;
                
                this.draw = SVG().addTo('#puzzle-svg').size(totalWidth, totalHeight);
                
                // Set viewBox for proper scaling
                this.draw.viewbox(0, 0, totalWidth, totalHeight);
                
                this.drawGrid();
                this.drawClues();
                this.createCells();
                this.drawBorders();
            }
            
            drawGrid() {
                const startX = this.clueAreaSize;
                const startY = this.clueAreaSize;
                
                // Draw horizontal lines
                for (let i = 0; i <= this.size; i++) {
                    const y = startY + i * this.cellSize;
                    const isThick = i % 5 === 0;
                    this.draw.line(startX, y, startX + this.size * this.cellSize, y)
                        .stroke({ width: isThick ? 2 : 1, color: this.colors.grid });
                }
                
                // Draw vertical lines
                for (let i = 0; i <= this.size; i++) {
                    const x = startX + i * this.cellSize;
                    const isThick = i % 5 === 0;
                    this.draw.line(x, startY, x, startY + this.size * this.cellSize)
                        .stroke({ width: isThick ? 2 : 1, color: this.colors.grid });
                }
            }
            
            drawClues() {
                const clueOffset = this.clueAreaSize - 10;
                
                // Row clues (left side)
                this.rowClues.forEach((clues, rowIndex) => {
                    const y = this.clueAreaSize + rowIndex * this.cellSize + this.cellSize / 2;
                    const clueText = clues.join(' ');
                    
                    this.draw.text(clueText)
                        .attr({
                            x: clueOffset,
                            y: y,
                            'text-anchor': 'end',
                            'dominant-baseline': 'middle',
                            'font-size': '12px',
                            'font-weight': clues.some(c => c > 9) ? 'normal' : 'bold',
                            fill: this.colors.text
                        });
                });
                
                // Column clues (top side)
                this.colClues.forEach((clues, colIndex) => {
                    const x = this.clueAreaSize + colIndex * this.cellSize + this.cellSize / 2;
                    // Stack clues vertically
                    const totalHeight = clues.length * 12;
                    const startY = clueOffset - totalHeight + 6;
                    
                    clues.forEach((clue, i) => {
                        this.draw.text(clue.toString())
                            .attr({
                                x: x,
                                y: startY + i * 12,
                                'text-anchor': 'middle',
                                'dominant-baseline': 'middle',
                                'font-size': '11px',
                                'font-weight': clue > 9 ? 'normal' : 'bold',
                                fill: this.colors.text
                            });
                    });
                });
            }
            
            createCells() {
                const startX = this.clueAreaSize;
                const startY = this.clueAreaSize;
                
                for (let row = 0; row < this.size; row++) {
                    this.cellElements[row] = [];
                    for (let col = 0; col < this.size; col++) {
                        const x = startX + col * this.cellSize;
                        const y = startY + row * this.cellSize;
                        
                        // Create transparent rectangle for click detection
                        const cell = this.draw.rect(this.cellSize, this.cellSize)
                            .move(x, y)
                            .fill('transparent')
                            .stroke('none')
                            .css({ cursor: 'pointer' });
                        
                        // Store reference for easy access
                        this.cellElements[row][col] = {
                            rect: cell,
                            content: null // Will hold X or fill rect
                        };
                        
                        // Left click: toggle fill
                        cell.on('click', (e) => {
                            e.preventDefault();
                            this.handleCellClick(row, col, 'fill');
                        });
                        
                        // Right click: toggle X
                        cell.on('contextmenu', (e) => {
                            e.preventDefault();
                            this.handleCellClick(row, col, 'x');
                        });
                    }
                }
            }
            
            handleCellClick(row, col, type) {
                if (this.checkWinCondition()) return; // Already won
                
                const currentState = this.playerState[row][col];
                const cellData = this.cellElements[row][col];
                
                // Remove existing content
                if (cellData.content) {
                    cellData.content.remove();
                    cellData.content = null;
                }
                
                if (type === 'fill') {
                    // Toggle fill: empty -> fill -> empty
                    if (currentState !== 1) {
                        this.playerState[row][col] = 1;
                        // Draw filled rectangle slightly smaller than cell for grid visibility
                        cellData.content = this.draw.rect(this.cellSize - 2, this.cellSize - 2)
                            .move(this.clueAreaSize + col * this.cellSize + 1, this.clueAreaSize + row * this.cellSize + 1)
                            .fill(this.colors.filled)
                            .radius(2);
                    } else {
                        this.playerState[row][col] = 0;
                    }
                } else if (type === 'x') {
                    // Toggle X: empty -> x -> empty
                    if (currentState !== 2) {
                        this.playerState[row][col] = 2;
                        // Draw X
                        const x = this.clueAreaSize + col * this.cellSize + this.cellSize / 2;
                        const y = this.clueAreaSize + row * this.cellSize + this.cellSize / 2;
                        const offset = 8;
                        
                        const group = this.draw.group();
                        group.line(x - offset, y - offset, x + offset, y + offset)
                            .stroke({ width: 3, color: this.colors.xMark, linecap: 'round' });
                        group.line(x - offset, y + offset, x + offset, y - offset)
                            .stroke({ width: 3, color: this.colors.xMark, linecap: 'round' });
                        
                        cellData.content = group;
                    } else {
                        this.playerState[row][col] = 0;
                    }
                }
                
                this.checkSolution();
            }
            
            checkSolution() {
                let isCorrect = true;
                
                for (let row = 0; row < this.size; row++) {
                    for (let col = 0; col < this.size; col++) {
                        const solutionVal = this.solution[row][col];
                        const playerVal = this.playerState[row][col];
                        
                        // If solution has 1, player must have 1 (filled)
                        if (solutionVal === 1 && playerVal !== 1) {
                            isCorrect = false;
                            break;
                        }
                        // If solution has 0, player must not have 1 (filled)
                        if (solutionVal === 0 && playerVal === 1) {
                            isCorrect = false;
                            break;
                        }
                    }
                    if (!isCorrect) break;
                }
                
                if (isCorrect) {
                    this.showWin();
                }
            }
            
            checkWinCondition() {
                return document.getElementById('success-message').style.display === 'block';
            }
            
            showWin() {
                const msg = document.getElementById('success-message');
                msg.style.display = 'block';
                
                // Add a nice drawing animation or effect
                this.draw.rect(this.size * this.cellSize, this.size * this.cellSize)
                    .move(this.clueAreaSize, this.clueAreaSize)
                    .fill('none')
                    .stroke({ width: 4, color: '#4CAF50', dasharray: '10,5' })
                    .animate(1000)
                    .stroke({ dashoffset: -20 })
                    .loop();
            }
            
            drawBorders() {
                // Draw border around clue areas and grid
                const totalSize = this.size * this.cellSize + this.clueAreaSize;
                
                // Main border
                this.draw.rect(this.size * this.cellSize, this.size * this.cellSize)
                    .move(this.clueAreaSize, this.clueAreaSize)
                    .fill('none')
                    .stroke({ width: 3, color: '#333' });
                
                // Separator lines
                this.draw.line(this.clueAreaSize, 0, this.clueAreaSize, totalSize)
                    .stroke({ width: 2, color: '#333' });
                this.draw.line(0, this.clueAreaSize, totalSize, this.clueAreaSize)
                    .stroke({ width: 2, color: '#333' });
            }
            
            reset() {
                // Clear all cells
                for (let row = 0; row < this.size; row++) {
                    for (let col = 0; col < this.size; col++) {
                        this.playerState[row][col] = 0;
                        const cellData = this.cellElements[row][col];
                        if (cellData.content) {
                            cellData.content.remove();
                            cellData.content = null;
                        }
                    }
                }
                
                document.getElementById('success-message').style.display = 'none';
            }
        }
        
        // Initialize game when DOM is ready
        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new NonogramGame();
        });
    </script>
</body>
</html>