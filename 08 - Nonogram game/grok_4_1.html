<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nonogram • Picross Puzzle</title>
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2.0/dist/svg.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f0f4f8 0%, #d9e2ec 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .game-container {
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
            max-width: 900px;
        }
        h1 {
            text-align: center;
            color: #2d3748;
            margin-bottom: 20px;
            font-size: 28px;
        }
        .subtitle {
            text-align: center;
            color: #718096;
            margin-bottom: 25px;
            font-size: 16px;
        }
        #nonogram-svg {
            display: block;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        .controls {
            text-align: center;
            margin-top: 20px;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0 8px;
        }
        button:hover {
            background: #5a67d8;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(90, 103, 216, 0.3);
        }
        .success-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #48bb78;
            color: white;
            padding: 30px 50px;
            border-radius: 16px;
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
            opacity: 0;
            pointer-events: none;
            transition: all 0.6s ease;
            z-index: 100;
        }
        .success-message.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.05);
        }
        .legend {
            text-align: center;
            margin-top: 15px;
            color: #718096;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Nonogram • Picross</h1>
        <p class="subtitle">Left-click to fill • Right-click to mark X • Complete the hidden picture!</p>
        
        <svg id="nonogram-svg" width="720" height="720"></svg>
        
        <div class="controls">
            <button onclick="game.newPuzzle()">New Puzzle</button>
            <button onclick="game.clearGrid()">Clear</button>
        </div>
        
        <div class="legend">
            Use mouse: Left-click = Fill • Right-click = X • Scroll = nothing (just for fun)
        </div>
    </div>

    <div class="success-message" id="success">Puzzle Complete!</div>

    <script>
        // Predefined 20x20 puzzle (a cute cat!)
        const SOLUTION = [
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
            [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
            [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
            [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
            [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
            [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
            [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
        ];

        class NonogramGame {
            constructor() {
                this.gridSize = 20;
                this.cellSize = 25;
                this.margin = 100; // Space for clues
                this.svg = null;
                this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0)); // 0=empty, 1=filled, 2=X
                this.rowClues = [];
                this.colClues = [];
                
                this.init();
            }

            init() {
                this.calculateClues();
                this.createSVG();
                this.drawGrid();
                this.drawClues();
                this.setupEvents();
            }

            // Calculate row and column clues from solution
            calculateClues() {
                this.rowClues = [];
                this.colClues = [];

                // Row clues
                for (let y = 0; y < this.gridSize; y++) {
                    const clues = [];
                    let count = 0;
                    for (let x = 0; x < this.gridSize; x++) {
                        if (SOLUTION[y][x] === 1) {
                            count++;
                        } else if (count > 0) {
                            clues.push(count);
                            count = 0;
                        }
                    }
                    if (count > 0) clues.push(count);
                    this.rowClues.push(clues.length > 0 ? clues : [0]);
                }

                // Column clues
                for (let x = 0; x < this.gridSize; x++) {
                    const clues = [];
                    let count = 0;
                    for (let y = 0; y < this.gridSize; y++) {
                        if (SOLUTION[y][x] === 1) {
                            count++;
                        } else if (count > 0) {
                            clues.push(count);
                            count = 0;
                        }
                    }
                    if (count > 0) clues.push(count);
                    this.colClues.push(clues.length > 0 ? clues : [0]);
                }
            }

            createSVG() {
                const totalWidth = this.margin + this.gridSize * this.cellSize;
                const totalHeight = this.margin + this.gridSize * this.cellSize;

                this.svg = SVG('#nonogram-svg')
                    .size(totalWidth, totalHeight)
                    .viewbox(0, 0, totalWidth, totalHeight);
            }

            drawGrid() {
                const gridGroup = this.svg.group();

                // Draw grid background
                gridGroup.rect(this.gridSize * this.cellSize, this.gridSize * this.cellSize)
                    .move(this.margin, this.margin)
                    .fill('#ffffff')
                    .stroke({ color: '#e2e8f0', width: 2 });

                // Draw grid lines
                for (let i = 0; i <= this.gridSize; i++) {
                    const x = this.margin + i * this.cellSize;
                    const y = this.margin + i * this.cellSize;

                    // Vertical lines
                    gridGroup.line(x, this.margin, x, this.margin + this.gridSize * this.cellSize)
                        .stroke({ color: i % 5 === 0 ? '#94a3b8' : '#e2e8f0', width: i % 5 === 0 ? 2 : 1 });

                    // Horizontal lines
                    gridGroup.line(this.margin, y, this.margin + this.gridSize * this.cellSize, y)
                        .stroke({ color: i % 5 === 0 ? '#94a3b8' : '#e2e8f0', width: i % 5 === 0 ? 2 : 1 });
                }

                // Create interactive cells
                this.cells = [];
                for (let y = 0; y < this.gridSize; y++) {
                    this.cells[y] = [];
                    for (let x = 0; x < this.gridSize; x++) {
                        const cellX = this.margin + x * this.cellSize;
                        const cellY = this.margin + y * this.cellSize;

                        const cell = gridGroup.group()
                            .data('x', x)
                            .data('y', y);

                        // Invisible clickable area
                        cell.rect(this.cellSize, this.cellSize)
                            .move(cellX, cellY)
                            .fill('transparent')
                            .style('cursor', 'pointer');

                        this.cells[y][x] = cell;
                    }
                }
            }

            drawClues() {
                const clueFontSize = 14;
                const clueColor = '#2d3748';

                // Row clues (left side)
                for (let y = 0; y < this.gridSize; y++) {
                    const clues = this.rowClues[y];
                    const totalClues = clues.length;
                    const clueY = this.margin + y * this.cellSize + this.cellSize / 2;

                    clues.forEach((clue, i) => {
                        const clueX = this.margin - 15 - (totalClues - i) * 20;
                        this.svg.text(clue.toString())
                            .font({ size: clueFontSize, weight: 'bold', family: 'monospace' })
                            .fill(clueColor)
                            .center(clueX, clueY);
                    });
                }

                // Column clues (top)
                for (let x = 0; x < this.gridSize; x++) {
                    const clues = this.colClues[x];
                    const totalClues = clues.length;
                    const clueX = this.margin + x * this.cellSize + this.cellSize / 2;

                    clues.forEach((clue, i) => {
                        const clueY = this.margin - 15 - (totalClues - i) * 18;
                        this.svg.text(clue.toString())
                            .font({ size: clueFontSize, weight: 'bold', family: 'monospace' })
                            .fill(clueColor)
                            .center(clueX, clueY);
                    });
                }
            }

            setupEvents() {
                this.svg.on('mousedown', (e) => {
                    if (e.button === 0 || e.button === 2) { // Left or right click
                        e.preventDefault();
                        const target = e.target;
                        const cell = target.parentNode; // The group
                        if (cell && cell.data) {
                            const x = cell.data('x');
                            const y = cell.data('y');
                            
                            if (e.button === 0) { // Left click - fill
                                this.toggleCell(x, y, 1);
                            } else if (e.button === 2) { // Right click - X
                                this.toggleCell(x, y, 2);
                            }
                            
                            this.checkSolution();
                        }
                    }
                });

                // Prevent context menu on right click
                this.svg.on('contextmenu', (e) => {
                    e.preventDefault();
                });
            }

            toggleCell(x, y, type) {
                const cell = this.cells[y][x];
                cell.clear(); // Remove previous content

                const cellX = this.margin + x * this.cellSize;
                const cellY = this.margin + y * this.cellSize;

                if (type === 1) { // Fill
                    cell.rect(this.cellSize - 4, this.cellSize - 4)
                        .move(cellX + 2, cellY + 2)
                        .fill('#2d3748')
                        .radius(2);
                    this.grid[y][x] = 1;
                } else if (type === 2) { // X mark
                    cell.line(cellX + 5, cellY + 5, cellX + this.cellSize - 5, cellY + this.cellSize - 5)
                        .stroke({ color: '#94a3b8', width: 3 });
                    cell.line(cellX + 5, cellY + this.cellSize - 5, cellX + this.cellSize - 5, cellY + 5)
                        .stroke({ color: '#94a3b8', width: 3 });
                    this.grid[y][x] = 2;
                } else { // Empty
                    this.grid[y][x] = 0;
                }
            }

            checkSolution() {
                let correct = true;
                
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        const playerCell = this.grid[y][x];
                        const solutionCell = SOLUTION[y][x];
                        
                        if (solutionCell === 1 && playerCell !== 1) {
                            correct = false;
                        }
                        if (solutionCell === 0 && playerCell === 1) {
                            correct = false;
                        }
                    }
                }
                
                if (correct) {
                    document.getElementById('success').classList.add('show');
                    setTimeout(() => {
                        document.getElementById('success').classList.remove('show');
                    }, 4000);
                }
            }

            clearGrid() {
                this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        this.cells[y][x].clear();
                    }
                }
            }

            newPuzzle() {
                // In a full game you'd have multiple puzzles
                // Here we'll just clear and keep the same one
                this.clearGrid();
                document.getElementById('success').classList.remove('show');
            }
        }

        // Start the game
        const game = new NonogramGame();
    </script>
</body>
</html>