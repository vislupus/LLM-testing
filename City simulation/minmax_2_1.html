<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D City Growth Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
        }

        #renderCanvas {
            width: 100%;
            height: 100vh;
            display: block;
            touch-action: none;
        }

        /* Control Panel */
        .control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 20px;
            padding: 20px;
            color: #fff;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        .panel-title {
            font-size: 1.3rem;
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(78, 205, 196, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .control-value {
            color: #f7b731;
            font-weight: bold;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .slider-density {
            background: linear-gradient(90deg, #20bf6b, #f7b731, #e94560);
        }

        .slider-traffic {
            background: linear-gradient(90deg, #20bf6b, #f7b731, #e94560);
        }

        .slider-speed {
            background: linear-gradient(90deg, #3498db, #4ecdc4, #20bf6b);
        }

        /* Stats Display */
        .stats-display {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            margin-top: 15px;
        }

        .stats-title {
            font-weight: bold;
            color: #f7b731;
            margin-bottom: 12px;
            font-size: 0.95rem;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }

        .stat-label {
            color: #aaa;
        }

        .stat-value {
            color: #fff;
            font-weight: bold;
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .action-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(78, 205, 196, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #e94560, #d63447);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(233, 69, 96, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f7b731, #f39c12);
            color: #1a1a2e;
        }

        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(247, 183, 49, 0.4);
        }

        /* Presets */
        .presets {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .presets-title {
            font-size: 0.9rem;
            color: #aaa;
            margin-bottom: 10px;
        }

        .preset-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .preset-btn {
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .preset-btn:hover {
            background: rgba(78, 205, 196, 0.3);
            border-color: #4ecdc4;
        }

        /* Title Overlay */
        .title-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 100;
        }

        .title-text {
            font-size: 1.8rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
            letter-spacing: 2px;
        }

        .subtitle-text {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 5px;
        }

        /* Controls Hint */
        .controls-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            padding: 12px 25px;
            border-radius: 25px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 100;
        }

        /* Day/Night Toggle */
        .time-toggle {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .time-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background: linear-gradient(135deg, #3498db, #2c3e50);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-switch.night {
            background: linear-gradient(135deg, #2c3e50, #1a1a2e);
        }

        .toggle-knob {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: #fff;
            border-radius: 50%;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .toggle-switch.night .toggle-knob {
            left: 33px;
        }
    </style>
</head>
<body>
    <!-- Main Canvas -->
    <canvas id="renderCanvas"></canvas>

    <!-- Title Overlay -->
    <div class="title-overlay">
        <div class="title-text">üåÜ Growing City Simulator</div>
        <div class="subtitle-text">Real-time 3D Urban Development</div>
    </div>

    <!-- Control Panel -->
    <div class="control-panel">
        <div class="panel-title">
            üèôÔ∏è City Controls
        </div>

        <!-- Population Density -->
        <div class="control-group">
            <div class="control-label">
                <span>üè¢ Population Density</span>
                <span class="control-value" id="densityValue">50%</span>
            </div>
            <input type="range" class="slider slider-density" id="densitySlider"
                   min="10" max="100" value="50">
        </div>

        <!-- Traffic Intensity -->
        <div class="control-group">
            <div class="control-label">
                <span>üöó Traffic Intensity</span>
                <span class="control-value" id="trafficValue">50%</span>
            </div>
            <input type="range" class="slider slider-traffic" id="trafficSlider"
                   min="0" max="100" value="50">
        </div>

        <!-- Development Speed -->
        <div class="control-group">
            <div class="control-label">
                <span>‚ö° Development Speed</span>
                <span class="control-value" id="speedValue">50%</span>
            </div>
            <input type="range" class="slider slider-speed" id="speedSlider"
                   min="10" max="100" value="50">
        </div>

        <!-- Time of Day -->
        <div class="time-toggle">
            <div class="time-label">
                <span>üåô Time of Day</span>
                <div class="toggle-switch" id="timeToggle" onclick="toggleTime()">
                    <div class="toggle-knob">‚òÄÔ∏è</div>
                </div>
            </div>
        </div>

        <!-- Stats Display -->
        <div class="stats-display">
            <div class="stats-title">üìä City Statistics</div>
            <div class="stat-row">
                <span class="stat-label">Buildings</span>
                <span class="stat-value" id="statBuildings">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Roads</span>
                <span class="stat-value" id="statRoads">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Vehicles</span>
                <span class="stat-value" id="statVehicles">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Population</span>
                <span class="stat-value" id="statPopulation">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Happiness</span>
                <span class="stat-value" id="statHappiness">100%</span>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons">
            <button class="action-btn btn-primary" onclick="pauseSimulation()">‚è∏Ô∏è Pause</button>
            <button class="action-btn btn-warning" onclick="resetSimulation()">üîÑ Reset</button>
        </div>

        <!-- Presets -->
        <div class="presets">
            <div class="presets-title">üìã Quick Presets</div>
            <div class="preset-buttons">
                <button class="preset-btn" onclick="applyPreset('village')">üèòÔ∏è Village</button>
                <button class="preset-btn" onclick="applyPreset('town')">üèôÔ∏è Town</button>
                <button class="preset-btn" onclick="applyPreset('city')">üè¢ City</button>
                <button class="preset-btn" onclick="applyPreset('metropolis')">üåÜ Metropolis</button>
            </div>
        </div>
    </div>

    <!-- Controls Hint -->
    <div class="controls-hint">
        üñ±Ô∏è Drag to Rotate &nbsp;|&nbsp; Scroll to Zoom &nbsp;|&nbsp; Right-click Drag to Pan
    </div>

    <!-- Babylon.js -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <script>
        // ==================== CITY SIMULATION CONFIGURATION ====================
        const CONFIG = {
            grid: {
                size: 30,
                cellSize: 4,
                roadWidth: 1.5
            },
            building: {
                minHeight: 3,
                maxHeight: 15,
                growthDuration: 2000,
                colors: {
                    residential: ['#4a90a4', '#5ba3b8', '#6bb6cc', '#7cc9e0'],
                    commercial: ['#e8a838', '#f0b84d', '#f8c862', '#ffd878'],
                    industrial: ['#8b7355', '#9c8465', '#ad9375', '#bea285'],
                    office: ['#3498db', '#4aa3df', '#5faee3', '#74b9e8']
                }
            },
            road: {
                gridInterval: 6,
                color: '#3a3a3a',
                lineColor: '#f7b731'
            },
            vehicle: {
                maxCount: 50,
                speed: 0.08,
                colors: ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c']
            },
            pedestrian: {
                maxCount: 100,
                speed: 0.03
            },
            tree: {
                colors: ['#2d5a27', '#3d7a37', '#4d8a47', '#1d4a17']
            }
        };

        // ==================== GAME STATE ====================
        let gameState = {
            isPaused: false,
            isNight: false,
            time: 0,
            grid: [],
            buildings: [],
            roads: [],
            vehicles: [],
            pedestrians: [],
            trees: [],
            stats: {
                buildings: 0,
                roads: 0,
                vehicles: 0,
                population: 0,
                happiness: 100
            },
            params: {
                density: 50,
                traffic: 50,
                speed: 50
            }
        };

        // ==================== BABYLON SETUP ====================
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
        let scene, camera, shadowGenerator, cityGroup;

        // ==================== CREATE SCENE ====================
        const createScene = () => {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.6, 0.75, 0.85, 1);

            // Camera
            camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 4, Math.PI / 3, 150, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 50;
            camera.upperRadiusLimit = 250;
            camera.lowerBetaLimit = 0.1;
            camera.upperBetaLimit = Math.PI / 2.1;
            camera.wheelPrecision = 15;
            camera.panningSensibility = 80;

            // Lighting
            setupLighting();

            // Create city
            cityGroup = new BABYLON.TransformNode("city", scene);
            createGround();
            initializeGrid();
            generateRoads();
            startSimulation();

            return scene;
        };

        // ==================== LIGHTING SETUP ====================
        let sunLight, hemiLight, nightLights = [];

        function setupLighting() {
            // Hemisphere light
            hemiLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
            hemiLight.intensity = 0.7;
            hemiLight.diffuse = new BABYLON.Color3(1, 0.98, 0.95);
            hemiLight.groundColor = new BABYLON.Color3(0.3, 0.35, 0.4);

            // Directional sun light
            sunLight = new BABYLON.DirectionalLight("sunLight", new BABYLON.Vector3(-0.5, -1, -0.3), scene);
            sunLight.position = new BABYLON.Vector3(80, 120, 50);
            sunLight.intensity = 1;
            sunLight.diffuse = new BABYLON.Color3(1, 0.98, 0.9);

            // Shadows
            shadowGenerator = new BABYLON.ShadowGenerator(2048, sunLight);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;
            shadowGenerator.bias = 0.001;

            // Night lights (initially hidden)
            for (let i = 0; i < 5; i++) {
                const light = new BABYLON.PointLight("nightLight" + i, new BABYLON.Vector3(0, 50, 0), scene);
                light.intensity = 0;
                light.diffuse = new BABYLON.Color3(1, 0.9, 0.7);
                light.range = 80;
                nightLights.push(light);
            }
        }

        function updateLighting() {
            if (gameState.isNight) {
                // Night mode
                hemiLight.intensity = 0.2;
                hemiLight.diffuse = new BABYLON.Color3(0.2, 0.25, 0.4);
                hemiLight.groundColor = new BABYLON.Color3(0.1, 0.1, 0.2);
                sunLight.intensity = 0.1;
                scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.15, 1);

                // Enable night lights
                nightLights.forEach((light, i) => {
                    light.intensity = 0.8;
                    light.position = new BABYLON.Vector3(
                        Math.cos(i * 1.2) * 40,
                        40,
                        Math.sin(i * 1.2) * 40
                    );
                });

                // Enable building lights
                gameState.buildings.forEach(building => {
                    if (building.lightMesh) {
                        building.lightMesh.material.emissiveColor = new BABYLON.Color3(1, 0.9, 0.6);
                    }
                });

                scene.fogDensity = 0.008;
                scene.fogColor = new BABYLON.Color3(0.1, 0.1, 0.15);
            } else {
                // Day mode
                hemiLight.intensity = 0.7;
                hemiLight.diffuse = new BABYLON.Color3(1, 0.98, 0.95);
                hemiLight.groundColor = new BABYLON.Color3(0.3, 0.35, 0.4);
                sunLight.intensity = 1;
                scene.clearColor = new BABYLON.Color4(0.6, 0.75, 0.85, 1);

                // Disable night lights
                nightLights.forEach(light => {
                    light.intensity = 0;
                });

                // Disable building lights
                gameState.buildings.forEach(building => {
                    if (building.lightMesh) {
                        building.lightMesh.material.emissiveColor = new BABYLON.Color3(0, 0, 0);
                    }
                });

                scene.fogDensity = 0.002;
                scene.fogColor = new BABYLON.Color3(0.65, 0.78, 0.88);
            }
        }

        // ==================== GROUND ====================
        function createGround() {
            const groundSize = CONFIG.grid.size * CONFIG.grid.cellSize + 20;

            // Main ground
            const ground = BABYLON.MeshBuilder.CreateGround("ground", {
                width: groundSize,
                height: groundSize
            }, scene);
            ground.position.y = -0.1;

            const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.35, 0.45, 0.3);
            groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            ground.material = groundMat;
            ground.receiveShadows = true;

            // Sidewalks
            createSidewalks();
        }

        function createSidewalks() {
            const sidewalkMat = new BABYLON.StandardMaterial("sidewalkMat", scene);
            sidewalkMat.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.6);
            sidewalkMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const halfSize = (CONFIG.grid.size * CONFIG.grid.cellSize) / 2;

            // Create sidewalk border
            const sidewalkBorder = BABYLON.MeshBuilder.CreateBox("sidewalkBorder", {
                width: groundSize,
                height: 0.2,
                depth: groundSize
            }, scene);
            sidewalkBorder.position.y = 0;
            sidewalkBorder.material = sidewalkMat;
            sidewalkBorder.receiveShadows = true;
        }

        // ==================== GRID INITIALIZATION ====================
        function initializeGrid() {
            const { size } = CONFIG.grid;
            gameState.grid = [];

            for (let x = 0; x < size; x++) {
                gameState.grid[x] = [];
                for (let z = 0; z < size; z++) {
                    gameState.grid[x][z] = {
                        x, z,
                        isRoad: false,
                        building: null,
                        tree: null,
                        pedestrian: null,
                        vehicleNode: false
                    };
                }
            }
        }

        // ==================== ROAD GENERATION ====================
        function generateRoads() {
            const { size, gridInterval } = CONFIG.grid;

            // Main roads (grid pattern)
            for (let i = 0; i < size; i += gridInterval) {
                createRoadLine(i, true);
                createRoadLine(i, false);
            }

            // Secondary roads
            for (let i = 0; i < size; i += gridInterval * 2) {
                for (let j = i + 1; j < i + gridInterval - 1; j += 2) {
                    if (j < size) {
                        createRoadSegment(j, true, 2);
                        createRoadSegment(j, false, 2);
                    }
                }
            }

            updateStats();
        }

        function createRoadLine(index, isHorizontal) {
            const { size } = CONFIG.grid;
            const positions = [];

            for (let i = 0; i < size; i++) {
                const x = isHorizontal ? i : index;
                const z = isHorizontal ? index : i;
                positions.push({ x, z });
                gameState.grid[x][z].isRoad = true;
                gameState.grid[x][z].vehicleNode = true;
            }

            createRoadMesh(positions, isHorizontal);
        }

        function createRoadSegment(index, isHorizontal, length) {
            const { size } = CONFIG.grid;
            const positions = [];

            for (let i = 0; i < length; i++) {
                const x = isHorizontal ? index : Math.min(size - 1, index + i);
                const z = isHorizontal ? Math.min(size - 1, index + i) : index;
                if (x < size && z < size) {
                    positions.push({ x, z });
                    gameState.grid[x][z].isRoad = true;
                    gameState.grid[x][z].vehicleNode = true;
                }
            }

            if (positions.length > 1) {
                createRoadMesh(positions, isHorizontal);
            }
        }

        function createRoadMesh(positions, isHorizontal) {
            const { cellSize, roadWidth } = CONFIG.grid;
            const roadMat = new BABYLON.StandardMaterial("roadMat", scene);
            roadMat.diffuseColor = BABYLON.Color3.FromHexString(CONFIG.road.color);
            roadMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);

            // Road surface
            const road = BABYLON.MeshBuilder.CreateBox("road", {
                width: isHorizontal ? cellSize : roadWidth,
                height: 0.1,
                depth: isHorizontal ? roadWidth : cellSize
            }, scene);

            const avgPos = positions[Math.floor(positions.length / 2)];
            const offset = (CONFIG.grid.size * CONFIG.grid.cellSize) / 2 - cellSize / 2;

            road.position.x = avgPos.x * cellSize - offset;
            road.position.z = avgPos.z * cellSize - offset;
            road.position.y = 0.05;
            road.material = roadMat;
            road.receiveShadows = true;

            gameState.roads.push(road);

            // Road markings
            if (positions.length > 2) {
                createRoadMarkings(positions, isHorizontal, roadMat);
            }
        }

        function createRoadMarkings(positions, isHorizontal, roadMat) {
            const { cellSize, roadWidth } = CONFIG.grid;
            const lineMat = new BABYLON.StandardMaterial("lineMat", scene);
            lineMat.diffuseColor = BABYLON.Color3.FromHexString(CONFIG.road.lineColor);
            lineMat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.1);

            positions.forEach((pos, i) => {
                if (i % 3 === 1 && i < positions.length - 1) {
                    const marking = BABYLON.MeshBuilder.CreateBox("marking", {
                        width: isHorizontal ? cellSize * 0.3 : 0.2,
                        height: 0.02,
                        depth: isHorizontal ? 0.2 : cellSize * 0.3
                    }, scene);

                    const offset = (CONFIG.grid.size * CONFIG.grid.cellSize) / 2 - cellSize / 2;
                    marking.position.x = pos.x * cellSize - offset;
                    marking.position.z = pos.z * cellSize - offset;
                    marking.position.y = 0.12;
                    marking.material = lineMat;

                    gameState.roads.push(marking);
                }
            });
        }

        // ==================== BUILDING GENERATION ====================
        function generateBuilding(x, z) {
            if (gameState.grid[x][z].isRoad || gameState.grid[x][z].building) return;

            const cellCenter = getCellCenter(x, z);
            const buildingParams = determineBuildingType(x, z);
            const building = createBuildingMesh(cellCenter, buildingParams);

            gameState.grid[x][z].building = building;
            gameState.buildings.push(building);

            // Add trees around building
            addTreesAroundBuilding(x, z);

            updateStats();
        }

        function getCellCenter(x, z) {
            const { cellSize } = CONFIG.grid;
            const offset = (CONFIG.grid.size * CONFIG.grid.cellSize) / 2 - cellSize / 2;
            return new BABYLON.Vector3(
                x * cellSize - offset,
                0,
                z * cellSize - offset
            );
        }

        function determineBuildingType(x, z) {
            const { size } = CONFIG.grid;
            const centerDist = Math.sqrt(Math.pow(x - size / 2, 2) + Math.pow(z - size / 2, 2));
            const maxDist = size / Math.sqrt(2);

            // Determine building type based on distance from center
            let type, height, color;

            if (centerDist < maxDist * 0.2) {
                // Downtown - tall commercial/office buildings
                type = Math.random() > 0.5 ? 'office' : 'commercial';
                height = CONFIG.building.maxHeight * (0.7 + Math.random() * 0.3);
                color = CONFIG.building.colors[type][Math.floor(Math.random() * 4)];
            } else if (centerDist < maxDist * 0.5) {
                // Mid-city - mixed commercial/residential
                type = Math.random() > 0.4 ? 'commercial' : 'residential';
                height = CONFIG.building.maxHeight * (0.4 + Math.random() * 0.4);
                color = CONFIG.building.colors[type][Math.floor(Math.random() * 4)];
            } else {
                // Suburbs - residential
                type = 'residential';
                height = CONFIG.building.minHeight + Math.random() * (CONFIG.building.maxHeight * 0.3);
                color = CONFIG.building.colors.residential[Math.floor(Math.random() * 4)];
            }

            // Apply density factor
            const densityFactor = gameState.params.density / 100;
            if (Math.random() > densityFactor) {
                height *= 0.5;
            }

            return { type, height, color };
        }

        function createBuildingMesh(position, params) {
            const { type, height, color } = params;
            const width = 2.5 + Math.random() * 1;
            const depth = 2.5 + Math.random() * 1;

            const building = new BABYLON.TransformNode("building", scene);

            // Main structure
            const mainMesh = BABYLON.MeshBuilder.CreateBox("buildingMain", {
                width: width,
                height: height,
                depth: depth
            }, scene);
            mainMesh.position.y = height / 2;
            mainMesh.material = createBuildingMaterial(color);
            mainMesh.parent = building;
            shadowGenerator.addShadowCaster(mainMesh);

            // Roof
            const roofHeight = 0.5 + Math.random() * 0.5;
            const roof = BABYLON.MeshBuilder.CreateCylinder("roof", {
                height: roofHeight,
                diameterTop: 0,
                diameterBottom: Math.min(width, depth) * 0.8,
                tessellation: 4
            }, scene);
            roof.position.y = height + roofHeight / 2;
            roof.rotation.y = Math.PI / 4;
            roof.material = mainMesh.material;
            roof.parent = building;
            shadowGenerator.addShadowCaster(roof);

            // Windows
            const windowMaterial = new BABYLON.StandardMaterial("windowMat", scene);
            windowMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.7, 0.8);
            windowMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0);
            windowMaterial.specularColor = new BABYLON.Color3(0.8, 0.8, 0.8);

            if (height > 5) {
                createWindows(building, width, height, depth, windowMaterial);
            }

            // Entrance
            const entrance = BABYLON.MeshBuilder.CreateBox("entrance", {
                width: width * 0.4,
                height: height * 0.15,
                depth: 0.2
            }, scene);
            entrance.position.y = height * 0.075;
            entrance.position.z = depth / 2;
            entrance.material = mainMesh.material;
            entrance.parent = building;

            // Position
            building.position = position;

            // Growth animation
            building.scaling = new BABYLON.Vector3(0, 0, 0);
            const targetScale = new BABYLON.Vector3(1, 1, 1);
            const growthSpeed = (gameState.params.speed / 100) * 0.02;

            scene.registerBeforeRender(() => {
                if (gameState.isPaused) return;

                building.scaling.x = BABYLON.Scalar.Lerp(building.scaling.x, targetScale.x, growthSpeed);
                building.scaling.y = BABYLON.Scalar.Lerp(building.scaling.y, targetScale.y, growthSpeed);
                building.scaling.z = BABYLON.Scalar.Lerp(building.scaling.z, targetScale.z, growthSpeed);
            });

            return {
                node: building,
                type,
                height,
                width,
                depth,
                position,
                population: Math.floor(height * 5 * (type === 'residential' ? 2 : 1))
            };
        }

        function createBuildingMaterial(color) {
            const mat = new BABYLON.StandardMaterial("buildingMat", scene);
            mat.diffuseColor = BABYLON.Color3.FromHexString(color);
            mat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            return mat;
        }

        function createWindows(building, width, height, depth, material) {
            const windowRows = Math.floor(height / 2);
            const windowCols = 2;

            for (let row = 0; row < windowRows; row++) {
                for (let col = 0; col < windowCols; col++) {
                    const windowMesh = BABYLON.MeshBuilder.CreatePlane("window", {
                        width: 0.4,
                        height: 0.6
                    }, scene);

                    windowMesh.position.y = 1.5 + row * 2;
                    windowMesh.position.z = depth / 2 + 0.01;

                    if (col === 1) {
                        windowMesh.position.x = width / 4;
                        windowMesh.rotation.y = Math.PI;
                    } else {
                        windowMesh.position.x = -width / 4;
                    }

                    windowMesh.material = material;
                    windowMesh.parent = building;

                    // Back windows
                    const backWindow = windowMesh.clone("windowBack");
                    backWindow.position.z = -depth / 2 - 0.01;
                    backWindow.rotation.y = Math.PI;
                    backWindow.parent = building;
                }
            }
        }

        // ==================== TREE GENERATION ====================
        function addTreesAroundBuilding(x, z) {
            const { size } = CONFIG.grid;
            const treePositions = [
                { x: x - 1, z: z - 1 },
                { x: x + 1, z: z - 1 },
                { x: x - 1, z: z + 1 },
                { x: x + 1, z: z + 1 }
            ];

            treePositions.forEach(pos => {
                if (pos.x >= 0 && pos.x < size && pos.z >= 0 && pos.z < size) {
                    if (!gameState.grid[pos.x][pos.z].isRoad && !gameState.grid[pos.x][pos.z].tree) {
                        createTree(pos.x, pos.z);
                    }
                }
            });
        }

        function createTree(x, z) {
            const position = getCellCenter(x, z);
            const tree = new BABYLON.TransformNode("tree", scene);

            // Trunk
            const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk", {
                height: 1.5 + Math.random(),
                diameter: 0.3 + Math.random() * 0.2,
                tessellation: 8
            }, scene);
            trunk.position.y = 0.75;
            const trunkMat = new BABYLON.StandardMaterial("trunkMat", scene);
            trunkMat.diffuseColor = new BABYLON.Color3(0.4, 0.3, 0.2);
            trunk.material = trunkMat;
            trunk.parent = tree;
            shadowGenerator.addShadowCaster(trunk);

            // Foliage
            const foliageSize = 1.5 + Math.random();
            const foliage = BABYLON.MeshBuilder.CreateSphere("foliage", {
                diameter: foliageSize,
                segments: 8
            }, scene);
            foliage.position.y = 2;
            foliage.scaling = new BABYLON.Vector3(1, 1.2, 1);
            const foliageMat = new BABYLON.StandardMaterial("foliageMat", scene);
            foliageMat.diffuseColor = BABYLON.Color3.FromHexString(
                CONFIG.tree.colors[Math.floor(Math.random() * CONFIG.tree.colors.length)]
            );
            foliage.material = foliageMat;
            foliage.parent = tree;
            shadowGenerator.addShadowCaster(foliage);

            tree.position = position;
            tree.parent = cityGroup;

            gameState.grid[x][z].tree = tree;
            gameState.trees.push(tree);
        }

        // ==================== VEHICLE SYSTEM ====================
        function spawnVehicle() {
            if (gameState.vehicles.length >= CONFIG.vehicle.maxCount * (gameState.params.traffic / 100)) return;

            // Find road node
            const roadNodes = [];
            for (let x = 0; x < CONFIG.grid.size; x++) {
                for (let z = 0; z < CONFIG.grid.size; z++) {
                    if (gameState.grid[x][z].vehicleNode) {
                        roadNodes.push({ x, z });
                    }
                }
            }

            if (roadNodes.length === 0) return;

            const startNode = roadNodes[Math.floor(Math.random() * roadNodes.length)];
            const vehicle = createVehicle(startNode);

            if (vehicle) {
                gameState.vehicles.push(vehicle);
                updateStats();
            }
        }

        function createVehicle(startNode) {
            const color = CONFIG.vehicle.colors[Math.floor(Math.random() * CONFIG.vehicle.colors.length)];
            const vehicle = new BABYLON.TransformNode("vehicle", scene);

            // Car body
            const body = BABYLON.MeshBuilder.CreateBox("carBody", {
                width: 1.8,
                height: 0.6,
                depth: 3
            }, scene);
            body.position.y = 0.4;
            const bodyMat = new BABYLON.StandardMaterial("bodyMat", scene);
            bodyMat.diffuseColor = BABYLON.Color3.FromHexString(color);
            bodyMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            body.material = bodyMat;
            body.parent = vehicle;
            shadowGenerator.addShadowCaster(body);

            // Car top
            const top = BABYLON.MeshBuilder.CreateBox("carTop", {
                width: 1.4,
                height: 0.5,
                depth: 1.5
            }, scene);
            top.position.y = 0.95;
            top.material = bodyMat;
            top.parent = vehicle;

            // Wheels
            const wheelMat = new BABYLON.StandardMaterial("wheelMat", scene);
            wheelMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const wheelPositions = [
                { x: 0.7, z: 0.9 },
                { x: -0.7, z: 0.9 },
                { x: 0.7, z: -0.9 },
                { x: -0.7, z: -0.9 }
            ];

            wheelPositions.forEach((pos, i) => {
                const wheel = BABYLON.MeshBuilder.CreateCylinder("wheel" + i, {
                    height: 0.2,
                    diameter: 0.5,
                    tessellation: 12
                }, scene);
                wheel.position = new BABYLON.Vector3(pos.x, 0.25, pos.z);
                wheel.rotation.z = Math.PI / 2;
                wheel.material = wheelMat;
                wheel.parent = vehicle;
            });

            // Headlights
            const headlightMat = new BABYLON.StandardMaterial("headlightMat", scene);
            headlightMat.emissiveColor = new BABYLON.Color3(1, 1, 0.8);
            headlightMat.diffuseColor = new BABYLON.Color3(1, 1, 0.8);

            [-0.5, 0.5].forEach((x, i) => {
                const headlight = BABYLON.MeshBuilder.CreatePlane("headlight" + i, {
                    width: 0.3,
                    height: 0.2
                }, scene);
                headlight.position = new BABYLON.Vector3(x, 0.4, 1.51);
                headlight.material = headlightMat;
                headlight.parent = vehicle;
            });

            // Position at start node
            const position = getCellCenter(startNode.x, startNode.z);
            vehicle.position = new BABYLON.Vector3(position.x, 0, position.z);

            // Find path
            const path = findVehiclePath(startNode);
            if (!path || path.length < 2) {
                vehicle.dispose();
                return null;
            }

            // Store vehicle data
            vehicle.metadata = {
                path,
                currentPathIndex: 0,
                speed: CONFIG.vehicle.speed * (0.5 + Math.random() * 0.5)
            };

            vehicle.parent = cityGroup;

            return vehicle;
        }

        function findVehiclePath(startNode) {
            const { size } = CONFIG.grid;
            const path = [startNode];

            // Simple random walk along roads
            let current = startNode;
            const maxSteps = 50;

            for (let i = 0; i < maxSteps; i++) {
                const neighbors = getRoadNeighbors(current.x, current.z);
                if (neighbors.length === 0) break;

                // Prefer direction towards center initially
                let next = neighbors[Math.floor(Math.random() * neighbors.length)];

                // Check if we've been here recently
                const recentIndex = path.findIndex(n => n.x === next.x && n.z === next.z);
                if (recentIndex > path.length - 5) {
                    const otherNeighbors = neighbors.filter(n =>
                        !path.slice(-5).some(p => p.x === n.x && p.z === n.z)
                    );
                    if (otherNeighbors.length > 0) {
                        next = otherNeighbors[Math.floor(Math.random() * otherNeighbors.length)];
                    }
                }

                path.push(next);
                current = next;
            }

            return path;
        }

        function getRoadNeighbors(x, z) {
            const neighbors = [];
            const directions = [
                { x: 1, z: 0 },
                { x: -1, z: 0 },
                { x: 0, z: 1 },
                { x: 0, z: -1 }
            ];

            directions.forEach(dir => {
                const nx = x + dir.x;
                const nz = z + dir.z;
                if (nx >= 0 && nx < CONFIG.grid.size && nz >= 0 && nz < CONFIG.grid.size) {
                    if (gameState.grid[nx][nz].isRoad) {
                        neighbors.push({ x: nx, z: nz });
                    }
                }
            });

            return neighbors;
        }

        function updateVehicles() {
            if (gameState.isPaused) return;

            gameState.vehicles.forEach(vehicle => {
                if (!vehicle.metadata) return;

                const { path, currentPathIndex, speed } = vehicle.metadata;

                if (currentPathIndex >= path.length - 1) {
                    // Reached destination, remove vehicle
                    const index = gameState.vehicles.indexOf(vehicle);
                    if (index > -1) {
                        gameState.vehicles.splice(index, 1);
                        vehicle.dispose();
                    }
                    return;
                }

                const currentNode = path[currentPathIndex];
                const nextNode = path[currentPathIndex + 1];
                const targetPos = getCellCenter(nextNode.x, nextNode.z);

                // Move towards target
                const direction = targetPos.subtract(vehicle.position);
                direction.y = 0;
                const distance = direction.length();

                if (distance < 0.5) {
                    vehicle.metadata.currentPathIndex++;
                } else {
                    direction.normalize();
                    vehicle.position.addInPlace(direction.scale(speed));
                    vehicle.lookAt(targetPos);
                }
            });
        }

        // ==================== PEDESTRIAN SYSTEM ====================
        function spawnPedestrian() {
            if (gameState.pedestrians.length >= CONFIG.pedestrian.maxCount) return;

            // Find valid spawn point (near road, not on road)
            const spawnPoints = [];
            for (let x = 1; x < CONFIG.grid.size - 1; x++) {
                for (let z = 1; z < CONFIG.grid.size - 1; z++) {
                    if (!gameState.grid[x][z].isRoad && !gameState.grid[x][z].building) {
                        // Check if near road
                        const nearRoad = getRoadNeighbors(x, z).length > 0;
                        if (nearRoad) {
                            spawnPoints.push({ x, z });
                        }
                    }
                }
            }

            if (spawnPoints.length === 0) return;

            const spawn = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
            const pedestrian = createPedestrian(spawn);

            if (pedestrian) {
                gameState.pedestrians.push(pedestrian);
            }
        }

        function createPedestrian(spawnNode) {
            const pedestrian = new BABYLON.TransformNode("pedestrian", scene);

            // Body
            const body = BABYLON.MeshBuilder.CreateCapsule("body", {
                height: 1.2,
                radius: 0.25
            }, scene);
            body.position.y = 0.6;

            const bodyMat = new BABYLON.StandardMaterial("pedBodyMat", scene);
            bodyMat.diffuseColor = new BABYLON.Color3(
                0.3 + Math.random() * 0.3,
                0.3 + Math.random() * 0.3,
                0.5 + Math.random() * 0.3
            );
            body.material = bodyMat;
            body.parent = pedestrian;

            // Head
            const head = BABYLON.MeshBuilder.CreateSphere("head", {
                diameter: 0.35,
                segments: 8
            }, scene);
            head.position.y = 1.35;
            const headMat = new BABYLON.StandardMaterial("headMat", scene);
            headMat.diffuseColor = new BABYLON.Color3(0.9, 0.8, 0.7);
            head.material = headMat;
            head.parent = pedestrian;

            // Position
            const position = getCellCenter(spawnNode.x, spawnNode.z);
            // Offset from road
            const offset = (Math.random() - 0.5) * 3;
            const angle = Math.random() * Math.PI * 2;
            pedestrian.position = new BABYLON.Vector3(
                position.x + Math.cos(angle) * offset,
                0,
                position.z + Math.sin(angle) * offset
            );

            // Random walking direction
            pedestrian.metadata = {
                direction: new BABYLON.Vector3(
                    Math.random() - 0.5,
                    0,
                    Math.random() - 0.5
                ).normalize(),
                speed: CONFIG.pedestrian.speed * (0.5 + Math.random() * 0.5),
                walkTime: 0
            };

            pedestrian.parent = cityGroup;

            return pedestrian;
        }

        function updatePedestrians() {
            if (gameState.isPaused) return;

            gameState.pedestrians.forEach(pedestrian => {
                if (!pedestrian.metadata) return;

                const { direction, speed, walkTime } = pedestrian.metadata;

                // Random direction change
                if (walkTime > 3 + Math.random() * 5 || Math.random() < 0.01) {
                    pedestrian.metadata.direction = new BABYLON.Vector3(
                        Math.random() - 0.5,
                        0,
                        Math.random() - 0.5
                    ).normalize();
                    pedestrian.metadata.walkTime = 0;
                }

                // Move
                pedestrian.position.addInPlace(direction.scale(speed));
                pedestrian.metadata.walkTime += 0.016;

                // Face direction
                const target = pedestrian.position.add(direction);
                pedestrian.lookAt(target);

                // Keep within bounds
                const bounds = (CONFIG.grid.size * CONFIG.grid.cellSize) / 2 - 2;
                if (Math.abs(pedestrian.position.x) > bounds || Math.abs(pedestrian.position.z) > bounds) {
                    pedestrian.metadata.direction.scaleInPlace(-1);
                    pedestrian.position.addInPlace(direction.scale(1));
                }

                // Avoid buildings
                const gridX = Math.floor((pedestrian.position.x + bounds) / CONFIG.grid.cellSize);
                const gridZ = Math.floor((pedestrian.position.z + bounds) / CONFIG.grid.cellSize);

                if (gridX >= 0 && gridX < CONFIG.grid.size && gridZ >= 0 && gridZ < CONFIG.grid.size) {
                    if (gameState.grid[gridX][gridZ].building) {
                        pedestrian.metadata.direction.scaleInPlace(-1);
                    }
                }
            });
        }

        // ==================== CITY GROWTH ====================
        let growthTimer = 0;

        function updateCityGrowth() {
            if (gameState.isPaused) return;

            growthTimer += 0.016;

            const growthRate = (gameState.params.speed / 100) * 2;

            if (growthTimer > growthRate) {
                growthTimer = 0;

                // Find empty spots and build
                const emptySpots = [];
                for (let x = 0; x < CONFIG.grid.size; x++) {
                    for (let z = 0; z < CONFIG.grid.size; z++) {
                        if (!gameState.grid[x][z].isRoad && !gameState.grid[x][z].building) {
                            // Check if near road
                            const nearRoad = getRoadNeighbors(x, z).length > 0;
                            if (nearRoad && Math.random() < (gameState.params.density / 100) * 0.3) {
                                emptySpots.push({ x, z });
                            }
                        }
                    }
                }

                // Build at random empty spots
                const buildCount = Math.min(3, emptySpots.length);
                for (let i = 0; i < buildCount; i++) {
                    if (emptySpots.length === 0) break;
                    const index = Math.floor(Math.random() * emptySpots.length);
                    const spot = emptySpots.splice(index, 1)[0];
                    generateBuilding(spot.x, spot.z);
                }
            }
        }

        // ==================== SIMULATION LOOP ====================
        function startSimulation() {
            // Initial population
            for (let i = 0; i < 10; i++) {
                spawnVehicle();
            }

            for (let i = 0; i < 20; i++) {
                spawnPedestrian();
            }

            // Simulation loop
            scene.registerBeforeRender(() => {
                updateCityGrowth();
                updateVehicles();
                updatePedestrians();

                // Spawn vehicles periodically
                if (Math.random() < (gameState.params.traffic / 100) * 0.02) {
                    spawnVehicle();
                }

                // Spawn pedestrians periodically
                if (Math.random() < 0.03) {
                    spawnPedestrian();
                }
            });
        }

        // ==================== UI CONTROLS ====================
        const densitySlider = document.getElementById('densitySlider');
        const trafficSlider = document.getElementById('trafficSlider');
        const speedSlider = document.getElementById('speedSlider');

        densitySlider.addEventListener('input', (e) => {
            gameState.params.density = parseInt(e.target.value);
            document.getElementById('densityValue').textContent = e.target.value + '%';
        });

        trafficSlider.addEventListener('input', (e) => {
            gameState.params.traffic = parseInt(e.target.value);
            document.getElementById('trafficValue').textContent = e.target.value + '%';
        });

        speedSlider.addEventListener('input', (e) => {
            gameState.params.speed = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = e.target.value + '%';
        });

        function toggleTime() {
            gameState.isNight = !gameState.isNight;
            const toggle = document.getElementById('timeToggle');
            toggle.classList.toggle('night');
            toggle.querySelector('.toggle-knob').textContent = gameState.isNight ? 'üåô' : '‚òÄÔ∏è';
            updateLighting();
        }

        function pauseSimulation() {
            gameState.isPaused = !gameState.isPaused;
            const btn = event.target;
            btn.textContent = gameState.isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
        }

        function resetSimulation() {
            // Clear all objects
            gameState.buildings.forEach(b => b.node.dispose());
            gameState.vehicles.forEach(v => v.dispose());
            gameState.pedestrians.forEach(p => p.dispose());
            gameState.trees.forEach(t => t.dispose());
            gameState.roads.forEach(r => r.dispose());

            gameState.buildings = [];
            gameState.vehicles = [];
            gameState.pedestrians = [];
            gameState.trees = [];
            gameState.roads = [];

            // Reinitialize grid
            initializeGrid();
            generateRoads();

            // Reset stats
            updateStats();
        }

        function applyPreset(preset) {
            const presets = {
                village: { density: 30, traffic: 20, speed: 40 },
                town: { density: 50, traffic: 50, speed: 50 },
                city: { density: 75, traffic: 75, speed: 70 },
                metropolis: { density: 95, traffic: 95, speed: 90 }
            };

            const p = presets[preset];
            if (p) {
                gameState.params = { ...p };
                densitySlider.value = p.density;
                trafficSlider.value = p.traffic;
                speedSlider.value = p.speed;

                document.getElementById('densityValue').textContent = p.density + '%';
                document.getElementById('trafficValue').textContent = p.traffic + '%';
                document.getElementById('speedValue').textContent = p.speed + '%';
            }
        }

        // ==================== STATS UPDATE ====================
        function updateStats() {
            let population = 0;
            gameState.buildings.forEach(b => {
                population += b.population;
            });

            // Calculate happiness based on balance
            const trafficRatio = gameState.params.traffic / 100;
            const densityRatio = gameState.params.density / 100;
            let happiness = 100 - (trafficRatio * 30) - (densityRatio > 0.8 ? 15 : 0);
            happiness = Math.max(0, Math.min(100, happiness));

            gameState.stats = {
                buildings: gameState.buildings.length,
                roads: gameState.roads.length,
                vehicles: gameState.vehicles.length,
                population: population,
                happiness: Math.round(happiness)
            };

            document.getElementById('statBuildings').textContent = gameState.stats.buildings;
            document.getElementById('statRoads').textContent = gameState.stats.roads;
            document.getElementById('statVehicles').textContent = gameState.stats.vehicles;
            document.getElementById('statPopulation').textContent = gameState.stats.population.toLocaleString();
            document.getElementById('statHappiness').textContent = gameState.stats.happiness + '%';
        }

        // ==================== INITIALIZATION ====================
        const scene = createScene();

        engine.runRenderLoop(() => {
            scene.render();
        });

        window.addEventListener('resize', () => {
            engine.resize();
        });

        console.log('City Growth Simulation loaded successfully!');
    </script>
</body>
</html>
