<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>3D Growing City Simulation</title>
    <style>
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; font-family: Arial, sans-serif; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            width: 280px;
            backdrop-filter: blur(10px);
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #00ff88;
        }
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
        }
        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
        }
        .value {
            display: inline-block;
            margin-left: 10px;
            color: #fff;
            font-weight: bold;
        }
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            backdrop-filter: blur(10px);
        }
        .stat-line {
            margin: 5px 0;
            font-size: 14px;
        }
        .stat-label {
            color: #00ff88;
        }
    </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<div id="controls">
    <h3 style="margin-top: 0; color: #00ff88;">City Controls</h3>
    
    <div class="control-group">
        <label>City Density: <span class="value" id="densityValue">50</span></label>
        <input type="range" class="slider" id="densitySlider" min="10" max="100" value="50">
    </div>
    
    <div class="control-group">
        <label>Traffic Intensity: <span class="value" id="trafficValue">50</span></label>
        <input type="range" class="slider" id="trafficSlider" min="0" max="100" value="50">
    </div>
    
    <div class="control-group">
        <label>Development Speed: <span class="value" id="speedValue">50</span></label>
        <input type="range" class="slider" id="speedSlider" min="1" max="100" value="50">
    </div>
    
    <div class="control-group">
        <button id="resetBtn" style="width: 100%; padding: 10px; background: #00ff88; border: none; border-radius: 5px; color: black; font-weight: bold; cursor: pointer;">Reset City</button>
    </div>
</div>

<div id="stats">
    <h4 style="margin-top: 0; color: #00ff88;">City Statistics</h4>
    <div class="stat-line"><span class="stat-label">Buildings:</span> <span id="buildingCount">0</span></div>
    <div class="stat-line"><span class="stat-label">Vehicles:</span> <span id="vehicleCount">0</span></div>
    <div class="stat-line"><span class="stat-label">Pedestrians:</span> <span id="pedestrianCount">0</span></div>
    <div class="stat-line"><span class="stat-label">Population:</span> <span id="population">0</span></div>
</div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

<script>
// ====================================================================
// 3D Growing City Simulation - Complete Standalone HTML
// Features: Procedural buildings, roads, traffic, pedestrians, real-time controls
// ====================================================================

const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color4(0.5, 0.7, 0.9, 1);

// Lighting
const hemisphericLight = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
hemisphericLight.intensity = 0.7;
const directionalLight = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-1, -2, -1), scene);
directionalLight.intensity = 0.5;

// Camera
const camera = new BABYLON.ArcRotateCamera("cam", Math.PI / 4, Math.PI / 3, 200, BABYLON.Vector3.Zero(), scene);
camera.attachControl(canvas, true);
camera.lowerRadiusLimit = 50;
camera.upperRadiusLimit = 500;

// City state
let cityState = {
    density: 50,
    trafficIntensity: 50,
    developmentSpeed: 50,
    buildings: [],
    roads: [],
    vehicles: [],
    pedestrians: [],
    grid: [],
    gridSize: 20,
    cellSize: 10
};

// Ground
const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 200, height: 200}, scene);
const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
groundMat.diffuseColor = new BABYLON.Color3(0.3, 0.5, 0.3);
ground.material = groundMat;

// Building class
class Building {
    constructor(x, z, type) {
        this.x = x;
        this.z = z;
        this.type = type;
        this.height = 0;
        this.targetHeight = this.calculateHeight();
        this.growthSpeed = 0.5;
        this.mesh = null;
        this.population = Math.floor(this.targetHeight / 2);
        this.createMesh();
    }

    calculateHeight() {
        const heights = {
            residential: 10 + Math.random() * 20,
            commercial: 20 + Math.random() * 30,
            office: 30 + Math.random() * 40
        };
        return heights[this.type] || heights.residential;
    }

    createMesh() {
        const width = 6 + Math.random() * 4;
        const depth = 6 + Math.random() * 4;
        
        this.mesh = BABYLON.MeshBuilder.CreateBox("building", {
            width: width,
            height: 0.1,
            depth: depth
        }, scene);
        
        this.mesh.position.x = this.x;
        this.mesh.position.y = 0.05;
        this.mesh.position.z = this.z;
        
        const mat = new BABYLON.StandardMaterial("buildingMat", scene);
        const colors = {
            residential: new BABYLON.Color3(0.7, 0.5, 0.3),
            commercial: new BABYLON.Color3(0.3, 0.3, 0.7),
            office: new BABYLON.Color3(0.5, 0.5, 0.5)
        };
        mat.diffuseColor = colors[this.type];
        mat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
        this.mesh.material = mat;
    }

    grow() {
        if (this.height < this.targetHeight) {
            this.height += this.growthSpeed * (cityState.developmentSpeed / 50);
            if (this.height > this.targetHeight) this.height = this.targetHeight;
            
            this.mesh.scaling.y = this.height / 0.1;
            this.mesh.position.y = this.height / 2;
            
            // Add windows as the building grows
            if (Math.random() < 0.1 && this.height > 5) {
                this.addWindow();
            }
        }
    }

    addWindow() {
        const window = BABYLON.MeshBuilder.CreateBox("window", {
            width: 0.8,
            height: 1,
            depth: 0.1
        }, scene);
        
        window.position.x = this.x + (Math.random() - 0.5) * 4;
        window.position.y = Math.random() * this.height;
        window.position.z = this.z + (Math.random() - 0.5) * 4;
        
        const windowMat = new BABYLON.StandardMaterial("windowMat", scene);
        windowMat.emissiveColor = Math.random() > 0.3 ? 
            new BABYLON.Color3(1, 0.9, 0.6) : new BABYLON.Color3(0, 0, 0);
        window.material = windowMat;
    }
}

// Road class
class Road {
    constructor(start, end, width) {
        this.start = start;
        this.end = end;
        this.width = width;
        this.mesh = null;
        this.createMesh();
    }

    createMesh() {
        const length = BABYLON.Vector3.Distance(this.start, this.end);
        const center = BABYLON.Vector3.Lerp(this.start, this.end, 0.5);
        
        this.mesh = BABYLON.MeshBuilder.CreateBox("road", {
            width: this.width,
            height: 0.1,
            depth: length
        }, scene);
        
        this.mesh.position = center;
        this.mesh.lookAt(this.end);
        
        const roadMat = new BABYLON.StandardMaterial("roadMat", scene);
        roadMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
        this.mesh.material = roadMat;
    }
}

// Vehicle class
class Vehicle {
    constructor() {
        this.mesh = null;
        this.speed = 2 + Math.random() * 3;
        this.path = [];
        this.currentPathIndex = 0;
        this.createMesh();
        this.generatePath();
    }

    createMesh() {
        this.mesh = BABYLON.MeshBuilder.CreateBox("vehicle", {
            width: 2,
            height: 1,
            depth: 4
        }, scene);
        
        const carMat = new BABYLON.StandardMaterial("carMat", scene);
        const colors = [new BABYLON.Color3(0.8, 0.2, 0.2), 
                       new BABYLON.Color3(0.2, 0.2, 0.8),
                       new BABYLON.Color3(0.8, 0.8, 0.2),
                       new BABYLON.Color3(0.2, 0.8, 0.2)];
        carMat.diffuseColor = colors[Math.floor(Math.random() * colors.length)];
        this.mesh.material = carMat;
        
        // Start at random position
        this.mesh.position.x = (Math.random() - 0.5) * 180;
        this.mesh.position.z = (Math.random() - 0.5) * 180;
        this.mesh.position.y = 0.5;
    }

    generatePath() {
        const points = [];
        const numPoints = 5 + Math.floor(Math.random() * 5);
        
        for (let i = 0; i < numPoints; i++) {
            points.push(new BABYLON.Vector3(
                (Math.random() - 0.5) * 180,
                0.5,
                (Math.random() - 0.5) * 180
            ));
        }
        
        this.path = points;
    }

    update() {
        if (this.path.length === 0) return;
        
        const target = this.path[this.currentPathIndex];
        const direction = target.subtract(this.mesh.position);
        const distance = direction.length();
        
        if (distance < 2) {
            this.currentPathIndex = (this.currentPathIndex + 1) % this.path.length;
        } else {
            const move = direction.normalize().scale(this.speed * (cityState.trafficIntensity / 50));
            this.mesh.position.addInPlace(move);
            this.mesh.lookAt(target);
        }
    }
}

// Pedestrian class
class Pedestrian {
    constructor() {
        this.mesh = null;
        this.speed = 0.5 + Math.random() * 0.5;
        this.target = null;
        this.createMesh();
        this.setNewTarget();
    }

    createMesh() {
        this.mesh = BABYLON.MeshBuilder.CreateCylinder("pedestrian", {
            height: 2,
            diameter: 0.5
        }, scene);
        
        const pedMat = new BABYLON.StandardMaterial("pedMat", scene);
        pedMat.diffuseColor = new BABYLON.Color3(0.8, 0.6, 0.4);
        this.mesh.material = pedMat;
        
        this.mesh.position.x = (Math.random() - 0.5) * 180;
        this.mesh.position.z = (Math.random() - 0.5) * 180;
        this.mesh.position.y = 1;
    }

    setNewTarget() {
        this.target = new BABYLON.Vector3(
            (Math.random() - 0.5) * 180,
            1,
            (Math.random() - 0.5) * 180
        );
    }

    update() {
        if (!this.target) return;
        
        const direction = this.target.subtract(this.mesh.position);
        const distance = direction.length();
        
        if (distance < 1) {
            this.setNewTarget();
        } else {
            const move = direction.normalize().scale(this.speed);
            this.mesh.position.addInPlace(move);
            this.mesh.rotation.y = Math.atan2(direction.x, direction.z);
        }
    }
}

// Initialize city grid
function initializeGrid() {
    cityState.grid = [];
    for (let i = 0; i < cityState.gridSize; i++) {
        cityState.grid[i] = [];
        for (let j = 0; j < cityState.gridSize; j++) {
            cityState.grid[i][j] = {
                occupied: false,
                building: null,
                road: false
            };
        }
    }
}

// Generate city
function generateCity() {
    initializeGrid();
    
    // Clear existing
    cityState.buildings.forEach(b => b.mesh.dispose());
    cityState.roads.forEach(r => r.mesh.dispose());
    cityState.buildings = [];
    cityState.roads = [];
    
    // Generate roads (grid pattern)
    const roadSpacing = 4;
    for (let i = 0; i < cityState.gridSize; i += roadSpacing) {
        for (let j = 0; j < cityState.gridSize; j++) {
            const x = (i - cityState.gridSize / 2) * cityState.cellSize;
            const z = (j - cityState.gridSize / 2) * cityState.cellSize;
            
            if (j < cityState.gridSize - 1) {
                const nextZ = ((j + 1) - cityState.gridSize / 2) * cityState.cellSize;
                cityState.roads.push(new Road(
                    new BABYLON.Vector3(x, 0.05, z),
                    new BABYLON.Vector3(x, 0.05, nextZ),
                    8
                ));
            }
            
            if (i < cityState.gridSize - 1) {
                const nextX = ((i + 1) - cityState.gridSize / 2) * cityState.cellSize;
                cityState.roads.push(new Road(
                    new BABYLON.Vector3(x, 0.05, z),
                    new BABYLON.Vector3(nextX, 0.05, z),
                    8
                ));
            }
        }
    }
    
    // Generate buildings
    const numBuildings = Math.floor((cityState.density / 100) * 150);
    const buildingTypes = ['residential', 'commercial', 'office'];
    
    for (let i = 0; i < numBuildings; i++) {
        let placed = false;
        let attempts = 0;
        
        while (!placed && attempts < 50) {
            const gridX = Math.floor(Math.random() * cityState.gridSize);
            const gridZ = Math.floor(Math.random() * cityState.gridSize);
            
            if (!cityState.grid[gridX][gridZ].occupied && 
                (gridX % roadSpacing !== 0) && 
                (gridZ % roadSpacing !== 0)) {
                
                const x = (gridX - cityState.gridSize / 2) * cityState.cellSize;
                const z = (gridZ - cityState.gridSize / 2) * cityState.cellSize;
                
                const type = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                const building = new Building(x, z, type);
                
                cityState.buildings.push(building);
                cityState.grid[gridX][gridZ].occupied = true;
                cityState.grid[gridX][gridZ].building = building;
                placed = true;
            }
            attempts++;
        }
    }
    
    updateStats();
}

// Generate traffic
function generateTraffic() {
    // Clear existing vehicles
    cityState.vehicles.forEach(v => v.mesh.dispose());
    cityState.vehicles = [];
    
    const numVehicles = Math.floor((cityState.trafficIntensity / 100) * 30);
    for (let i = 0; i < numVehicles; i++) {
        cityState.vehicles.push(new Vehicle());
    }
    
    // Clear existing pedestrians
    cityState.pedestrians.forEach(p => p.mesh.dispose());
    cityState.pedestrians = [];
    
    const numPedestrians = Math.floor((cityState.density / 100) * 50);
    for (let i = 0; i < numPedestrians; i++) {
        cityState.pedestrians.push(new Pedestrian());
    }
    
    updateStats();
}

// Update statistics
function updateStats() {
    document.getElementById('buildingCount').textContent = cityState.buildings.length;
    document.getElementById('vehicleCount').textContent = cityState.vehicles.length;
    document.getElementById('pedestrianCount').textContent = cityState.pedestrians.length;
    
    const population = cityState.buildings.reduce((sum, b) => sum + b.population, 0);
    document.getElementById('population').textContent = Math.floor(population);
}

// Animation loop
scene.registerBeforeRender(() => {
    // Grow buildings
    cityState.buildings.forEach(building => building.grow());
    
    // Update vehicles
    cityState.vehicles.forEach(vehicle => vehicle.update());
    
    // Update pedestrians
    cityState.pedestrians.forEach(pedestrian => pedestrian.update());
});

// Control handlers
document.getElementById('densitySlider').addEventListener('input', (e) => {
    cityState.density = parseInt(e.target.value);
    document.getElementById('densityValue').textContent = cityState.density;
    generateCity();
    generateTraffic();
});

document.getElementById('trafficSlider').addEventListener('input', (e) => {
    cityState.trafficIntensity = parseInt(e.target.value);
    document.getElementById('trafficValue').textContent = cityState.trafficIntensity;
    generateTraffic();
});

document.getElementById('speedSlider').addEventListener('input', (e) => {
    cityState.developmentSpeed = parseInt(e.target.value);
    document.getElementById('speedValue').textContent = cityState.developmentSpeed;
});

document.getElementById('resetBtn').addEventListener('click', () => {
    generateCity();
    generateTraffic();
});

// Initialize
generateCity();
generateTraffic();

// Start render loop
engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());

</script>
</body>
</html>