<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Babylon.js Growing City Simulation</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            display: block;
        }
        #uiPanel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 10px 14px;
            border-radius: 4px;
            font-family: Arial, sans-serif;
            font-size: 12px;
            max-width: 260px;
            box-shadow: 0 0 10px rgba(0,0,0,0.7);
        }
        #uiPanel h2 {
            margin: 0 0 8px 0;
            font-size: 16px;
            font-weight: normal;
        }
        .control {
            margin-bottom: 10px;
        }
        .control label {
            display: block;
            margin-bottom: 2px;
        }
        .control input[type="range"] {
            width: 100%;
        }
        .valueLabel {
            font-weight: bold;
        }
    </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<div id="uiPanel">
    <h2>Growing City Controls</h2>
    <div class="control">
        <label>
            City size (population / density):
            <span class="valueLabel" id="citySizeValue">60%</span>
        </label>
        <input id="citySizeSlider" type="range" min="5" max="100" value="60">
    </div>
    <div class="control">
        <label>
            Traffic intensity:
            <span class="valueLabel" id="trafficValue">50%</span>
        </label>
        <input id="trafficSlider" type="range" min="0" max="100" value="50">
    </div>
    <div class="control">
        <label>
            Development speed:
            <span class="valueLabel" id="devSpeedValue">60%</span>
        </label>
        <input id="devSpeedSlider" type="range" min="5" max="100" value="60">
    </div>
</div>

<!-- Babylon.js core (library itself is the only external script) -->
<script src="https://cdn.babylonjs.com/babylon.js"></script>

<script>
(function () {
    var canvas = document.getElementById("renderCanvas");
    var engine = new BABYLON.Engine(canvas, true, {
        preserveDrawingBuffer: true,
        stencil: true
    });

    // UI elements & state
    var citySizeSlider   = document.getElementById("citySizeSlider");
    var trafficSlider    = document.getElementById("trafficSlider");
    var devSpeedSlider   = document.getElementById("devSpeedSlider");
    var citySizeValue    = document.getElementById("citySizeValue");
    var trafficValue     = document.getElementById("trafficValue");
    var devSpeedValue    = document.getElementById("devSpeedValue");

    function updateLabels() {
        citySizeValue.textContent  = citySizeSlider.value + "%";
        trafficValue.textContent   = trafficSlider.value + "%";
        devSpeedValue.textContent  = devSpeedSlider.value + "%";
    }
    updateLabels();

    var citySizeFactor          = parseFloat(citySizeSlider.value) / 100;   // 0..1
    var trafficIntensity        = parseFloat(trafficSlider.value) / 100;    // 0..1
    var developmentSpeedFactor  = parseFloat(devSpeedSlider.value) / 100;   // 0..1

    citySizeSlider.addEventListener("input", function () {
        citySizeFactor = parseFloat(this.value) / 100;
        citySizeValue.textContent = this.value + "%";
    });
    trafficSlider.addEventListener("input", function () {
        trafficIntensity = parseFloat(this.value) / 100;
        trafficValue.textContent = this.value + "%";
    });
    devSpeedSlider.addEventListener("input", function () {
        developmentSpeedFactor = parseFloat(this.value) / 100;
        devSpeedValue.textContent = this.value + "%";
    });

    // Scene creation
    var createScene = function () {
        var scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0.02, 0.02, 0.05, 1);

        // Constants for city layout
        var GRID_SIZE  = 16;      // number of blocks per side
        var CELL_SIZE  = 6;       // world units per block
        var ROAD_WIDTH = 1.2;
        var CITY_EXTENT = GRID_SIZE * CELL_SIZE / 2;

        // Camera
        var camera = new BABYLON.ArcRotateCamera(
            "camera",
            -Math.PI / 4,
            Math.PI / 3,
            CITY_EXTENT * 2,
            new BABYLON.Vector3(0, 0, 0),
            scene
        );
        camera.upperBetaLimit = Math.PI / 2.1;
        camera.lowerRadiusLimit = CITY_EXTENT * 0.6;
        camera.upperRadiusLimit = CITY_EXTENT * 3;
        camera.attachControl(canvas, true);

        // Lights
        var hemiLight = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0.1, 1, 0.3), scene);
        hemiLight.intensity = 0.9;

        var dirLight = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-0.5, -1, -0.3), scene);
        dirLight.position = new BABYLON.Vector3(40, 40, 40);
        dirLight.intensity = 0.7;

        // Ground
        var ground = BABYLON.MeshBuilder.CreateGround("ground", {
            width: GRID_SIZE * CELL_SIZE * 1.3,
            height: GRID_SIZE * CELL_SIZE * 1.3
        }, scene);
        var groundMat = new BABYLON.StandardMaterial("groundMat", scene);
        groundMat.diffuseColor = new BABYLON.Color3(0.08, 0.1, 0.12);
        groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
        ground.material = groundMat;

        // Subtle skybox gradient using hemispheric light only
        scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
        scene.fogDensity = 0.0006;
        scene.fogColor = new BABYLON.Color3(0.01, 0.01, 0.04);

        // City data structures
        var cells = [];                 // all cells
        var remainingCells = [];        // undeveloped cells (for random selection)
        var developedCellsList = [];    // developed cells
        var developedCount = 0;
        var constructionCells = [];     // cells with buildings growing

        var activeRoadX = new Set();    // active north-south road x-positions
        var activeRoadZ = new Set();    // active east-west road z-positions

        var vehicles = [];
        var people = [];

        var vehicleSpawnAccum = 0;
        var peopleSpawnAccum = 0;
        var developmentAccumulator = 0;

        var MAX_VEHICLES = 80;
        var MAX_PEOPLE = 120;

        // Shared materials
        var roadMat = new BABYLON.StandardMaterial("roadMat", scene);
        roadMat.diffuseColor = new BABYLON.Color3(0.04, 0.04, 0.045);
        roadMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

        var buildingMats = [];
        (function createBuildingMaterials() {
            var m1 = new BABYLON.StandardMaterial("bld1", scene);
            m1.diffuseColor = new BABYLON.Color3(0.35, 0.38, 0.42);
            m1.specularColor = new BABYLON.Color3(0.7, 0.7, 0.8);
            m1.emissiveColor = new BABYLON.Color3(0.02, 0.02, 0.04);

            var m2 = new BABYLON.StandardMaterial("bld2", scene);
            m2.diffuseColor = new BABYLON.Color3(0.28, 0.3, 0.34);
            m2.specularColor = new BABYLON.Color3(0.9, 0.8, 0.7);
            m2.emissiveColor = new BABYLON.Color3(0.03, 0.03, 0.05);

            var m3 = new BABYLON.StandardMaterial("bld3", scene);
            m3.diffuseColor = new BABYLON.Color3(0.22, 0.24, 0.3);
            m3.specularColor = new BABYLON.Color3(0.5, 0.5, 0.6);
            m3.emissiveColor = new BABYLON.Color3(0.015, 0.015, 0.04);

            buildingMats.push(m1, m2, m3);
        })();

        var carColors = [
            new BABYLON.Color3(0.8, 0.2, 0.2),
            new BABYLON.Color3(0.2, 0.8, 0.3),
            new BABYLON.Color3(0.2, 0.4, 0.9),
            new BABYLON.Color3(0.9, 0.7, 0.2),
            new BABYLON.Color3(0.8, 0.4, 0.8)
        ];

        // Grid and initial roads (hidden)
        (function initGrid() {
            var half = GRID_SIZE / 2;

            for (var ix = 0; ix < GRID_SIZE; ix++) {
                for (var iz = 0; iz < GRID_SIZE; iz++) {
                    var worldX = (ix - half) * CELL_SIZE + CELL_SIZE / 2;
                    var worldZ = (iz - half) * CELL_SIZE + CELL_SIZE / 2;

                    var cell = {
                        ix: ix,
                        iz: iz,
                        worldX: worldX,
                        worldZ: worldZ,
                        developed: false,
                        buildingMesh: null,
                        constructionProgress: 0,
                        roadEW: null,
                        roadNS: null
                    };

                    // East-West road segment (along x axis), north edge of cell
                    var roadEW = BABYLON.MeshBuilder.CreateBox("roadEW_" + ix + "_" + iz, {
                        width: CELL_SIZE,
                        height: 0.03,
                        depth: ROAD_WIDTH
                    }, scene);
                    roadEW.position = new BABYLON.Vector3(worldX, 0.015, worldZ - CELL_SIZE / 2);
                    roadEW.material = roadMat;
                    roadEW.isVisible = false;

                    // North-South road segment (along z axis), west edge of cell
                    var roadNS = BABYLON.MeshBuilder.CreateBox("roadNS_" + ix + "_" + iz, {
                        width: ROAD_WIDTH,
                        height: 0.03,
                        depth: CELL_SIZE
                    }, scene);
                    roadNS.position = new BABYLON.Vector3(worldX - CELL_SIZE / 2, 0.015, worldZ);
                    roadNS.material = roadMat;
                    roadNS.isVisible = false;

                    cell.roadEW = roadEW;
                    cell.roadNS = roadNS;

                    cells.push(cell);
                    remainingCells.push(cell);
                }
            }
        })();

        function developNextCell() {
            if (remainingCells.length === 0) return;

            var idx = Math.floor(Math.random() * remainingCells.length);
            var cell = remainingCells.splice(idx, 1)[0];

            if (cell.developed) return;
            cell.developed = true;
            developedCellsList.push(cell);
            developedCount++;

            // Activate roads for this cell
            if (cell.roadEW) {
                cell.roadEW.isVisible = true;
                activeRoadZ.add(cell.roadEW.position.z);
            }
            if (cell.roadNS) {
                cell.roadNS.isVisible = true;
                activeRoadX.add(cell.roadNS.position.x);
            }

            // Create building
            var baseSizeX = CELL_SIZE * (0.4 + Math.random() * 0.4);
            var baseSizeZ = CELL_SIZE * (0.4 + Math.random() * 0.4);
            var baseHeight = 3 + Math.random() * 14 * (0.5 + citySizeFactor * 0.7);

            var building = BABYLON.MeshBuilder.CreateBox("b_" + cell.ix + "_" + cell.iz, {
                width: baseSizeX,
                depth: baseSizeZ,
                height: baseHeight
            }, scene);
            building.material = buildingMats[Math.floor(Math.random() * buildingMats.length)];

            // Pivot at base so vertical scale grows from ground
            building.setPivotPoint(new BABYLON.Vector3(0, -baseHeight / 2, 0));
            building.position = new BABYLON.Vector3(cell.worldX, 0, cell.worldZ);
            building.scaling.y = 0.01;

            cell.buildingMesh = building;
            cell.constructionProgress = 0.01;
            constructionCells.push(cell);
        }

        function updateDevelopment(dt) {
            var desired = Math.floor(citySizeFactor * cells.length);
            if (desired > cells.length) desired = cells.length;

            if (developedCount < desired) {
                var speedScale = 0.4 + developmentSpeedFactor * 3.0;
                developmentAccumulator += dt * speedScale;

                while (developmentAccumulator >= 1 && developedCount < desired) {
                    developmentAccumulator -= 1;
                    developNextCell();
                }
            }
        }

        function updateConstruction(dt) {
            for (var i = constructionCells.length - 1; i >= 0; i--) {
                var cell = constructionCells[i];
                var speed = 0.2 + developmentSpeedFactor * 2.0;
                cell.constructionProgress += dt * speed;

                if (cell.constructionProgress >= 1) {
                    cell.constructionProgress = 1;
                    constructionCells.splice(i, 1);
                }

                if (cell.buildingMesh) {
                    cell.buildingMesh.scaling.y = cell.constructionProgress;
                }
            }
        }

        function createVehicle() {
            if (activeRoadX.size === 0 && activeRoadZ.size === 0) return null;

            var orientation;
            if (activeRoadZ.size > 0 && activeRoadX.size > 0) {
                orientation = Math.random() < 0.5 ? "H" : "V";
            } else if (activeRoadZ.size > 0) {
                orientation = "H";
            } else {
                orientation = "V";
            }

            var dir = Math.random() < 0.5 ? 1 : -1;
            var length = 2 + Math.random() * 1.2;
            var width = 1.1;
            var height = 0.6;

            var car = BABYLON.MeshBuilder.CreateBox("car", {
                width: width,
                depth: length,
                height: height
            }, scene);

            var carMat = new BABYLON.StandardMaterial("carMat" + Math.random(), scene);
            var color = carColors[Math.floor(Math.random() * carColors.length)];
            carMat.diffuseColor = color;
            carMat.specularColor = new BABYLON.Color3(0.8, 0.8, 0.8);
            car.material = carMat;

            var minX = -CITY_EXTENT - 6;
            var maxX = CITY_EXTENT + 6;
            var minZ = -CITY_EXTENT - 6;
            var maxZ = CITY_EXTENT + 6;

            if (orientation === "H") {
                var zs = Array.from(activeRoadZ);
                var z = zs[Math.floor(Math.random() * zs.length)];
                var y = 0.2;
                var x = dir > 0 ? minX : maxX;
                car.position = new BABYLON.Vector3(x, y, z);
                car.rotation.y = 0;
            } else {
                var xs = Array.from(activeRoadX);
                var x2 = xs[Math.floor(Math.random() * xs.length)];
                var y2 = 0.2;
                var z2 = dir > 0 ? minZ : maxZ;
                car.position = new BABYLON.Vector3(x2, y2, z2);
                car.rotation.y = Math.PI / 2;
            }

            var speed = 6 + Math.random() * 6; // units per second

            return {
                mesh: car,
                orientation: orientation,
                dir: dir,
                speed: speed,
                minX: minX,
                maxX: maxX,
                minZ: minZ,
                maxZ: maxZ
            };
        }

        function assignNewWalk(person) {
            if (developedCellsList.length < 2) return;

            var aIndex = Math.floor(Math.random() * developedCellsList.length);
            var bIndex = Math.floor(Math.random() * developedCellsList.length);
            if (bIndex === aIndex) {
                bIndex = (aIndex + 1) % developedCellsList.length;
            }
            var cellA = developedCellsList[aIndex];
            var cellB = developedCellsList[bIndex];

            var startPos = new BABYLON.Vector3(
                cellA.worldX + (Math.random() - 0.5) * CELL_SIZE * 0.4,
                0.05,
                cellA.worldZ + (Math.random() - 0.5) * CELL_SIZE * 0.4
            );
            var endPos = new BABYLON.Vector3(
                cellB.worldX + (Math.random() - 0.5) * CELL_SIZE * 0.4,
                0.05,
                cellB.worldZ + (Math.random() - 0.5) * CELL_SIZE * 0.4
            );

            person.start = startPos;
            person.end = endPos;
            person.progress = 0;
            person.distance = BABYLON.Vector3.Distance(startPos, endPos) || 1;
            person.mesh.position.copyFrom(startPos);
        }

        function createPerson() {
            if (developedCellsList.length < 2) return null;

            var height = 0.8 + Math.random() * 0.4;
            var personMesh = BABYLON.MeshBuilder.CreateCylinder("person", {
                diameterTop: 0.25,
                diameterBottom: 0.3,
                height: height,
                tessellation: 6
            }, scene);

            var pMat = new BABYLON.StandardMaterial("personMat" + Math.random(), scene);
            pMat.diffuseColor = new BABYLON.Color3(
                0.5 + Math.random() * 0.3,
                0.4 + Math.random() * 0.4,
                0.4 + Math.random() * 0.4
            );
            pMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            personMesh.material = pMat;

            var person = {
                mesh: personMesh,
                start: BABYLON.Vector3.Zero(),
                end: BABYLON.Vector3.Zero(),
                progress: 0,
                distance: 1,
                speed: 1 + Math.random() * 0.8
            };

            assignNewWalk(person);
            return person;
        }

        function manageTrafficCounts(dt) {
            var cityFactor = cells.length > 0 ? developedCount / cells.length : 0;
            var effectiveTraffic = trafficIntensity * Math.min(1, cityFactor + 0.2);

            var targetVehicles = Math.floor(effectiveTraffic * MAX_VEHICLES);
            var targetPeople   = Math.floor(effectiveTraffic * MAX_PEOPLE);

            // Adjust vehicle count
            if (vehicles.length > targetVehicles) {
                var toRemoveV = vehicles.length - targetVehicles;
                for (var i = 0; i < toRemoveV; i++) {
                    var v = vehicles.pop();
                    v.mesh.dispose();
                }
            } else if (vehicles.length < targetVehicles) {
                vehicleSpawnAccum += dt * (0.5 + effectiveTraffic * 3.0);
                while (vehicleSpawnAccum >= 1 && vehicles.length < targetVehicles) {
                    vehicleSpawnAccum -= 1;
                    var newV = createVehicle();
                    if (!newV) break;
                    vehicles.push(newV);
                }
            }

            // Adjust pedestrian count
            if (people.length > targetPeople) {
                var toRemoveP = people.length - targetPeople;
                for (var j = 0; j < toRemoveP; j++) {
                    var p = people.pop();
                    p.mesh.dispose();
                }
            } else if (people.length < targetPeople) {
                peopleSpawnAccum += dt * (0.5 + effectiveTraffic * 2.0);
                while (peopleSpawnAccum >= 1 && people.length < targetPeople) {
                    peopleSpawnAccum -= 1;
                    var newP = createPerson();
                    if (!newP) break;
                    people.push(newP);
                }
            }
        }

        function updateVehicles(dt) {
            for (var i = 0; i < vehicles.length; i++) {
                var v = vehicles[i];
                if (v.orientation === "H") {
                    v.mesh.position.x += v.dir * v.speed * dt;
                    if (v.dir > 0 && v.mesh.position.x > v.maxX) {
                        v.mesh.position.x = v.minX;
                    } else if (v.dir < 0 && v.mesh.position.x < v.minX) {
                        v.mesh.position.x = v.maxX;
                    }
                } else {
                    v.mesh.position.z += v.dir * v.speed * dt;
                    if (v.dir > 0 && v.mesh.position.z > v.maxZ) {
                        v.mesh.position.z = v.minZ;
                    } else if (v.dir < 0 && v.mesh.position.z < v.minZ) {
                        v.mesh.position.z = v.maxZ;
                    }
                }
            }
        }

        function updatePeople(dt) {
            for (var i = 0; i < people.length; i++) {
                var p = people[i];
                if (p.distance <= 0.001) {
                    assignNewWalk(p);
                    continue;
                }
                p.progress += (dt * p.speed) / p.distance;
                if (p.progress >= 1) {
                    assignNewWalk(p);
                } else {
                    var newPos = BABYLON.Vector3.Lerp(p.start, p.end, p.progress);
                    p.mesh.position.copyFrom(newPos);

                    var dir = p.end.subtract(p.start);
                    dir.y = 0;
                    if (dir.lengthSquared() > 0.001) {
                        var lookTarget = p.mesh.position.add(dir);
                        p.mesh.lookAt(lookTarget);
                    }
                }
            }
        }

        // Main update loop
        var lastTime = performance.now();
        scene.onBeforeRenderObservable.add(function () {
            var now = performance.now();
            var dt = (now - lastTime) / 1000;
            if (dt > 0.1) dt = 0.1; // clamp to avoid large jumps
            lastTime = now;

            updateDevelopment(dt);
            updateConstruction(dt);
            manageTrafficCounts(dt);
            updateVehicles(dt);
            updatePeople(dt);
        });

        return scene;
    };

    var scene = createScene();

    engine.runRenderLoop(function () {
        scene.render();
    });

    window.addEventListener("resize", function () {
        engine.resize();
    });
})();
</script>
</body>
</html>