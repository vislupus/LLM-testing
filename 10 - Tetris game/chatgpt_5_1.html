<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pure JS Tetris</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      background: radial-gradient(circle at top, #333 0, #050505 60%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #eee;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .game-wrapper {
      display: flex;
      gap: 20px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 16px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }
    .board-container {
      position: relative;
    }
    canvas#board {
      background: #050711;
      border-radius: 8px;
      box-shadow: 0 0 0 2px #111, 0 0 40px rgba(0, 0, 0, 0.8);
      image-rendering: pixelated;
      display: block;
    }
    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fff;
      text-align: center;
      padding: 20px;
      border-radius: 8px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    .overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }
    .overlay h1 {
      font-size: 32px;
      margin-bottom: 10px;
    }
    .overlay p {
      margin: 4px 0;
    }
    .overlay button {
      margin-top: 16px;
      padding: 8px 20px;
      border-radius: 999px;
      border: none;
      background: #3b82f6;
      color: #fff;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(59, 130, 246, 0.8);
      transition: transform 0.1s ease, box-shadow 0.1s ease, background 0.1s ease;
    }
    .overlay button:hover {
      transform: translateY(-1px);
      background: #2563eb;
      box-shadow: 0 0 16px rgba(59, 130, 246, 0.9);
    }
    .sidebar {
      width: 180px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }
    .panel {
      background: rgba(10, 10, 20, 0.9);
      border-radius: 10px;
      padding: 12px 14px;
      margin-bottom: 12px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    .panel h2 {
      font-size: 14px;
      margin-bottom: 8px;
      color: #cbd5f5;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .stat-row {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      margin: 2px 0;
    }
    .stat-label {
      color: #9ca3af;
    }
    .stat-value {
      font-weight: 600;
      color: #e5e7eb;
    }
    .instructions p {
      font-size: 12px;
      color: #d1d5db;
      line-height: 1.4;
      margin: 2px 0;
    }
    .instructions code {
      background: rgba(15, 23, 42, 0.8);
      padding: 1px 6px;
      border-radius: 999px;
      font-size: 11px;
      border: 1px solid rgba(148, 163, 184, 0.5);
    }
    .footer-note {
      font-size: 11px;
      color: #9ca3af;
      text-align: center;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="game-wrapper">
    <div class="board-container">
      <canvas id="board" width="300" height="600"></canvas>
      <div id="overlay" class="overlay">
        <h1 id="overlay-title">TETRIS</h1>
        <p id="overlay-message">Press space to start</p>
        <p id="overlay-score" style="margin-top:8px;"></p>
        <button id="restartBtn">Play Again</button>
      </div>
    </div>
    <div class="sidebar">
      <div class="panel">
        <h2>Stats</h2>
        <div class="stat-row">
          <span class="stat-label">Score</span>
          <span class="stat-value" id="scoreValue">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Level</span>
          <span class="stat-value" id="levelValue">1</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Lines</span>
          <span class="stat-value" id="linesValue">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Speed</span>
          <span class="stat-value" id="speedValue">1x</span>
        </div>
      </div>
      <div class="panel instructions">
        <h2>Controls</h2>
        <p><code>←</code> / <code>→</code> Move</p>
        <p><code>↑</code> Rotate</p>
        <p><code>↓</code> Soft drop</p>
        <p><code>Space</code> Hard drop</p>
        <p><code>R</code> Restart</p>
      </div>
      <div class="footer-note">
        Pure HTML / CSS / JS Tetris
      </div>
    </div>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById('board');
      const ctx = canvas.getContext('2d');

      const COLS = 10;
      const ROWS = 20;
      const BLOCK_SIZE = 30;
      const BOARD_WIDTH = COLS * BLOCK_SIZE;
      const BOARD_HEIGHT = ROWS * BLOCK_SIZE;

      canvas.width = BOARD_WIDTH;
      canvas.height = BOARD_HEIGHT;

      const COLORS = {
        I: '#00f0f0',
        O: '#f0f000',
        T: '#a000f0',
        S: '#00f000',
        Z: '#f00000',
        J: '#0000f0',
        L: '#f0a000'
      };

      // Tetromino shapes: 4 rotation states, coordinates in a 4x4 grid
      const SHAPES = {
        I: [
          [ [0,1],[1,1],[2,1],[3,1] ],
          [ [2,0],[2,1],[2,2],[2,3] ],
          [ [0,2],[1,2],[2,2],[3,2] ],
          [ [1,0],[1,1],[1,2],[1,3] ]
        ],
        J: [
          [ [0,0],[0,1],[1,1],[2,1] ],
          [ [1,0],[2,0],[1,1],[1,2] ],
          [ [0,1],[1,1],[2,1],[2,2] ],
          [ [1,0],[1,1],[0,2],[1,2] ]
        ],
        L: [
          [ [2,0],[0,1],[1,1],[2,1] ],
          [ [1,0],[1,1],[1,2],[2,2] ],
          [ [0,1],[1,1],[2,1],[0,2] ],
          [ [0,0],[1,0],[1,1],[1,2] ]
        ],
        O: [
          [ [1,0],[2,0],[1,1],[2,1] ],
          [ [1,0],[2,0],[1,1],[2,1] ],
          [ [1,0],[2,0],[1,1],[2,1] ],
          [ [1,0],[2,0],[1,1],[2,1] ]
        ],
        S: [
          [ [1,0],[2,0],[0,1],[1,1] ],
          [ [1,0],[1,1],[2,1],[2,2] ],
          [ [1,1],[2,1],[0,2],[1,2] ],
          [ [0,0],[0,1],[1,1],[1,2] ]
        ],
        Z: [
          [ [0,0],[1,0],[1,1],[2,1] ],
          [ [2,0],[1,1],[2,1],[1,2] ],
          [ [0,1],[1,1],[1,2],[2,2] ],
          [ [1,0],[0,1],[1,1],[0,2] ]
        ],
        T: [
          [ [1,0],[0,1],[1,1],[2,1] ],
          [ [1,0],[1,1],[2,1],[1,2] ],
          [ [0,1],[1,1],[2,1],[1,2] ],
          [ [1,0],[0,1],[1,1],[1,2] ]
        ]
      };

      const TETROMINO_TYPES = Object.keys(SHAPES);

      let board;
      let currentPiece;
      let nextRandomType = null;

      let lastTime = 0;
      let dropCounter = 0;
      let dropInterval = 1000; // ms
      let score = 0;
      let linesCleared = 0;
      let level = 1;
      let speedMultiplier = 1;

      let gameOver = false;
      let gameStarted = false;

      const overlay = document.getElementById('overlay');
      const overlayTitle = document.getElementById('overlay-title');
      const overlayMsg = document.getElementById('overlay-message');
      const overlayScore = document.getElementById('overlay-score');
      const restartBtn = document.getElementById('restartBtn');

      const scoreValueEl = document.getElementById('scoreValue');
      const levelValueEl = document.getElementById('levelValue');
      const linesValueEl = document.getElementById('linesValue');
      const speedValueEl = document.getElementById('speedValue');

      function createBoard() {
        const grid = [];
        for (let y = 0; y < ROWS; y++) {
          const row = new Array(COLS).fill(0);
          grid.push(row);
        }
        return grid;
      }

      function resetGame() {
        board = createBoard();
        score = 0;
        level = 1;
        linesCleared = 0;
        dropInterval = 1000;
        speedMultiplier = 1;
        gameOver = false;
        gameStarted = true;
        nextRandomType = null;
        spawnPiece();
        updateScoreboard();
        hideOverlay();
      }

      function randomTetrominoType() {
        if (nextRandomType === null) {
          nextRandomType = TETROMINO_TYPES[Math.floor(Math.random() * TETROMINO_TYPES.length)];
        }
        const type = nextRandomType;
        nextRandomType = TETROMINO_TYPES[Math.floor(Math.random() * TETROMINO_TYPES.length)];
        return type;
      }

      function spawnPiece() {
        const type = randomTetrominoType();
        const piece = {
          type,
          rotation: 0,
          x: 3,  // spawn near center
          y: 0
        };
        if (!isValidPosition(piece, 0, 0, piece.rotation)) {
          triggerGameOver();
        } else {
          currentPiece = piece;
        }
      }

      function getCells(piece, offsetX = 0, offsetY = 0, rotation = piece.rotation) {
        const shape = SHAPES[piece.type][rotation];
        return shape.map(([x, y]) => ({
          x: piece.x + x + offsetX,
          y: piece.y + y + offsetY
        }));
      }

      function isValidPosition(piece, offsetX, offsetY, rotation) {
        const cells = getCells(piece, offsetX, offsetY, rotation);
        for (const cell of cells) {
          if (cell.x < 0 || cell.x >= COLS || cell.y >= ROWS) {
            return false;
          }
          if (cell.y >= 0 && board[cell.y][cell.x]) {
            return false;
          }
        }
        return true;
      }

      function mergePiece() {
        const cells = getCells(currentPiece);
        for (const cell of cells) {
          if (cell.y >= 0 && cell.y < ROWS) {
            board[cell.y][cell.x] = currentPiece.type;
          }
        }
      }

      function clearLines() {
        let lines = 0;
        outer: for (let y = ROWS - 1; y >= 0; ) {
          for (let x = 0; x < COLS; x++) {
            if (!board[y][x]) {
              y--;
              continue outer;
            }
          }
          // full line
          board.splice(y, 1);
          board.unshift(new Array(COLS).fill(0));
          lines++;
        }
        if (lines > 0) {
          const lineScores = [0, 100, 300, 500, 800];
          score += lineScores[lines] * level;
          linesCleared += lines;
          const newLevel = Math.floor(linesCleared / 10) + 1;
          if (newLevel > level) {
            level = newLevel;
            dropInterval = Math.max(120, 1000 - (level - 1) * 80);
            speedMultiplier = (1000 / dropInterval).toFixed(1);
          }
          updateScoreboard();
        }
      }

      function movePiece(dx, dy) {
        if (!currentPiece || gameOver) return false;
        if (isValidPosition(currentPiece, dx, dy, currentPiece.rotation)) {
          currentPiece.x += dx;
          currentPiece.y += dy;
          return true;
        }
        return false;
      }

      function rotatePiece() {
        if (!currentPiece || currentPiece.type === 'O') return;
        const nextRotation = (currentPiece.rotation + 1) % 4;
        if (isValidPosition(currentPiece, 0, 0, nextRotation)) {
          currentPiece.rotation = nextRotation;
        } else {
          // basic wall kicks: try shifting left or right
          const offsets = [-1, 1, -2, 2];
          for (const offset of offsets) {
            if (isValidPosition(currentPiece, offset, 0, nextRotation)) {
              currentPiece.x += offset;
              currentPiece.rotation = nextRotation;
              break;
            }
          }
        }
      }

      function softDrop() {
        if (!currentPiece || gameOver) return;
        if (movePiece(0, 1)) {
          score += 1; // small reward for soft drop
          updateScoreboard();
        } else {
          lockPiece();
        }
      }

      function hardDrop() {
        if (!currentPiece || gameOver) return;
        let dropped = 0;
        while (movePiece(0, 1)) {
          dropped++;
        }
        score += dropped * 2; // reward hard drop
        updateScoreboard();
        lockPiece();
      }

      function lockPiece() {
        mergePiece();
        clearLines();
        spawnPiece();
      }

      function triggerGameOver() {
        gameOver = true;
        showOverlay();
      }

      function update(time = 0) {
        const delta = time - lastTime;
        lastTime = time;

        if (gameStarted && !gameOver) {
          dropCounter += delta;
          if (dropCounter > dropInterval) {
            dropCounter = 0;
            if (!movePiece(0, 1)) {
              lockPiece();
            }
          }
        }

        draw();
        requestAnimationFrame(update);
      }

      function drawBackground() {
        const g = ctx.createLinearGradient(0, 0, 0, BOARD_HEIGHT);
        g.addColorStop(0, '#020617');
        g.addColorStop(1, '#020617');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, BOARD_WIDTH, BOARD_HEIGHT);

        // grid
        ctx.strokeStyle = 'rgba(15,23,42,0.9)';
        ctx.lineWidth = 1;
        for (let x = 0; x <= COLS; x++) {
          ctx.beginPath();
          ctx.moveTo(x * BLOCK_SIZE + 0.5, 0);
          ctx.lineTo(x * BLOCK_SIZE + 0.5, BOARD_HEIGHT);
          ctx.stroke();
        }
        for (let y = 0; y <= ROWS; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y * BLOCK_SIZE + 0.5);
          ctx.lineTo(BOARD_WIDTH, y * BLOCK_SIZE + 0.5);
          ctx.stroke();
        }
      }

      function drawCell(x, y, color) {
        const px = x * BLOCK_SIZE;
        const py = y * BLOCK_SIZE;

        const base = color;
        const darker = shadeColor(color, -0.4);
        const lighter = shadeColor(color, 0.4);

        const grad = ctx.createLinearGradient(px, py, px, py + BLOCK_SIZE);
        grad.addColorStop(0, lighter);
        grad.addColorStop(0.4, base);
        grad.addColorStop(1, darker);

        ctx.fillStyle = grad;
        const r = 6;
        roundRect(ctx, px + 2, py + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4, r, true, false);

        ctx.strokeStyle = 'rgba(15,23,42,0.8)';
        ctx.lineWidth = 1;
        roundRect(ctx, px + 2, py + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4, r, false, true);

        // inner highlight
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 1;
        roundRect(ctx, px + 5, py + 5, BLOCK_SIZE - 10, BLOCK_SIZE - 10, 4, false, true);
      }

      function draw() {
        drawBackground();

        // Draw fixed blocks
        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            const cell = board[y][x];
            if (cell) {
              drawCell(x, y, COLORS[cell]);
            }
          }
        }

        // Draw current piece
        if (currentPiece && !gameOver) {
          const cells = getCells(currentPiece);
          const color = COLORS[currentPiece.type];
          for (const cell of cells) {
            if (cell.y >= 0) {
              drawCell(cell.x, cell.y, color);
            }
          }
        }
      }

      function updateScoreboard() {
        scoreValueEl.textContent = score;
        levelValueEl.textContent = level;
        linesValueEl.textContent = linesCleared;
        speedValueEl.textContent = speedMultiplier + 'x';
      }

      function showOverlay() {
        overlayTitle.textContent = gameOver ? 'Game Over' : 'TETRIS';
        overlayMsg.textContent = gameOver
          ? 'Press Space or click the button to restart'
          : 'Press Space to start';
        overlayScore.textContent = gameOver ? `Final Score: ${score}` : '';
        overlay.classList.add('visible');
      }

      function hideOverlay() {
        overlay.classList.remove('visible');
      }

      function handleKeyDown(e) {
        const key = e.code;

        if (['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp', 'Space'].includes(key)) {
          e.preventDefault();
        }

        if (!gameStarted) {
          if (key === 'Space') {
            resetGame();
          }
          return;
        }

        if (gameOver) {
          if (key === 'Space' || key === 'KeyR') {
            resetGame();
          }
          return;
        }

        switch (key) {
          case 'ArrowLeft':
            movePiece(-1, 0);
            break;
          case 'ArrowRight':
            movePiece(1, 0);
            break;
          case 'ArrowDown':
            softDrop();
            break;
          case 'ArrowUp':
            rotatePiece();
            break;
          case 'Space':
            hardDrop();
            break;
          case 'KeyR':
            resetGame();
            break;
        }
      }

      function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
        if (typeof radius === 'number') {
          radius = { tl: radius, tr: radius, br: radius, bl: radius };
        } else {
          const defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
          for (let side in defaultRadius) {
            radius[side] = radius[side] || defaultRadius[side];
          }
        }
        ctx.beginPath();
        ctx.moveTo(x + radius.tl, y);
        ctx.lineTo(x + width - radius.tr, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
        ctx.lineTo(x + width, y + height - radius.br);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
        ctx.lineTo(x + radius.bl, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
        ctx.lineTo(x, y + radius.tl);
        ctx.quadraticCurveTo(x, y, x + radius.tl, y);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
      }

      function shadeColor(color, percent) {
        // color: "#rrggbb"
        const f = parseInt(color.slice(1), 16);
        const t = percent < 0 ? 0 : 255;
        const p = Math.abs(percent);
        const R = f >> 16;
        const G = (f >> 8) & 0x00ff;
        const B = f & 0x0000ff;
        const newR = Math.round((t - R) * p) + R;
        const newG = Math.round((t - G) * p) + G;
        const newB = Math.round((t - B) * p) + B;
        return (
          '#' +
          (0x1000000 + (newR << 16) + (newG << 8) + newB)
            .toString(16)
            .slice(1)
        );
      }

      // Event listeners
      document.addEventListener('keydown', handleKeyDown);
      restartBtn.addEventListener('click', () => {
        if (!gameStarted || gameOver) resetGame();
      });

      // Initial state
      board = createBoard();
      showOverlay();
      updateScoreboard();
      requestAnimationFrame(update);
    })();
  </script>
</body>
</html>