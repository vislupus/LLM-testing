<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Ray Tracing Simulation (PBR)</title>
    <!-- Babylon.js Core -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
        }

        /* Floating Control Panel */
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(20, 20, 25, 0.85);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            z-index: 10;
        }

        h2 { margin-top: 0; font-size: 1.2rem; font-weight: 300; letter-spacing: 1px; color: #00bcd4; }
        
        .control-group { margin-bottom: 15px; }
        
        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            margin-bottom: 5px;
            color: #ccc;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
            accent-color: #00bcd4;
        }

        .value-display { font-family: monospace; color: #00bcd4; }

        .sphere-select {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .sphere-btn {
            flex: 1;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.1);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: 0.2s;
        }
        
        .sphere-btn.active { background: #00bcd4; color: #000; font-weight: bold; }

        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            pointer-events: none;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="loading">Loading Environment...</div>

    <canvas id="renderCanvas"></canvas>

    <div id="controls">
        <h2>Material Properties</h2>
        
        <div class="sphere-select">
            <button class="sphere-btn active" id="btn1" onclick="selectSphere(1)">Sphere 1</button>
            <button class="sphere-btn" id="btn2" onclick="selectSphere(2)">Sphere 2</button>
        </div>

        <div class="control-group">
            <label>Roughness <span id="valRough" class="value-display">0.1</span></label>
            <input type="range" id="slRough" min="0" max="1" step="0.01" value="0.1">
        </div>

        <div class="control-group">
            <label>Metallic <span id="valMetal" class="value-display">1.0</span></label>
            <input type="range" id="slMetal" min="0" max="1" step="0.01" value="1.0">
        </div>

        <div class="control-group">
            <label>Reflectivity (F0) <span id="valRefl" class="value-display">0.9</span></label>
            <input type="range" id="slRefl" min="0" max="1" step="0.01" value="0.9">
        </div>
        
        <div class="control-group">
            <label>Environment Intensity <span id="valEnv" class="value-display">1.0</span></label>
            <input type="range" id="slEnv" min="0" max="5" step="0.1" value="1.0">
        </div>

        <div style="font-size: 0.8rem; color: #888; margin-top: 10px; line-height: 1.4;">
            <strong>Environment:</strong> Royal Esplanade (HDR)<br>
            <strong>Technique:</strong> PBR with IBL (Simulated Ray Tracing)
        </div>
    </div>

<script>
    // --- SETUP ---
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);
    
    // Global Material References
    let mat1, mat2;
    let activeMaterial = 1;
    let envTexture;

    // --- SCENE CREATION ---
    const createScene = function () {
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);

        // 1. Camera
        const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 8, new BABYLON.Vector3(0, 0, 0), scene);
        camera.attachControl(canvas, true);
        camera.wheelPrecision = 50;
        camera.lowerRadiusLimit = 4;
        camera.upperRadiusLimit = 20;

        // 2. Lighting (Simulated via HDRI, but added for shadow casting if needed)
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
        light.intensity = 0.5;
        light.groundColor = new BABYLON.Color3(0.1, 0.1, 0.1);

        const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
        dirLight.position = new BABYLON.Vector3(20, 40, 20);
        dirLight.intensity = 1.5;
        
        // Shadows (Optional, adds realism)
        const shadowGenerator = new BABYLON.ShadowGenerator(1024, dirLight);
        shadowGenerator.useBlurExponentialShadowMap = true;
        shadowGenerator.blurKernel = 32;

        // 3. Environment (Street Scene)
        // Using Poly Haven "Royal Esplanade" for a realistic street look
        // Note: If this fails to load (CORS), we fallback to a generated environment.
        const envUrl = "https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/2k/royal_esplanade_2k.hdr";
        
        envTexture = new BABYLON.HDRCubeTexture(envUrl, scene, 512, false, false, false, true);
        
        // Fallback in case of loading error (for robustness)
        envTexture.onLoadObservable.add(() => {
            document.getElementById("loading").style.opacity = 0;
        });
        envTexture.onErrorObservable.add(() => {
            console.warn("HDRI failed to load, using default environment.");
            scene.createDefaultEnvironment();
            document.getElementById("loading").style.opacity = 0;
        });

        // Apply environment to scene
        scene.environmentTexture = envTexture;
        // Create a skybox to match the environment (makes spheres look grounded in the world)
        scene.createDefaultSkybox(envTexture, true, 1000);

        // 4. Post-Processing (Make it look like Ray Tracing)
        const pipeline = new BABYLON.DefaultRenderingPipeline("pipeline", true, scene, [camera]);
        pipeline.glowLayerEnabled = true;
        pipeline.glowLayer.intensity = 0.5;
        pipeline.samples = 4; // Anti-aliasing
        pipeline.fxaaEnabled = true;
        pipeline.chromaticAberrationEnabled = true;
        pipeline.chromaticAberration.aberrationAmount = 10;

        // 5. Objects (Spheres)
        // Sphere 1 (Left)
        const sphere1 = BABYLON.MeshBuilder.CreateSphere("sphere1", {diameter: 2, segments: 64}, scene);
        sphere1.position.x = -1.5;
        sphere1.receiveShadows = true;

        // Sphere 2 (Right)
        const sphere2 = BABYLON.MeshBuilder.CreateSphere("sphere2", {diameter: 2, segments: 64}, scene);
        sphere2.position.x = 1.5;
        sphere2.receiveShadows = true;

        // Ground (Invisible shadow catcher)
        const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 20, height: 20}, scene);
        ground.position.y = -1.5;
        ground.receiveShadows = true;
        ground.isVisible = false; // Hide the mesh, but show shadows? 
        // Babylon shadow catchers usually need the material to be configured. 
        // For this specific request, we want them "suspended". Let's remove the ground 
        // and just rely on the Skybox for the street feel.
        ground.dispose(); 

        // 6. Materials (PBR - Physically Based Rendering)
        
        // Material 1: Chrome-like
        mat1 = new BABYLON.PBRMaterial("mat1", scene);
        mat1.albedoColor = new BABYLON.Color3(1, 1, 1);
        mat1.metallic = 1.0;
        mat1.roughness = 0.1;
        mat1.reflectivityColor = new BABYLON.Color3(1, 1, 1); // High F0
        mat1.environmentIntensity = 1.0;
        sphere1.material = mat1;
        shadowGenerator.addShadowCaster(sphere1);

        // Material 2: Gold-like
        mat2 = new BABYLON.PBRMaterial("mat2", scene);
        mat2.albedoColor = new BABYLON.Color3(1, 0.86, 0.57); // Gold
        mat2.metallic = 1.0;
        mat2.roughness = 0.3; // Slightly brushed
        mat2.reflectivityColor = new BABYLON.Color3(1, 0.76, 0.33);
        mat2.environmentIntensity = 1.0;
        sphere2.material = mat2;
        shadowGenerator.addShadowCaster(sphere2);

        // 7. Animation
        let alpha = 0;
        scene.registerBeforeRender(() => {
            alpha += 0.01;
            
            // Float effect
            sphere1.position.y = Math.sin(alpha) * 0.2;
            sphere2.position.y = Math.sin(alpha + Math.PI) * 0.2;

            // Rotation (to show reflections moving)
            sphere1.rotation.y += 0.005;
            sphere2.rotation.y -= 0.005;
        });

        return scene;
    };

    const scene = createScene();

    engine.runRenderLoop(function () {
        scene.render();
    });

    window.addEventListener("resize", function () {
        engine.resize();
    });

    // --- UI LOGIC ---
    
    function selectSphere(id) {
        activeMaterial = id;
        document.getElementById("btn1").classList.toggle("active", id === 1);
        document.getElementById("btn2").classList.toggle("active", id === 2);
        updateSliders();
    }

    function updateSliders() {
        const mat = (activeMaterial === 1) ? mat1 : mat2;
        document.getElementById("slRough").value = mat.roughness;
        document.getElementById("slMetal").value = mat.metallic;
        document.getElementById("slRefl").value = mat.reflectivityColor.r; // Simplified
        document.getElementById("slEnv").value = mat.environmentIntensity;

        document.getElementById("valRough").innerText = mat.roughness.toFixed(2);
        document.getElementById("valMetal").innerText = mat.metallic.toFixed(2);
        document.getElementById("valRefl").innerText = mat.reflectivityColor.r.toFixed(2);
        document.getElementById("valEnv").innerText = mat.environmentIntensity.toFixed(2);
    }

    // Event Listeners for Sliders
    document.getElementById("slRough").addEventListener("input", (e) => {
        const val = parseFloat(e.target.value);
        const mat = (activeMaterial === 1) ? mat1 : mat2;
        mat.roughness = val;
        document.getElementById("valRough").innerText = val.toFixed(2);
    });

    document.getElementById("slMetal").addEventListener("input", (e) => {
        const val = parseFloat(e.target.value);
        const mat = (activeMaterial === 1) ? mat1 : mat2;
        mat.metallic = val;
        document.getElementById("valMetal").innerText = val.toFixed(2);
    });

    document.getElementById("slRefl").addEventListener("input", (e) => {
        const val = parseFloat(e.target.value);
        const mat = (activeMaterial === 1) ? mat1 : mat2;
        // Update all channels of reflectivity color (simple metallic tint)
        mat.reflectivityColor = new BABYLON.Color3(val, val, val);
        document.getElementById("valRefl").innerText = val.toFixed(2);
    });

    document.getElementById("slEnv").addEventListener("input", (e) => {
        const val = parseFloat(e.target.value);
        const mat = (activeMaterial === 1) ? mat1 : mat2;
        mat.environmentIntensity = val;
        document.getElementById("valEnv").innerText = val.toFixed(2);
    });

    // Initialize sliders
    updateSliders();

</script>
</body>
</html>