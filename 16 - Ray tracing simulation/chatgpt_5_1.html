<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Babylon.js Real‑Time Ray Tracing Style Reflection Demo</title>
    <!-- Babylon.js core + loaders from CDN -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            margin: 0;
            padding: 0;
            background: #000;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            display: block;
        }
        /* Simple UI overlay */
        #ui {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 260px;
            background: rgba(15, 15, 24, 0.9);
            color: #f3f4f6;
            padding: 12px 14px 10px;
            border-radius: 8px;
            border: 1px solid rgba(148, 163, 184, 0.6);
            font-size: 12px;
            backdrop-filter: blur(8px);
        }
        #ui h2 {
            font-size: 14px;
            margin: 0 0 6px;
            text-align: center;
        }
        #ui small {
            display: block;
            text-align: center;
            color: #9ca3af;
            margin-bottom: 8px;
        }
        .ui-row {
            margin: 6px 0;
        }
        .ui-row label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2px;
        }
        .ui-row span.value {
            color: #a5b4fc;
            font-variant-numeric: tabular-nums;
            margin-left: 6px;
        }
        .ui-row input[type="range"] {
            width: 100%;
        }
        select, option {
            background: #020617;
            color: #e5e7eb;
        }
        select {
            width: 100%;
            padding: 2px 4px;
            border-radius: 4px;
            border: 1px solid #4b5563;
            font-size: 12px;
        }
        .hint {
            font-size: 11px;
            color: #9ca3af;
            margin-top: 6px;
            line-height: 1.3;
        }
    </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<div id="ui">
    <h2>Metal Spheres</h2>
    <small>Real‑time PBR reflections in a street scene</small>

    <div class="ui-row">
        <label>
            Sphere:
            <select id="sphereSelect">
                <option value="0">Sphere 1 (left)</option>
                <option value="1">Sphere 2 (right)</option>
            </select>
        </label>
    </div>

    <div class="ui-row">
        <label>Metallic
            <span class="value" id="metallicVal">1.00</span>
        </label>
        <input id="metallic" type="range" min="0" max="1" step="0.01" value="1">
    </div>

    <div class="ui-row">
        <label>Roughness
            <span class="value" id="roughnessVal">0.20</span>
        </label>
        <input id="roughness" type="range" min="0" max="1" step="0.01" value="0.2">
    </div>

    <div class="ui-row">
        <label>Reflection Intensity
            <span class="value" id="envIntVal">1.20</span>
        </label>
        <input id="envIntensity" type="range" min="0" max="2" step="0.01" value="1.2">
    </div>

    <div class="ui-row">
        <label>Base Tint
            <span class="value" id="tintVal">0.95</span>
        </label>
        <input id="tint" type="range" min="0.2" max="1" step="0.01" value="0.95">
    </div>

    <div class="ui-row">
        <label>Clear Coat
            <span class="value" id="coatVal">0.30</span>
        </label>
        <input id="clearCoat" type="range" min="0" max="1" step="0.01" value="0.3">
    </div>

    <div class="hint">
        • Drag with mouse / touch to orbit the camera.<br>
        • Scroll to zoom.<br>
        • Sliders update the selected sphere's PBR material in real time.
    </div>
</div>

<script>
    window.addEventListener("DOMContentLoaded", function () {
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

        let scene = createScene();
        engine.runRenderLoop(function () {
            if (scene) {
                scene.render();
            }
        });
        window.addEventListener("resize", function () {
            engine.resize();
        });

        function createScene() {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.02, 0.02, 0.03, 1);

            // High quality environment for reflections (IBL)
            const envTex = BABYLON.CubeTexture.CreateFromPrefilteredData(
                "https://playground.babylonjs.com/textures/environment.env",
                scene
            );
            scene.environmentTexture = envTex;
            scene.environmentIntensity = 1.0;

            // Camera
            const camera = new BABYLON.ArcRotateCamera(
                "camera",
                -Math.PI / 2.5,
                Math.PI / 3,
                45,
                new BABYLON.Vector3(0, 6, 0),
                scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 15;
            camera.upperRadiusLimit = 80;
            camera.wheelDeltaPercentage = 0.02;
            camera.panningSensibility = 0; // disable panning for simplicity

            // Lights
            const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0.2, 1, 0.3), scene);
            hemi.intensity = 0.8;
            const dir = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-0.6, -1, -0.3), scene);
            dir.position = new BABYLON.Vector3(20, 40, 20);
            dir.intensity = 0.9;

            // Load a publicly available 3D "street" style environment (Babylon's village scene)
            // (This is a small town / street environment from Babylon assets.)
            BABYLON.SceneLoader.Append(
                "https://assets.babylonjs.com/meshes/",
                "village.glb",
                scene,
                function () {
                    // Slightly dim the environment geometry to make spheres stand out
                    scene.meshes.forEach(m => {
                        if (m.name && m.name.toLowerCase().indexOf("village") === -1 && m.material && m.material.diffuseColor) {
                            m.material.diffuseColor = m.material.diffuseColor.scale(0.9);
                        }
                    });
                }
            );

            // Ground helper (almost invisible, only to catch shadows if desired)
            const ground = BABYLON.MeshBuilder.CreateGround("groundPlane", { width: 120, height: 120 }, scene);
            ground.position.y = 0.01;
            const gMat = new BABYLON.StandardMaterial("gMat", scene);
            gMat.diffuseColor = new BABYLON.Color3(0, 0, 0);
            gMat.specularColor = new BABYLON.Color3(0, 0, 0);
            gMat.alpha = 0;
            ground.material = gMat;
            ground.receiveShadows = true;

            // Spheres (metallic) suspended above the street
            const spheres = [];
            const sphereMaterials = [];

            const createMetalSphere = (name, position) => {
                const s = BABYLON.MeshBuilder.CreateSphere(name, {
                    diameter: 5,
                    segments: 64
                }, scene);
                s.position.copyFrom(position);

                const m = new BABYLON.PBRMaterial(name + "Mat", scene);
                m.metallic = 1;
                m.roughness = 0.2;
                m.albedoColor = new BABYLON.Color3(0.95, 0.95, 0.96);
                m.reflectivityColor = new BABYLON.Color3(1, 1, 1);
                m.environmentIntensity = 1.2;
                m.clearCoat.isEnabled = true;
                m.clearCoat.intensity = 0.3;
                m.indexOfRefraction = 1.5;
                s.material = m;

                spheres.push(s);
                sphereMaterials.push(m);
            };

            createMetalSphere("sphere1", new BABYLON.Vector3(-6, 9, 0));
            createMetalSphere("sphere2", new BABYLON.Vector3( 6, 9, 0));

            // Soft orbiting motion for nice parallax
            scene.onBeforeRenderObservable.add(() => {
                const t = performance.now() * 0.00015;
                spheres[0].position.y = 9 + Math.sin(t * 3) * 0.5;
                spheres[1].position.y = 9 + Math.cos(t * 3) * 0.5;
            });

            // Hook up UI
            setupUI(sphereMaterials);

            return scene;
        }

        function setupUI(materials) {
            let currentIndex = 0;
            let currentMat = materials[currentIndex];

            const $ = id => document.getElementById(id);

            const sphereSelect = $("sphereSelect");
            const metallicSlider = $("metallic");
            const roughnessSlider = $("roughness");
            const envIntensitySlider = $("envIntensity");
            const tintSlider = $("tint");
            const clearCoatSlider = $("clearCoat");

            const metallicVal = $("metallicVal");
            const roughnessVal = $("roughnessVal");
            const envIntVal = $("envIntVal");
            const tintVal = $("tintVal");
            const coatVal = $("coatVal");

            function updateFromMaterial() {
                if (!currentMat) return;
                metallicSlider.value = currentMat.metallic.toFixed(2);
                roughnessSlider.value = currentMat.roughness.toFixed(2);
                envIntensitySlider.value = currentMat.environmentIntensity.toFixed(2);
                tintSlider.value = currentMat.albedoColor.r.toFixed(2);
                clearCoatSlider.value = currentMat.clearCoat.isEnabled ? currentMat.clearCoat.intensity.toFixed(2) : 0;

                metallicVal.textContent = (+metallicSlider.value).toFixed(2);
                roughnessVal.textContent = (+roughnessSlider.value).toFixed(2);
                envIntVal.textContent = (+envIntensitySlider.value).toFixed(2);
                tintVal.textContent = (+tintSlider.value).toFixed(2);
                coatVal.textContent = (+clearCoatSlider.value).toFixed(2);
            }

            sphereSelect.addEventListener("change", () => {
                currentIndex = parseInt(sphereSelect.value, 10) || 0;
                currentMat = materials[currentIndex];
                updateFromMaterial();
            });

            metallicSlider.addEventListener("input", e => {
                const v = parseFloat(e.target.value);
                if (!isNaN(v) && currentMat) {
                    currentMat.metallic = v;
                    metallicVal.textContent = v.toFixed(2);
                }
            });

            roughnessSlider.addEventListener("input", e => {
                const v = parseFloat(e.target.value);
                if (!isNaN(v) && currentMat) {
                    currentMat.roughness = v;
                    roughnessVal.textContent = v.toFixed(2);
                }
            });

            envIntensitySlider.addEventListener("input", e => {
                const v = parseFloat(e.target.value);
                if (!isNaN(v) && currentMat) {
                    currentMat.environmentIntensity = v;
                    envIntVal.textContent = v.toFixed(2);
                }
            });

            tintSlider.addEventListener("input", e => {
                const v = parseFloat(e.target.value);
                if (!isNaN(v) && currentMat) {
                    currentMat.albedoColor = new BABYLON.Color3(v, v, v);
                    tintVal.textContent = v.toFixed(2);
                }
            });

            clearCoatSlider.addEventListener("input", e => {
                const v = parseFloat(e.target.value);
                if (!isNaN(v) && currentMat) {
                    currentMat.clearCoat.isEnabled = v > 0.001;
                    currentMat.clearCoat.intensity = v;
                    coatVal.textContent = v.toFixed(2);
                }
            });

            // Initialize from default material values
            updateFromMaterial();
        }
    });
</script>
</body>
</html>