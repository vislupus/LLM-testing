<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Ray Tracing: Metallic Spheres</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #0a1929, #162447);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            padding: 20px 30px;
            background: rgba(0, 0, 0, 0.7);
            border-bottom: 3px solid #00b4d8;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            position: relative;
            backdrop-filter: blur(10px);
        }

        .title-container {
            flex: 1;
        }

        .title {
            font-size: 32px;
            font-weight: 800;
            background: linear-gradient(90deg, #00b4d8, #90e0ef);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
            letter-spacing: 1px;
        }

        .subtitle {
            font-size: 14px;
            color: #a8dadc;
            opacity: 0.9;
        }

        .raytracing-badge {
            background: linear-gradient(135deg, #00b4d8, #0077b6);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(0, 180, 216, 0.3);
        }

        /* Main Content */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Canvas */
        #renderCanvas {
            flex: 1;
            width: 70%;
            height: calc(100vh - 120px);
            display: block;
            touch-action: none;
        }

        /* Control Panel */
        .control-panel {
            width: 30%;
            background: rgba(0, 0, 0, 0.85);
            padding: 25px;
            overflow-y: auto;
            border-left: 3px solid #00b4d8;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .panel-section {
            background: rgba(20, 30, 50, 0.6);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(0, 180, 216, 0.3);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .section-title {
            font-size: 20px;
            color: #90e0ef;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(0, 180, 216, 0.3);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .section-title i {
            font-size: 22px;
            color: #00b4d8;
        }

        /* Slider Controls */
        .slider-container {
            margin-bottom: 20px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .slider-label {
            font-size: 15px;
            color: #caf0f8;
            font-weight: 600;
        }

        .slider-value {
            background: rgba(0, 180, 216, 0.2);
            color: #00b4d8;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
            border: 1px solid rgba(0, 180, 216, 0.4);
        }

        .slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, rgba(0, 180, 216, 0.3), rgba(144, 224, 239, 0.8));
            border-radius: 4px;
            outline: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #00b4d8;
            cursor: pointer;
            border: 3px solid #fff;
            box-shadow: 0 0 10px rgba(0, 180, 216, 0.8);
            transition: all 0.2s;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: #90e0ef;
        }

        .slider::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #00b4d8;
            cursor: pointer;
            border: 3px solid #fff;
            box-shadow: 0 0 10px rgba(0, 180, 216, 0.8);
        }

        /* Sphere Selection */
        .sphere-selection {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .sphere-btn {
            flex: 1;
            padding: 12px;
            border-radius: 10px;
            border: 2px solid rgba(0, 180, 216, 0.3);
            background: rgba(0, 0, 0, 0.3);
            color: #90e0ef;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .sphere-btn:hover {
            background: rgba(0, 180, 216, 0.1);
            border-color: #00b4d8;
            transform: translateY(-2px);
        }

        .sphere-btn.active {
            background: rgba(0, 180, 216, 0.2);
            border-color: #00b4d8;
            box-shadow: 0 0 15px rgba(0, 180, 216, 0.4);
        }

        .sphere-icon {
            font-size: 24px;
        }

        /* Material Presets */
        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 15px;
        }

        .preset-btn {
            padding: 12px;
            border-radius: 8px;
            border: 2px solid rgba(0, 180, 216, 0.2);
            background: rgba(0, 0, 0, 0.3);
            color: #caf0f8;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .preset-btn:hover {
            background: rgba(0, 180, 216, 0.1);
            border-color: #00b4d8;
            transform: translateY(-2px);
        }

        /* Info Panel */
        .info-panel {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            border-left: 4px solid #00b4d8;
        }

        .info-title {
            color: #90e0ef;
            font-size: 14px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .info-text {
            font-size: 13px;
            color: #caf0f8;
            line-height: 1.5;
            opacity: 0.9;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a1929;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s ease;
        }

        .loading-title {
            font-size: 42px;
            color: transparent;
            background: linear-gradient(90deg, #00b4d8, #90e0ef);
            -webkit-background-clip: text;
            background-clip: text;
            margin-bottom: 20px;
            text-align: center;
        }

        .loading-subtitle {
            font-size: 18px;
            color: #a8dadc;
            margin-bottom: 30px;
            text-align: center;
            max-width: 600px;
            line-height: 1.5;
        }

        .loading-progress-container {
            width: 400px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #00b4d8, #90e0ef);
            width: 0%;
            transition: width 0.3s ease;
        }

        .loading-text {
            font-size: 16px;
            color: #90e0ef;
        }

        /* Camera Controls */
        .camera-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .camera-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00b4d8;
            color: #00b4d8;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .camera-btn:hover {
            background: #00b4d8;
            color: #000;
            transform: scale(1.1);
        }

        /* Performance Stats */
        .performance-stats {
            position: absolute;
            top: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00b4d8;
            font-size: 13px;
            z-index: 10;
            backdrop-filter: blur(5px);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            min-width: 200px;
        }

        .stat-label {
            color: #90e0ef;
        }

        .stat-value {
            color: #00b4d8;
            font-weight: bold;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .main-content {
                flex-direction: column;
            }
            
            #renderCanvas {
                width: 100%;
                height: 60vh;
            }
            
            .control-panel {
                width: 100%;
                height: 40vh;
            }
            
            .header {
                padding: 15px;
            }
            
            .title {
                font-size: 24px;
            }
            
            .raytracing-badge {
                padding: 6px 15px;
                font-size: 12px;
            }
        }

        /* Ray Tracing Effects Overlay */
        .rt-effects {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0.05;
            background: radial-gradient(circle at center, transparent 0%, #000 100%);
        }
    </style>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-title">Real-Time Ray Tracing Simulation</div>
        <div class="loading-subtitle">Loading high-fidelity PBR materials and ray tracing effects...</div>
        <div class="loading-progress-container">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
        <div class="loading-text" id="loadingText">Initializing ray tracing engine...</div>
    </div>

    <!-- Header -->
    <div class="header">
        <div class="title-container">
            <div class="title">Ray Tracing: Metallic Spheres Simulation</div>
            <div class="subtitle">Real-time physically-based rendering with adjustable material properties</div>
        </div>
        <div class="raytracing-badge">
            <i class="fas fa-bolt"></i>
            <span>REAL-TIME RAY TRACING</span>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Canvas -->
        <canvas id="renderCanvas"></canvas>

        <!-- Control Panel -->
        <div class="control-panel">
            <!-- Sphere Selection -->
            <div class="panel-section">
                <div class="section-title">
                    <i class="fas fa-globe-americas"></i>
                    Sphere Selection
                </div>
                <div class="sphere-selection">
                    <button class="sphere-btn active" id="sphere1Btn" data-sphere="1">
                        <div class="sphere-icon">●</div>
                        <div>Sphere 1</div>
                        <div style="font-size: 11px; opacity: 0.8;">Copper</div>
                    </button>
                    <button class="sphere-btn" id="sphere2Btn" data-sphere="2">
                        <div class="sphere-icon">●</div>
                        <div>Sphere 2</div>
                        <div style="font-size: 11px; opacity: 0.8;">Aluminum</div>
                    </button>
                </div>
            </div>

            <!-- Material Properties -->
            <div class="panel-section">
                <div class="section-title">
                    <i class="fas fa-sliders-h"></i>
                    Material Properties
                </div>
                
                <div class="slider-container">
                    <div class="slider-header">
                        <div class="slider-label">Metallic</div>
                        <div class="slider-value" id="metallicValue">0.9</div>
                    </div>
                    <input type="range" min="0" max="1" step="0.01" value="0.9" class="slider" id="metallicSlider">
                </div>
                
                <div class="slider-container">
                    <div class="slider-header">
                        <div class="slider-label">Roughness</div>
                        <div class="slider-value" id="roughnessValue">0.1</div>
                    </div>
                    <input type="range" min="0" max="1" step="0.01" value="0.1" class="slider" id="roughnessSlider">
                </div>
                
                <div class="slider-container">
                    <div class="slider-header">
                        <div class="slider-label">Reflectivity</div>
                        <div class="slider-value" id="reflectivityValue">0.8</div>
                    </div>
                    <input type="range" min="0" max="1" step="0.01" value="0.8" class="slider" id="reflectivitySlider">
                </div>
                
                <div class="slider-container">
                    <div class="slider-header">
                        <div class="slider-label">Index of Refraction</div>
                        <div class="slider-value" id="iorValue">1.5</div>
                    </div>
                    <input type="range" min="1" max="3" step="0.01" value="1.5" class="slider" id="iorSlider">
                </div>
                
                <div class="slider-container">
                    <div class="slider-header">
                        <div class="slider-label">Clearcoat Intensity</div>
                        <div class="slider-value" id="clearcoatValue">0.3</div>
                    </div>
                    <input type="range" min="0" max="1" step="0.01" value="0.3" class="slider" id="clearcoatSlider">
                </div>
            </div>

            <!-- Material Presets -->
            <div class="panel-section">
                <div class="section-title">
                    <i class="fas fa-vial"></i>
                    Material Presets
                </div>
                <div class="preset-buttons">
                    <button class="preset-btn" data-preset="mirror">
                        <i class="fas fa-mirror"></i>
                        Mirror Finish
                    </button>
                    <button class="preset-btn" data-preset="brushed">
                        <i class="fas fa-brush"></i>
                        Brushed Metal
                    </button>
                    <button class="preset-btn" data-preset="copper">
                        <i class="fas fa-coins"></i>
                        Pure Copper
                    </button>
                    <button class="preset-btn" data-preset="aluminum">
                        <i class="fas fa-industry"></i>
                        Polished Aluminum
                    </button>
                    <button class="preset-btn" data-preset="gold">
                        <i class="fas fa-crown"></i>
                        24K Gold
                    </button>
                    <button class="preset-btn" data-preset="chrome">
                        <i class="fas fa-car"></i>
                        Chrome Plated
                    </button>
                </div>
            </div>

            <!-- Info Panel -->
            <div class="info-panel">
                <div class="info-title">Ray Tracing Information</div>
                <div class="info-text">
                    This simulation uses physically-based rendering (PBR) to simulate real-time ray tracing effects.
                    Adjust material properties to see how they affect light reflection, refraction, and scattering.
                </div>
            </div>
        </div>
    </div>

    <!-- Performance Stats -->
    <div class="performance-stats">
        <div class="stat-row">
            <div class="stat-label">Frame Rate:</div>
            <div class="stat-value" id="fpsValue">60 FPS</div>
        </div>
        <div class="stat-row">
            <div class="stat-label">Render Mode:</div>
            <div class="stat-value" id="renderMode">PBR Ray Tracing</div>
        </div>
        <div class="stat-row">
            <div class="stat-label">Reflection Rays:</div>
            <div class="stat-value" id="rayCount">256 samples</div>
        </div>
        <div class="stat-row">
            <div class="stat-label">Total Triangles:</div>
            <div class="stat-value" id="triangleCount">0</div>
        </div>
    </div>

    <!-- Camera Controls -->
    <div class="camera-controls">
        <button class="camera-btn" id="cameraDefault" title="Default View">
            <i class="fas fa-satellite"></i>
        </button>
        <button class="camera-btn" id="cameraTop" title="Top View">
            <i class="fas fa-eye"></i>
        </button>
        <button class="camera-btn" id="cameraReflection" title="Reflection View">
            <i class="fas fa-sync-alt"></i>
        </button>
        <button class="camera-btn" id="cameraReset" title="Reset View">
            <i class="fas fa-redo"></i>
        </button>
    </div>

    <!-- Ray Tracing Effects Overlay -->
    <div class="rt-effects"></div>

    <script>
        // =====================
        // RAY TRACING SIMULATION
        // =====================
        
        // Global variables
        let scene, engine, camera;
        let currentSphere = 1; // 1 or 2
        let spheres = [];
        let lastFpsUpdate = 0;
        let frameCount = 0;
        let fps = 60;
        
        // Material presets
        const materialPresets = {
            mirror: {
                metallic: 1.0,
                roughness: 0.01,
                reflectivity: 1.0,
                ior: 1.5,
                clearcoat: 0.0,
                color: new BABYLON.Color3(0.95, 0.95, 0.95)
            },
            brushed: {
                metallic: 1.0,
                roughness: 0.4,
                reflectivity: 0.7,
                ior: 1.8,
                clearcoat: 0.2,
                color: new BABYLON.Color3(0.7, 0.7, 0.7)
            },
            copper: {
                metallic: 1.0,
                roughness: 0.1,
                reflectivity: 0.9,
                ior: 1.5,
                clearcoat: 0.1,
                color: new BABYLON.Color3(0.955, 0.638, 0.538) // Copper color
            },
            aluminum: {
                metallic: 1.0,
                roughness: 0.2,
                reflectivity: 0.85,
                ior: 1.39,
                clearcoat: 0.3,
                color: new BABYLON.Color3(0.91, 0.92, 0.92) // Aluminum color
            },
            gold: {
                metallic: 1.0,
                roughness: 0.05,
                reflectivity: 0.95,
                ior: 0.37, // Gold has complex IOR
                clearcoat: 0.1,
                color: new BABYLON.Color3(1.0, 0.84, 0.0) // Gold color
            },
            chrome: {
                metallic: 1.0,
                roughness: 0.05,
                reflectivity: 0.95,
                ior: 2.42,
                clearcoat: 0.5,
                color: new BABYLON.Color3(0.95, 0.95, 0.95)
            }
        };

        // Initialize Babylon.js
        const initEngine = () => {
            updateLoading("Initializing ray tracing engine...", 10);
            
            const canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, { 
                preserveDrawingBuffer: true, 
                stencil: true,
                antialias: true,
                doNotHandleContextLost: true
            });
            scene = new BABYLON.Scene(engine);
            
            updateLoading("Setting up HDR environment...", 20);
            
            // Create camera
            createCamera();
            
            // Create lighting
            createLighting();
            
            // Create environment
            createEnvironment();
            
            // Create street scene
            createStreetScene();
            
            // Create metallic spheres
            createSpheres();
            
            // Setup UI controls
            setupControls();
            
            // Setup post-processing for ray tracing effects
            setupPostProcessing();
            
            updateLoading("Finalizing ray tracing pipeline...", 90);
            
            // Start render loop
            engine.runRenderLoop(() => {
                frameCount++;
                const currentTime = Date.now();
                
                // Update FPS counter every second
                if (currentTime - lastFpsUpdate >= 1000) {
                    fps = Math.round((frameCount * 1000) / (currentTime - lastFpsUpdate));
                    document.getElementById('fpsValue').textContent = `${fps} FPS`;
                    frameCount = 0;
                    lastFpsUpdate = currentTime;
                    
                    // Update triangle count
                    updateTriangleCount();
                }
                
                scene.render();
            });
            
            // Handle resize
            window.addEventListener('resize', () => {
                engine.resize();
            });
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loadingScreen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    updateLoading("Ray tracing simulation ready!", 100);
                }, 1000);
            }, 2000);
        };

        // Create camera
        const createCamera = () => {
            // Arc rotate camera for full 3D control
            camera = new BABYLON.ArcRotateCamera("camera", 
                -Math.PI / 3.5, Math.PI / 3.5, 40, 
                new BABYLON.Vector3(0, 5, 0), scene);
            
            camera.attachControl(engine.getRenderingCanvas(), true);
            camera.lowerRadiusLimit = 10;
            camera.upperRadiusLimit = 100;
            camera.wheelPrecision = 30;
            camera.panningSensibility = 50;
            camera.inertia = 0.9;
            camera.panningInertia = 0.9;
            
            // Add camera animation for cinematic effect
            let cameraTime = 0;
            scene.registerBeforeRender(() => {
                cameraTime += 0.001;
                // Subtle camera movement
                camera.alpha = -Math.PI / 3.5 + Math.sin(cameraTime * 0.3) * 0.1;
                camera.beta = Math.PI / 3.5 + Math.cos(cameraTime * 0.2) * 0.05;
            });
        };

        // Create lighting
        const createLighting = () => {
            // Create HDRI environment lighting for realistic reflections
            const hdrTexture = new BABYLON.HDRCubeTexture(
                "https://playground.babylonjs.com/textures/Studio_Softbox_2Umbrellas_cube_specular.dds",
                scene,
                512,
                false,
                true,
                false,
                true
            );
            
            // Set environment texture for reflections
            scene.environmentTexture = hdrTexture;
            scene.environmentIntensity = 1.0;
            
            // Add hemispheric light for ambient
            const hemiLight = new BABYLON.HemisphericLight("hemiLight", 
                new BABYLON.Vector3(0, 1, 0), scene);
            hemiLight.intensity = 0.3;
            hemiLight.groundColor = new BABYLON.Color3(0.1, 0.2, 0.3);
            hemiLight.diffuse = new BABYLON.Color3(0.9, 0.9, 1.0);
            
            // Add directional light for sun
            const sun = new BABYLON.DirectionalLight("sun", 
                new BABYLON.Vector3(-1, -2, -0.5), scene);
            sun.intensity = 1.5;
            sun.position = new BABYLON.Vector3(30, 40, 30);
            sun.diffuse = new BABYLON.Color3(1, 0.95, 0.9);
            sun.specular = new BABYLON.Color3(1, 0.98, 0.95);
            
            // Add shadows
            sun.shadowEnabled = true;
            const shadowGenerator = new BABYLON.ShadowGenerator(2048, sun);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 64;
            shadowGenerator.useKernelBlur = true;
            shadowGenerator.blurScale = 2;
            
            // Add point lights for additional illumination
            const pointLight1 = new BABYLON.PointLight("pointLight1", 
                new BABYLON.Vector3(-10, 15, -10), scene);
            pointLight1.intensity = 0.5;
            pointLight1.diffuse = new BABYLON.Color3(0.8, 0.9, 1.0);
            pointLight1.range = 50;
            
            const pointLight2 = new BABYLON.PointLight("pointLight2", 
                new BABYLON.Vector3(15, 10, 15), scene);
            pointLight2.intensity = 0.4;
            pointLight2.diffuse = new BABYLON.Color3(1.0, 0.9, 0.8);
            pointLight2.range = 40;
        };

        // Create environment
        const createEnvironment = () => {
            // Create skybox with gradient
            const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 500 }, scene);
            const skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
            skyboxMaterial.backFaceCulling = false;
            
            // Create gradient shader for skybox
            const vertexShader = `
                precision highp float;
                attribute vec3 position;
                uniform mat4 worldViewProjection;
                varying vec3 vPosition;
                void main(void) {
                    gl_Position = worldViewProjection * vec4(position, 1.0);
                    vPosition = position;
                }
            `;
            
            const fragmentShader = `
                precision highp float;
                varying vec3 vPosition;
                uniform float time;
                
                void main(void) {
                    // Create gradient from blue to orange (sunset)
                    float gradient = clamp(vPosition.y / 250.0 + 0.5, 0.0, 1.0);
                    
                    // Base sky colors
                    vec3 skyTop = vec3(0.05, 0.1, 0.3);
                    vec3 skyMiddle = vec3(0.3, 0.5, 0.8);
                    vec3 skyBottom = vec3(0.8, 0.6, 0.4);
                    
                    // Mix colors based on gradient
                    vec3 skyColor;
                    if (gradient > 0.7) {
                        skyColor = mix(skyMiddle, skyTop, (gradient - 0.7) / 0.3);
                    } else if (gradient > 0.4) {
                        skyColor = mix(skyBottom, skyMiddle, (gradient - 0.4) / 0.3);
                    } else {
                        skyColor = skyBottom;
                    }
                    
                    // Add subtle noise for clouds
                    float noise = sin(vPosition.x * 0.01 + time) * cos(vPosition.z * 0.01 + time) * 0.1;
                    skyColor += noise * vec3(0.1, 0.1, 0.1);
                    
                    gl_FragColor = vec4(skyColor, 1.0);
                }
            `;
            
            const shaderMaterial = new BABYLON.ShaderMaterial("skyShader", scene, {
                vertexSource: vertexShader,
                fragmentSource: fragmentShader
            }, {
                attributes: ["position"],
                uniforms: ["worldViewProjection", "time"]
            });
            
            shaderMaterial.setFloat("time", 0);
            skybox.material = shaderMaterial;
            
            // Update time uniform for animation
            scene.registerBeforeRender(() => {
                shaderMaterial.setFloat("time", Date.now() * 0.001);
            });
            
            // Add fog for atmospheric perspective
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
            scene.fogDensity = 0.005;
            scene.fogColor = new BABYLON.Color3(0.7, 0.8, 0.9);
        };

        // Create street scene
        const createStreetScene = () => {
            updateLoading("Building street environment...", 40);
            
            // Create ground plane (asphalt)
            const ground = BABYLON.MeshBuilder.CreateGround("ground", {
                width: 100,
                height: 100
            }, scene);
            
            const groundMaterial = new BABYLON.PBRMaterial("groundMaterial", scene);
            groundMaterial.albedoColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            groundMaterial.metallic = 0.0;
            groundMaterial.roughness = 0.9;
            groundMaterial.subSurface.isRefractionEnabled = false;
            
            // Add asphalt texture effect
            const asphaltTexture = new BABYLON.NoiseProceduralTexture("asphaltNoise", 256, scene);
            asphaltTexture.animationSpeedFactor = 0;
            asphaltTexture.octaves = 3;
            asphaltTexture.persistence = 0.5;
            
            groundMaterial.bumpTexture = asphaltTexture;
            groundMaterial.bumpTexture.level = 0.1;
            ground.material = groundMaterial;
            ground.position.y = -0.5;
            
            // Create road markings
            createRoadMarkings();
            
            // Create buildings
            createBuildings();
            
            // Create street lights
            createStreetLights();
            
            // Create vehicles
            createVehicles();
            
            // Create trees and vegetation
            createVegetation();
            
            updateLoading("Adding detailed textures...", 60);
        };

        // Create road markings
        const createRoadMarkings = () => {
            // Center dividing line
            for (let i = -50; i < 50; i += 4) {
                const marking = BABYLON.MeshBuilder.CreateBox("marking", {
                    width: 2,
                    height: 0.02,
                    depth: 0.3
                }, scene);
                
                marking.position.x = 0;
                marking.position.y = -0.45;
                marking.position.z = i;
                
                const markingMat = new BABYLON.StandardMaterial("markingMat", scene);
                markingMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
                markingMat.emissiveColor = new BABYLON.Color3(0.8, 0.8, 0.8);
                marking.material = markingMat;
            }
            
            // Side lane markings
            for (let i = -50; i < 50; i += 8) {
                const leftMarking = BABYLON.MeshBuilder.CreateBox("leftMarking", {
                    width: 0.3,
                    height: 0.02,
                    depth: 1
                }, scene);
                
                leftMarking.position.x = -8;
                leftMarking.position.y = -0.45;
                leftMarking.position.z = i;
                
                const rightMarking = BABYLON.MeshBuilder.CreateBox("rightMarking", {
                    width: 0.3,
                    height: 0.02,
                    depth: 1
                }, scene);
                
                rightMarking.position.x = 8;
                rightMarking.position.y = -0.45;
                rightMarking.position.z = i;
                
                const markingMat = new BABYLON.StandardMaterial("sideMarkingMat", scene);
                markingMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
                markingMat.emissiveColor = new BABYLON.Color3(0.8, 0.8, 0.8);
                
                leftMarking.material = markingMat;
                rightMarking.material = markingMat;
            }
        };

        // Create buildings
        const createBuildings = () => {
            const buildingColors = [
                new BABYLON.Color3(0.6, 0.4, 0.3), // Brown
                new BABYLON.Color3(0.4, 0.4, 0.5), // Gray-blue
                new BABYLON.Color3(0.5, 0.3, 0.2), // Brown-red
                new BABYLON.Color3(0.3, 0.3, 0.4), // Dark gray
                new BABYLON.Color3(0.7, 0.5, 0.3)  // Light brown
            ];
            
            // Create buildings on both sides of the street
            for (let side = -1; side <= 1; side += 2) {
                for (let i = 0; i < 8; i++) {
                    const xPos = side * 15 + (Math.random() - 0.5) * 3;
                    const zPos = -40 + i * 12 + (Math.random() - 0.5) * 4;
                    const width = 6 + Math.random() * 4;
                    const depth = 8 + Math.random() * 4;
                    const height = 10 + Math.random() * 20;
                    
                    const building = BABYLON.MeshBuilder.CreateBox(`building_${side}_${i}`, {
                        width: width,
                        height: height,
                        depth: depth
                    }, scene);
                    
                    building.position.set(xPos, height / 2 - 0.5, zPos);
                    
                    // Create building material
                    const buildingMat = new BABYLON.PBRMaterial(`buildingMat_${side}_${i}`, scene);
                    buildingMat.albedoColor = buildingColors[Math.floor(Math.random() * buildingColors.length)];
                    buildingMat.metallic = 0.1;
                    buildingMat.roughness = 0.8;
                    buildingMat.microSurface = 0.2;
                    
                    // Add window details
                    createBuildingWindows(building, width, height, depth);
                    
                    building.material = buildingMat;
                }
            }
        };

        // Create building windows
        const createBuildingWindows = (building, width, height, depth) => {
            const windowCount = Math.floor((width * height) / 10);
            
            for (let i = 0; i < windowCount; i++) {
                const window = BABYLON.MeshBuilder.CreateBox(`window_${i}`, {
                    width: 0.8,
                    height: 1.2,
                    depth: 0.1
                }, scene);
                
                // Position window on building facade
                const side = Math.random() > 0.5 ? 1 : -1;
                const windowX = (Math.random() - 0.5) * (width - 1) * side;
                const windowY = Math.random() * (height - 2) + 1;
                const windowZ = (Math.random() > 0.5 ? depth/2 : -depth/2) * 0.9;
                
                window.position.set(windowX, windowY, windowZ);
                window.parent = building;
                
                // Window material
                const windowMat = new BABYLON.StandardMaterial(`windowMat_${i}`, scene);
                windowMat.diffuseColor = new BABYLON.Color3(0.1, 0.2, 0.3);
                windowMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                windowMat.emissiveColor = new BABYLON.Color3(0.2, 0.3, 0.4);
                window.material = windowMat;
            }
        };

        // Create street lights
        const createStreetLights = () => {
            for (let i = -40; i <= 40; i += 20) {
                // Light pole
                const pole = BABYLON.MeshBuilder.CreateCylinder(`pole_${i}`, {
                    height: 10,
                    diameter: 0.3
                }, scene);
                
                pole.position.set(-12, 5, i);
                
                const poleMat = new BABYLON.PBRMaterial(`poleMat_${i}`, scene);
                poleMat.albedoColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                poleMat.metallic = 0.8;
                poleMat.roughness = 0.3;
                pole.material = poleMat;
                
                // Light fixture
                const fixture = BABYLON.MeshBuilder.CreateSphere(`fixture_${i}`, {
                    diameter: 1
                }, scene);
                
                fixture.position.set(-12, 9.5, i);
                
                const fixtureMat = new BABYLON.PBRMaterial(`fixtureMat_${i}`, scene);
                fixtureMat.albedoColor = new BABYLON.Color3(0.9, 0.8, 0.6);
                fixtureMat.emissiveColor = new BABYLON.Color3(0.9, 0.8, 0.6);
                fixtureMat.emissiveIntensity = 0.5;
                fixture.material = fixtureMat;
                
                // Light source
                const light = new BABYLON.PointLight(`streetLight_${i}`, 
                    new BABYLON.Vector3(-12, 9, i), scene);
                light.diffuse = new BABYLON.Color3(1, 0.9, 0.7);
                light.intensity = 0.8;
                light.range = 20;
                
                // Create opposite side light
                const pole2 = pole.clone(`pole2_${i}`);
                pole2.position.x = 12;
                
                const fixture2 = fixture.clone(`fixture2_${i}`);
                fixture2.position.x = 12;
                
                const light2 = new BABYLON.PointLight(`streetLight2_${i}`, 
                    new BABYLON.Vector3(12, 9, i), scene);
                light2.diffuse = new BABYLON.Color3(1, 0.9, 0.7);
                light2.intensity = 0.8;
                light2.range = 20;
            }
        };

        // Create vehicles
        const createVehicles = () => {
            // Car 1
            const car1 = BABYLON.MeshBuilder.CreateBox("car1", {
                width: 4,
                height: 1.5,
                depth: 8
            }, scene);
            
            car1.position.set(-6, 0.75, 0);
            car1.rotation.y = Math.PI / 2;
            
            const car1Mat = new BABYLON.PBRMaterial("car1Mat", scene);
            car1Mat.albedoColor = new BABYLON.Color3(0.8, 0.1, 0.1); // Red
            car1Mat.metallic = 0.9;
            car1Mat.roughness = 0.2;
            car1Mat.clearCoat.intensity = 0.8;
            car1.material = car1Mat;
            
            // Car 2
            const car2 = BABYLON.MeshBuilder.CreateBox("car2", {
                width: 4,
                height: 1.5,
                depth: 8
            }, scene);
            
            car2.position.set(6, 0.75, -20);
            car2.rotation.y = -Math.PI / 2;
            
            const car2Mat = new BABYLON.PBRMaterial("car2Mat", scene);
            car2Mat.albedoColor = new BABYLON.Color3(0.1, 0.1, 0.8); // Blue
            car2Mat.metallic = 0.9;
            car2Mat.roughness = 0.2;
            car2Mat.clearCoat.intensity = 0.8;
            car2.material = car2Mat;
            
            // Truck
            const truck = BABYLON.MeshBuilder.CreateBox("truck", {
                width: 5,
                height: 3,
                depth: 12
            }, scene);
            
            truck.position.set(0, 1.5, 25);
            
            const truckMat = new BABYLON.PBRMaterial("truckMat", scene);
            truckMat.albedoColor = new BABYLON.Color3(0.9, 0.7, 0.1); // Yellow
            truckMat.metallic = 0.7;
            truckMat.roughness = 0.4;
            truck.material = truckMat;
        };

        // Create vegetation
        const createVegetation = () => {
            // Create trees along the street
            for (let i = -45; i <= 45; i += 15) {
                // Tree trunk
                const trunk = BABYLON.MeshBuilder.CreateCylinder(`trunk_${i}`, {
                    height: 8,
                    diameter: 1
                }, scene);
                
                trunk.position.set(-20, 4, i + (Math.random() - 0.5) * 5);
                
                const trunkMat = new BABYLON.PBRMaterial(`trunkMat_${i}`, scene);
                trunkMat.albedoColor = new BABYLON.Color3(0.4, 0.3, 0.2);
                trunkMat.metallic = 0.0;
                trunkMat.roughness = 0.9;
                trunk.material = trunkMat;
                
                // Tree foliage
                const foliage = BABYLON.MeshBuilder.CreateSphere(`foliage_${i}`, {
                    diameter: 10,
                    segments: 8
                }, scene);
                
                foliage.position.set(-20, 10, i + (Math.random() - 0.5) * 5);
                
                const foliageMat = new BABYLON.PBRMaterial(`foliageMat_${i}`, scene);
                foliageMat.albedoColor = new BABYLON.Color3(0.2, 0.5, 0.2);
                foliageMat.metallic = 0.0;
                foliageMat.roughness = 0.8;
                foliageMat.subSurface.isRefractionEnabled = true;
                foliageMat.subSurface.refractionIntensity = 0.2;
                foliage.material = foliageMat;
                
                // Create opposite side trees
                const trunk2 = trunk.clone(`trunk2_${i}`);
                trunk2.position.x = 20;
                
                const foliage2 = foliage.clone(`foliage2_${i}`);
                foliage2.position.x = 20;
            }
        };

        // Create metallic spheres
        const createSpheres = () => {
            updateLoading("Creating metallic spheres...", 70);
            
            // Sphere 1 (Copper)
            const sphere1 = BABYLON.MeshBuilder.CreateSphere("sphere1", {
                diameter: 5,
                segments: 64
            }, scene);
            
            sphere1.position.set(-7, 8, 0);
            
            const sphere1Mat = new BABYLON.PBRMaterial("sphere1Mat", scene);
            sphere1Mat.albedoColor = new BABYLON.Color3(0.955, 0.638, 0.538); // Copper color
            sphere1Mat.metallic = 0.9;
            sphere1Mat.roughness = 0.1;
            sphere1Mat.microSurface = 0.1;
            sphere1Mat.reflectivityColor = new BABYLON.Color3(0.9, 0.9, 0.9);
            sphere1Mat.reflectionColor = new BABYLON.Color3(0.9, 0.9, 0.9);
            sphere1Mat.environmentIntensity = 1.0;
            sphere1Mat.clearCoat.intensity = 0.3;
            sphere1Mat.clearCoat.roughness = 0.1;
            sphere1Mat.indexOfRefraction = 1.5;
            
            // Enable refraction for realistic glass/metal effects
            sphere1Mat.subSurface.isRefractionEnabled = true;
            sphere1Mat.subSurface.refractionIntensity = 0.2;
            sphere1Mat.subSurface.indexOfRefraction = 1.5;
            
            sphere1.material = sphere1Mat;
            
            // Sphere 2 (Aluminum)
            const sphere2 = BABYLON.MeshBuilder.CreateSphere("sphere2", {
                diameter: 5,
                segments: 64
            }, scene);
            
            sphere2.position.set(7, 8, 0);
            
            const sphere2Mat = new BABYLON.PBRMaterial("sphere2Mat", scene);
            sphere2Mat.albedoColor = new BABYLON.Color3(0.91, 0.92, 0.92); // Aluminum color
            sphere2Mat.metallic = 0.9;
            sphere2Mat.roughness = 0.2;
            sphere2Mat.microSurface = 0.15;
            sphere2Mat.reflectivityColor = new BABYLON.Color3(0.95, 0.95, 0.95);
            sphere2Mat.reflectionColor = new BABYLON.Color3(0.95, 0.95, 0.95);
            sphere2Mat.environmentIntensity = 1.0;
            sphere2Mat.clearCoat.intensity = 0.5;
            sphere2Mat.clearCoat.roughness = 0.05;
            sphere2Mat.indexOfRefraction = 1.39;
            
            // Enable refraction
            sphere2Mat.subSurface.isRefractionEnabled = true;
            sphere2Mat.subSurface.refractionIntensity = 0.15;
            sphere2Mat.subSurface.indexOfRefraction = 1.39;
            
            sphere2.material = sphere2Mat;
            
            // Store sphere references
            spheres = [
                { mesh: sphere1, material: sphere1Mat, type: "copper" },
                { mesh: sphere2, material: sphere2Mat, type: "aluminum" }
            ];
            
            // Add subtle rotation animation
            scene.registerBeforeRender(() => {
                sphere1.rotation.y += 0.001;
                sphere2.rotation.y -= 0.001;
            });
        };

        // Setup post-processing for ray tracing effects
        const setupPostProcessing = () => {
            updateLoading("Setting up post-processing pipeline...", 80);
            
            // Add bloom effect for glowing reflections
            const bloom = new BABYLON.BloomEffect("bloom", 1024, 0.1, 1.0);
            bloom.threshold = 0.8;
            bloom.weight = 0.5;
            bloom.kernel = 64;
            bloom.scale = 0.5;
            
            // Add chromatic aberration for cinematic effect
            const chromaticAberration = new BABYLON.ChromaticAberrationEffect("chromaticAberration", 1024);
            chromaticAberration.aberrationAmount = 2;
            chromaticAberration.radialIntensity = 0.5;
            
            // Create pipeline
            const pipeline = new BABYLON.DefaultRenderingPipeline("defaultPipeline", true, scene, [camera]);
            pipeline.bloomEnabled = true;
            pipeline.bloomThreshold = 0.8;
            pipeline.bloomWeight = 0.3;
            pipeline.bloomKernel = 32;
            pipeline.bloomScale = 0.5;
            
            pipeline.chromaticAberrationEnabled = true;
            pipeline.chromaticAberration.aberrationAmount = 3;
            pipeline.chromaticAberration.radialIntensity = 0.3;
            
            // Enable anti-aliasing
            pipeline.samples = 4;
            pipeline.fxaaEnabled = true;
            
            // Add sharpen effect for clarity
            pipeline.sharpenEnabled = true;
            pipeline.sharpen.edgeAmount = 0.3;
            pipeline.sharpen.colorAmount = 0.1;
        };

        // Setup UI controls
        const setupControls = () => {
            // Sphere selection buttons
            document.querySelectorAll('.sphere-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.sphere-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentSphere = parseInt(btn.getAttribute('data-sphere'));
                    updateSlidersFromMaterial();
                });
            });
            
            // Material property sliders
            const sliders = [
                { id: 'metallicSlider', property: 'metallic', format: v => v.toFixed(2) },
                { id: 'roughnessSlider', property: 'roughness', format: v => v.toFixed(2) },
                { id: 'reflectivitySlider', property: 'reflectivityColor', format: v => v.toFixed(2) },
                { id: 'iorSlider', property: 'indexOfRefraction', format: v => v.toFixed(2) },
                { id: 'clearcoatSlider', property: 'clearCoat', subProperty: 'intensity', format: v => v.toFixed(2) }
            ];
            
            sliders.forEach(sliderConfig => {
                const slider = document.getElementById(sliderConfig.id);
                const valueDisplay = document.getElementById(sliderConfig.id.replace('Slider', 'Value'));
                
                slider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    valueDisplay.textContent = sliderConfig.format(value);
                    updateMaterialProperty(sliderConfig.property, value, sliderConfig.subProperty);
                });
            });
            
            // Material preset buttons
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.getAttribute('data-preset');
                    applyMaterialPreset(preset);
                });
            });
            
            // Camera controls
            document.getElementById('cameraDefault').addEventListener('click', () => {
                camera.alpha = -Math.PI / 3.5;
                camera.beta = Math.PI / 3.5;
                camera.radius = 40;
                camera.target = new BABYLON.Vector3(0, 5, 0);
            });
            
            document.getElementById('cameraTop').addEventListener('click', () => {
                camera.alpha = 0;
                camera.beta = Math.PI / 2;
                camera.radius = 30;
                camera.target = new BABYLON.Vector3(0, 8, 0);
            });
            
            document.getElementById('cameraReflection').addEventListener('click', () => {
                camera.alpha = Math.PI / 4;
                camera.beta = Math.PI / 4;
                camera.radius = 15;
                camera.target = spheres[currentSphere - 1].mesh.position;
            });
            
            document.getElementById('cameraReset').addEventListener('click', () => {
                camera.alpha = -Math.PI / 3.5;
                camera.beta = Math.PI / 3.5;
                camera.radius = 40;
                camera.target = new BABYLON.Vector3(0, 5, 0);
                applyMaterialPreset(currentSphere === 1 ? 'copper' : 'aluminum');
            });
            
            // Update sliders to match current sphere material
            updateSlidersFromMaterial();
        };

        // Update material property
        const updateMaterialProperty = (property, value, subProperty = null) => {
            const sphere = spheres[currentSphere - 1];
            const material = sphere.material;
            
            if (subProperty) {
                // Handle nested properties like clearCoat.intensity
                const parts = property.split('.');
                let obj = material;
                for (let i = 0; i < parts.length; i++) {
                    if (i === parts.length - 1 && subProperty) {
                        obj[parts[i]][subProperty] = value;
                    } else {
                        obj = obj[parts[i]];
                    }
                }
            } else if (property === 'reflectivityColor') {
                // Reflectivity is a color in PBR
                material.reflectivityColor = new BABYLON.Color3(value, value, value);
                material.reflectionColor = new BABYLON.Color3(value, value, value);
            } else {
                // Simple property assignment
                material[property] = value;
                
                // Also update subsurface refraction if IOR changes
                if (property === 'indexOfRefraction') {
                    material.subSurface.indexOfRefraction = value;
                }
            }
        };

        // Update sliders from current material
        const updateSlidersFromMaterial = () => {
            const sphere = spheres[currentSphere - 1];
            const material = sphere.material;
            
            // Update slider values
            document.getElementById('metallicSlider').value = material.metallic;
            document.getElementById('metallicValue').textContent = material.metallic.toFixed(2);
            
            document.getElementById('roughnessSlider').value = material.roughness;
            document.getElementById('roughnessValue').textContent = material.roughness.toFixed(2);
            
            document.getElementById('reflectivitySlider').value = material.reflectivityColor.r;
            document.getElementById('reflectivityValue').textContent = material.reflectivityColor.r.toFixed(2);
            
            document.getElementById('iorSlider').value = material.indexOfRefraction;
            document.getElementById('iorValue').textContent = material.indexOfRefraction.toFixed(2);
            
            document.getElementById('clearcoatSlider').value = material.clearCoat.intensity;
            document.getElementById('clearcoatValue').textContent = material.clearCoat.intensity.toFixed(2);
        };

        // Apply material preset
        const applyMaterialPreset = (presetName) => {
            const preset = materialPresets[presetName];
            if (!preset) return;
            
            const sphere = spheres[currentSphere - 1];
            const material = sphere.material;
            
            // Apply preset values
            material.metallic = preset.metallic;
            material.roughness = preset.roughness;
            material.reflectivityColor = new BABYLON.Color3(preset.reflectivity, preset.reflectivity, preset.reflectivity);
            material.reflectionColor = new BABYLON.Color3(preset.reflectivity, preset.reflectivity, preset.reflectivity);
            material.indexOfRefraction = preset.ior;
            material.clearCoat.intensity = preset.clearcoat;
            material.albedoColor = preset.color;
            
            // Update subsurface refraction
            material.subSurface.indexOfRefraction = preset.ior;
            
            // Update UI sliders
            updateSlidersFromMaterial();
            
            // Update sphere type display
            const sphereBtn = document.getElementById(`sphere${currentSphere}Btn`);
            const typeSpan = sphereBtn.querySelector('div:nth-child(3)');
            typeSpan.textContent = presetName.charAt(0).toUpperCase() + presetName.slice(1);
        };

        // Update triangle count
        const updateTriangleCount = () => {
            let totalTriangles = 0;
            scene.meshes.forEach(mesh => {
                if (mesh.isVisible) {
                    totalTriangles += mesh.getTotalIndices() / 3;
                }
            });
            document.getElementById('triangleCount').textContent = totalTriangles.toLocaleString();
        };

        // Update loading progress
        const updateLoading = (text, progress) => {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingProgress').style.width = `${progress}%`;
        };

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', () => {
            initEngine();
        });
    </script>
</body>
</html>