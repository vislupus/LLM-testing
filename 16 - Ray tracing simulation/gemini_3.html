<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js Real-time PBR Ray Tracing</title>
    <!-- Babylon.js Core and Loaders -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
        }
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 280px;
            background: rgba(20, 20, 25, 0.85);
            backdrop-filter: blur(8px);
            padding: 20px;
            border-radius: 12px;
            color: #eee;
            border: 1px solid #444;
            box-shadow: 0 4px 20px rgba(0,0,0,0.6);
            z-index: 10;
        }
        h2 {
            margin-top: 0;
            font-size: 16px;
            color: #00e5ff;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-header {
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
            font-weight: bold;
            text-transform: uppercase;
        }
        label {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            margin-bottom: 5px;
        }
        input[type=range] {
            width: 100%;
            cursor: pointer;
            accent-color: #00e5ff;
            background: transparent;
        }
        .value-display {
            color: #00e5ff;
            font-family: monospace;
        }
    </style>
</head>
<body>

    <div id="ui-panel">
        <h2>Material Controls</h2>
        
        <div class="control-group">
            <div class="control-header">Left Sphere (Gold)</div>
            <label><span>Metallic</span> <span id="val-met-1" class="value-display">1.0</span></label>
            <input type="range" id="slider-met-1" min="0" max="1" step="0.01" value="1.0">
            
            <label><span>Roughness</span> <span id="val-ruf-1" class="value-display">0.1</span></label>
            <input type="range" id="slider-ruf-1" min="0" max="1" step="0.01" value="0.1">
        </div>

        <div class="control-group">
            <div class="control-header">Right Sphere (Silver)</div>
            <label><span>Metallic</span> <span id="val-met-2" class="value-display">1.0</span></label>
            <input type="range" id="slider-met-2" min="0" max="1" step="0.01" value="1.0">
            
            <label><span>Roughness</span> <span id="val-ruf-2" class="value-display">0.05</span></label>
            <input type="range" id="slider-ruf-2" min="0" max="1" step="0.01" value="0.05">
        </div>

        <div class="control-group">
            <div class="control-header">Scene</div>
            <label><span>Exposure</span> <span id="val-exp" class="value-display">1.0</span></label>
            <input type="range" id="slider-exp" min="0.5" max="3" step="0.1" value="1.0">
        </div>
    </div>

    <canvas id="renderCanvas"></canvas>

    <script>
        window.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('renderCanvas');
            const engine = new BABYLON.Engine(canvas, true);

            const createScene = function() {
                const scene = new BABYLON.Scene(engine);
                
                // 1. Camera setup (ArcRotate for orbiting)
                const camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2, Math.PI / 2.5, 8, new BABYLON.Vector3(0, 0, 0), scene);
                camera.attachControl(canvas, true);
                camera.wheelPrecision = 50;
                camera.minZ = 0.1;

                // 2. Environment (The "Ray Tracing" source)
                // We use an HDR environment map for Image Based Lighting (IBL).
                // This simulates the street scene reflections.
                const envTexture = BABYLON.CubeTexture.CreateFromPrefilteredData("https://playground.babylonjs.com/textures/country.env", scene);
                scene.environmentTexture = envTexture;
                scene.createDefaultSkybox(envTexture, true, 1000, 0.25); // Create visible skybox, slightly blurred

                // 3. PBR Materials
                // Gold Material
                const pbrGold = new BABYLON.PBRMaterial("pbrGold", scene);
                pbrGold.albedoColor = new BABYLON.Color3(1.0, 0.766, 0.336); // Gold base color
                pbrGold.metallic = 1.0; 
                pbrGold.roughness = 0.1;
                pbrGold.reflectionTexture = envTexture; // Force reflection source
                
                // Silver/Chrome Material
                const pbrSilver = new BABYLON.PBRMaterial("pbrSilver", scene);
                pbrSilver.albedoColor = new BABYLON.Color3(0.95, 0.95, 0.95); // Silver base color
                pbrSilver.metallic = 1.0;
                pbrSilver.roughness = 0.05;
                pbrSilver.reflectionTexture = envTexture;

                // Asphalt Ground Material
                const pbrGround = new BABYLON.PBRMaterial("pbrGround", scene);
                pbrGround.albedoColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                pbrGround.roughness = 0.8;
                pbrGround.metallic = 0.1;

                // 4. Meshes
                const sphereLeft = BABYLON.MeshBuilder.CreateSphere("sphereLeft", {diameter: 2, segments: 64}, scene);
                sphereLeft.position = new BABYLON.Vector3(-1.5, 1.2, 0);
                sphereLeft.material = pbrGold;

                const sphereRight = BABYLON.MeshBuilder.CreateSphere("sphereRight", {diameter: 2, segments: 64}, scene);
                sphereRight.position = new BABYLON.Vector3(1.5, 1.2, 0);
                sphereRight.material = pbrSilver;

                // Ground plane
                const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 20, height: 20}, scene);
                ground.material = pbrGround;
                
                // Shadow Catcher (to make spheres feel grounded)
                const shadowGenerator = new BABYLON.ShadowGenerator(1024, new BABYLON.DirectionalLight("dir01", new BABYLON.Vector3(-1, -2, -1), scene));
                shadowGenerator.addShadowCaster(sphereLeft);
                shadowGenerator.addShadowCaster(sphereRight);
                shadowGenerator.useBlurExponentialShadowMap = true;
                ground.receiveShadows = true;

                // 5. Post Processing (Optional for realism)
                const pipeline = new BABYLON.DefaultRenderingPipeline(
                    "defaultPipeline", 
                    true, 
                    scene, 
                    [camera]
                );
                pipeline.bloomEnabled = true;
                pipeline.bloomThreshold = 0.8;
                pipeline.bloomWeight = 0.3;
                pipeline.bloomKernel = 64;
                pipeline.bloomScale = 0.5;

                // --- UI Binding ---
                const bindSlider = (id, displayId, obj, prop) => {
                    const slider = document.getElementById(id);
                    const display = document.getElementById(displayId);
                    slider.addEventListener('input', (e) => {
                        const val = parseFloat(e.target.value);
                        obj[prop] = val;
                        display.innerText = val.toFixed(2);
                    });
                };

                bindSlider('slider-met-1', 'val-met-1', pbrGold, 'metallic');
                bindSlider('slider-ruf-1', 'val-ruf-1', pbrGold, 'roughness');
                
                bindSlider('slider-met-2', 'val-met-2', pbrSilver, 'metallic');
                bindSlider('slider-ruf-2', 'val-ruf-2', pbrSilver, 'roughness');

                // Exposure Control
                const sliderExp = document.getElementById('slider-exp');
                const dispExp = document.getElementById('val-exp');
                sliderExp.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    scene.imageProcessingConfiguration.exposure = val;
                    dispExp.innerText = val.toFixed(1);
                });

                // Animation loop for floating effect
                let alpha = 0;
                scene.registerBeforeRender(() => {
                    alpha += 0.01;
                    sphereLeft.position.y = 1.2 + Math.sin(alpha) * 0.1;
                    sphereRight.position.y = 1.2 + Math.cos(alpha) * 0.1;
                });

                return scene;
            };

            const scene = createScene();

            engine.runRenderLoop(function() {
                scene.render();
            });

            window.addEventListener('resize', function() {
                engine.resize();
            });
        });
    </script>
</body>
</html>