<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elemental Weaver: The Alchemist's Path</title>
    <!-- Load SVG.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.1.2/svg.min.js"></script>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --ui-bg: #16213e;
            --accent: #e94560;
            --text: #f1f1f1;
        }
        
        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        h1 { margin: 10px 0 5px 0; font-size: 1.5rem; letter-spacing: 2px; text-transform: uppercase; }
        
        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            border-radius: 12px;
            overflow: hidden;
            background: #0f3460;
        }

        /* UI Panels */
        .ui-panel {
            position: absolute;
            background: rgba(22, 33, 62, 0.95);
            border: 1px solid #0f3460;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            color: white;
            z-index: 10;
        }

        #stats-panel {
            top: 10px; left: 10px;
            width: 220px;
        }

        #inventory-panel {
            top: 10px; right: 10px;
            width: 200px;
            text-align: center;
        }

        #mix-panel {
            bottom: 10px; right: 10px;
            width: 250px;
            display: none; /* Hidden until needed */
        }

        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 0.9rem; }
        .stat-label { color: #a0a0a0; }
        .stat-value { font-weight: bold; color: var(--accent); }

        .slot {
            width: 40px; height: 40px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin: 2px;
            border: 1px dashed #555;
            position: relative;
        }
        
        .slot.filled { border: 1px solid white; box-shadow: 0 0 10px rgba(255,255,255,0.2); }

        button.game-btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            margin-top: 5px;
            transition: transform 0.1s;
        }
        button.game-btn:active { transform: scale(0.95); }

        /* Modal Overlay */
        #modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; justify-content: center; align-items: center;
            z-index: 100;
            opacity: 0; pointer-events: none;
            transition: opacity 0.3s;
        }
        #modal-overlay.active { opacity: 1; pointer-events: all; }
        
        .modal-content {
            background: #16213e;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
            border: 2px solid var(--accent);
        }

        .fact-card {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-style: italic;
            border-left: 4px solid var(--accent);
            display: none;
        }

        /* SVG Specific Styles */
        .tile { cursor: pointer; stroke: rgba(0,0,0,0.1); stroke-width: 1; transition: filter 0.2s; }
        .tile:hover { filter: brightness(1.2); }
        .tile-locked { opacity: 0.5; pointer-events: none; }
        
        .player-flask { filter: drop-shadow(0 4px 4px rgba(0,0,0,0.3)); }
        
        .liquid { transition: height 0.3s; }
        
        /* Particle Effects */
        .particle { pointer-events: none; }
    </style>
</head>
<body>

    <h1>Elemental Weaver</h1>

    <div id="game-container">
        <!-- SVG Canvas will be injected here -->
        
        <!-- HUD: Stats -->
        <div id="stats-panel" class="ui-panel">
            <div class="stat-row">
                <span class="stat-label">Move Cost:</span>
                <span class="stat-value">1 AP</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Quest:</span>
                <span class="stat-value" id="quest-desc">Create Mud</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Progress:</span>
                <span class="stat-value" id="progress-val">0 / 5</span>
            </div>
            <div style="font-size: 0.8rem; color: #888; margin-top:10px;">
                Use Arrow Keys or Click Tiles to Move.
            </div>
        </div>

        <!-- HUD: Inventory -->
        <div id="inventory-panel" class="ui-panel">
            <div style="margin-bottom: 5px; font-size: 0.9rem;">Elements Carried</div>
            <div id="slots-container">
                <div class="slot" id="slot-0"></div>
                <div class="slot" id="slot-1"></div>
            </div>
            <button class="game-btn" onclick="game.attemptMix()">Mix Elements</button>
        </div>

        <!-- Fact Popup -->
        <div id="fact-popup" class="fact-card" onclick="this.style.display='none'">
            <strong>Did you know?</strong>
            <p id="fact-text"></p>
            <div style="text-align:right; font-size:0.7rem; margin-top:5px;">(Click to dismiss)</div>
        </div>
    </div>

    <!-- Start/End Modal -->
    <div id="modal-overlay" class="active">
        <div class="modal-content">
            <h2 id="modal-title" style="margin-top:0; color:var(--accent);">Welcome Alchemist</h2>
            <p id="modal-msg">
                The world needs new compounds! Travel the elemental grid, collect raw materials, and combine them to solve world problems.
            </p>
            <button class="game-btn" onclick="game.start()">Start Journey</button>
        </div>
    </div>

<script>
/**
 * Elemental Weaver - Educational Board Game
 * Concept: A board game where players navigate a grid of elemental terrain.
 * Education: Teaches basic elemental combinations (e.g., Earth + Water = Mud).
 * Tech: SVG.js for all rendering.
 */

const BOARD_SIZE = 7;
const TILE_SIZE = 70;
const BOARD_DIM = BOARD_SIZE * TILE_SIZE;

// Element Definitions & Colors
const ELEMENTS = {
    FIRE: { color: '#e94560', label: 'Fire', fact: 'Fire is a chemical reaction that releases light and heat.' },
    WATER: { color: '#4cc9f0', label: 'Water', fact: 'Water is the only substance naturally found in all three states.' },
    EARTH: { color: '#8d99ae', label: 'Earth', fact: 'Earth contains 70% of the same elements as the human body.' },
    AIR: { color: '#f1faee', label: 'Air', fact: 'Air is mostly made of Nitrogen (78%) and Oxygen (21%).' },
    EMPTY: { color: '#2b2d42', label: 'Void' }
};

// Recipes
const RECIPES = [
    { result: 'Mud', parts: ['Earth', 'Water'], color: '#5c4033', desc: 'Created fertile soil!' },
    { result: 'Steam', parts: ['Fire', 'Water'], color: '#d8e2dc', desc: 'Created gas!' },
    { result: 'Lava', parts: ['Fire', 'Earth'], color: '#ff4d4d', desc: 'Created molten rock!' },
    { result: 'Dust', parts: ['Earth', 'Air'], color: '#c0a080', desc: 'Created particles!' },
    { result: 'Energy', parts: ['Fire', 'Air'], color: '#ffd700', desc: 'Created pure power!' }
];

const LEVELS = [
    { target: 'Mud', count: 1 },
    { target: 'Steam', count: 1 },
    { target: 'Lava', count: 1 },
    { target: 'Energy', count: 1 },
    { target: 'Mud', count: 2 }
];

class Game {
    constructor() {
        this.draw = SVG().addTo('#game-container').size(BOARD_DIM, BOARD_DIM);
        this.level = 0;
        this.playerPos = { x: 0, y: 0 };
        this.inventory = [];
        this.score = 0;
        this.targetCount = 0;
        this.grid = []; // Stores element type at {x,y}
        this.isAnimating = false;
    }

    start() {
        document.getElementById('modal-overlay').classList.remove('active');
        this.level = 0;
        this.score = 0;
        this.loadLevel(0);
    }

    loadLevel(lvlIndex) {
        if (lvlIndex >= LEVELS.length) {
            this.showModal("Master Alchemist!", "You have restored balance to the elements! The world is saved.", true);
            return;
        }

        this.level = lvlIndex;
        const lvlData = LEVELS[lvlIndex];
        const targetRecipe = RECIPES.find(r => r.result === lvlData.target);
        
        this.targetCount = lvlData.count;
        this.inventory = [];
        
        // Update UI
        document.getElementById('quest-desc').innerText = `Create ${this.targetCount}x ${targetRecipe.result}`;
        document.getElementById('progress-val').innerText = `0 / ${this.targetCount}`;
        this.updateInventoryUI();

        // Generate Grid
        this.draw.clear();
        this.grid = [];
        
        // Simple Perlin-ish noise or random clusters
        for (let y = 0; y < BOARD_SIZE; y++) {
            this.grid[y] = [];
            for (let x = 0; x < BOARD_SIZE; x++) {
                // Randomly assign elements, ensuring we don't block start
                const types = ['FIRE', 'WATER', 'EARTH', 'AIR', 'EMPTY'];
                let type = types[Math.floor(Math.random() * types.length)];
                
                // Bias towards ingredients needed for the quest
                if(Math.random() < 0.3) {
                    type = targetRecipe.parts[Math.floor(Math.random() * targetRecipe.parts.length)];
                }

                // Start position always Empty
                if(x===0 && y===0) type = 'EMPTY';

                this.grid[y][x] = type;
                this.drawTile(x, y, type);
            }
        }

        this.playerPos = { x: 0, y: 0 };
        this.drawPlayer();
    }

    drawTile(x, y, type) {
        const elData = ELEMENTS[type];
        const group = this.draw.group();
        
        // Tile Background
        group.rect(TILE_SIZE, TILE_SIZE).fill(elData.color);
        
        // Add some texture
        if (type === 'FIRE') group.circle(20).cx(35).cy(35).fill('#ff9f1c').opacity(0.3);
        if (type === 'WATER') group.circle(20).cx(15).cy(15).fill('rgba(255,255,255,0.2)');
        if (type === 'EARTH') group.rect(30,30).move(20,20).fill('rgba(0,0,0,0.1)');
        if (type === 'AIR') group.path('M10,10 Q30,40 50,10').stroke('white').fill('none').opacity(0.3).stroke({width:2});

        // Grid overlay
        group.rect(TILE_SIZE, TILE_SIZE).fill('none').stroke('rgba(0,0,0,0.2)');
        
        group.move(x * TILE_SIZE, y * TILE_SIZE);
        group.on('click', () => this.tryMove(x, y));
    }

    drawPlayer() {
        this.playerGroup = this.draw.group().addClass('player-flask');
        const cx = this.playerPos.x * TILE_SIZE + TILE_SIZE/2;
        const cy = this.playerPos.y * TILE_SIZE + TILE_SIZE/2;

        // Flask Body
        this.playerGroup.path("M25,25 L35,25 L38,40 L22,40 Z").fill('white').stroke('#333').strokeWidth(2);
        this.playerGroup.rect(24, 15, 12, 10).fill('white').stroke('#333').strokeWidth(2);
        
        // Liquid inside
        this.liquid = this.playerGroup.rect(14, 24, 12, 15).fill('none').addClass('liquid');
        
        this.playerGroup.move(cx - 25, cy - 30);
    }

    tryMove(tx, ty) {
        if (this.isAnimating) return;
        
        const dx = Math.abs(tx - this.playerPos.x);
        const dy = Math.abs(ty - this.playerPos.y);

        // Orthogonal movement only, distance 1
        if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
            this.movePlayerTo(tx, ty);
        }
    }

    movePlayerTo(x, y) {
        this.isAnimating = true;
        const targetX = x * TILE_SIZE + TILE_SIZE/2 - 25;
        const targetY = y * TILE_SIZE + TILE_SIZE/2 - 30;

        // Animate
        this.playerGroup.animate(300, '<>').move(targetX, targetY).after(() => {
            this.playerPos = { x, y };
            this.handleTileInteraction(x, y);
            this.isAnimating = false;
        });
    }

    handleTileInteraction(x, y) {
        const type = this.grid[y][x];
        
        // Update liquid color based on tile
        this.liquid.fill(ELEMENTS[type].color).attr('height', 15); // Reset liquid height
        
        if (type !== 'EMPTY') {
            this.showFact(type);
            
            // Collect logic
            // Simple logic: Walk on tile -> Add to inventory (simulating extraction)
            // To make it harder, we could require a key press, but for "Board Game" feel, walking is sufficient flow.
            this.collectElement(type);
        }
    }

    collectElement(type) {
        if (this.inventory.length < 2) {
            this.inventory.push(type);
            this.spawnParticles(this.playerPos.x, this.playerPos.y, ELEMENTS[type].color);
            this.updateInventoryUI();
        } else {
            // Inventory full visual feedback
            this.playerGroup.animate(100, '<>', 3).move(this.playerPos.x * TILE_SIZE + 2, this.playerPos.y * TILE_SIZE).after(()=> {
                this.playerGroup.move(this.playerPos.x * TILE_SIZE, this.playerPos.y * TILE_SIZE);
            });
        }
    }

    updateInventoryUI() {
        const slot0 = document.getElementById('slot-0');
        const slot1 = document.getElementById('slot-1');
        
        this.updateSlot(slot0, this.inventory[0]);
        this.updateSlot(slot1, this.inventory[1]);
    }

    updateSlot(el, type) {
        el.innerHTML = '';
        el.classList.remove('filled');
        if (type) {
            el.classList.add('filled');
            el.style.backgroundColor = ELEMENTS[type].color;
            el.innerText = ELEMENTS[type].label;
            el.style.color = type === 'AIR' || type === 'EARTH' ? '#333' : '#fff';
        }
    }

    attemptMix() {
        if (this.inventory.length < 2) return;

        // Check recipes
        const recipe = RECIPES.find(r => {
            return (this.inventory.includes(r.parts[0]) && this.inventory.includes(r.parts[1]));
        });

        if (recipe) {
            // Success Mix
            this.inventory = [];
            this.updateInventoryUI();
            
            // Explosion effect
            const cx = this.playerPos.x * TILE_SIZE + TILE_SIZE/2;
            const cy = this.playerPos.y * TILE_SIZE + TILE_SIZE/2;
            this.spawnParticles(this.playerPos.x, this.playerPos.y, recipe.color, 20);
            
            // Check Level Goal
            const lvlTarget = LEVELS[this.level].target;
            if (recipe.result === lvlTarget) {
                this.score++;
                this.updateProgress();
            }

            // Feedback
            const factEl = document.getElementById('fact-popup');
            document.getElementById('fact-text').innerHTML = `<strong>Success!</strong> You created <span style="color:${recipe.color}">${recipe.result}</span>.<br>${recipe.desc}`;
            factEl.style.display = 'block';
            factEl.style.borderColor = recipe.color;

        } else {
            // Fail
            const factEl = document.getElementById('fact-popup');
            document.getElementById('fact-text').innerHTML = `<strong>Failed!</strong> These elements don't react.<br>Try again elsewhere.`;
            factEl.style.display = 'block';
            factEl.style.borderColor = '#ff4d4d';
            
            // Shake animation
            this.playerGroup.animate(50, '<>', 3).move(this.playerPos.x * TILE_SIZE - 5, this.playerPos.y * TILE_SIZE);
            setTimeout(() => {
                 this.playerGroup.move(this.playerPos.x * TILE_SIZE, this.playerPos.y * TILE_SIZE);
            }, 200);
        }
    }

    updateProgress() {
        const current = this.score;
        const total = this.targetCount;
        document.getElementById('progress-val').innerText = `${current} / ${total}`;
        
        if (current >= total) {
            setTimeout(() => {
                this.showModal("Level Complete!", "Great work! You have synthesized the required compounds.", false, () => {
                    this.loadLevel(this.level + 1);
                });
            }, 1000);
        }
    }

    spawnParticles(gx, gy, color, count = 5) {
        const cx = gx * TILE_SIZE + TILE_SIZE/2;
        const cy = gy * TILE_SIZE + TILE_SIZE/2;

        for(let i=0; i<count; i++) {
            const p = this.draw.circle(5 + Math.random()*5).fill(color);
            p.move(cx, cy).addClass('particle');
            
            const angle = Math.random() * Math.PI * 2;
            const dist = 20 + Math.random() * 30;
            const tx = cx + Math.cos(angle) * dist;
            const ty = cy + Math.sin(angle) * dist;

            p.animate(400, '>').move(tx, ty).opacity(0).after(() => p.remove());
        }
    }

    showFact(type) {
        const elData = ELEMENTS[type];
        const popup = document.getElementById('fact-popup');
        document.getElementById('fact-text').innerHTML = `<strong>Harvested ${elData.label}</strong><br>${elData.fact}`;
        popup.style.display = 'block';
        popup.style.borderColor = elData.color;
    }

    showModal(title, text, isEnd = false, action = null) {
        document.getElementById('modal-title').innerText = title;
        document.getElementById('modal-msg').innerText = text;
        document.getElementById('modal-overlay').classList.add('active');
        
        const btn = document.querySelector('#modal-overlay button');
        btn.innerText = isEnd ? "Play Again" : "Next Level";
        btn.onclick = () => {
            if (action) action();
            else if (isEnd) this.start();
        };
    }
}

// Keyboard Input
document.addEventListener('keydown', (e) => {
    if(!window.game) return;
    const p = window.game.playerPos;
    switch(e.key) {
        case 'ArrowUp': window.game.tryMove(p.x, p.y - 1); break;
        case 'ArrowDown': window.game.tryMove(p.x, p.y + 1); break;
        case 'ArrowLeft': window.game.tryMove(p.x - 1, p.y); break;
        case 'ArrowRight': window.game.tryMove(p.x + 1, p.y); break;
    }
});

// Initialize Game
window.game = new Game();

</script>
</body>
</html>