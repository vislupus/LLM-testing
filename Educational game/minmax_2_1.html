<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elemental Odyssey - Chemistry Board Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.1.2/svg.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            overflow-x: hidden;
            color: #fff;
        }

        .game-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-title {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #e94560, #f7b731, #20bf6b, #3498db);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            margin-bottom: 10px;
            animation: titleGlow 3s ease-in-out infinite;
        }

        @keyframes titleGlow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        .game-subtitle {
            font-size: 1rem;
            color: #8892b0;
            margin-bottom: 15px;
        }

        .game-layout {
            display: grid;
            grid-template-columns: 250px 1fr 280px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .panel-title {
            font-size: 1.1rem;
            color: #e94560;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(233, 69, 96, 0.3);
        }

        #game-canvas {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .player-info.active {
            background: rgba(233, 69, 96, 0.2);
            border: 1px solid rgba(233, 69, 96, 0.5);
        }

        .player-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .player-details {
            flex: 1;
        }

        .player-name {
            font-weight: 600;
            font-size: 0.95rem;
        }

        .player-stats {
            font-size: 0.8rem;
            color: #8892b0;
            margin-top: 3px;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-top: 15px;
        }

        .inventory-slot {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .inventory-slot:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.05);
        }

        .inventory-slot.has-element {
            background: rgba(32, 191, 107, 0.2);
            border-color: rgba(32, 191, 107, 0.5);
        }

        .molecule-list {
            margin-top: 15px;
        }

        .molecule-item {
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 10px;
            border-left: 3px solid #20bf6b;
        }

        .molecule-item.completed {
            background: rgba(32, 191, 107, 0.1);
        }

        .game-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .game-btn {
            flex: 1;
            min-width: 100px;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #e94560, #d63447);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(233, 69, 96, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(52, 152, 219, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #20bf6b, #1abc9c);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(32, 191, 107, 0.4);
        }

        .game-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .dice-display {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .dice-value {
            font-size: 3rem;
            font-weight: bold;
            color: #f7b731;
            text-shadow: 0 0 20px rgba(247, 183, 49, 0.5);
        }

        .turn-indicator {
            text-align: center;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 10px;
            font-weight: 600;
            background: linear-gradient(135deg, rgba(233, 69, 96, 0.3), rgba(247, 183, 49, 0.3));
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            border: 2px solid rgba(255, 255, 255, 0.1);
            animation: modalSlide 0.3s ease;
        }

        @keyframes modalSlide {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #e94560;
        }

        .modal-content {
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .question-text {
            font-size: 1.1rem;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .answer-btn {
            display: block;
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            cursor: pointer;
            text-align: left;
            transition: all 0.3s ease;
        }

        .answer-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #e94560;
        }

        .answer-btn.correct {
            background: rgba(32, 191, 107, 0.3);
            border-color: #20bf6b;
        }

        .answer-btn.incorrect {
            background: rgba(233, 69, 96, 0.3);
            border-color: #e94560;
        }

        .game-log {
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.85rem;
        }

        .log-entry {
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 5px;
            border-left: 3px solid #3498db;
        }

        .log-entry.important {
            border-left-color: #f7b731;
        }

        .log-entry.success {
            border-left-color: #20bf6b;
        }

        .log-entry.error {
            border-left-color: #e94560;
        }

        .element-card-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }

        .element-card {
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .element-card:hover {
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .element-symbol {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .element-name {
            font-size: 0.75rem;
            margin-top: 5px;
            color: #8892b0;
        }

        .molecule-builder {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            margin: 15px 0;
        }

        .builder-slot {
            width: 60px;
            height: 60px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .builder-slot.filled {
            border-style: solid;
            border-color: #20bf6b;
            background: rgba(32, 191, 107, 0.2);
        }

        .builder-operator {
            font-size: 1.5rem;
            color: #f7b731;
        }

        .winner-display {
            text-align: center;
            padding: 30px;
        }

        .winner-avatar {
            font-size: 4rem;
            margin-bottom: 20px;
            animation: bounce 1s ease infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .winner-score {
            font-size: 2rem;
            color: #f7b731;
            margin-bottom: 10px;
        }

        .final-stats {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .instructions-list {
            padding-left: 20px;
            line-height: 1.8;
        }

        .instructions-list li {
            margin-bottom: 8px;
        }

        @media (max-width: 1200px) {
            .game-layout {
                grid-template-columns: 1fr;
            }

            #game-canvas {
                min-height: 500px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <header class="game-header">
            <h1 class="game-title">‚öóÔ∏è Elemental Odyssey</h1>
            <p class="game-subtitle">Journey Through the World of Chemistry</p>
        </header>

        <div class="game-layout">
            <aside class="panel">
                <h2 class="panel-title">üéÆ Players</h2>
                <div id="player-list"></div>

                <h2 class="panel-title" style="margin-top: 20px;">üé≤ Controls</h2>
                <div class="dice-display">
                    <div class="dice-value" id="dice-value">-</div>
                    <div style="color: #8892b0; font-size: 0.85rem;">Roll the dice!</div>
                </div>
                <div class="turn-indicator" id="turn-indicator">Click Roll to Start!</div>
                <div class="game-controls">
                    <button class="game-btn btn-primary" id="roll-btn">Roll Dice</button>
                    <button class="game-btn btn-secondary" id="combine-btn">Combine</button>
                </div>
                <div class="game-controls">
                    <button class="game-btn btn-success" id="pass-btn">Pass Turn</button>
                </div>
            </aside>

            <main>
                <div id="game-canvas"></div>
            </main>

            <aside class="panel">
                <h2 class="panel-title">üéí Inventory</h2>
                <div class="inventory-grid" id="inventory-grid"></div>

                <h2 class="panel-title" style="margin-top: 20px;">üß™ Molecules</h2>
                <div class="molecule-list" id="molecule-list"></div>

                <h2 class="panel-title" style="margin-top: 20px;">üìú Game Log</h2>
                <div class="game-log" id="game-log"></div>
            </aside>
        </div>
    </div>

    <div class="modal-overlay" id="modal-overlay">
        <div class="modal" id="modal-content"></div>
    </div>

    <script>
        // Game Configuration and Data
        const CONFIG = {
            BOARD_WIDTH: 1000,
            BOARD_HEIGHT: 650,
            PLAYER_COLORS: ['#e94560', '#3498db', '#20bf6b', '#f7b731'],
            PLAYER_AVATARS: ['üî¨', '‚öóÔ∏è', 'üß™', '‚öõÔ∏è'],
            ELEMENT_CATEGORIES: {
                metals: { color: '#3498db', label: 'Metals', elements: ['Fe', 'Cu', 'Zn', 'Ag', 'Au'] },
                nonmetals: { color: '#e94560', label: 'Non-Metals', elements: ['C', 'O', 'N', 'S', 'P'] },
                halogens: { color: '#20bf6b', label: 'Halogens', elements: ['F', 'Cl', 'Br', 'I'] },
                noble: { color: '#f7b731', label: 'Noble Gases', elements: ['He', 'Ne', 'Ar', 'Kr'] }
            },
            MOLECULES: [
                { name: 'Water', formula: 'H2O', elements: ['H', 'H', 'O'], points: 100 },
                { name: 'Carbon Dioxide', formula: 'CO2', elements: ['C', 'O', 'O'], points: 120 },
                { name: 'Methane', formula: 'CH4', elements: ['C', 'H', 'H', 'H', 'H'], points: 150 },
                { name: 'Ammonia', formula: 'NH3', elements: ['N', 'H', 'H', 'H'], points: 130 },
                { name: 'Oxygen', formula: 'O2', elements: ['O', 'O'], points: 80 },
                { name: 'Nitrogen', formula: 'N2', elements: ['N', 'N'], points: 80 },
                { name: 'Salt', formula: 'NaCl', elements: ['Na', 'Cl'], points: 110 },
                { name: 'Iron Oxide', formula: 'Fe2O3', elements: ['Fe', 'Fe', 'O', 'O', 'O'], points: 180 },
                { name: 'Sulfuric Acid', formula: 'H2SO4', elements: ['H', 'H', 'S', 'O', 'O', 'O', 'O'], points: 250 },
                { name: 'Glucose', formula: 'C6H12O6', elements: ['C', 'C', 'C', 'C', 'C', 'C', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'H', 'O', 'O', 'O', 'O', 'O', 'O'], points: 400 }
            ],
            QUESTIONS: [
                { q: 'What is the atomic number of Carbon?', options: ['4', '6', '8', '12'], correct: 1, points: 50 },
                { q: 'Which element has the symbol "Fe"?', options: ['Fluorine', 'Iron', 'Fermium', 'Francium'], correct: 1, points: 50 },
                { q: 'What is the most abundant element in Earth\'s atmosphere?', options: ['Oxygen', 'Nitrogen', 'Carbon Dioxide', 'Argon'], correct: 1, points: 50 },
                { q: 'How many protons does Helium have?', options: ['1', '2', '4', '8'], correct: 1, points: 50 },
                { q: 'Which is NOT a noble gas?', options: ['Neon', 'Argon', 'Krypton', 'Chlorine'], correct: 3, points: 50 },
                { q: 'What is the chemical symbol for Gold?', options: ['Go', 'Gd', 'Au', 'Ag'], correct: 2, points: 50 },
                { q: 'Water (H2O) is an example of what type of compound?', options: ['Acid', 'Base', 'Salt', 'Oxide'], correct: 1, points: 50 },
                { q: 'What element has atomic number 1?', options: ['Helium', 'Hydrogen', 'Lithium', 'Carbon'], correct: 1, points: 50 },
                { q: 'Which element is essential for life and found in all organic molecules?', options: ['Oxygen', 'Carbon', 'Nitrogen', 'Hydrogen'], correct: 1, points: 50 },
                { q: 'What is the atomic mass of Oxygen?', options: ['8', '16', '32', '64'], correct: 1, points: 50 }
            ]
        };

        // Game State
        let gameState = {
            players: [],
            currentPlayer: 0,
            boardTiles: [],
            playerPositions: {},
            inventory: {},
            completedMolecules: {},
            scores: {},
            gamePhase: 'setup', // setup, playing, ended
            selectedElements: [],
            canRoll: true
        };

        // SVG.js instances
        let draw;
        let tileElements = {};
        let playerElements = {};

        // Initialize Game
        function initGame() {
            // Create SVG canvas
            draw = SVG().addTo('#game-canvas').size('100%', '100%').viewbox(0, 0, CONFIG.BOARD_WIDTH, CONFIG.BOARD_HEIGHT);

            // Create background
            createBackground();

            // Generate board tiles
            generateBoard();

            // Initialize players
            initializePlayers();

            // Setup UI
            setupEventListeners();

            // Show start modal
            showStartModal();
        }

        function createBackground() {
            // Gradient background
            const bgGradient = draw.gradient('linear', function(add) {
                add.stop(0, '#1a1a2e');
                add.stop(0.5, '#16213e');
                add.stop(1, '#0f3460');
            }).from(0, 0).to(0, 1);

            draw.rect(CONFIG.BOARD_WIDTH, CONFIG.BOARD_HEIGHT).fill(bgGradient);

            // Add decorative elements
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * CONFIG.BOARD_WIDTH;
                const y = Math.random() * CONFIG.BOARD_HEIGHT;
                const size = Math.random() * 3 + 1;
                const opacity = Math.random() * 0.5 + 0.1;

                draw.circle(size).move(x, y).fill('#fff').opacity(opacity);
            }

            // Add floating atoms decoration
            drawAtom(CONFIG.BOARD_WIDTH - 100, 80, 30, '#e94560', 0.3);
            drawAtom(100, CONFIG.BOARD_HEIGHT - 80, 25, '#3498db', 0.3);
            drawAtom(CONFIG.BOARD_WIDTH / 2, CONFIG.BOARD_HEIGHT / 2, 40, '#20bf6b', 0.2);
        }

        function drawAtom(x, y, size, color, opacity) {
            const group = draw.group();
            group.circle(size).center(x, y).fill('none').stroke({ color: color, width: 2, opacity: opacity });
            group.circle(size * 0.6).center(x, y).fill('none').stroke({ color: color, width: 2, opacity: opacity * 0.7 }).rotate(60, x, y);
            group.circle(size * 0.3).center(x, y).fill(color).opacity(opacity);
        }

        function generateBoard() {
            // Create a winding path with different tile types
            const pathPoints = generateWindingPath();

            pathPoints.forEach((point, index) => {
                const tileType = determineTileType(index);
                const tileData = {
                    x: point.x,
                    y: point.y,
                    type: tileType,
                    index: index,
                    element: tileType === 'element' ? getRandomElement() : null
                };
                gameState.boardTiles.push(tileData);
                createTile(tileData);
            });

            // Add decorative periodic table zones
            createPeriodicZones();
        }

        function generateWindingPath() {
            const points = [];
            const segments = [
                // Start area
                { start: [80, 580], end: [200, 580], steps: 8 },
                // Curve up
                { start: [200, 580], end: [280, 500], steps: 6 },
                // Zigzag pattern
                { start: [280, 500], end: [400, 550], steps: 6 },
                { start: [400, 550], end: [500, 450], steps: 6 },
                { start: [500, 450], end: [600, 520], steps: 6 },
                { start: [600, 520], end: [700, 400], steps: 6 },
                { start: [700, 400], end: [800, 480], steps: 6 },
                // Final stretch to finish
                { start: [800, 480], end: [900, 400], steps: 5 }
            ];

            let currentX = 80;
            let currentY = 580;

            segments.forEach(segment => {
                const startX = segment.start[0];
                const startY = segment.start[1];
                const endX = segment.end[0];
                const endY = segment.end[1];
                const steps = segment.steps;

                for (let i = 0; i < steps; i++) {
                    const t = i / steps;
                    const x = startX + (endX - startX) * t + (Math.random() - 0.5) * 20;
                    const y = startY + (endY - startY) * t + (Math.random() - 0.5) * 20;
                    points.push({ x, y });
                }
            });

            return points;
        }

        function determineTileType(index) {
            const totalTiles = gameState.boardTiles.length || 50;
            if (index === 0) return 'start';
            if (index === totalTiles - 1) return 'finish';
            if (index % 8 === 0) return 'question';
            if (index % 5 === 0) return 'element';
            if (index % 10 === 0) return 'bonus';
            return 'normal';
        }

        function getRandomElement() {
            const categories = Object.values(CONFIG.ELEMENT_CATEGORIES);
            const category = categories[Math.floor(Math.random() * categories.length)];
            return category.elements[Math.floor(Math.random() * category.elements.length)];
        }

        function createTile(tileData) {
            const { x, y, type, index } = tileData;
            const group = draw.group();

            let fillColor, strokeColor;

            switch (type) {
                case 'start':
                    fillColor = '#20bf6b';
                    strokeColor = '#1abc9c';
                    break;
                case 'finish':
                    fillColor = '#f7b731';
                    strokeColor = '#f39c12';
                    break;
                case 'question':
                    fillColor = '#9b59b6';
                    strokeColor = '#8e44ad';
                    break;
                case 'element':
                    fillColor = '#3498db';
                    strokeColor = '#2980b9';
                    break;
                case 'bonus':
                    fillColor = '#e94560';
                    strokeColor = '#d63447';
                    break;
                default:
                    fillColor = 'rgba(255, 255, 255, 0.1)';
                    strokeColor = 'rgba(255, 255, 255, 0.3)';
            }

            // Tile base
            const tile = group.rect(50, 50)
                .center(x, y)
                .fill(fillColor)
                .stroke({ color: strokeColor, width: 2 })
                .radius(8)
                .opacity(0.9);

            // Add subtle glow effect
            if (type !== 'normal') {
                group.rect(50, 50)
                    .center(x, y)
                    .fill(fillColor)
                    .radius(8)
                    .opacity(0.3)
                    .animate(2000)
                    .attr({ opacity: 0.1 })
                    .loop(true, true);
            }

            // Tile content
            let content;
            switch (type) {
                case 'start':
                    content = group.text('START').font({ size: 10, weight: 'bold', family: 'Arial' }).center(x, y).fill('#fff');
                    break;
                case 'finish':
                    content = group.text('FINISH').font({ size: 10, weight: 'bold', family: 'Arial' }).center(x, y).fill('#000');
                    break;
                case 'question':
                    content = group.text('?').font({ size: 20, weight: 'bold', family: 'Arial' }).center(x, y).fill('#fff');
                    break;
                case 'element':
                    const elem = tileData.element;
                    content = group.text(elem).font({ size: 14, weight: 'bold', family: 'Arial' }).center(x, y).fill('#fff');
                    break;
                case 'bonus':
                    content = group.text('‚òÖ').font({ size: 16, weight: 'bold', family: 'Arial' }).center(x, y).fill('#fff');
                    break;
            }

            // Tile number
            group.text(String(index + 1))
                .font({ size: 8, family: 'Arial' })
                .center(x + 18, y - 18)
                .fill('#8892b0');

            tileElements[index] = group;

            // Hover effects
            group.css({ cursor: 'pointer' });
            group.on('mouseenter', () => {
                tile.animate(200).transform({ scale: 1.1 });
                showTileTooltip(tileData, x, y);
            });
            group.on('mouseleave', () => {
                tile.animate(200).transform({ scale: 1 });
                hideTooltip();
            });
        }

        function createPeriodicZones() {
            // Create decorative zone labels
            const zones = [
                { text: 'Metals', x: 250, y: 150, color: '#3498db' },
                { text: 'Non-Metals', x: 700, y: 200, color: '#e94560' },
                { text: 'Noble Gases', x: 450, y: 100, color: '#f7b731' },
                { text: 'Halogens', x: 600, y: 300, color: '#20bf6b' }
            ];

            zones.forEach(zone => {
                const zoneGroup = draw.group();

                // Zone background
                zoneGroup.rect(120, 40)
                    .center(zone.x, zone.y)
                    .fill(zone.color)
                    .opacity(0.2)
                    .radius(10);

                // Zone label
                zoneGroup.text(zone.text)
                    .font({ size: 14, weight: 'bold', family: 'Arial' })
                    .center(zone.x, zone.y)
                    .fill(zone.color);
            });

            // Title
            draw.text('PERIODIC TABLE ADVENTURE')
                .font({ size: 24, weight: 'bold', family: 'Arial' })
                .center(CONFIG.BOARD_WIDTH / 2, 40)
                .fill('rgba(255, 255, 255, 0.3)');
        }

        let tooltipElement = null;

        function showTileTooltip(tileData, x, y) {
            hideTooltip();

            let content = '';
            switch (tileData.type) {
                case 'start':
                    content = 'Starting Point - Begin your journey!';
                    break;
                case 'finish':
                    content = 'Finish Line - Complete the race!';
                    break;
                case 'question':
                    content = 'Challenge Tile - Answer a chemistry question!';
                    break;
                case 'element':
                    content = `Element Tile - Collect ${tileData.element}!`;
                    break;
                case 'bonus':
                    content = 'Bonus Tile - Get extra points!';
                    break;
                default:
                    content = `Tile ${tileData.index + 1}`;
            }

            tooltipElement = draw.group();
            tooltipElement.rect(200, 35)
                .move(x - 100, y - 80)
                .fill('rgba(0, 0, 0, 0.9)')
                .stroke({ color: '#e94560', width: 1 })
                .radius(5);
            tooltipElement.text(content)
                .font({ size: 12, family: 'Arial' })
                .center(x, y - 62)
                .fill('#fff');
        }

        function hideTooltip() {
            if (tooltipElement) {
                tooltipElement.remove();
                tooltipElement = null;
            }
        }

        function initializePlayers() {
            const playerCount = Math.min(4, Math.max(2, parseInt(localStorage.getItem('playerCount') || '2')));
            localStorage.removeItem('playerCount');

            for (let i = 0; i < playerCount; i++) {
                const player = {
                    id: i,
                    name: `Player ${i + 1}`,
                    color: CONFIG.PLAYER_COLORS[i],
                    avatar: CONFIG.PLAYER_AVATARS[i],
                    position: 0
                };

                gameState.players.push(player);
                gameState.playerPositions[i] = 0;
                gameState.inventory[i] = [];
                gameState.completedMolecules[i] = [];
                gameState.scores[i] = 0;
            }

            gameState.currentPlayer = 0;
            updatePlayerDisplay();
            placePlayers();
        }

        function placePlayers() {
            gameState.players.forEach((player, index) => {
                const pos = gameState.playerPositions[index];
                const tile = gameState.boardTiles[pos];
                if (!tile) return;

                const offsetX = (index - (gameState.players.length - 1) / 2) * 15;
                const playerGroup = draw.group();

                // Player token
                playerGroup.circle(30)
                    .center(tile.x + offsetX, tile.y)
                    .fill(player.color)
                    .stroke({ color: '#fff', width: 2 })
                    .radius(15);

                // Avatar
                playerGroup.text(player.avatar)
                    .font({ size: 14 })
                    .center(tile.x + offsetX, tile.y);

                // Pulse animation for current player
                if (index === gameState.currentPlayer) {
                    playerGroup.circle(35)
                        .center(tile.x + offsetX, tile.y)
                        .fill('none')
                        .stroke({ color: player.color, width: 2 })
                        .radius(17)
                        .opacity(0.8)
                        .animate(1000)
                        .attr({ r: 40, opacity: 0 })
                        .loop();
                }

                playerElements[index] = playerGroup;
            });
        }

        function updatePlayerDisplay() {
            const playerList = document.getElementById('player-list');
            playerList.innerHTML = '';

            gameState.players.forEach((player, index) => {
                const div = document.createElement('div');
                div.className = `player-info ${index === gameState.currentPlayer ? 'active' : ''}`;
                div.innerHTML = `
                    <div class="player-avatar" style="background: ${player.color}">${player.avatar}</div>
                    <div class="player-details">
                        <div class="player-name">${player.name}</div>
                        <div class="player-stats">Score: ${gameState.scores[index]} | Elements: ${gameState.inventory[index].length}</div>
                    </div>
                `;
                playerList.appendChild(div);
            });

            // Update turn indicator
            document.getElementById('turn-indicator').textContent =
                `${gameState.players[gameState.currentPlayer].name}'s Turn`;
        }

        function updateInventoryDisplay() {
            const grid = document.getElementById('inventory-grid');
            grid.innerHTML = '';

            const inventory = gameState.inventory[gameState.currentPlayer];
            const maxSlots = 10;

            for (let i = 0; i < maxSlots; i++) {
                const slot = document.createElement('div');
                slot.className = `inventory-slot ${i < inventory.length ? 'has-element' : ''}`;
                slot.textContent = inventory[i] || '';
                slot.onclick = () => selectElement(inventory[i], i);
                grid.appendChild(slot);
            }

            // Update molecule list
            const moleculeList = document.getElementById('molecule-list');
            moleculeList.innerHTML = '';

            const molecules = gameState.completedMolecules[gameState.currentPlayer];
            molecules.forEach(mol => {
                const div = document.createElement('div');
                div.className = 'molecule-item completed';
                div.innerHTML = `<strong>${mol.formula}</strong> - ${mol.name} (+${mol.points}pts)`;
                moleculeList.appendChild(div);
            });

            // Show available molecules to craft
            CONFIG.MOLECULES.filter(mol =>
                !molecules.find(m => m.formula === mol.formula) &&
                mol.elements.every(e => inventory.includes(e))
            ).forEach(mol => {
                const div = document.createElement('div');
                div.className = 'molecule-item';
                div.innerHTML = `<strong>${mol.formula}</strong> - ${mol.name} (${mol.points}pts)`;
                div.style.cursor = 'pointer';
                div.onclick = () => craftMolecule(mol);
                moleculeList.appendChild(div);
            });
        }

        function selectElement(element, index) {
            const pos = gameState.selectedElements.indexOf(index);
            if (pos > -1) {
                gameState.selectedElements.splice(pos, 1);
            } else if (gameState.selectedElements.length < 2) {
                gameState.selectedElements.push(index);
            }
            updateInventoryDisplay();
        }

        function craftMolecule(molecule) {
            const player = gameState.currentPlayer;
            const inventory = gameState.inventory[player];

            // Check if we have all required elements
            const canCraft = molecule.elements.every(elem => {
                const count = molecule.elements.filter(e => e === elem).length;
                const have = inventory.filter(e => e === elem).length;
                return have >= count;
            });

            if (canCraft) {
                // Remove used elements
                molecule.elements.forEach(elem => {
                    const index = inventory.indexOf(elem);
                    if (index > -1) inventory.splice(index, 1);
                });

                // Add molecule to completed
                gameState.completedMolecules[player].push({
                    name: molecule.name,
                    formula: molecule.formula,
                    points: molecule.points
                });

                // Add points
                gameState.scores[player] += molecule.points;

                addLog(`${gameState.players[player].name} crafted ${molecule.name} (${molecule.formula})! +${molecule.points} points!`, 'success');
                updatePlayerDisplay();
                updateInventoryDisplay();

                // Check win condition
                checkWinCondition();
            }
        }

        function setupEventListeners() {
            document.getElementById('roll-btn').addEventListener('click', rollDice);
            document.getElementById('pass-btn').addEventListener('click', passTurn);
            document.getElementById('combine-btn').addEventListener('click', combineElements);
        }

        function rollDice() {
            if (!gameState.canRoll || gameState.gamePhase !== 'playing') return;

            gameState.canRoll = false;
            const btn = document.getElementById('roll-btn');
            btn.disabled = true;

            // Animate dice
            let rolls = 0;
            const rollInterval = setInterval(() => {
                const value = Math.floor(Math.random() * 6) + 1;
                document.getElementById('dice-value').textContent = value;
                rolls++;
                if (rolls > 10) {
                    clearInterval(rollInterval);
                    const finalValue = Math.floor(Math.random() * 6) + 1;
                    document.getElementById('dice-value').textContent = finalValue;
                    movePlayer(finalValue);
                }
            }, 100);
        }

        function movePlayer(steps) {
            const player = gameState.currentPlayer;
            const currentPos = gameState.playerPositions[player];
            let newPos = Math.min(currentPos + steps, gameState.boardTiles.length - 1);

            // Animate movement
            animatePlayerMovement(player, currentPos, newPos, () => {
                gameState.playerPositions[player] = newPos;
                handleTileAction(newPos);
            });
        }

        function animatePlayerMovement(playerIndex, fromIndex, toIndex, callback) {
            const player = gameState.players[playerIndex];
            const playerGroup = playerElements[playerIndex];

            if (!playerGroup) {
                callback();
                return;
            }

            const steps = Math.abs(toIndex - fromIndex);
            const duration = Math.max(500, steps * 100);
            const startTile = gameState.boardTiles[fromIndex];
            const endTile = gameState.boardTiles[toIndex];

            // Remove old position
            playerGroup.remove();

            // Create new animated player
            const newPlayerGroup = draw.group();

            newPlayerGroup.circle(30)
                .center(startTile.x, startTile.y)
                .fill(player.color)
                .stroke({ color: '#fff', width: 2 })
                .radius(15);

            newPlayerGroup.text(player.avatar)
                .font({ size: 14 })
                .center(startTile.x, startTile.y);

            playerElements[playerIndex] = newPlayerGroup;

            // Animate
            const animDuration = duration / steps;

            for (let i = 0; i <= steps; i++) {
                const tileIndex = fromIndex < toIndex ? fromIndex + i : fromIndex - i;
                const tile = gameState.boardTiles[tileIndex];
                const offsetX = (playerIndex - (gameState.players.length - 1) / 2) * 15;

                setTimeout(() => {
                    newPlayerGroup.animate(animDuration * 0.9)
                        .center(tile.x + offsetX, tile.y);
                }, i * animDuration);
            }

            setTimeout(() => {
                // Pulse animation for current player
                if (playerIndex === gameState.currentPlayer) {
                    newPlayerGroup.circle(35)
                        .center(endTile.x, endTile.y)
                        .fill('none')
                        .stroke({ color: player.color, width: 2 })
                        .radius(17)
                        .opacity(0.8)
                        .animate(1000)
                        .attr({ r: 40, opacity: 0 })
                        .loop();
                }
                callback();
            }, duration + 100);
        }

        function handleTileAction(tileIndex) {
            const tile = gameState.boardTiles[tileIndex];
            const player = gameState.currentPlayer;

            setTimeout(() => {
                switch (tile.type) {
                    case 'element':
                        collectElement(tile.element, player);
                        break;
                    case 'question':
                        showQuestion();
                        break;
                    case 'bonus':
                        gameState.scores[player] += 25;
                        addLog(`${gameState.players[player].name} found bonus points! +25`, 'success');
                        updatePlayerDisplay();
                        endTurn();
                        break;
                    case 'finish':
                        gameState.scores[player] += 50;
                        addLog(`${gameState.players[player].name} reached the finish! +50 bonus`, 'important');
                        updatePlayerDisplay();
                        checkWinCondition();
                        break;
                    default:
                        endTurn();
                }
            }, 300);
        }

        function collectElement(element, player) {
            const inventory = gameState.inventory[player];
            if (inventory.length < 10) {
                inventory.push(element);
                addLog(`${gameState.players[player].name} collected ${element}!`, 'success');
            } else {
                addLog(`${gameState.players[player].name}'s inventory is full!`, 'error');
            }
            updatePlayerDisplay();
            updateInventoryDisplay();
            endTurn();
        }

        function showQuestion() {
            const question = CONFIG.QUESTIONS[Math.floor(Math.random() * CONFIG.QUESTIONS.length)];

            showModal({
                title: 'üß™ Chemistry Challenge!',
                content: `
                    <div class="question-text">${question.q}</div>
                    <div class="element-card-display">
                        ${question.options.map((opt, i) => `
                            <button class="answer-btn" data-index="${i}">${String.fromCharCode(65 + i)}. ${opt}</button>
                        `).join('')}
                    </div>
                `,
                buttons: [],
                onReady: () => {
                    document.querySelectorAll('.answer-btn').forEach(btn => {
                        btn.addEventListener('click', () => handleAnswer(btn, question));
                    });
                }
            });
        }

        function handleAnswer(btn, question) {
            const selectedIndex = parseInt(btn.dataset.index);
            const isCorrect = selectedIndex === question.correct;
            const player = gameState.currentPlayer;

            // Disable all buttons
            document.querySelectorAll('.answer-btn').forEach(b => {
                b.disabled = true;
                const idx = parseInt(b.dataset.index);
                if (idx === question.correct) {
                    b.classList.add('correct');
                } else if (idx === selectedIndex && !isCorrect) {
                    b.classList.add('incorrect');
                }
            });

            setTimeout(() => {
                if (isCorrect) {
                    gameState.scores[player] += question.points;
                    addLog(`${gameState.players[player].name} answered correctly! +${question.points} points`, 'success');
                    showModal({
                        title: '‚úÖ Correct!',
                        content: `<p>Great job! You earned <strong>${question.points} points</strong>!</p>`,
                        buttons: [{ text: 'Continue', action: () => closeModal(); endTurn(); }]
                    });
                } else {
                    addLog(`${gameState.players[player].name} answered incorrectly.`, 'error');
                    showModal({
                        title: '‚ùå Incorrect',
                        content: `<p>Don't worry! The correct answer was: <strong>${question.options[question.correct]}</strong></p>`,
                        buttons: [{ text: 'Try Again', action: () => closeModal(); endTurn(); }]
                    });
                }
                updatePlayerDisplay();
            }, 1000);
        }

        function combineElements() {
            const player = gameState.currentPlayer;
            const inventory = gameState.inventory[player];

            if (gameState.selectedElements.length !== 2) {
                addLog('Select exactly 2 elements to combine!', 'error');
                return;
            }

            const elem1 = inventory[gameState.selectedElements[0]];
            const elem2 = inventory[gameState.selectedElements[1]];

            // Check for known molecules
            const possibleMolecule = CONFIG.MOLECULES.find(mol => {
                const needed = [...mol.elements];
                const has1 = needed.filter(e => e === elem1).length;
                const has2 = needed.filter(e => e === elem2).length;
                return (elem1 === elem2 && mol.elements.filter(e => e === elem1).length >= 2) ||
                       (elem1 !== elem2 && has1 >= 1 && has2 >= 1);
            });

            if (possibleMolecule) {
                craftMolecule(possibleMolecule);
            } else {
                addLog(`${elem1} + ${elem2} doesn't form a known molecule. Keep collecting!`, 'important');
            }

            gameState.selectedElements = [];
        }

        function passTurn() {
            addLog(`${gameState.players[gameState.currentPlayer].name} passed their turn.`);
            endTurn();
        }

        function endTurn() {
            gameState.currentPlayer = (gameState.currentPlayer + 1) % gameState.players.length;
            gameState.canRoll = true;
            gameState.selectedElements = [];

            updatePlayerDisplay();
            updateInventoryDisplay();

            document.getElementById('roll-btn').disabled = false;

            // Check if next player has reached finish
            if (gameState.playerPositions[gameState.currentPlayer] >= gameState.boardTiles.length - 1) {
                endTurn(); // Skip finished players
            }
        }

        function checkWinCondition() {
            const player = gameState.currentPlayer;
            const pos = gameState.playerPositions[player];

            // Win if reached finish OR score >= 1000
            if (pos >= gameState.boardTiles.length - 1 || gameState.scores[player] >= 1000) {
                gameState.gamePhase = 'ended';
                showWinner(player);
            }
        }

        function showWinner(playerIndex) {
            const player = gameState.players[playerIndex];

            showModal({
                title: 'üèÜ Victory!',
                content: `
                    <div class="winner-display">
                        <div class="winner-avatar">${player.avatar}</div>
                        <div class="winner-score">${player.name} Wins!</div>
                        <p>Final Score: ${gameState.scores[playerIndex]} points</p>
                        <div class="final-stats">
                            <p>Molecules Crafted: ${gameState.completedMolecules[playerIndex].length}</p>
                            <p>Elements Collected: ${gameState.inventory[playerIndex].length}</p>
                        </div>
                    </div>
                `,
                buttons: [{ text: 'Play Again', action: () => location.reload(); }]
            });
        }

        function showStartModal() {
            showModal({
                title: '‚öóÔ∏è Elemental Odyssey',
                content: `
                    <p style="margin-bottom: 15px;">Welcome to your chemistry adventure!</p>
                    <p style="margin-bottom: 15px;"><strong>Objective:</strong> Travel through the periodic table, collect elements, and craft molecules to earn the highest score!</p>
                    <h4 style="margin: 15px 0 10px; color: #e94560;">How to Play:</h4>
                    <ol class="instructions-list">
                        <li>Roll the dice to move around the board</li>
                        <li><strong>Element Tiles:</strong> Collect chemical elements</li>
                        <li><strong>Question Tiles:</strong> Answer chemistry questions for bonus points</li>
                        <li><strong>Bonus Tiles:</strong> Get extra points!</li>
                        <li>Combine elements in your inventory to craft molecules</li>
                        <li>First to 1000 points OR reach the finish wins!</li>
                    </ol>
                    <p style="margin-top: 15px; color: #f7b731;">Good luck, young chemist! üî¨</p>
                `,
                buttons: [{ text: 'Start Game', action: () => closeModal(); startGame(); }]
            });
        }

        function startGame() {
            gameState.gamePhase = 'playing';
            addLog('Game started! Roll the dice to begin your journey!', 'important');
        }

        function showModal(config) {
            const overlay = document.getElementById('modal-overlay');
            const content = document.getElementById('modal-content');

            content.innerHTML = `
                <h2 class="modal-title">${config.title}</h2>
                <div class="modal-content">${config.content}</div>
                <div class="modal-buttons">
                    ${config.buttons.map(btn => `
                        <button class="game-btn btn-primary" data-action="${btn.action ? 'custom' : 'close'}">
                            ${btn.text}
                        </button>
                    `).join('')}
                </div>
            `;

            overlay.classList.add('active');

            // Setup button actions
            content.querySelectorAll('.game-btn').forEach((btn, index) => {
                btn.addEventListener('click', () => {
                    if (config.buttons[index].action) {
                        config.buttons[index].action();
                    } else {
                        closeModal();
                    }
                });
            });

            // Call onReady if provided
            if (config.onReady) {
                config.onReady();
            }
        }

        function closeModal() {
            document.getElementById('modal-overlay').classList.remove('active');
        }

        function addLog(message, type = '') {
            const log = document.getElementById('game-log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = message;
            log.insertBefore(entry, log.firstChild);

            // Keep only last 50 entries
            while (log.children.length > 50) {
                log.removeChild(log.lastChild);
            }
        }

        // Start the game when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
