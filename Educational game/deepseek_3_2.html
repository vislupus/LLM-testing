<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Quest: The Geometric Kingdom</title>
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2.2/dist/svg.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a237e 0%, #311b92 100%);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 1000px;
        }

        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #ff9800, #ffeb3b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .subtitle {
            font-size: 1.2rem;
            color: #bbdefb;
            margin-bottom: 20px;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
        }

        .main-game-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            width: 100%;
        }

        .board-container {
            flex: 1;
            min-width: 700px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #game-board {
            width: 100%;
            height: 600px;
            border-radius: 15px;
            overflow: hidden;
            background: linear-gradient(145deg, #0d47a1, #1565c0);
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5);
        }

        .controls-panel {
            width: 300px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel-title {
            font-size: 1.5rem;
            color: #ffeb3b;
            text-align: center;
            margin-bottom: 10px;
            border-bottom: 2px solid #ff9800;
            padding-bottom: 8px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .player-color {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid white;
        }

        .player-details {
            flex: 1;
        }

        .player-name {
            font-weight: bold;
            font-size: 1.2rem;
        }

        .player-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #bbdefb;
            margin-top: 5px;
        }

        .dice-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #dice {
            width: 100px;
            height: 100px;
            background: white;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            font-weight: bold;
            color: #333;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: transform 0.3s;
        }

        #dice:hover {
            transform: scale(1.05);
        }

        .dice-label {
            font-size: 1.1rem;
            color: #ffeb3b;
        }

        .btn {
            padding: 15px 25px;
            font-size: 1.1rem;
            font-weight: bold;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            background: linear-gradient(135deg, #ff9800, #ff5722);
            color: white;
            box-shadow: 0 5px 15px rgba(255, 87, 34, 0.4);
            text-align: center;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(255, 87, 34, 0.6);
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .challenge-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-top: 10px;
        }

        .challenge-title {
            font-size: 1.3rem;
            color: #ffeb3b;
            margin-bottom: 15px;
            text-align: center;
        }

        .challenge-question {
            font-size: 1.2rem;
            margin-bottom: 20px;
            line-height: 1.5;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
        }

        .answer-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .answer-btn {
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .answer-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #ff9800;
        }

        .answer-btn.correct {
            background: rgba(76, 175, 80, 0.7);
            border-color: #4caf50;
        }

        .answer-btn.incorrect {
            background: rgba(244, 67, 54, 0.7);
            border-color: #f44336;
        }

        .info-panel {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .info-title {
            font-size: 0.9rem;
            color: #bbdefb;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #ffeb3b;
        }

        .tutorial-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            max-width: 1000px;
            width: 100%;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .tutorial-title {
            font-size: 1.5rem;
            color: #ffeb3b;
            margin-bottom: 15px;
            text-align: center;
        }

        .tutorial-content {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }

        .tutorial-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .tutorial-icon {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .tutorial-card h4 {
            color: #ff9800;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .tutorial-card p {
            font-size: 0.95rem;
            color: #bbdefb;
            line-height: 1.4;
        }

        .game-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px 50px;
            border-radius: 20px;
            text-align: center;
            z-index: 1000;
            border: 3px solid #ff9800;
            box-shadow: 0 0 50px rgba(255, 152, 0, 0.5);
            display: none;
        }

        .message-title {
            font-size: 2.5rem;
            color: #ffeb3b;
            margin-bottom: 15px;
        }

        .message-text {
            font-size: 1.3rem;
            margin-bottom: 25px;
            color: #fff;
        }

        .achievement {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border-left: 5px solid #ff9800;
            display: none;
            z-index: 1000;
            max-width: 300px;
        }

        .achievement-title {
            color: #ffeb3b;
            font-weight: bold;
            margin-bottom: 5px;
        }

        @media (max-width: 1100px) {
            .main-game-area {
                flex-direction: column;
                align-items: center;
            }
            
            .board-container {
                min-width: 95%;
            }
            
            .controls-panel {
                width: 95%;
            }
            
            .tutorial-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Math Quest: The Geometric Kingdom</h1>
        <p class="subtitle">An educational adventure through the world of geometry and shapes!</p>
    </div>

    <div class="game-container">
        <div class="main-game-area">
            <div class="board-container">
                <div id="game-board"></div>
            </div>
            
            <div class="controls-panel">
                <div class="panel-title">Players</div>
                
                <div id="player-info-container">
                    <!-- Player info will be dynamically added here -->
                </div>
                
                <div class="dice-container">
                    <div class="dice-label">Click to Roll Dice</div>
                    <div id="dice">?</div>
                    <div id="current-player">Current Player: <span id="current-player-name">Red</span></div>
                </div>
                
                <button id="roll-btn" class="btn">Roll Dice & Move</button>
                <button id="new-game-btn" class="btn">New Game</button>
                
                <div class="info-panel">
                    <div class="info-card">
                        <div class="info-title">Turn</div>
                        <div class="info-value" id="turn-number">1</div>
                    </div>
                    <div class="info-card">
                        <div class="info-title">Challenges Solved</div>
                        <div class="info-value" id="challenges-solved">0</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="challenge-panel" id="challenge-panel" style="display: none;">
            <div class="challenge-title">Geometry Challenge!</div>
            <div class="challenge-question" id="challenge-question"></div>
            <div class="answer-options" id="answer-options"></div>
            <button id="submit-answer-btn" class="btn" disabled>Submit Answer</button>
        </div>
        
        <div class="tutorial-panel">
            <div class="tutorial-title">How to Play</div>
            <div class="tutorial-content">
                <div class="tutorial-card">
                    <div class="tutorial-icon">üé≤</div>
                    <h4>Roll & Move</h4>
                    <p>Roll the dice and move your player piece along the geometric path. Each space has a unique geometry challenge.</p>
                </div>
                <div class="tutorial-card">
                    <div class="tutorial-icon">‚ùì</div>
                    <h4>Solve Challenges</h4>
                    <p>When you land on a challenge space, answer a geometry question correctly to earn knowledge points and special abilities.</p>
                </div>
                <div class="tutorial-card">
                    <div class="tutorial-icon">üèÜ</div>
                    <h4>Win the Game</h4>
                    <p>Be the first to reach the Castle of Knowledge at the end of the board, or collect the most knowledge points in 30 turns.</p>
                </div>
            </div>
        </div>
    </div>
    
    <div class="game-message" id="game-message">
        <div class="message-title" id="message-title">Congratulations!</div>
        <div class="message-text" id="message-text"></div>
        <button id="close-message-btn" class="btn">Continue Playing</button>
    </div>
    
    <div class="achievement" id="achievement">
        <div class="achievement-title" id="achievement-title">Geometry Master!</div>
        <div class="achievement-text" id="achievement-text">Solved 5 geometry challenges in a row</div>
    </div>

    <script>
        // Game State
        const gameState = {
            players: [],
            currentPlayerIndex: 0,
            gameBoard: null,
            dice: null,
            turn: 1,
            maxTurns: 30,
            isGameActive: true,
            playerPositions: {},
            playerKnowledge: {},
            challengesSolved: 0,
            currentChallenge: null,
            boardSpaces: []
        };

        // Geometry questions database
        const geometryQuestions = [
            {
                question: "What is the sum of interior angles in a triangle?",
                options: ["90¬∞", "180¬∞", "270¬∞", "360¬∞"],
                correctAnswer: 1,
                difficulty: 1,
                category: "Angles"
            },
            {
                question: "How many sides does a hexagon have?",
                options: ["4", "5", "6", "8"],
                correctAnswer: 2,
                difficulty: 1,
                category: "Polygons"
            },
            {
                question: "What is the area of a rectangle with length 8 and width 5?",
                options: ["13", "26", "40", "80"],
                correctAnswer: 2,
                difficulty: 1,
                category: "Area"
            },
            {
                question: "What is the value of œÄ (pi) to two decimal places?",
                options: ["3.14", "3.16", "3.18", "3.20"],
                correctAnswer: 0,
                difficulty: 1,
                category: "Circles"
            },
            {
                question: "How many degrees are in a right angle?",
                options: ["45¬∞", "90¬∞", "180¬∞", "360¬∞"],
                correctAnswer: 1,
                difficulty: 1,
                category: "Angles"
            },
            {
                question: "What is the perimeter of a square with side length 7?",
                options: ["14", "21", "28", "49"],
                correctAnswer: 2,
                difficulty: 2,
                category: "Perimeter"
            },
            {
                question: "A triangle with all sides equal is called:",
                options: ["Isosceles", "Scalene", "Equilateral", "Right"],
                correctAnswer: 2,
                difficulty: 2,
                category: "Triangles"
            },
            {
                question: "What is the formula for the circumference of a circle?",
                options: ["œÄr", "2œÄr", "œÄr¬≤", "2œÄr¬≤"],
                correctAnswer: 1,
                difficulty: 2,
                category: "Circles"
            },
            {
                question: "How many faces does a cube have?",
                options: ["4", "6", "8", "12"],
                correctAnswer: 1,
                difficulty: 2,
                category: "3D Shapes"
            },
            {
                question: "What is the area of a triangle with base 10 and height 6?",
                options: ["16", "30", "60", "80"],
                correctAnswer: 1,
                difficulty: 2,
                category: "Area"
            },
            {
                question: "What is the volume of a cube with side length 3?",
                options: ["9", "18", "27", "36"],
                correctAnswer: 2,
                difficulty: 3,
                category: "Volume"
            },
            {
                question: "In a right triangle, a¬≤ + b¬≤ = c¬≤ is known as:",
                options: ["Euler's formula", "Pythagorean theorem", "Newton's law", "Fibonacci sequence"],
                correctAnswer: 1,
                difficulty: 3,
                category: "Triangles"
            },
            {
                question: "How many edges does a tetrahedron have?",
                options: ["4", "6", "8", "12"],
                correctAnswer: 1,
                difficulty: 3,
                category: "3D Shapes"
            },
            {
                question: "What is the sum of exterior angles of any polygon?",
                options: ["90¬∞", "180¬∞", "360¬∞", "720¬∞"],
                correctAnswer: 2,
                difficulty: 3,
                category: "Polygons"
            },
            {
                question: "A polygon with 8 sides is called:",
                options: ["Hexagon", "Heptagon", "Octagon", "Nonagon"],
                correctAnswer: 2,
                difficulty: 3,
                category: "Polygons"
            }
        ];

        // Special spaces on the board
        const specialSpaces = {
            CHALLENGE: 'challenge',
            KNOWLEDGE_BOOST: 'knowledge_boost',
            TELEPORT: 'teleport',
            TRAP: 'trap',
            BONUS: 'bonus'
        };

        // Initialize the game
        function initGame() {
            // Create SVG drawing area
            const board = SVG().addTo('#game-board').size('100%', '100%');
            gameState.gameBoard = board;
            
            // Initialize players
            initPlayers();
            
            // Draw the game board
            drawBoard();
            
            // Position players at start
            positionPlayers();
            
            // Set up event listeners
            setupEventListeners();
            
            // Update UI
            updateUI();
            
            // Show welcome message
            showMessage("Welcome to Math Quest!", "Roll the dice to start your geometric adventure!");
        }

        // Initialize players
        function initPlayers() {
            const playerColors = [
                { name: "Red", color: "#ff5252" },
                { name: "Blue", color: "#448aff" },
                { name: "Green", color: "#69f0ae" },
                { name: "Yellow", color: "#ffeb3b" }
            ];
            
            gameState.players = playerColors;
            gameState.currentPlayerIndex = 0;
            
            // Initialize player positions and knowledge
            playerColors.forEach(player => {
                gameState.playerPositions[player.name] = 0;
                gameState.playerKnowledge[player.name] = 0;
            });
            
            // Render player info in the UI
            renderPlayerInfo();
        }

        // Render player information
        function renderPlayerInfo() {
            const container = document.getElementById('player-info-container');
            container.innerHTML = '';
            
            gameState.players.forEach((player, index) => {
                const isCurrent = index === gameState.currentPlayerIndex;
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';
                if (isCurrent) {
                    playerInfo.style.background = 'rgba(255, 152, 0, 0.3)';
                    playerInfo.style.border = '2px solid #ff9800';
                }
                
                playerInfo.innerHTML = `
                    <div class="player-color" style="background-color: ${player.color}"></div>
                    <div class="player-details">
                        <div class="player-name">${player.name}</div>
                        <div class="player-stats">
                            <span>Position: ${gameState.playerPositions[player.name] + 1}</span>
                            <span>Knowledge: ${gameState.playerKnowledge[player.name]}</span>
                        </div>
                    </div>
                `;
                
                container.appendChild(playerInfo);
            });
            
            // Update current player name
            document.getElementById('current-player-name').textContent = 
                gameState.players[gameState.currentPlayerIndex].name;
        }

        // Draw the game board
        function drawBoard() {
            const board = gameState.gameBoard;
            const width = 700;
            const height = 600;
            
            // Clear the board
            board.clear();
            
            // Draw background with geometric pattern
            drawBackground();
            
            // Draw the spiral path
            drawSpiralPath();
            
            // Draw special spaces
            drawSpecialSpaces();
            
            // Draw the castle at the end
            drawCastle();
        }

        // Draw background with geometric pattern
        function drawBackground() {
            const board = gameState.gameBoard;
            const width = 700;
            const height = 600;
            
            // Draw gradient background
            const bg = board.rect(width, height).fill({ color: '#0d47a1' });
            
            // Add geometric pattern
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const size = Math.random() * 30 + 10;
                const opacity = Math.random() * 0.1 + 0.05;
                
                // Random geometric shapes in background
                const shapeType = Math.floor(Math.random() * 3);
                if (shapeType === 0) {
                    board.circle(size).center(x, y).fill({ color: '#1565c0', opacity });
                } else if (shapeType === 1) {
                    board.rect(size, size).center(x, y).fill({ color: '#1e88e5', opacity });
                } else {
                    board.polygon(`${x},${y} ${x+size},${y+size/2} ${x},${y+size}`).fill({ color: '#42a5f5', opacity });
                }
            }
        }

        // Draw the spiral path
        function drawSpiralPath() {
            const board = gameState.gameBoard;
            const spaces = 40;
            const centerX = 350;
            const centerY = 300;
            const startRadius = 50;
            const angleStep = 0.3;
            const radiusStep = 15;
            
            gameState.boardSpaces = [];
            
            // Create spiral path
            for (let i = 0; i < spaces; i++) {
                const angle = i * angleStep;
                const radius = startRadius + i * radiusStep;
                
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                // Determine space type
                let spaceType = 'normal';
                let specialType = null;
                
                if (i === 0) {
                    spaceType = 'start';
                } else if (i === spaces - 1) {
                    spaceType = 'castle';
                } else if (i % 5 === 0) {
                    spaceType = 'challenge';
                    specialType = specialSpaces.CHALLENGE;
                } else if (i % 7 === 0) {
                    spaceType = 'knowledge';
                    specialType = specialSpaces.KNOWLEDGE_BOOST;
                } else if (i % 9 === 0) {
                    spaceType = 'teleport';
                    specialType = specialSpaces.TELEPORT;
                } else if (i % 11 === 0) {
                    spaceType = 'trap';
                    specialType = specialSpaces.TRAP;
                } else if (i % 13 === 0) {
                    spaceType = 'bonus';
                    specialType = specialSpaces.BONUS;
                }
                
                // Draw the space
                const space = drawSpace(x, y, i, spaceType);
                gameState.boardSpaces.push({
                    x, y, index: i, type: spaceType, specialType, element: space
                });
                
                // Draw space number
                if (i % 2 === 0 || i < 10) {
                    board.text(i + 1).center(x, y).font({
                        size: 12,
                        fill: '#fff',
                        family: 'Arial'
                    });
                }
            }
            
            // Connect spaces with a path
            const pathPoints = gameState.boardSpaces.map(space => `${space.x},${space.y}`);
            const pathString = 'M' + pathPoints.join(' L');
            board.path(pathString).stroke({ width: 8, color: '#fff', opacity: 0.3 }).fill('none');
        }

        // Draw a single space on the board
        function drawSpace(x, y, index, type) {
            const board = gameState.gameBoard;
            let space;
            
            // Different shapes for different space types
            switch(type) {
                case 'start':
                    space = board.rect(40, 40).center(x, y).fill({ color: '#4caf50' });
                    board.text('START').center(x, y).font({ size: 10, fill: '#fff', weight: 'bold' });
                    break;
                case 'castle':
                    space = drawCastleSpace(x, y);
                    break;
                case 'challenge':
                    space = board.rect(35, 35).center(x, y).fill({ color: '#ff9800' });
                    board.text('?').center(x, y).font({ size: 16, fill: '#fff', weight: 'bold' });
                    break;
                case 'knowledge':
                    space = board.circle(25).center(x, y).fill({ color: '#2196f3' });
                    board.text('K').center(x, y).font({ size: 14, fill: '#fff', weight: 'bold' });
                    break;
                case 'teleport':
                    space = board.polygon(`${x-15},${y+15} ${x},${y-15} ${x+15},${y+15}`).fill({ color: '#9c27b0' });
                    board.text('T').center(x, y).font({ size: 14, fill: '#fff', weight: 'bold' });
                    break;
                case 'trap':
                    space = board.rect(30, 30).center(x, y).fill({ color: '#f44336' }).rotate(45);
                    break;
                case 'bonus':
                    space = board.circle(30).center(x, y).fill({ color: '#ffeb3b' });
                    board.text('B').center(x, y).font({ size: 14, fill: '#333', weight: 'bold' });
                    break;
                default:
                    space = board.circle(20).center(x, y).fill({ color: '#fff', opacity: 0.3 });
                    break;
            }
            
            // Add glow effect for special spaces
            if (type !== 'normal' && type !== 'start') {
                space.stroke({ width: 3, color: '#fff' });
            }
            
            return space;
        }

        // Draw the castle space
        function drawCastleSpace(x, y) {
            const board = gameState.gameBoard;
            const group = board.group();
            
            // Castle base
            group.rect(50, 40).center(x, y - 5).fill({ color: '#795548' });
            
            // Castle towers
            group.rect(15, 30).center(x - 15, y - 20).fill({ color: '#9e9e9e' });
            group.rect(15, 30).center(x + 15, y - 20).fill({ color: '#9e9e9e' });
            
            // Castle flags
            group.polygon(`${x-15},${y-35} ${x-8},${y-35} ${x-8},${y-45}`).fill({ color: '#f44336' });
            group.polygon(`${x+15},${y-35} ${x+8},${y-35} ${x+8},${y-45}`).fill({ color: '#f44336' });
            
            return group;
        }

        // Draw the castle at the center
        function drawCastle() {
            const board = gameState.gameBoard;
            const castle = board.group().translate(550, 50);
            
            // Castle base
            castle.rect(120, 80).fill({ color: '#795548' });
            
            // Castle walls
            castle.rect(140, 60).y(20).x(-10).fill({ color: '#9e9e9e' });
            
            // Castle towers
            castle.rect(30, 100).x(-20).fill({ color: '#757575' });
            castle.rect(30, 100).x(110).fill({ color: '#757575' });
            
            // Tower roofs
            castle.polygon("-20,0 10,0 -5,-30").fill({ color: '#f44336' });
            castle.polygon("110,0 140,0 125,-30").fill({ color: '#f44336' });
            
            // Castle gate
            castle.rect(40, 50).x(40).y(30).fill({ color: '#5d4037' });
            castle.circle(10).center(60, 55).fill({ color: '#ffeb3b' });
            
            // Banner
            castle.text("GOAL").center(70, 15).font({ size: 16, fill: '#ffeb3b', weight: 'bold' });
            
            return castle;
        }

        // Draw special spaces
        function drawSpecialSpaces() {
            // Already handled in drawSpiralPath
        }

        // Position players on the board
        function positionPlayers() {
            // Remove existing player markers
            gameState.gameBoard.find('circle.player-marker').forEach(marker => marker.remove());
            
            // Place each player on their current position
            gameState.players.forEach((player, playerIndex) => {
                const position = gameState.playerPositions[player.name];
                if (position < gameState.boardSpaces.length) {
                    const space = gameState.boardSpaces[position];
                    
                    // Calculate offset based on player index (so players don't overlap)
                    const angle = (playerIndex / gameState.players.length) * Math.PI * 2;
                    const offsetX = Math.cos(angle) * 15;
                    const offsetY = Math.sin(angle) * 15;
                    
                    // Draw player marker
                    const marker = gameState.gameBoard.circle(25)
                        .center(space.x + offsetX, space.y + offsetY)
                        .fill({ color: player.color })
                        .addClass('player-marker');
                    
                    // Add player initial
                    gameState.gameBoard.text(player.name.charAt(0))
                        .center(space.x + offsetX, space.y + offsetY)
                        .font({ size: 14, fill: '#fff', weight: 'bold' });
                        
                    // Add glow effect
                    marker.stroke({ width: 3, color: '#fff' });
                }
            });
        }

        // Set up event listeners
        function setupEventListeners() {
            // Dice roll button
            document.getElementById('roll-btn').addEventListener('click', rollDice);
            
            // Dice click to roll
            document.getElementById('dice').addEventListener('click', rollDice);
            
            // New game button
            document.getElementById('new-game-btn').addEventListener('click', resetGame);
            
            // Submit answer button
            document.getElementById('submit-answer-btn').addEventListener('click', submitAnswer);
            
            // Close message button
            document.getElementById('close-message-btn').addEventListener('click', () => {
                document.getElementById('game-message').style.display = 'none';
            });
            
            // Answer button clicks
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('answer-btn') && !e.target.classList.contains('correct') && !e.target.classList.contains('incorrect')) {
                    selectAnswer(e.target);
                }
            });
        }

        // Roll the dice
        function rollDice() {
            if (!gameState.isGameActive) return;
            
            const diceElement = document.getElementById('dice');
            const rollBtn = document.getElementById('roll-btn');
            
            // Disable roll button during animation
            rollBtn.disabled = true;
            
            // Animate the dice
            let rolls = 0;
            const maxRolls = 15;
            const rollInterval = setInterval(() => {
                const randomValue = Math.floor(Math.random() * 6) + 1;
                diceElement.textContent = randomValue;
                diceElement.style.transform = `rotate(${rolls * 45}deg) scale(${1 + Math.sin(rolls * 0.5) * 0.2})`;
                rolls++;
                
                if (rolls >= maxRolls) {
                    clearInterval(rollInterval);
                    
                    // Final dice value
                    const diceValue = Math.floor(Math.random() * 6) + 1;
                    diceElement.textContent = diceValue;
                    diceElement.style.transform = 'rotate(0deg) scale(1)';
                    
                    // Move player
                    setTimeout(() => movePlayer(diceValue), 500);
                }
            }, 80);
        }

        // Move the current player
        function movePlayer(spaces) {
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            const currentPosition = gameState.playerPositions[currentPlayer.name];
            const newPosition = Math.min(currentPosition + spaces, gameState.boardSpaces.length - 1);
            
            // Update player position
            gameState.playerPositions[currentPlayer.name] = newPosition;
            
            // Animate movement
            animatePlayerMovement(currentPlayer, currentPosition, newPosition, () => {
                // Check if player reached the castle
                if (newPosition === gameState.boardSpaces.length - 1) {
                    endGame(currentPlayer);
                    return;
                }
                
                // Check the space type and trigger appropriate action
                const space = gameState.boardSpaces[newPosition];
                triggerSpaceAction(space);
            });
        }

        // Animate player movement
        function animatePlayerMovement(player, fromPos, toPos, callback) {
            if (fromPos === toPos) {
                positionPlayers();
                callback();
                return;
            }
            
            const steps = Math.abs(toPos - fromPos);
            const direction = toPos > fromPos ? 1 : -1;
            let currentStep = 0;
            
            const animateStep = () => {
                if (currentStep <= steps) {
                    const currentPos = fromPos + (direction * currentStep);
                    gameState.playerPositions[player.name] = currentPos;
                    positionPlayers();
                    currentStep++;
                    setTimeout(animateStep, 300);
                } else {
                    callback();
                }
            };
            
            animateStep();
        }

        // Trigger action based on space type
        function triggerSpaceAction(space) {
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            
            switch(space.type) {
                case 'challenge':
                    showChallenge();
                    break;
                case 'knowledge':
                    gainKnowledge(5);
                    showMessage("Knowledge Boost!", `${currentPlayer.name} gained 5 knowledge points!`);
                    nextTurn();
                    break;
                case 'teleport':
                    teleportPlayer();
                    break;
                case 'trap':
                    trapPlayer();
                    break;
                case 'bonus':
                    gainKnowledge(10);
                    showMessage("Bonus Space!", `${currentPlayer.name} gained 10 knowledge points!`);
                    nextTurn();
                    break;
                default:
                    nextTurn();
                    break;
            }
        }

        // Show a geometry challenge
        function showChallenge() {
            // Get a random geometry question
            const randomIndex = Math.floor(Math.random() * geometryQuestions.length);
            const question = geometryQuestions[randomIndex];
            gameState.currentChallenge = question;
            
            // Display the challenge panel
            const challengePanel = document.getElementById('challenge-panel');
            const questionElement = document.getElementById('challenge-question');
            const optionsContainer = document.getElementById('answer-options');
            const submitBtn = document.getElementById('submit-answer-btn');
            
            // Set question text
            questionElement.textContent = question.question;
            
            // Clear and add answer options
            optionsContainer.innerHTML = '';
            question.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'answer-btn';
                button.textContent = option;
                button.dataset.index = index;
                optionsContainer.appendChild(button);
            });
            
            // Reset submit button
            submitBtn.disabled = true;
            submitBtn.textContent = 'Submit Answer';
            
            // Show the panel
            challengePanel.style.display = 'block';
            
            // Scroll to challenge panel
            challengePanel.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Select an answer
        function selectAnswer(button) {
            // Clear previous selection
            document.querySelectorAll('.answer-btn').forEach(btn => {
                btn.style.border = '2px solid rgba(255, 255, 255, 0.3)';
                btn.style.background = 'rgba(255, 255, 255, 0.1)';
            });
            
            // Highlight selected answer
            button.style.border = '2px solid #ff9800';
            button.style.background = 'rgba(255, 152, 0, 0.2)';
            
            // Enable submit button
            document.getElementById('submit-answer-btn').disabled = false;
            
            // Store selected answer
            button.dataset.selected = 'true';
        }

        // Submit answer
        function submitAnswer() {
            const challengePanel = document.getElementById('challenge-panel');
            const answerButtons = document.querySelectorAll('.answer-btn');
            const submitBtn = document.getElementById('submit-answer-btn');
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            
            // Find selected answer
            let selectedAnswer = -1;
            answerButtons.forEach(button => {
                if (button.dataset.selected === 'true') {
                    selectedAnswer = parseInt(button.dataset.index);
                }
            });
            
            if (selectedAnswer === -1) return;
            
            // Check if answer is correct
            const isCorrect = selectedAnswer === gameState.currentChallenge.correctAnswer;
            
            // Show correct/incorrect feedback
            answerButtons.forEach((button, index) => {
                if (index === gameState.currentChallenge.correctAnswer) {
                    button.classList.add('correct');
                } else if (index === selectedAnswer && !isCorrect) {
                    button.classList.add('incorrect');
                }
                button.disabled = true;
            });
            
            // Update submit button
            submitBtn.textContent = isCorrect ? 'Correct! Continue' : 'Incorrect! Continue';
            submitBtn.onclick = () => {
                challengePanel.style.display = 'none';
                
                if (isCorrect) {
                    // Award knowledge points
                    const pointsEarned = gameState.currentChallenge.difficulty * 5;
                    gainKnowledge(pointsEarned);
                    
                    // Increment challenges solved
                    gameState.challengesSolved++;
                    document.getElementById('challenges-solved').textContent = gameState.challengesSolved;
                    
                    // Show success message
                    showMessage("Challenge Solved!", 
                        `${currentPlayer.name} answered correctly and earned ${pointsEarned} knowledge points!`);
                    
                    // Check for achievement
                    checkAchievements();
                } else {
                    // Penalty for wrong answer
                    const penalty = Math.max(1, Math.floor(gameState.playerKnowledge[currentPlayer.name] * 0.1));
                    gameState.playerKnowledge[currentPlayer.name] = Math.max(0, gameState.playerKnowledge[currentPlayer.name] - penalty);
                    
                    showMessage("Challenge Failed", 
                        `${currentPlayer.name} answered incorrectly and lost ${penalty} knowledge points.`);
                }
                
                nextTurn();
            };
        }

        // Gain knowledge points
        function gainKnowledge(points) {
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            gameState.playerKnowledge[currentPlayer.name] += points;
            
            // Update UI
            updateUI();
            
            // Show floating text animation
            showFloatingText(`+${points} Knowledge`, currentPlayer.color);
        }

        // Teleport player
        function teleportPlayer() {
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            const currentPosition = gameState.playerPositions[currentPlayer.name];
            
            // Find a teleport destination (forward or backward)
            let destination;
            if (Math.random() > 0.5) {
                // Teleport forward
                destination = Math.min(currentPosition + 5, gameState.boardSpaces.length - 1);
                showMessage("Teleport!", `${currentPlayer.name} teleported forward 5 spaces!`);
            } else {
                // Teleport backward
                destination = Math.max(currentPosition - 5, 0);
                showMessage("Teleport!", `${currentPlayer.name} teleported backward 5 spaces!`);
            }
            
            gameState.playerPositions[currentPlayer.name] = destination;
            positionPlayers();
            
            // Check new space
            const space = gameState.boardSpaces[destination];
            setTimeout(() => triggerSpaceAction(space), 1000);
        }

        // Trap player
        function trapPlayer() {
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            const penalty = Math.floor(Math.random() * 3) + 1;
            
            // Move player back
            const currentPosition = gameState.playerPositions[currentPlayer.name];
            const newPosition = Math.max(currentPosition - penalty, 0);
            gameState.playerPositions[currentPlayer.name] = newPosition;
            
            showMessage("Trap!", `${currentPlayer.name} fell into a trap and moved back ${penalty} spaces!`);
            positionPlayers();
            
            setTimeout(nextTurn, 1500);
        }

        // Move to next turn
        function nextTurn() {
            // Update turn counter
            gameState.turn++;
            document.getElementById('turn-number').textContent = gameState.turn;
            
            // Check if max turns reached
            if (gameState.turn > gameState.maxTurns) {
                endGameByPoints();
                return;
            }
            
            // Move to next player
            gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
            
            // Update UI
            updateUI();
            
            // Re-enable roll button
            document.getElementById('roll-btn').disabled = false;
            
            // Show whose turn it is
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            showFloatingText(`${currentPlayer.name}'s Turn`, currentPlayer.color);
        }

        // Update UI elements
        function updateUI() {
            renderPlayerInfo();
            positionPlayers();
        }

        // Show a message
        function showMessage(title, text) {
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-text').textContent = text;
            document.getElementById('game-message').style.display = 'block';
        }

        // Show floating text animation
        function showFloatingText(text, color) {
            const board = gameState.gameBoard;
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            const position = gameState.playerPositions[currentPlayer.name];
            
            if (position >= gameState.boardSpaces.length) return;
            
            const space = gameState.boardSpaces[position];
            const floatingText = board.text(text)
                .center(space.x, space.y - 40)
                .font({ size: 16, fill: color, weight: 'bold' });
            
            // Animate floating up and fading out
            floatingText.animate(1000, '-')
                .move(space.x, space.y - 80)
                .opacity(0)
                .after(() => floatingText.remove());
        }

        // Check for achievements
        function checkAchievements() {
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            const knowledge = gameState.playerKnowledge[currentPlayer.name];
            
            // Achievement for reaching certain knowledge points
            if (knowledge >= 50) {
                showAchievement("Geometry Master", `${currentPlayer.name} has reached 50 knowledge points!`);
            } else if (knowledge >= 25) {
                showAchievement("Geometry Apprentice", `${currentPlayer.name} has reached 25 knowledge points!`);
            }
            
            // Achievement for solving many challenges
            if (gameState.challengesSolved >= 10) {
                showAchievement("Problem Solver", "Solved 10 geometry challenges!");
            }
        }

        // Show achievement notification
        function showAchievement(title, text) {
            const achievement = document.getElementById('achievement');
            document.getElementById('achievement-title').textContent = title;
            document.getElementById('achievement-text').textContent = text;
            achievement.style.display = 'block';
            
            // Hide after 5 seconds
            setTimeout(() => {
                achievement.style.display = 'none';
            }, 5000);
        }

        // End game when player reaches the castle
        function endGame(winningPlayer) {
            gameState.isGameActive = false;
            document.getElementById('roll-btn').disabled = true;
            
            showMessage("Victory!", 
                `${winningPlayer.name} has reached the Castle of Knowledge and wins the game! 
                Final Score: ${gameState.playerKnowledge[winningPlayer.name]} knowledge points.`);
                
            // Show final scores
            setTimeout(() => {
                let scoresText = "Final Scores:\n";
                gameState.players.forEach(player => {
                    scoresText += `${player.name}: ${gameState.playerKnowledge[player.name]} points\n`;
                });
                showMessage("Game Over", scoresText);
            }, 3000);
        }

        // End game by points after max turns
        function endGameByPoints() {
            gameState.isGameActive = false;
            document.getElementById('roll-btn').disabled = true;
            
            // Determine winner by knowledge points
            let winner = gameState.players[0];
            let maxPoints = 0;
            
            gameState.players.forEach(player => {
                const points = gameState.playerKnowledge[player.name];
                if (points > maxPoints) {
                    maxPoints = points;
                    winner = player;
                }
            });
            
            // Check for ties
            const tiedPlayers = gameState.players.filter(player => 
                gameState.playerKnowledge[player.name] === maxPoints);
            
            if (tiedPlayers.length > 1) {
                showMessage("It's a Tie!", 
                    `The game ended in a tie between ${tiedPlayers.map(p => p.name).join(' and ')} with ${maxPoints} points each!`);
            } else {
                showMessage("Game Over!", 
                    `${winner.name} wins with ${maxPoints} knowledge points after ${gameState.maxTurns} turns!`);
            }
            
            // Show final scores
            setTimeout(() => {
                let scoresText = "Final Scores:\n";
                gameState.players.forEach(player => {
                    scoresText += `${player.name}: ${gameState.playerKnowledge[player.name]} points\n`;
                });
                showMessage("Final Results", scoresText);
            }, 3000);
        }

        // Reset the game
        function resetGame() {
            // Reset game state
            gameState.currentPlayerIndex = 0;
            gameState.turn = 1;
            gameState.isGameActive = true;
            gameState.challengesSolved = 0;
            gameState.currentChallenge = null;
            
            // Reset player positions and knowledge
            gameState.players.forEach(player => {
                gameState.playerPositions[player.name] = 0;
                gameState.playerKnowledge[player.name] = 0;
            });
            
            // Update UI
            document.getElementById('turn-number').textContent = '1';
            document.getElementById('challenges-solved').textContent = '0';
            document.getElementById('roll-btn').disabled = false;
            document.getElementById('challenge-panel').style.display = 'none';
            document.getElementById('game-message').style.display = 'none';
            
            // Redraw board and position players
            drawBoard();
            positionPlayers();
            updateUI();
            
            showMessage("New Game Started!", "Good luck on your geometric adventure!");
        }

        // Initialize the game when page loads
        window.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>