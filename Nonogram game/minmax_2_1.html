<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nonogram Puzzle - Educational Logic Game</title>

    <!-- Include svg.js library from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.1.2/svg.min.js"></script>

    <style>
        /* ========================================
           NONOGRAM PUZZLE GAME STYLES
           Clean, Educational Design
           ======================================== */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8ec 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 30px 20px;
        }

        /* Main Title */
        h1 {
            font-size: 2.2em;
            color: #2c3e50;
            margin-bottom: 8px;
            text-align: center;
        }

        .subtitle {
            font-size: 1.1em;
            color: #7f8c8d;
            margin-bottom: 25px;
            text-align: center;
        }

        /* Game Container */
        .game-container {
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            margin-bottom: 25px;
        }

        /* Instructions Panel */
        .instructions {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px 25px;
            margin-bottom: 25px;
            max-width: 800px;
        }

        .instructions h3 {
            color: #2c3e50;
            margin-bottom: 12px;
            font-size: 1.2em;
        }

        .instructions ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }

        .instructions li {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #5a6c7d;
            font-size: 0.95em;
        }

        .instruction-icon {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
        }

        .filled-icon {
            background: #3498db;
            color: white;
        }

        .marked-icon {
            background: white;
            border: 2px solid #e74c3c;
            color: #e74c3c;
        }

        .empty-icon {
            background: white;
            border: 2px solid #bdc3c7;
        }

        /* SVG Container */
        #puzzle-svg {
            display: block;
            border-radius: 8px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.05);
        }

        /* Control Buttons */
        .button-container {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 25px;
        }

        .control-btn {
            font-family: inherit;
            font-size: 1em;
            padding: 12px 28px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        /* Check Solution Button */
        #check-btn {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            box-shadow: 0 4px 0 #1e8449;
        }

        #check-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #1e8449;
        }

        #check-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #1e8449;
        }

        /* Reset Button */
        #reset-btn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            box-shadow: 0 4px 0 #a93226;
        }

        #reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #a93226;
        }

        #reset-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #a93226;
        }

        /* New Puzzle Button */
        #new-puzzle-btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            box-shadow: 0 4px 0 #1f618d;
        }

        #new-puzzle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #1f618d;
        }

        #new-puzzle-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #1f618d;
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 30px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #5a6c7d;
            font-size: 0.9em;
        }

        .legend-symbol {
            width: 24px;
            height: 24px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        /* Success Modal Overlay */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 40px 50px;
            text-align: center;
            animation: modalPop 0.4s ease;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        @keyframes modalPop {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.05); }
            100% { transform: scale(1); opacity: 1; }
        }

        .modal-content h2 {
            font-size: 2.5em;
            color: #27ae60;
            margin-bottom: 10px;
        }

        .modal-content p {
            font-size: 1.2em;
            color: #5a6c7d;
            margin-bottom: 25px;
        }

        .modal-content .stats {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px 25px;
            margin-bottom: 25px;
            display: inline-block;
        }

        .modal-content .stats span {
            color: #3498db;
            font-weight: bold;
        }

        /* Progress indicator */
        .progress-container {
            margin-top: 15px;
            text-align: center;
        }

        .progress-label {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-bottom: 8px;
        }

        .progress-bar {
            width: 200px;
            height: 12px;
            background: #ecf0f1;
            border-radius: 6px;
            overflow: hidden;
            display: inline-block;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            border-radius: 6px;
            transition: width 0.3s ease;
            width: 0%;
        }
    </style>
</head>
<body>

    <!-- Main Title -->
    <h1>ðŸ§© Nonogram Puzzle</h1>
    <p class="subtitle">A fun logic puzzle for everyone!</p>

    <!-- Instructions -->
    <div class="instructions">
        <h3>How to Play</h3>
        <ul>
            <li>
                <span class="instruction-icon filled-icon">â– </span>
                <span><strong>Left-click</strong> to fill a cell</span>
            </li>
            <li>
                <span class="instruction-icon marked-icon">âœ•</span>
                <span><strong>Right-click</strong> to mark with X</span>
            </li>
            <li>
                <span class="instruction-icon empty-icon">â–¡</span>
                <span><strong>Click again</strong> to clear</span>
            </li>
            <li>
                <span style="color: #3498db;">ðŸ“Š</span>
                <span>Use the numbers as clues!</span>
            </li>
        </ul>
    </div>

    <!-- Game Container -->
    <div class="game-container">
        <div id="puzzle-svg"></div>

        <!-- Progress Display -->
        <div class="progress-container">
            <div class="progress-label">Cells Filled: <span id="filled-count">0</span> / <span id="total-filled">0</span></div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
        </div>
    </div>

    <!-- Control Buttons -->
    <div class="button-container">
        <button id="check-btn" class="control-btn" onclick="checkSolution()">âœ“ Check Solution</button>
        <button id="reset-btn" class="control-btn" onclick="resetPuzzle()">â†º Reset</button>
        <button id="new-puzzle-btn" class="control-btn" onclick="newPuzzle()">â™» New Puzzle</button>
    </div>

    <!-- Legend -->
    <div class="legend">
        <div class="legend-item">
            <span class="legend-symbol" style="background: #3498db; color: white;">â– </span>
            <span>Filled Cell</span>
        </div>
        <div class="legend-item">
            <span class="legend-symbol" style="background: white; border: 2px solid #e74c3c; color: #e74c3c;">âœ•</span>
            <span>Marked (Empty)</span>
        </div>
        <div class="legend-item">
            <span class="legend-symbol" style="background: white; border: 1px solid #bdc3c7;"></span>
            <span>Empty Cell</span>
        </div>
    </div>

    <!-- Success Modal -->
    <div class="modal-overlay" id="success-modal">
        <div class="modal-content">
            <h2>ðŸŽ‰ Congratulations!</h2>
            <p>You solved the puzzle!</p>
            <div class="stats">
                Time: <span id="solve-time">0:00</span> | Moves: <span id="move-count">0</span>
            </div>
            <button class="control-btn" onclick="closeModal()" style="background: linear-gradient(135deg, #27ae60, #2ecc71); color: white; box-shadow: 0 4px 0 #1e8449;">Play Again!</button>
        </div>
    </div>

    <script>
        /* ========================================
           NONOGRAM PUZZLE GAME
           Complete Interactive Implementation
           ======================================== */

        // ========================================
        // CONFIGURATION
        // ========================================

        const GRID_SIZE = 20;           // 20x20 puzzle
        const CELL_SIZE = 28;           // Size of each cell in pixels
        const CLUE_AREA_SIZE = 100;     // Size of clue area
        const STROKE_WIDTH = 1;         // Grid line width

        // ========================================
        // PUZZLE PATTERNS
        // ========================================

        // Predefined puzzle patterns (1 = filled, 0 = empty)
        // Each pattern creates a recognizable image
        const PUZZLE_PATTERNS = [
            // Pattern 0: Heart Shape
            [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0],
                [0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0],
                [0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,0],
                [0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0],
                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Pattern 1: Star
            [
                [0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,0,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Pattern 2: House
            [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0],
                [0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0],
                [0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0],
                [0,0,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,0],
                [0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0],
                [0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Pattern 3: Smiley Face
            [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0],
                [0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0],
                [0,0,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0],
                [0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // Pattern 4: Boat
            [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ]
        ];

        // ========================================
        // GAME STATE
        // ========================================

        let draw = null;              // SVG.js drawing object
        let solution = [];            // Current puzzle solution
        let playerGrid = [];          // Player's current grid (0=empty, 1=filled, 2=marked)
        let rowClues = [];            // Row clues
        let colClues = [];            // Column clues
        let cellGroups = [];          // SVG groups for each cell
        let moveCount = 0;            // Number of moves
        let startTime = null;         // Start time for timing
        let puzzleIndex = 0;          // Current puzzle pattern

        // ========================================
        // CLUE CALCULATION
        // ========================================

        /**
         * Calculate clues for a single line (row or column).
         * Returns array of clue numbers.
         */
        function calculateClues(line) {
            const clues = [];
            let count = 0;

            for (let i = 0; i < line.length; i++) {
                if (line[i] === 1) {
                    count++;
                } else if (count > 0) {
                    clues.push(count);
                    count = 0;
                }
            }

            if (count > 0) {
                clues.push(count);
            }

            return clues.length > 0 ? clues : [0];
        }

        /**
         * Calculate all row and column clues from the solution.
         */
        function calculateAllClues() {
            // Row clues
            rowClues = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                const row = solution[y];
                rowClues.push(calculateClues(row));
            }

            // Column clues
            colClues = [];
            for (let x = 0; x < GRID_SIZE; x++) {
                const col = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                    col.push(solution[y][x]);
                }
                colClues.push(calculateClues(col));
            }
        }

        // ========================================
        // SVG DRAWING
        // ========================================

        /**
         * Initialize the SVG drawing area.
         */
        function initDrawing() {
            const container = document.getElementById('puzzle-svg');
            container.innerHTML = '';

            const totalWidth = CLUE_AREA_SIZE + GRID_SIZE * CELL_SIZE;
            const totalHeight = CLUE_AREA_SIZE + GRID_SIZE * CELL_SIZE;

            draw = SVG().addTo('#puzzle-svg').size(totalWidth, totalHeight);

            // Draw background
            draw.rect(totalWidth, totalHeight).fill('#fafafa');

            // Draw clue area background
            draw.rect(CLUE_AREA_SIZE, CLUE_AREA_SIZE).fill('#e8e8e8');
            draw.rect(CLUE_AREA_SIZE, GRID_SIZE * CELL_SIZE).move(0, CLUE_AREA_SIZE).fill('#e8e8e8');
            draw.rect(GRID_SIZE * CELL_SIZE, CLUE_AREA_SIZE).move(CLUE_AREA_SIZE, 0).fill('#e8e8e8');
        }

        /**
         * Draw all clues on the puzzle.
         */
        function drawClues() {
            // Draw row clues (left side)
            for (let y = 0; y < GRID_SIZE; y++) {
                const clues = rowClues[y];
                const cellY = CLUE_AREA_SIZE + y * CELL_SIZE;

                // Draw clues right-aligned
                let xOffset = CLUE_AREA_SIZE - 5;
                for (let i = clues.length - 1; i >= 0; i--) {
                    const text = draw.text(String(clues[i]))
                        .font({
                            family: 'Segoe UI',
                            size: 12,
                            weight: '600'
                        })
                        .fill('#2c3e50')
                        .move(xOffset - 15, cellY + CELL_SIZE / 2 - 8);

                    xOffset -= 18;
                }
            }

            // Draw column clues (top side)
            for (let x = 0; x < GRID_SIZE; x++) {
                const clues = colClues[x];
                const cellX = CLUE_AREA_SIZE + x * CELL_SIZE;

                // Draw clues bottom-aligned
                let yOffset = CLUE_AREA_SIZE - 5;
                for (let i = clues.length - 1; i >= 0; i--) {
                    const text = draw.text(String(clues[i]))
                        .font({
                            family: 'Segoe UI',
                            size: 12,
                            weight: '600'
                        })
                        .fill('#2c3e50')
                        .move(cellX + CELL_SIZE / 2 - 5, yOffset - 15);

                    yOffset -= 18;
                }
            }
        }

        /**
         * Draw the main grid with all cells.
         */
        function drawGrid() {
            cellGroups = [];

            for (let y = 0; y < GRID_SIZE; y++) {
                cellGroups[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cellX = CLUE_AREA_SIZE + x * CELL_SIZE;
                    const cellY = CLUE_AREA_SIZE + y * CELL_SIZE;

                    // Create group for this cell
                    const group = draw.group();

                    // Cell background (white)
                    const bg = group.rect(CELL_SIZE - 1, CELL_SIZE - 1)
                        .move(cellX, cellY)
                        .fill('#ffffff')
                        .stroke({ color: '#d0d0d0', width: 0.5 });

                    // Store reference to the fill element for updating
                    group.cellFill = bg;

                    // Add click handlers
                    group.on('click', () => handleCellClick(x, y));
                    group.on('contextmenu', (e) => {
                        e.preventDefault();
                        handleRightClick(x, y);
                    });

                    // Store cell state
                    playerGrid[y][x] = 0;

                    cellGroups[y][x] = group;
                }
            }

            // Draw grid lines
            for (let i = 0; i <= GRID_SIZE; i++) {
                const pos = CLUE_AREA_SIZE + i * CELL_SIZE;

                // Vertical lines
                draw.line(pos, CLUE_AREA_SIZE, pos, CLUE_AREA_SIZE + GRID_SIZE * CELL_SIZE)
                    .stroke({ color: '#a0a0a0', width: STROKE_WIDTH });

                // Horizontal lines
                draw.line(CLUE_AREA_SIZE, pos, CLUE_AREA_SIZE + GRID_SIZE * CELL_SIZE, pos)
                    .stroke({ color: '#a0a0a0', width: STROKE_WIDTH });
            }

            // Draw thicker border around grid
            const gridStart = CLUE_AREA_SIZE;
            const gridEnd = CLUE_AREA_SIZE + GRID_SIZE * CELL_SIZE;

            draw.rect(gridEnd - gridStart, gridEnd - gridStart)
                .move(gridStart, gridStart)
                .fill('none')
                .stroke({ color: '#666666', width: 2 });
        }

        /**
         * Update the visual appearance of a cell.
         */
        function updateCell(x, y) {
            const group = cellGroups[y][x];
            const state = playerGrid[y][x];

            // Reset fill
            group.cellFill.fill('#ffffff');

            if (state === 1) {
                // Filled cell - blue
                group.cellFill.fill('#3498db');
            } else if (state === 2) {
                // Marked cell - X pattern
                const cellX = CLUE_AREA_SIZE + x * CELL_SIZE;
                const cellY = CLUE_AREA_SIZE + y * CELL_SIZE;

                // Clear previous X if exists
                group.find('.x-mark').forEach(el => el.remove());

                // Draw X
                const xSize = CELL_SIZE - 10;
                const offset = 5;

                group.line(cellX + offset, cellY + offset, cellX + offset + xSize, cellY + offset + xSize)
                    .stroke({ color: '#e74c3c', width: 2 })
                    .addClass('x-mark');

                group.line(cellX + offset + xSize, cellY + offset, cellX + offset, cellY + offset + xSize)
                    .stroke({ color: '#e74c3c', width: 2 })
                    .addClass('x-mark');
            }
        }

        // ========================================
        // GAME LOGIC
        // ========================================

        /**
         * Handle left-click on a cell (toggle fill).
         */
        function handleCellClick(x, y) {
            startTimer();

            if (playerGrid[y][x] === 1) {
                // Unfill
                playerGrid[y][x] = 0;
            } else {
                // Fill (and clear mark if present)
                playerGrid[y][x] = 1;
            }

            updateCell(x, y);
            moveCount++;
            updateProgress();
        }

        /**
         * Handle right-click on a cell (toggle X mark).
         */
        function handleRightClick(x, y) {
            startTimer();

            if (playerGrid[y][x] === 2) {
                // Unmark
                playerGrid[y][x] = 0;
            } else {
                // Mark (and clear fill if present)
                playerGrid[y][x] = 2;
            }

            updateCell(x, y);
            moveCount++;
            updateProgress();
        }

        /**
         * Start the timer if not already running.
         */
        function startTimer() {
            if (!startTime) {
                startTime = Date.now();
            }
        }

        /**
         * Calculate elapsed time and format as string.
         */
        function getElapsedTime() {
            if (!startTime) return '0:00';

            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;

            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        /**
         * Update the progress display.
         */
        function updateProgress() {
            let filledCount = 0;
            let totalFilled = 0;

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (solution[y][x] === 1) {
                        totalFilled++;
                        if (playerGrid[y][x] === 1) {
                            filledCount++;
                        }
                    }
                }
            }

            document.getElementById('filled-count').textContent = filledCount;
            document.getElementById('total-filled').textContent = totalFilled;

            const percentage = totalFilled > 0 ? (filledCount / totalFilled) * 100 : 0;
            document.getElementById('progress-fill').style.width = percentage + '%';
        }

        /**
         * Check if the player's solution is correct.
         */
        function checkSolution() {
            startTimer();

            let correct = true;

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const shouldBeFilled = solution[y][x] === 1;
                    const isFilled = playerGrid[y][x] === 1;

                    if (shouldBeFilled !== isFilled) {
                        correct = false;
                        break;
                    }
                }
                if (!correct) break;
            }

            if (correct) {
                showSuccessModal();
            } else {
                // Mark incorrect cells temporarily
                markIncorrectCells();
            }
        }

        /**
         * Mark cells that don't match the solution.
         */
        function markIncorrectCells() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const shouldBeFilled = solution[y][x] === 1;
                    const isFilled = playerGrid[y][x] === 1;

                    if (shouldBeFilled !== isFilled) {
                        // Flash the cell red temporarily
                        const group = cellGroups[y][x];
                        const originalFill = group.cellFill.fill();

                        group.cellFill.fill('#e74c3c');

                        setTimeout(() => {
                            group.cellFill.fill(originalFill);
                            updateCell(x, y);
                        }, 300);
                    }
                }
            }
        }

        /**
         * Show the success modal.
         */
        function showSuccessModal() {
            document.getElementById('solve-time').textContent = getElapsedTime();
            document.getElementById('move-count').textContent = moveCount;
            document.getElementById('success-modal').classList.add('active');
        }

        /**
         * Close the success modal.
         */
        function closeModal() {
            document.getElementById('success-modal').classList.remove('active');
            newPuzzle();
        }

        /**
         * Reset the current puzzle.
         */
        function resetPuzzle() {
            // Clear player grid
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    playerGrid[y][x] = 0;
                    updateCell(x, y);
                }
            }

            // Reset counters
            moveCount = 0;
            startTime = null;

            // Update display
            updateProgress();
        }

        /**
         * Load a new puzzle.
         */
        function newPuzzle() {
            // Reset counters
            moveCount = 0;
            startTime = null;

            // Select a random puzzle (or cycle through)
            puzzleIndex = Math.floor(Math.random() * PUZZLE_PATTERNS.length);
            solution = PUZZLE_PATTERNS[puzzleIndex].map(row => [...row]);

            // Calculate clues
            calculateAllClues();

            // Initialize player grid
            playerGrid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                playerGrid[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    playerGrid[y][x] = 0;
                }
            }

            // Draw everything
            initDrawing();
            drawClues();
            drawGrid();

            // Update progress
            updateProgress();
        }

        // ========================================
        // INITIALIZATION
        // ========================================

        // Prevent context menu on the puzzle area
        document.getElementById('puzzle-svg').addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Start the game
        newPuzzle();
    </script>
</body>
</html>