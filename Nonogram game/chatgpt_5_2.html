<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SVG.js Nonogram (Picross) 20Ã—20 â€” Single File</title>
  <style>
    html, body { height:100%; margin:0; background:#0b1020; overflow:hidden; }
    #app { width:100%; height:100%; }
    noscript { color:#fff; padding:16px; font-family:system-ui, sans-serif; }
  </style>
</head>
<body>
<noscript>This game needs JavaScript enabled.</noscript>
<div id="app"></div>

<!-- SVG.js (CDN). Still a single HTML file; if you need offline, inline svg.js here. -->
<script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2/dist/svg.min.js"></script>

<script>
/*
  ============================================================
  20Ã—20 NONOGRAM / PICROSS (SVG.js only)
  - Row + column clues
  - Left click: fill cell
  - Right click: mark X  (also: hold Shift and left click)
  - Checks against a predefined 20Ã—20 pattern
  - Clean educational style
  - Single HTML file + vanilla JS + svg.js
  ============================================================
*/

(() => {
  // -------------------------
  // 1) Config / sizes
  // -------------------------
  const N = 20;          // 20Ã—20 grid
  const CELL = 24;       // px per cell
  const GRID_LINE = 1.2; // grid line width
  const CLUE_W = 140;    // left clue area width
  const CLUE_H = 110;    // top clue area height
  const PAD = 22;        // outer padding

  const GRID_W = N * CELL;
  const GRID_H = N * CELL;
  const W = PAD*2 + CLUE_W + GRID_W + 260;
  const H = PAD*2 + CLUE_H + GRID_H + 40;

  // -------------------------
  // 2) Palette / typography
  // -------------------------
  const C = {
    bg: '#0b1020',
    panel: 'rgba(255,255,255,.06)',
    stroke: 'rgba(255,255,255,.14)',
    faint: 'rgba(255,255,255,.10)',
    ink: '#f3f7ff',
    muted: 'rgba(243,247,255,.72)',
    fill: '#111a33',
    filled: '#111111',
    x: 'rgba(243,247,255,.65)',
    accent: '#67b3ff',
    good: '#35d39f',
    bad: '#ff6b87',
  };

  const FONT = {family:'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial', size: 12, weight: 800};
  const FONT_CLUE = {family:'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial', size: 12, weight: 900};
  const FONT_BIG = {family:'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial', size: 20, weight: 1000};

  // -------------------------
  // 3) SVG setup
  // -------------------------
  const draw = SVG().addTo('#app').size('100%', '100%').viewbox(0, 0, W, H);

  // prevent default context menu (for right-click X marking)
  document.addEventListener('contextmenu', (e) => e.preventDefault());

  // -------------------------
  // 4) Predefined 20Ã—20 solution pattern
  //    (Original: a friendly "rocket + star" icon)
  //    1 = filled, 0 = empty
  // -------------------------
  const SOL = [
    // 0..19 rows, each 20 columns
    [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
    [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
    [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
    [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
    [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0],
    // flame + star below (cute)
    [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0],
    // star (right side)
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],
  ];

  // -------------------------
  // 5) Compute clues (runs of 1s)
  // -------------------------
  function runs(arr){
    const out = [];
    let c = 0;
    for (let i=0;i<arr.length;i++){
      if (arr[i]===1) c++;
      else if (c>0){ out.push(c); c=0; }
    }
    if (c>0) out.push(c);
    return out.length ? out : [0]; // show 0 if empty row/col
  }

  const rowClues = SOL.map(r => runs(r));
  const colClues = Array.from({length:N}, (_,x) => runs(SOL.map(r => r[x])));

  // -------------------------
  // 6) Game state: player grid
  //    0 empty, 1 filled, 2 X-marked
  // -------------------------
  const player = Array.from({length:N}, ()=>Array(N).fill(0));
  let solved = false;

  // -------------------------
  // 7) Layout groups
  // -------------------------
  const bg = draw.group();
  bg.rect(W,H).fill(C.bg);

  // subtle "paper" panel behind puzzle
  const panel = draw.group();
  panel.rect(CLUE_W + GRID_W + 28, CLUE_H + GRID_H + 28).radius(18)
    .fill(C.panel).stroke({color:C.stroke, width:1})
    .move(PAD + 120, PAD + 56);

  const root = draw.group().move(PAD + 120, PAD + 56);

  const clueTopG = root.group().move(CLUE_W, 0);
  const clueLeftG = root.group().move(0, CLUE_H);
  const gridG = root.group().move(CLUE_W, CLUE_H);

  // overlays / messages
  const msgG = draw.group();
  const msgBox = msgG.rect(520, 70).radius(18).fill('rgba(255,255,255,.08)').stroke({color:'rgba(255,255,255,.14)', width:1});
  msgBox.move(PAD + 120, 18);
  const msgTitle = msgG.text('Nonogram (Picross) â€” 20Ã—20').font(FONT_BIG).fill(C.ink).move(PAD + 140, 36);
  const msgHint = msgG.text('Left click = fill â€¢ Right click (or Shift+Click) = X mark â€¢ Solve to reveal success!')
    .font({ ...FONT, size: 12, weight: 750 }).fill(C.muted).move(PAD + 140, 62);

  // Right side controls
  const side = draw.group().move(PAD + 120 + CLUE_W + GRID_W + 40, PAD + 90);
  side.rect(230, 360).radius(18).fill('rgba(255,255,255,.06)').stroke({color:'rgba(255,255,255,.14)', width:1});

  function makeButton(g, x,y,w,h,label, sub=''){
    const btn = g.group().move(x,y);
    const r = btn.rect(w,h).radius(14).fill('rgba(255,255,255,.08)').stroke({color:'rgba(255,255,255,.18)', width:1});
    const t = btn.text(label).font({family:FONT.family, size: 14, weight: 950}).fill(C.ink);
    t.center(w/2, h/2 + (sub? -6 : 0));
    if (sub){
      const s = btn.text(sub).font({family:'ui-monospace, SFMono-Regular, Menlo, Consolas, monospace', size: 11, weight: 800})
        .fill(C.muted);
      s.center(w/2, h/2 + 14);
    }
    btn.attr({cursor:'pointer'});
    btn.on('mouseover', ()=> r.animate(120).fill('rgba(255,255,255,.12)'));
    btn.on('mouseout',  ()=> r.animate(120).fill('rgba(255,255,255,.08)'));
    btn.flash = ()=> r.animate(90).fill('rgba(103,179,255,.18)').after(()=> r.animate(140).fill('rgba(255,255,255,.08)'));
    btn.bg = r;
    return btn;
  }

  const btnCheck = makeButton(side, 18, 22, 194, 52, 'Check Now', 'Enter');
  const btnClear = makeButton(side, 18, 86, 194, 52, 'Clear Board', 'C');
  const btnToggleX = makeButton(side, 18, 150, 194, 52, 'Mark Mode: OFF', 'M');

  let markMode = false;
  btnToggleX.on('click', () => {
    markMode = !markMode;
    btnToggleX.flash();
    btnToggleX.get(1).text(markMode ? 'Mark Mode: ON' : 'Mark Mode: OFF');
  });

  const sideInfo = side.text('').font({ ...FONT, size: 12, weight: 750, leading: 1.35 }).fill(C.muted).move(18, 224);
  sideInfo.text(add => {
    add.tspan('Goal: match the hidden picture.').newLine();
    add.tspan('Numbers show groups of').newLine();
    add.tspan('filled cells in each row').newLine();
    add.tspan('and column.').newLine();
    add.tspan(' ').newLine();
    add.tspan('Tip: Use X marks').newLine();
    add.tspan('to note empty cells.').newLine();
  });

  const resultText = side.text('Not solved yet.').font({ ...FONT, size: 13, weight: 900 }).fill(C.muted).move(18, 330);

  // -------------------------
  // 8) Draw clue numbers
  // -------------------------
  function drawClues(){
    clueTopG.clear();
    clueLeftG.clear();

    // Top clues: each column, stack numbers bottom-aligned
    for (let x=0;x<N;x++){
      const clues = colClues[x];
      const g = clueTopG.group();
      const x0 = x*CELL;

      // highlight every 5 columns lightly
      if (x % 5 === 0){
        g.rect(CELL, CLUE_H).fill('rgba(255,255,255,.03)').move(x0, 0);
      }

      // place from bottom upward
      for (let i=0;i<clues.length;i++){
        const val = clues[clues.length-1-i];
        g.text(String(val)).font(FONT_CLUE).fill(C.ink)
          .center(x0 + CELL/2, CLUE_H - 12 - i*14);
      }
    }

    // Left clues: each row, align to right
    for (let y=0;y<N;y++){
      const clues = rowClues[y];
      const g = clueLeftG.group();
      const y0 = y*CELL;

      // highlight every 5 rows lightly
      if (y % 5 === 0){
        g.rect(CLUE_W, CELL).fill('rgba(255,255,255,.03)').move(0, y0);
      }

      // place from right to left
      for (let i=0;i<clues.length;i++){
        const val = clues[clues.length-1-i];
        g.text(String(val)).font(FONT_CLUE).fill(C.ink)
          .center(CLUE_W - 10 - i*16, y0 + CELL/2 + 0.5);
      }
    }

    // separators between clue areas and grid
    root.line(CLUE_W, 0, CLUE_W, CLUE_H + GRID_H).stroke({color:'rgba(255,255,255,.18)', width:2});
    root.line(0, CLUE_H, CLUE_W + GRID_W, CLUE_H).stroke({color:'rgba(255,255,255,.18)', width:2});
  }

  // -------------------------
  // 9) Draw grid + interactive cells
  // -------------------------
  const cellRects = []; // store references for update
  const cellMarks = []; // store X lines groups

  function drawGrid(){
    gridG.clear();
    cellRects.length = 0;
    cellMarks.length = 0;

    // background plate
    gridG.rect(GRID_W, GRID_H).fill(C.fill).stroke({color:'rgba(255,255,255,.18)', width:1});

    // draw cells
    for (let y=0;y<N;y++){
      const rowR = [];
      const rowM = [];
      for (let x=0;x<N;x++){
        const x0 = x*CELL, y0 = y*CELL;

        // slightly different background to help eye tracking
        const bg = ((Math.floor(x/5)+Math.floor(y/5)) % 2 === 0) ? 'rgba(255,255,255,.02)' : 'rgba(255,255,255,.04)';
        const base = gridG.rect(CELL, CELL).move(x0, y0).fill(bg);

        // click target (transparent but on top)
        const hit = gridG.rect(CELL, CELL).move(x0, y0).fill('rgba(0,0,0,0)').stroke({color:'rgba(0,0,0,0)', width:0});
        hit.attr({cursor:'pointer'});

        // filled overlay rect
        const filled = gridG.rect(CELL, CELL).move(x0, y0).fill(C.filled).opacity(0);

        // X mark group
        const mg = gridG.group().move(x0, y0).opacity(0);
        mg.line(6,6, CELL-6, CELL-6).stroke({color:C.x, width:2, linecap:'round'});
        mg.line(CELL-6,6, 6, CELL-6).stroke({color:C.x, width:2, linecap:'round'});

        rowR.push(filled);
        rowM.push(mg);

        // mouse interactions:
        // - left click: fill toggle (or X if mark mode / shift)
        // - right click: X toggle
        hit.on('mousedown', (ev) => {
          if (solved) return;

          // svg.js passes a MouseEvent-like object
          const e = ev.detail?.event || ev; // compatibility
          const isRight = e.button === 2;
          const isShift = !!e.shiftKey;
          const useX = isRight || isShift || markMode;

          if (useX) toggleX(x,y);
          else toggleFill(x,y);
        });

      }
      cellRects.push(rowR);
      cellMarks.push(rowM);
    }

    // grid lines (thin + thicker every 5)
    for (let i=0;i<=N;i++){
      const w = (i%5===0) ? 2.6 : GRID_LINE;
      const col = (i%5===0) ? 'rgba(255,255,255,.30)' : 'rgba(255,255,255,.12)';
      // vertical
      gridG.line(i*CELL, 0, i*CELL, GRID_H).stroke({color: col, width: w});
      // horizontal
      gridG.line(0, i*CELL, GRID_W, i*CELL).stroke({color: col, width: w});
    }
  }

  function renderCell(x,y){
    const v = player[y][x];
    const r = cellRects[y][x];
    const m = cellMarks[y][x];

    // 0 empty
    if (v === 0){
      r.opacity(0);
      m.opacity(0);
    }
    // 1 filled
    else if (v === 1){
      r.opacity(1);
      m.opacity(0);
    }
    // 2 X
    else {
      r.opacity(0);
      m.opacity(1);
    }
  }

  function toggleFill(x,y){
    // If currently X, switch to filled
    if (player[y][x] === 2) player[y][x] = 1;
    else player[y][x] = (player[y][x] === 1 ? 0 : 1);
    renderCell(x,y);
    autoCheckIfClose();
  }

  function toggleX(x,y){
    // If currently filled, switch to X
    if (player[y][x] === 1) player[y][x] = 2;
    else player[y][x] = (player[y][x] === 2 ? 0 : 2);
    renderCell(x,y);
    autoCheckIfClose();
  }

  // -------------------------
  // 10) Check solution
  //     Important: Only "filled" cells (1) must match SOL.
  //     X marks are just notes and do not count as filled.
  // -------------------------
  function isSolved(){
    for (let y=0;y<N;y++){
      for (let x=0;x<N;x++){
        const filled = (player[y][x] === 1) ? 1 : 0;
        if (filled !== SOL[y][x]) return false;
      }
    }
    return true;
  }

  function checkNow(){
    if (isSolved()){
      solved = true;
      showSuccess();
    } else {
      // tiny feedback
      btnCheck.flash();
      resultText.fill(C.bad).text('Not solved yet. Keep going!');
      setTimeout(()=> resultText.fill(C.muted), 650);
    }
  }

  function showSuccess(){
    resultText.fill(C.good).text('Solved! Great job ðŸŽ‰');
    btnCheck.flash();

    // Overlay ribbon
    const overlay = draw.group();
    overlay.rect(W,H).fill('rgba(0,0,0,.45)');
    const box = overlay.rect(620, 220).radius(22).fill('rgba(255,255,255,.10)').stroke({color:'rgba(255,255,255,.20)', width:1});
    box.center(W/2, H/2);
    overlay.text('ðŸŽ‰ Puzzle Solved! ðŸŽ‰').font({ ...FONT_BIG, size: 34 }).fill(C.ink).center(W/2, H/2 - 34);
    overlay.text('Your picture matches perfectly.').font({ ...FONT, size: 16, weight: 850 }).fill(C.muted).center(W/2, H/2 + 14);

    const close = overlay.group();
    const b = close.rect(180, 54).radius(16).fill('rgba(103,179,255,.20)').stroke({color:'rgba(103,179,255,.40)', width:1});
    b.center(W/2, H/2 + 86);
    const t = close.text('Nice!').font({ ...FONT, size: 16, weight: 1000 }).fill(C.ink);
    t.center(W/2, H/2 + 86);

    close.attr({cursor:'pointer'});
    close.on('click', ()=> overlay.remove());

    // confetti dots (SVG)
    for (let i=0;i<120;i++){
      const dot = overlay.circle(6).fill(choice([C.accent, C.good, '#ffd166', '#ff77c8', '#a78bfa']))
        .center(W/2 + (Math.random()*600-300), H/2 + (Math.random()*220-110))
        .opacity(0.9);
      dot.animate(900).dy(120 + Math.random()*150).opacity(0).after(()=> dot.remove());
    }
  }

  // Optional: when close to solved, auto-run check (educational convenience)
  function autoCheckIfClose(){
    if (solved) return;
    // lightweight: check only occasionally
    // If player has at least 70% of required filled cells, perform a full check
    let need = 0, have = 0;
    for (let y=0;y<N;y++){
      for (let x=0;x<N;x++){
        if (SOL[y][x]===1){ need++; if (player[y][x]===1) have++; }
      }
    }
    if (have >= need * 0.70 && isSolved()){
      solved = true;
      showSuccess();
    }
  }

  // -------------------------
  // 11) Clear board
  // -------------------------
  function clearBoard(){
    solved = false;
    for (let y=0;y<N;y++){
      for (let x=0;x<N;x++){
        player[y][x] = 0;
        renderCell(x,y);
      }
    }
    resultText.fill(C.muted).text('Not solved yet.');
    btnClear.flash();
  }

  // -------------------------
  // 12) Button bindings + keyboard shortcuts
  // -------------------------
  btnCheck.on('click', checkNow);
  btnClear.on('click', clearBoard);

  window.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') checkNow();
    if (e.key.toLowerCase() === 'c') clearBoard();
    if (e.key.toLowerCase() === 'm') {
      markMode = !markMode;
      btnToggleX.flash();
      btnToggleX.get(1).text(markMode ? 'Mark Mode: ON' : 'Mark Mode: OFF');
    }
  });

  // -------------------------
  // 13) Render everything
  // -------------------------
  drawClues();
  drawGrid();

  // Initialize all cells rendering
  for (let y=0;y<N;y++){
    for (let x=0;x<N;x++){
      renderCell(x,y);
    }
  }

})();
</script>
</body>
</html>
