<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG.js Nonogram (20x20)</title>
    <!-- Load SVG.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.2.0/svg.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            user-select: none; /* Prevent text selection while playing */
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .controls {
            margin-bottom: 15px;
            font-size: 14px;
            color: #555;
        }

        #game-container {
            background-color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border-radius: 8px;
            padding: 20px;
        }

        /* Prevent context menu on right click inside the game */
        #drawing {
            cursor: pointer;
        }
    </style>
</head>
<body>

    <h1>Nonogram Challenge</h1>
    <div class="controls">
        Left Click: <strong>Fill</strong> | Right Click: <strong>Mark (X)</strong>
    </div>
    
    <div id="game-container">
        <div id="drawing"></div>
    </div>

    <script>
        // --- GAME CONFIGURATION ---
        const GRID_SIZE = 20;
        const CELL_SIZE = 25;
        const CLUE_AREA_SIZE = 140; // Pixels reserved for clues top/left
        
        // Colors and Styles
        const COLOR_BG = '#ffffff';
        const COLOR_GRID = '#dddddd';
        const COLOR_THICK_LINE = '#555555';
        const COLOR_FILLED = '#2c3e50';
        const COLOR_X = '#e74c3c';
        const COLOR_HOVER = '#f1f1f1';
        const COLOR_CLUE_TEXT = '#333333';

        // State Variables
        let solutionGrid = []; // 1 = filled, 0 = empty
        let playerGrid = [];   // 1 = filled, 2 = marked (X), 0 = empty
        let draw = null;       // SVG.js instance
        let cells = [];        // References to SVG cell elements
        let isGameOver = false;

        // --- INITIALIZATION ---
        
        // 1. Generate a random puzzle
        function generatePuzzle() {
            solutionGrid = [];
            playerGrid = [];
            
            // Generate random pattern (approx 55% fill rate for playability)
            for (let r = 0; r < GRID_SIZE; r++) {
                let row = [];
                let pRow = [];
                for (let c = 0; c < GRID_SIZE; c++) {
                    row.push(Math.random() > 0.45 ? 1 : 0);
                    pRow.push(0);
                }
                solutionGrid.push(row);
                playerGrid.push(pRow);
            }
        }

        // 2. Logic to calculate clues from a line (row or col)
        function getClues(line) {
            let clues = [];
            let count = 0;
            for (let val of line) {
                if (val === 1) {
                    count++;
                } else if (count > 0) {
                    clues.push(count);
                    count = 0;
                }
            }
            if (count > 0) clues.push(count);
            if (clues.length === 0) clues.push(0);
            return clues;
        }

        // 3. Main Setup Function
        function initGame() {
            generatePuzzle();

            // Calculate Canvas Size
            const totalWidth = CLUE_AREA_SIZE + (GRID_SIZE * CELL_SIZE);
            const totalHeight = CLUE_AREA_SIZE + (GRID_SIZE * CELL_SIZE);

            // Initialize SVG
            draw = SVG().addTo('#drawing').size(totalWidth, totalHeight);

            // Draw Clues
            drawClues();

            // Draw Grid Cells
            drawGridCells();

            // Draw Grid Overlay (Lines)
            drawGridLines();

            // Add Context Menu preventer
            document.getElementById('drawing').addEventListener('contextmenu', e => e.preventDefault());
        }

        // --- DRAWING FUNCTIONS ---

        function drawClues() {
            // Rows (Left side)
            for (let r = 0; r < GRID_SIZE; r++) {
                let clues = getClues(solutionGrid[r]);
                let textString = clues.join(' ');
                
                let text = draw.text(textString).font({
                    family: 'monospace',
                    size: 12,
                    anchor: 'end',
                    fill: COLOR_CLUE_TEXT
                });

                // Position: x = just before grid, y = center of row
                text.move(CLUE_AREA_SIZE - 10, CLUE_AREA_SIZE + (r * CELL_SIZE) + (CELL_SIZE/2) - 8);
            }

            // Columns (Top side)
            for (let c = 0; c < GRID_SIZE; c++) {
                // Extract column array
                let colArr = solutionGrid.map(row => row[c]);
                let clues = getClues(colArr);
                
                // For vertical clues, we stack numbers vertically
                let group = draw.group();
                let startY = CLUE_AREA_SIZE - 5 - (clues.length * 14);

                clues.forEach((num, index) => {
                    let t = group.text(num.toString()).font({
                        family: 'monospace',
                        size: 12,
                        anchor: 'middle',
                        fill: COLOR_CLUE_TEXT
                    });
                    t.move(CLUE_AREA_SIZE + (c * CELL_SIZE) + (CELL_SIZE/2), startY + (index * 14));
                });
            }
        }

        function drawGridCells() {
            for (let r = 0; r < GRID_SIZE; r++) {
                cells[r] = [];
                for (let c = 0; c < GRID_SIZE; c++) {
                    let x = CLUE_AREA_SIZE + (c * CELL_SIZE);
                    let y = CLUE_AREA_SIZE + (r * CELL_SIZE);

                    let group = draw.group().attr({ class: 'cell-group' });

                    // Background Rect (hit area)
                    let rect = group.rect(CELL_SIZE, CELL_SIZE)
                        .move(x, y)
                        .fill(COLOR_BG)
                        .stroke({ width: 1, color: COLOR_GRID });

                    // Content (Fill or X) - initially hidden/empty
                    let content = group.group(); // Placeholder for drawing X or Square

                    // Store reference
                    cells[r][c] = { group, rect, content, r, c };

                    // Interaction
                    group.on('mousedown', (e) => handleInput(r, c, e));
                    
                    // Hover effect
                    group.on('mouseover', () => {
                        if(!isGameOver && playerGrid[r][c] === 0) rect.fill(COLOR_HOVER);
                    });
                    group.on('mouseout', () => {
                        if(playerGrid[r][c] === 0) rect.fill(COLOR_BG);
                    });
                }
            }
        }

        function drawGridLines() {
            // Draw thicker lines every 5 cells to help counting
            const startX = CLUE_AREA_SIZE;
            const startY = CLUE_AREA_SIZE;
            const endX = startX + (GRID_SIZE * CELL_SIZE);
            const endY = startY + (GRID_SIZE * CELL_SIZE);

            // Outer border
            draw.rect(GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE)
                .move(startX, startY)
                .fill('none')
                .stroke({ width: 2, color: COLOR_THICK_LINE });

            // Internal thick lines
            for (let i = 5; i < GRID_SIZE; i += 5) {
                // Vertical
                draw.line(startX + (i * CELL_SIZE), startY, startX + (i * CELL_SIZE), endY)
                    .stroke({ width: 2, color: COLOR_THICK_LINE });
                // Horizontal
                draw.line(startX, startY + (i * CELL_SIZE), endX, startY + (i * CELL_SIZE))
                    .stroke({ width: 2, color: COLOR_THICK_LINE });
            }
        }

        // --- GAME LOGIC ---

        function handleInput(r, c, e) {
            if (isGameOver) return;

            const isRightClick = (e.button === 2);
            const currentState = playerGrid[r][c];
            
            // Logic State Table:
            // 0 = Empty, 1 = Filled, 2 = Marked
            
            if (isRightClick) {
                // Right Click: Toggle X (Empty -> Marked -> Empty)
                // Should not overwrite a Filled cell
                if (currentState === 0) {
                    updateCell(r, c, 2);
                } else if (currentState === 2) {
                    updateCell(r, c, 0);
                }
            } else {
                // Left Click: Toggle Fill (Empty -> Filled -> Empty)
                // Should not overwrite a Marked cell
                if (currentState === 0) {
                    updateCell(r, c, 1);
                } else if (currentState === 1) {
                    updateCell(r, c, 0);
                }
            }

            checkWinCondition();
        }

        function updateCell(r, c, newState) {
            playerGrid[r][c] = newState;
            let cellObj = cells[r][c];
            
            // Clear previous visual content
            cellObj.content.clear();
            cellObj.rect.fill(COLOR_BG); // Reset BG

            const cx = CLUE_AREA_SIZE + (c * CELL_SIZE) + (CELL_SIZE/2);
            const cy = CLUE_AREA_SIZE + (r * CELL_SIZE) + (CELL_SIZE/2);

            if (newState === 1) {
                // Filled
                cellObj.content.rect(CELL_SIZE, CELL_SIZE)
                    .move(CLUE_AREA_SIZE + (c*CELL_SIZE), CLUE_AREA_SIZE + (r*CELL_SIZE))
                    .fill(COLOR_FILLED);
            } else if (newState === 2) {
                // Marked (X)
                let pad = 6;
                let x = CLUE_AREA_SIZE + (c * CELL_SIZE);
                let y = CLUE_AREA_SIZE + (r * CELL_SIZE);
                
                cellObj.content.line(x + pad, y + pad, x + CELL_SIZE - pad, y + CELL_SIZE - pad)
                    .stroke({ width: 2, color: COLOR_X });
                cellObj.content.line(x + CELL_SIZE - pad, y + pad, x + pad, y + CELL_SIZE - pad)
                    .stroke({ width: 2, color: COLOR_X });
            }
        }

        function checkWinCondition() {
            let isCorrect = true;
            
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    // We only care if filled cells match. 
                    // A cell is correct if:
                    // 1. Solution is 1 AND Player is 1
                    // 2. Solution is 0 AND Player is NOT 1 (0 or 2 is fine)
                    
                    let sol = solutionGrid[r][c];
                    let play = playerGrid[r][c];

                    if (sol === 1 && play !== 1) isCorrect = false;
                    if (sol === 0 && play === 1) isCorrect = false;
                }
            }

            if (isCorrect) {
                victory();
            }
        }

        function victory() {
            isGameOver = true;
            
            // Draw overlay message
            let totalSize = CLUE_AREA_SIZE + (GRID_SIZE * CELL_SIZE);
            
            let group = draw.group();
            
            // Semi-transparent background
            group.rect(GRID_SIZE * CELL_SIZE, 80)
                .move(CLUE_AREA_SIZE, CLUE_AREA_SIZE + (GRID_SIZE * CELL_SIZE)/2 - 40)
                .fill({ color: '#27ae60', opacity: 0.9 })
                .radius(5);

            // Text
            group.text('PUZZLE SOLVED!')
                .font({ size: 30, family: 'Arial', weight: 'bold', anchor: 'middle' })
                .fill('#fff')
                .center(CLUE_AREA_SIZE + (GRID_SIZE * CELL_SIZE)/2, CLUE_AREA_SIZE + (GRID_SIZE * CELL_SIZE)/2);
        }

        // Start
        initGame();

    </script>
</body>
</html>