<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kids' Magical Maze</title>
    <!-- Load SVG.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.1.2/svg.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #E0F7FA; /* Light Blue Background */
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif; /* Kid-friendly font */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        h1 {
            color: #006064;
            text-shadow: 2px 2px 0px #fff;
            margin: 10px 0;
        }

        #game-container {
            background: #fff;
            padding: 10px;
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            border: 5px solid #4DD0E1;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }

        button {
            background-color: #FF7043;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 18px;
            border-radius: 50px;
            cursor: pointer;
            font-family: inherit;
            box-shadow: 0 4px 0 #D84315;
            transition: transform 0.1s;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #D84315;
        }

        #solution-btn {
            background-color: #66BB6A;
            box-shadow: 0 4px 0 #2E7D32;
        }
        
        #solution-btn:active {
            box-shadow: 0 0 0 #2E7D32;
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 30px;
            color: #D84315;
            text-align: center;
            border: 5px solid #FFCCBC;
            display: none;
            z-index: 10;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .instructions {
            margin-bottom: 10px;
            color: #555;
            font-size: 14px;
        }
        
        /* Mobile Controls */
        .d-pad {
            display: none;
            margin-top: 15px;
            gap: 10px;
        }
        .d-btn {
            width: 50px; height: 50px; font-size: 24px;
        }
        @media (max-width: 600px) {
            .d-pad { display: flex; flex-direction: column; align-items: center; }
            .instructions { display: none; }
        }
    </style>
</head>
<body>

    <h1>The Maze Adventure</h1>
    <div class="instructions">Use Arrow Keys to move. Reach the Flag! Avoid the monsters!</div>

    <div id="game-container">
        <!-- SVG Canvas will be injected here -->
    </div>

    <div id="message">Game Over!</div>

    <div class="controls">
        <button id="solution-btn" onclick="game.showSolution()">Show Hint</button>
        <button onclick="game.init()">Restart Game</button>
    </div>

    <!-- Mobile Controls -->
    <div class="d-pad">
        <div><button class="d-btn" onclick="game.handleInput('ArrowUp')">‚¨ÜÔ∏è</button></div>
        <div>
            <button class="d-btn" onclick="game.handleInput('ArrowLeft')">‚¨ÖÔ∏è</button>
            <button class="d-btn" onclick="game.handleInput('ArrowDown')">‚¨áÔ∏è</button>
            <button class="d-btn" onclick="game.handleInput('ArrowRight')">‚û°Ô∏è</button>
        </div>
    </div>

<script>
/**
 * MAZE GAME LOGIC
 * - Generates a perfect maze (Recursive Backtracker)
 * - Solves the maze (BFS) for the hint system
 * - Uses SVG.js for rendering
 */

const COLS = 20;
const ROWS = 20;
const CELL_SIZE = 25; // Pixels per cell

class MazeGame {
    constructor() {
        // Setup SVG Canvas
        this.draw = SVG().addTo('#game-container').size(COLS * CELL_SIZE, ROWS * CELL_SIZE);
        this.maze = []; // Stores wall data
        this.stack = []; // For generation
        this.solutionPath = [];
        
        // Game State
        this.hero = { x: 0, y: 0, el: null };
        this.goal = { x: COLS-1, y: ROWS-1, el: null };
        this.enemies = [];
        this.trail = [];
        this.isGameOver = false;
        this.frameCount = 0;

        // Bind input
        document.addEventListener('keydown', (e) => this.handleInput(e.key));
        
        this.init();
        this.loop();
    }

    // --- 1. Maze Generation (Recursive Backtracker) ---
    init() {
        this.isGameOver = false;
        this.enemies = [];
        this.trail = [];
        this.draw.clear();
        document.getElementById('message').style.display = 'none';
        
        // Initialize Grid
        for (let y = 0; y < ROWS; y++) {
            let row = [];
            for (let x = 0; x < COLS; x++) {
                row.push({
                    x, y,
                    visited: false,
                    walls: [true, true, true, true] // Top, Right, Bottom, Left
                });
            }
            this.maze.push(row);
        }

        // Generate Maze
        let current = this.maze[0][0];
        current.visited = true;
        this.stack.push(current);

        while (this.stack.length > 0) {
            let next = this.checkNeighbors(current);
            if (next) {
                next.visited = true;
                this.stack.push(current);
                this.removeWalls(current, next);
                current = next;
            } else {
                current = this.stack.pop();
            }
        }

        this.drawMaze();
        this.spawnEntities();
        this.solveMaze(); // Pre-calculate solution for the button
    }

    checkNeighbors(cell) {
        let neighbors = [];
        const { x, y } = cell;

        if (y > 0 && !this.maze[y-1][x].visited) neighbors.push(this.maze[y-1][x]);
        if (x < COLS-1 && !this.maze[y][x+1].visited) neighbors.push(this.maze[y][x+1]);
        if (y < ROWS-1 && !this.maze[y+1][x].visited) neighbors.push(this.maze[y+1][x]);
        if (x > 0 && !this.maze[y][x-1].visited) neighbors.push(this.maze[y][x-1]);

        if (neighbors.length > 0) {
            let r = Math.floor(Math.random() * neighbors.length);
            return neighbors[r];
        }
        return undefined;
    }

    removeWalls(a, b) {
        let x = a.x - b.x;
        if (x === 1) { a.walls[3] = false; b.walls[1] = false; }
        else if (x === -1) { a.walls[1] = false; b.walls[3] = false; }
        
        let y = a.y - b.y;
        if (y === 1) { a.walls[0] = false; b.walls[2] = false; }
        else if (y === -1) { a.walls[2] = false; b.walls[0] = false; }
    }

    // --- 2. Rendering ---
    drawMaze() {
        const bg = this.draw.rect(COLS * CELL_SIZE, ROWS * CELL_SIZE).fill('#FFF8E1');
        
        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                let cell = this.maze[y][x];
                let cx = x * CELL_SIZE;
                let cy = y * CELL_SIZE;

                // Draw Walls (Lines)
                // We draw Right and Bottom to avoid overlapping, except for outer edges
                if (cell.walls[1]) this.draw.line(cx + CELL_SIZE, cy, cx + CELL_SIZE, cy + CELL_SIZE).stroke({ color: '#5D4037', width: 3 });
                if (cell.walls[2]) this.draw.line(cx, cy + CELL_SIZE, cx + CELL_SIZE, cy + CELL_SIZE).stroke({ color: '#5D4037', width: 3 });
                if (x === 0 && cell.walls[3]) this.draw.line(cx, cy, cx, cy + CELL_SIZE).stroke({ color: '#5D4037', width: 3 });
                if (y === 0 && cell.walls[0]) this.draw.line(cx, cy, cx + CELL_SIZE, cy).stroke({ color: '#5D4037', width: 3 });
            }
        }

        // Draw Goal
        this.goal.el = this.draw.group().move(this.goal.x * CELL_SIZE, this.goal.y * CELL_SIZE);
        this.goal.el.circle(CELL_SIZE).fill('#4CAF50');
        this.goal.el.text('üèÅ').font({size: 15}).move(5, 4);

        // Draw Hero
        this.hero.x = 0;
        this.hero.y = 0;
        this.hero.el = this.createHeroGroup(0, 0);
    }

    createHeroGroup(x, y) {
        let g = this.draw.group().move(x * CELL_SIZE, y * CELL_SIZE);
        
        // Body
        g.circle(CELL_SIZE - 4).fill('#29B6F6').move(2, 2);
        
        // Eyes
        g.circle(4).fill('white').move(6, 8);
        g.circle(4).fill('white').move(14, 8);
        g.circle(2).fill('black').move(7, 9);
        g.circle(2).fill('black').move(15, 9);
        
        // Smile
        g.path('M7 16 Q12 20 17 16').fill('none').stroke('#000').stroke({width: 1.5});

        return g;
    }

    spawnEntities() {
        // Spawn 4 Enemies
        for(let i=0; i<4; i++) {
            let ex, ey;
            do {
                ex = Math.floor(Math.random() * COLS);
                ey = Math.floor(Math.random() * ROWS);
            } while ((ex < 5 && ey < 5) || (ex === this.goal.x && ey === this.goal.y)); // Keep away from start/goal

            let enemyGroup = this.draw.group().move(ex * CELL_SIZE, ey * CELL_SIZE);
            // Monster design: Cute Purple Ghost
            enemyGroup.circle(CELL_SIZE-4).fill('#AB47BC').move(2,2); // Head
            enemyGroup.rect(CELL_SIZE-4, 10).fill('#AB47BC').move(2, 10); // Bottom blob
            enemyGroup.circle(3).fill('white').move(6, 8);
            enemyGroup.circle(3).fill('white').move(14, 8);
            enemyGroup.circle(1.5).fill('black').move(7.5, 9);
            enemyGroup.circle(1.5).fill('black').move(15.5, 9);
            
            this.enemies.push({ x: ex, y: ey, el: enemyGroup, dir: Math.floor(Math.random()*4) });
        }
    }

    // --- 3. Game Logic ---
    handleInput(key) {
        if (this.isGameOver) return;

        let dx = 0; 
        let dy = 0;
        let wallIndex = 0;

        if (key === 'ArrowUp') { dy = -1; wallIndex = 0; }
        else if (key === 'ArrowRight') { dx = 1; wallIndex = 1; }
        else if (key === 'ArrowDown') { dy = 1; wallIndex = 2; }
        else if (key === 'ArrowLeft') { dx = -1; wallIndex = 3; }
        else return;

        let currentCell = this.maze[this.hero.y][this.hero.x];

        // Check Wall Collision
        if (!currentCell.walls[wallIndex]) {
            this.hero.x += dx;
            this.hero.y += dy;
            this.hero.el.animate(150, '<>').move(this.hero.x * CELL_SIZE, this.hero.y * CELL_SIZE);
            
            // Clear hint if user moves
            if(this.hintLine) this.hintLine.remove();
        }

        this.checkWin();
    }

    checkWin() {
        // Win Condition
        if (this.hero.x === this.goal.x && this.hero.y === this.goal.y) {
            this.isGameOver = true;
            this.showMsg("You Won! üéâ");
        }
    }

    gameOver() {
        this.isGameOver = true;
        this.showMsg("Oh no! A Monster caught you! üëæ");
    }

    showMsg(text) {
        const el = document.getElementById('message');
        el.innerText = text;
        el.style.display = 'block';
    }

    // --- 4. Enemy AI & Trail System ---
    loop() {
        if (!this.isGameOver) {
            this.frameCount++;

            // Trail Logic: Every 20 frames (approx 0.3 sec), place a dot
            if (this.frameCount % 20 === 0) {
                const cx = this.hero.x * CELL_SIZE + CELL_SIZE/2;
                const cy = this.hero.y * CELL_SIZE + CELL_SIZE/2;
                
                // Add a small dot
                const dot = this.draw.circle(4).fill('#FFEB3B').center(cx, cy).opacity(0.8);
                
                this.trail.push(dot);
                
                // Limit trail length to keep performance high (keep last 50)
                if (this.trail.length > 50) {
                    const oldDot = this.trail.shift();
                    oldDot.remove();
                }
            }

            // Enemy Movement: Every 30 frames
            if (this.frameCount % 30 === 0) {
                this.moveEnemies();
            }

            requestAnimationFrame(() => this.loop());
        }
    }

    moveEnemies() {
        this.enemies.forEach(en => {
            // Simple random move, but must respect walls
            let moves = []; // Possible directions: 0,1,2,3
            
            // Check walls of current cell
            let cell = this.maze[en.y][en.x];
            if (!cell.walls[0]) moves.push(0); // Up
            if (!cell.walls[1]) moves.push(1); // Right
            if (!cell.walls[2]) moves.push(2); // Down
            if (!cell.walls[3]) moves.push(3); // Left

            if (moves.length > 0) {
                let r = moves[Math.floor(Math.random() * moves.length)];
                let dx=0, dy=0;
                if (r===0) dy=-1; if (r===1) dx=1; if (r===2) dy=1; if (r===3) dx=-1;

                en.x += dx;
                en.y += dy;
                en.el.animate(300, '<>').move(en.x * CELL_SIZE, en.y * CELL_SIZE);

                // Check collision with hero
                if (en.x === this.hero.x && en.y === this.hero.y) {
                    this.gameOver();
                }
            }
        });
    }

    // --- 5. Solver (BFS) ---
    solveMaze() {
        let start = this.maze[0][0];
        let queue = [{ cell: start, path: [] }];
        let visited = new Set();
        visited.add(`0,0`);

        let finalPath = null;

        while (queue.length > 0) {
            let { cell, path } = queue.shift();
            let newPath = [...path, cell];

            if (cell.x === COLS - 1 && cell.y === ROWS - 1) {
                finalPath = newPath;
                break;
            }

            // Add neighbors
            // Neighbors must NOT have a wall between them
            // Up
            if (!cell.walls[0] && !visited.has(`${cell.x},${cell.y-1}`)) {
                visited.add(`${cell.x},${cell.y-1}`);
                queue.push({ cell: this.maze[cell.y-1][cell.x], path: newPath });
            }
            // Right
            if (!cell.walls[1] && !visited.has(`${cell.x+1},${cell.y}`)) {
                visited.add(`${cell.x+1},${cell.y}`);
                queue.push({ cell: this.maze[cell.y][cell.x+1], path: newPath });
            }
            // Down
            if (!cell.walls[2] && !visited.has(`${cell.x},${cell.y+1}`)) {
                visited.add(`${cell.x},${cell.y+1}`);
                queue.push({ cell: this.maze[cell.y+1][cell.x], path: newPath });
            }
            // Left
            if (!cell.walls[3] && !visited.has(`${cell.x-1},${cell.y}`)) {
                visited.add(`${cell.x-1},${cell.y}`);
                queue.push({ cell: this.maze[cell.y][cell.x-1], path: newPath });
            }
        }

        this.solutionPath = finalPath;
    }

    showSolution() {
        if (this.isGameOver || !this.solutionPath) return;
        
        // Draw the solution path line
        if(this.hintLine) this.hintLine.remove();
        
        let points = "";
        this.solutionPath.forEach((cell, i) => {
            let cx = cell.x * CELL_SIZE + CELL_SIZE/2;
            let cy = cell.y * CELL_SIZE + CELL_SIZE/2;
            points += `${cx},${cy} `;
        });

        this.hintLine = this.draw.polyline(points).fill('none').stroke({ color: '#FF5722', width: 5, dasharray: '5,5' }).back(); // Put behind entities
    }
}

// Start Game
const game = new MazeGame();

</script>
</body>
</html>