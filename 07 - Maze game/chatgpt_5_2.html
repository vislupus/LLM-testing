<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kindergarten Maze Adventure (20√ó20) ‚Äî SVG.js Single File</title>
  <style>
    html, body { height:100%; margin:0; background:#0b1020; overflow:hidden; }
    #app { width:100%; height:100%; }
    noscript { color:#fff; padding:16px; font-family:system-ui, sans-serif; }
  </style>
</head>
<body>
<noscript>This game needs JavaScript enabled.</noscript>
<div id="app"></div>

<!-- SVG.js from CDN (still one HTML file; if you need fully offline, inline svg.js here) -->
<script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2/dist/svg.min.js"></script>

<script>
/*
  ============================================================
  KINDERGARTEN MAZE ADVENTURE (Single-file SVG.js game)

  Requirements met:
  ‚úÖ Random maze 20√ó20 each time (perfect maze generation)
  ‚úÖ Always solvable (spanning tree / DFS carving guarantees solution)
  ‚úÖ Cute animated hero controlled with arrow keys; cannot pass walls
  ‚úÖ Friendly monsters that roam; if they reach hero -> restart
  ‚úÖ Hero leaves trail of small circles at regular intervals while moving
  ‚úÖ Button shows correct solution path for current maze
  ‚úÖ Everything drawn + animated with SVG.js (no canvas, no DOM shapes)
  ‚úÖ Fully self-contained in one HTML file (except svg.js loaded from CDN)
  ‚úÖ Colorful, child-friendly style, clear comments
  ============================================================
*/

(() => {
  // ---------------------------
  // 1) SVG / Game dimensions
  // ---------------------------
  const GRID = 20;              // 20√ó20 maze
  const CELL = 28;              // cell size in pixels
  const WALL = 4;               // wall thickness
  const PAD = 90;               // padding around maze for UI text
  const MAZE_W = GRID * CELL;
  const MAZE_H = GRID * CELL;
  const W = MAZE_W + PAD * 2;
  const H = MAZE_H + PAD * 2;

  const draw = SVG().addTo('#app').size('100%', '100%').viewbox(0, 0, W, H);

  // ---------------------------
  // 2) Friendly palette
  // ---------------------------
  const C = {
    bg0: '#101a3a',
    bg1: '#1e3a8a',
    panel: 'rgba(255,255,255,.12)',
    ink: '#f7fbff',
    soft: 'rgba(247,251,255,.80)',
    wall: '#5b7cfa',
    wallGlow: 'rgba(255,255,255,.18)',
    floor: 'rgba(255,255,255,.06)',
    start: '#34d399',
    goal:  '#f59e0b',
    hero:  '#ff77c8',
    hero2: '#ffd1f0',
    monster1: '#67b3ff',
    monster2: '#9bffb5',
    monster3: '#ffd166',
    trail: 'rgba(255,255,255,.65)',
    path: 'rgba(255,255,255,.95)',
    pathGlow: 'rgba(255,255,255,.35)',
    danger: '#ff6b87',
  };

  // ---------------------------
  // 3) Helpers
  // ---------------------------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rint = (a,b)=>Math.floor(a + Math.random()*(b-a+1));
  const choice = (arr)=>arr[Math.floor(Math.random()*arr.length)];

  function cellToXY(x, y){
    return {
      cx: PAD + x*CELL + CELL/2,
      cy: PAD + y*CELL + CELL/2
    };
  }

  // For collision / snapping
  const keyDir = {
    ArrowUp:    {dx:0, dy:-1},
    ArrowDown:  {dx:0, dy: 1},
    ArrowLeft:  {dx:-1,dy: 0},
    ArrowRight: {dx: 1,dy: 0},
  };

  // ---------------------------
  // 4) Background & UI panel
  // ---------------------------
  const bg = draw.group();
  const sky = draw.gradient('radial', add => {
    add.stop(0, 'rgba(155,255,181,.12)');
    add.stop(0.35, 'rgba(103,179,255,.14)');
    add.stop(1, C.bg0);
  });
  bg.rect(W,H).fill(C.bg0);
  bg.rect(W,H).fill(sky);

  // Cute stars
  const stars = draw.group().opacity(0.95);
  for (let i=0;i<140;i++){
    const x = Math.random()*W, y = Math.random()*H;
    const s = Math.random()<0.85 ? 1 : 2;
    stars.circle(s).move(x,y).fill(`rgba(247,251,255,${0.15 + Math.random()*0.55})`);
  }

  // UI header
  const ui = draw.group();
  const header = ui.group();
  header.rect(W-30, 64).radius(18).fill(C.panel).stroke({color:'rgba(255,255,255,.18)', width:1}).move(15, 14);
  header.text('üåà Maze Adventure!').font({family:'system-ui', size: 22, weight: 900}).fill(C.ink).move(34, 32);
  header.text('Arrow keys to move ‚Ä¢ Avoid the silly monsters ‚Ä¢ Reach the ‚≠ê goal!').font({family:'system-ui', size: 13, weight: 700}).fill(C.soft).move(250, 38);

  // ‚ÄúShow Solution‚Äù button (drawn with SVG.js)
  function makeButton(x,y,w,h,label){
    const g = ui.group().move(x,y);
    const r = g.rect(w,h).radius(16).fill('rgba(255,255,255,.10)').stroke({color:'rgba(255,255,255,.22)', width:1});
    const t = g.text(label).font({family:'system-ui', size: 14, weight: 900}).fill(C.ink);
    t.center(w/2, h/2 + 0.5);
    g.attr({cursor:'pointer'});
    g.on('mouseover', ()=> r.animate(120).fill('rgba(255,255,255,.16)'));
    g.on('mouseout',  ()=> r.animate(120).fill('rgba(255,255,255,.10)'));
    g.flash = ()=> r.animate(90).fill('rgba(255,255,255,.18)').after(()=>r.animate(140).fill('rgba(255,255,255,.10)'));
    g.bg = r;
    return g;
  }

  const btnSolution = makeButton(W-250, 24, 220, 44, 'Show Solution Path');

  // Score / status text (SVG text)
  const statusText = ui.text('Ready!').font({family:'system-ui', size: 14, weight: 900}).fill(C.soft).move(34, 86);

  // ---------------------------
  // 5) Maze data structure
  //    We'll generate a "perfect maze" using randomized DFS.
  //    Each cell has walls: top, right, bottom, left
  // ---------------------------
  function newMaze(){
    const cells = [];
    for (let y=0;y<GRID;y++){
      const row = [];
      for (let x=0;x<GRID;x++){
        row.push({
          x,y,
          visited:false,
          walls: {t:true, r:true, b:true, l:true}
        });
      }
      cells.push(row);
    }
    // DFS stack carving
    const stack = [];
    const start = cells[0][0];
    start.visited = true;
    stack.push(start);

    const neighbors = (c) => {
      const list = [];
      const {x,y} = c;
      if (y>0) list.push({dir:'t', cell: cells[y-1][x]});
      if (x<GRID-1) list.push({dir:'r', cell: cells[y][x+1]});
      if (y<GRID-1) list.push({dir:'b', cell: cells[y+1][x]});
      if (x>0) list.push({dir:'l', cell: cells[y][x-1]});
      return list.filter(n => !n.cell.visited);
    };

    while (stack.length){
      const cur = stack[stack.length-1];
      const opts = neighbors(cur);
      if (opts.length === 0){
        stack.pop();
      } else {
        const pick = choice(opts);
        const nxt = pick.cell;

        // Knock down walls between cur and nxt
        if (pick.dir === 't'){ cur.walls.t=false; nxt.walls.b=false; }
        if (pick.dir === 'r'){ cur.walls.r=false; nxt.walls.l=false; }
        if (pick.dir === 'b'){ cur.walls.b=false; nxt.walls.t=false; }
        if (pick.dir === 'l'){ cur.walls.l=false; nxt.walls.r=false; }

        nxt.visited = true;
        stack.push(nxt);
      }
    }

    // Clear visited marks (optional)
    for (let y=0;y<GRID;y++) for (let x=0;x<GRID;x++) cells[y][x].visited = false;
    return cells;
  }

  // ---------------------------
  // 6) Solve maze (BFS) for solution path
  // ---------------------------
  function solveMaze(cells, sx,sy,gx,gy){
    const q = [{x:sx,y:sy}];
    const prev = Array.from({length:GRID}, ()=>Array(GRID).fill(null));
    prev[sy][sx] = {x:sx,y:sy}; // mark start

    const canGo = (x,y, nx,ny) => {
      const c = cells[y][x];
      if (nx===x && ny===y-1) return !c.walls.t;
      if (nx===x+1 && ny===y) return !c.walls.r;
      if (nx===x && ny===y+1) return !c.walls.b;
      if (nx===x-1 && ny===y) return !c.walls.l;
      return false;
    };

    while (q.length){
      const cur = q.shift();
      if (cur.x===gx && cur.y===gy) break;
      const dirs = [
        {dx:0,dy:-1},{dx:1,dy:0},{dx:0,dy:1},{dx:-1,dy:0}
      ];
      for (const d of dirs){
        const nx = cur.x + d.dx, ny = cur.y + d.dy;
        if (nx<0||ny<0||nx>=GRID||ny>=GRID) continue;
        if (prev[ny][nx]) continue;
        if (!canGo(cur.x, cur.y, nx, ny)) continue;
        prev[ny][nx] = {x:cur.x, y:cur.y};
        q.push({x:nx,y:ny});
      }
    }

    // Reconstruct
    if (!prev[gy][gx]) return [];
    const path = [];
    let cur = {x:gx,y:gy};
    while (!(cur.x===sx && cur.y===sy)){
      path.push(cur);
      cur = prev[cur.y][cur.x];
    }
    path.push({x:sx,y:sy});
    path.reverse();
    return path;
  }

  // ---------------------------
  // 7) Draw maze with SVG.js
  // ---------------------------
  const world = draw.group();
  const mazeG = world.group();
  const floorG = world.group();
  const fxG = world.group();       // trail / effects
  const pathG = world.group();     // solution path layer
  const actorsG = world.group();   // hero + monsters
  const overlayG = world.group();  // win/lose animations

  // Friendly ‚Äúplay mat‚Äù
  const mat = world.group();
  mat.rect(MAZE_W+30, MAZE_H+30).radius(28)
    .fill('rgba(255,255,255,.04)')
    .stroke({color:'rgba(255,255,255,.14)', width:1})
    .move(PAD-15, PAD-15);

  // Floor tint
  floorG.rect(MAZE_W, MAZE_H).fill(C.floor).move(PAD, PAD);

  function drawMaze(cells){
    mazeG.clear();
    // We draw walls as lines. To keep it cute, make them thick and rounded.
    const wallStyle = {color: C.wall, width: WALL, linecap:'round', linejoin:'round'};
    const glowStyle = {color: C.wallGlow, width: WALL+4, linecap:'round', linejoin:'round', opacity: 0.25};

    // Outer border (always walls)
    mazeG.rect(MAZE_W, MAZE_H).fill('none').stroke({color:C.wall, width:WALL}).move(PAD, PAD);

    for (let y=0;y<GRID;y++){
      for (let x=0;x<GRID;x++){
        const c = cells[y][x];
        const x0 = PAD + x*CELL;
        const y0 = PAD + y*CELL;
        const x1 = x0 + CELL;
        const y1 = y0 + CELL;

        // Draw each wall only once (top and left for each cell, plus bottom/right on edges)
        if (c.walls.t){
          mazeG.line(x0, y0, x1, y0).stroke(glowStyle);
          mazeG.line(x0, y0, x1, y0).stroke(wallStyle);
        }
        if (c.walls.l){
          mazeG.line(x0, y0, x0, y1).stroke(glowStyle);
          mazeG.line(x0, y0, x0, y1).stroke(wallStyle);
        }
        if (y === GRID-1 && c.walls.b){
          mazeG.line(x0, y1, x1, y1).stroke(glowStyle);
          mazeG.line(x0, y1, x1, y1).stroke(wallStyle);
        }
        if (x === GRID-1 && c.walls.r){
          mazeG.line(x1, y0, x1, y1).stroke(glowStyle);
          mazeG.line(x1, y0, x1, y1).stroke(wallStyle);
        }
      }
    }
  }

  // Start & Goal markers
  const startMarker = world.group();
  const goalMarker = world.group();

  function drawStartGoal(){
    startMarker.clear();
    goalMarker.clear();

    // START at (0,0)
    let p = cellToXY(0,0);
    startMarker.circle(CELL*0.78).center(p.cx, p.cy)
      .fill(C.start).opacity(0.20).stroke({color:'rgba(255,255,255,.18)', width:1});
    startMarker.text('START').font({family:'system-ui', size: 11, weight: 1000})
      .fill(C.ink).center(p.cx, p.cy + CELL*0.52);

    // GOAL at (19,19)
    p = cellToXY(GRID-1, GRID-1);
    goalMarker.circle(CELL*0.86).center(p.cx, p.cy)
      .fill(C.goal).opacity(0.20).stroke({color:'rgba(255,255,255,.18)', width:1});
    goalMarker.text('‚≠ê').font({family:'system-ui', size: 18, weight: 900}).fill(C.ink).center(p.cx, p.cy);
    goalMarker.text('GOAL').font({family:'system-ui', size: 11, weight: 1000})
      .fill(C.ink).center(p.cx, p.cy + CELL*0.55);

    // Little pulsing for goal
    const ring = goalMarker.circle(CELL*1.15).center(p.cx,p.cy).fill('none').stroke({color:'rgba(245,158,11,.65)', width:2, dasharray:'6 8'});
    ring.animate(1200).rotate(360, p.cx, p.cy).loop();
  }

  // ---------------------------
  // 8) Hero (cute animated)
  // ---------------------------
  function makeHero(){
    const g = actorsG.group();
    // body
    const body = g.circle(CELL*0.68).fill(C.hero).opacity(0.95);
    // belly
    const belly = g.circle(CELL*0.42).fill(C.hero2).opacity(0.85);
    // eyes
    const eyeL = g.circle(6).fill('#1a1a2e');
    const eyeR = g.circle(6).fill('#1a1a2e');
    const shineL = g.circle(2).fill('#fff');
    const shineR = g.circle(2).fill('#fff');
    // smile
    const smile = g.path('M 0 0 C 6 8 16 8 22 0').fill('none').stroke({color:'#1a1a2e', width:3, linecap:'round'});
    // tiny cheeks
    const cheekL = g.circle(6).fill('rgba(255,255,255,.35)');
    const cheekR = g.circle(6).fill('rgba(255,255,255,.35)');

    // position parts relative
    body.center(0,0);
    belly.center(0, 6);

    eyeL.center(-8, -6);
    eyeR.center( 8, -6);
    shineL.center(-6, -8);
    shineR.center(10, -8);

    smile.center(0, 8);
    cheekL.center(-16, 2);
    cheekR.center( 16, 2);

    // ‚Äúwobble‚Äù animation
    g.animate(900).rotate(3, 0, 0).after(()=> {
      g.animate(900).rotate(-3, 0, 0).loop();
    });

    return {g, body};
  }

  // ---------------------------
  // 9) Monsters (friendly but "tag you!")
  // ---------------------------
  function makeMonster(color, face='üò∫'){
    const g = actorsG.group();
    const blob = g.circle(CELL*0.68).fill(color).opacity(0.85);
    const glow = g.circle(CELL*0.9).fill(color).opacity(0.18);
    const emoji = g.text(face).font({family:'system-ui', size: 18, weight: 900}).fill('#0b1020');
    glow.center(0,0);
    blob.center(0,0);
    emoji.center(0, 2);

    // bouncy animation
    g.animate(420).scale(1.05, 0.98).after(()=> g.animate(420).scale(0.98, 1.05).loop());

    return {g, blob};
  }

  // ---------------------------
  // 10) Movement rules (walls)
  // ---------------------------
  function canMove(cells, x, y, dx, dy){
    const nx = x + dx, ny = y + dy;
    if (nx<0 || ny<0 || nx>=GRID || ny>=GRID) return false;
    const c = cells[y][x];
    if (dx===0 && dy===-1) return !c.walls.t;
    if (dx===1 && dy===0)  return !c.walls.r;
    if (dx===0 && dy===1)  return !c.walls.b;
    if (dx===-1 && dy===0) return !c.walls.l;
    return false;
  }

  // ---------------------------
  // 11) Game state & restart
  // ---------------------------
  let cells = null;
  let hero = null;
  let heroCell = {x:0,y:0};
  let heroMoving = false;

  let monsters = [];   // {g, x,y, dir, speedMs, face}
  let gameLoopTimer = null;
  let trailTimer = null;

  let solutionPath = [];
  let solutionVisible = false;

  function clearAll(){
    mazeG.clear();
    pathG.clear();
    fxG.clear();
    actorsG.clear();
    overlayG.clear();
    startMarker.clear();
    goalMarker.clear();
  }

  function restartGame(message='New maze!'){
    // stop timers
    if (gameLoopTimer) clearInterval(gameLoopTimer);
    if (trailTimer) clearInterval(trailTimer);

    solutionVisible = false;
    clearAll();

    // Generate a new maze and draw it
    cells = newMaze();
    drawMaze(cells);
    drawStartGoal();

    // Solve for current maze and store path
    solutionPath = solveMaze(cells, 0,0, GRID-1, GRID-1);

    // Create hero
    hero = makeHero();
    heroCell = {x:0,y:0};
    placeHero();

    // Create monsters (kindergarten-friendly count)
    monsters = [];
    const monsterCount = 3;
    const faces = ['üò∫','üêª','üê∏','üêº','ü¶ä','üêµ'];
    const colors = [C.monster1, C.monster2, C.monster3];
    for (let i=0;i<monsterCount;i++){
      // place monsters away from hero
      let mx, my;
      do {
        mx = rint(6, GRID-1);
        my = rint(6, GRID-1);
      } while ((mx===0 && my===0) || (mx===GRID-1 && my===GRID-1));

      const m = makeMonster(colors[i%colors.length], faces[i%faces.length]);
      const speed = rint(420, 650); // ms per step
      const dir = choice([{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}]);

      m.x = mx; m.y = my;
      m.dir = dir;
      m.speedMs = speed;
      placeActor(m.g, mx, my);
      monsters.push(m);
    }

    // Start monster loop
    gameLoopTimer = setInterval(monsterStepAll, 120);

    // Trail timer (leave circles while moving)
    trailTimer = setInterval(() => {
      if (!heroMoving) return;
      dropTrail();
    }, 120);

    statusText.text(message);
  }

  function placeActor(g, x, y){
    const p = cellToXY(x,y);
    g.center(p.cx, p.cy);
  }

  function placeHero(){
    placeActor(hero.g, heroCell.x, heroCell.y);
  }

  // ---------------------------
  // 12) Trail dots (cute crumbs)
  // ---------------------------
  function dropTrail(){
    const p = cellToXY(heroCell.x, heroCell.y);
    const dot = fxG.circle(6).center(
      p.cx + rint(-5,5),
      p.cy + rint(-5,5)
    ).fill(C.trail).opacity(0.55);

    // fade out over time, then remove
    dot.animate(1200).opacity(0).after(() => dot.remove());
  }

  // ---------------------------
  // 13) Solution path drawing (toggle)
  // ---------------------------
  let solutionLine = null;

  function drawSolutionPath(){
    pathG.clear();
    if (!solutionPath || solutionPath.length < 2) return;

    // Build a smooth-ish polyline through cell centers
    const pts = solutionPath.map(c => {
      const p = cellToXY(c.x, c.y);
      return [p.cx, p.cy];
    });

    // glow stroke
    const glow = pathG.polyline(pts).fill('none')
      .stroke({color:C.pathGlow, width: 12, linecap:'round', linejoin:'round', opacity:0.35});
    const line = pathG.polyline(pts).fill('none')
      .stroke({color:C.path, width: 5, linecap:'round', linejoin:'round', opacity:0.9, dasharray:'10 8'});

    // Animated dash offset for ‚Äúmagic‚Äù feeling
    let dash = 0;
    solutionLine = line;
    const anim = () => {
      if (!solutionVisible) return;
      dash = (dash + 1) % 200;
      line.attr({ 'stroke-dashoffset': -dash });
      requestAnimationFrame(anim);
    };
    requestAnimationFrame(anim);

    // little sparkles along the path
    for (let i=0;i<18;i++){
      const idx = Math.floor(i * (solutionPath.length-1) / 18);
      const p = cellToXY(solutionPath[idx].x, solutionPath[idx].y);
      const s = pathG.circle(8).center(p.cx, p.cy).fill('rgba(255,255,255,.9)').opacity(0.15);
      s.animate(800).opacity(0.55).after(()=> s.animate(800).opacity(0.15).loop());
    }
  }

  function toggleSolution(){
    solutionVisible = !solutionVisible;
    btnSolution.flash();
    if (solutionVisible){
      drawSolutionPath();
      statusText.text('‚ú® Follow the sparkly path!');
    } else {
      pathG.clear();
      statusText.text('Try by yourself! You can do it!');
    }
  }

  btnSolution.on('click', toggleSolution);

  // ---------------------------
  // 14) Hero movement with keyboard
  // ---------------------------
  const keysDown = new Set();
  window.addEventListener('keydown', (e) => {
    if (keyDir[e.key]){
      e.preventDefault();
      keysDown.add(e.key);
      tryMoveHero(); // attempt immediately
    }
  });
  window.addEventListener('keyup', (e) => {
    if (keyDir[e.key]){
      keysDown.delete(e.key);
      if (keysDown.size === 0) heroMoving = false;
    }
  });

  function tryMoveHero(){
    if (!cells || !hero) return;
    // If multiple keys held, prefer last pressed: we‚Äôll just pick any in Set
    const key = [...keysDown].slice(-1)[0];
    if (!key) return;
    const d = keyDir[key];
    if (!d) return;

    if (!canMove(cells, heroCell.x, heroCell.y, d.dx, d.dy)){
      // cute bump
      hero.g.animate(80).scale(1.06).after(()=> hero.g.animate(120).scale(1.0));
      heroMoving = false;
      return;
    }

    // Move one cell at a time with animation
    heroMoving = true;
    const nx = heroCell.x + d.dx;
    const ny = heroCell.y + d.dy;

    heroCell.x = nx; heroCell.y = ny;
    const p = cellToXY(nx, ny);

    // ‚Äúhop‚Äù motion
    hero.g.animate(120).scale(1.06, 0.98).after(()=> hero.g.animate(140).scale(1.0));
    hero.g.animate(120, 0, 'easeOutCubic').center(p.cx, p.cy).after(() => {
      // continue moving if key still held
      if (keysDown.has(key)) {
        // small delay so it feels controllable
        setTimeout(tryMoveHero, 10);
      } else {
        heroMoving = false;
      }
      checkWin();
    });

    // drop trail immediately as you move
    dropTrail();
  }

  function checkWin(){
    if (heroCell.x === GRID-1 && heroCell.y === GRID-1){
      // cute win overlay
      overlayG.clear();
      const p = cellToXY(heroCell.x, heroCell.y);
      const ring = overlayG.circle(80).center(p.cx,p.cy).fill('none')
        .stroke({color:'rgba(245,158,11,.85)', width:6, dasharray:'10 8'});
      ring.animate(1200).rotate(360, p.cx,p.cy).loop();
      overlayG.text('You did it! ‚≠ê').font({family:'system-ui', size: 34, weight: 1000})
        .fill(C.ink).center(W/2, PAD-30);

      statusText.text('üéâ Yay! New maze coming up!');
      setTimeout(()=> restartGame('Great job! New maze!'), 1200);
    }
  }

  // ---------------------------
  // 15) Monster movement (maze-aware)
  //     Monsters choose a direction and step.
  //     If blocked, pick a new valid direction.
  //     Occasionally they ‚Äúhunt‚Äù by biasing toward hero.
  // ---------------------------
  let lastMonsterStepAt = 0;
  const monsterNextMoveAt = []; // per monster time

  function monsterStepAll(){
    const now = performance.now();
    if (now - lastMonsterStepAt < 30) return; // throttle
    lastMonsterStepAt = now;

    monsters.forEach((m, idx) => {
      if (!monsterNextMoveAt[idx]) monsterNextMoveAt[idx] = now + rint(0, m.speedMs);
      if (now < monsterNextMoveAt[idx]) return;

      monsterNextMoveAt[idx] = now + m.speedMs;

      // Choose direction
      const dirs = [
        {dx:0,dy:-1},{dx:1,dy:0},{dx:0,dy:1},{dx:-1,dy:0}
      ].filter(d => canMove(cells, m.x, m.y, d.dx, d.dy));

      if (!dirs.length) return;

      // Bias: 35% chance to pick a direction that reduces distance to hero
      let pick;
      if (Math.random() < 0.35){
        const best = dirs.slice().sort((a,b) => {
          const da = Math.abs((m.x+a.dx) - heroCell.x) + Math.abs((m.y+a.dy) - heroCell.y);
          const db = Math.abs((m.x+b.dx) - heroCell.x) + Math.abs((m.y+b.dy) - heroCell.y);
          return da - db;
        });
        pick = best[0];
      } else {
        // Otherwise wander, but avoid immediately reversing too often
        const rev = {dx:-m.dir.dx, dy:-m.dir.dy};
        const nonRev = dirs.filter(d => !(d.dx===rev.dx && d.dy===rev.dy));
        pick = (nonRev.length && Math.random()<0.7) ? choice(nonRev) : choice(dirs);
      }

      m.dir = pick;
      m.x += pick.dx; m.y += pick.dy;

      // Animate move
      const p = cellToXY(m.x, m.y);
      m.g.animate(180, 0, 'easeOutCubic').center(p.cx, p.cy);

      // Check collision with hero
      if (m.x === heroCell.x && m.y === heroCell.y){
        heroCaught();
      }
    });
  }

  function heroCaught(){
    // Fun ‚Äúpop‚Äù effect
    overlayG.clear();
    const p = cellToXY(heroCell.x, heroCell.y);
    const boom = overlayG.circle(20).center(p.cx,p.cy).fill(C.danger).opacity(0.35);
    boom.animate(300).radius(80).opacity(0).after(()=> boom.remove());

    overlayG.text('Oh no! Try again!').font({family:'system-ui', size: 30, weight: 1000})
      .fill(C.ink).center(W/2, PAD-30);

    statusText.text('üòµ The monster tagged you! New maze‚Ä¶');
    keysDown.clear();
    heroMoving = false;

    setTimeout(()=> restartGame('New maze! Be brave!'), 700);
  }

  // ---------------------------
  // 16) Small responsive centering
  // ---------------------------
  function centerWorld(){
    // Keep the maze centered in view if browser is smaller/larger (we use viewBox, but still nice)
    // Nothing needed; SVG scales automatically. Kept for clarity / future.
  }
  window.addEventListener('resize', centerWorld);

  // ---------------------------
  // 17) Start!
  // ---------------------------
  restartGame('New maze! Find the ‚≠ê goal!');

})();
</script>
</body>
</html>
