<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kindergarten Maze Adventure</title>
    
    <!-- Load SVG.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.1.2/svg.min.js"></script>

    <style>
        body {
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif; /* Child-friendly font */
            background-color: #f0f8ff;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            overflow: hidden;
        }

        h1 {
            color: #ff6b6b;
            text-shadow: 2px 2px 0px #feca57;
            margin-bottom: 10px;
        }

        #game-container {
            background-color: white;
            border: 5px solid #54a0ff;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }

        .controls {
            margin-top: 15px;
            display: flex;
            gap: 15px;
        }

        button {
            padding: 10px 20px;
            font-size: 18px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            transition: transform 0.1s;
        }

        button:active {
            transform: scale(0.95);
        }

        #btn-solve {
            background-color: #feca57;
            color: #fff;
            border-bottom: 4px solid #ff9f43;
        }

        #btn-reset {
            background-color: #1dd1a1;
            color: #fff;
            border-bottom: 4px solid #10ac84;
        }

        .instructions {
            margin-top: 10px;
            color: #576574;
            font-size: 14px;
        }
    </style>
</head>
<body>

    <h1>üåü Amazing Maze Adventure üåü</h1>
    
    <div id="game-container"></div>

    <div class="controls">
        <button id="btn-reset" onclick="initGame()">üîÑ New Game</button>
        <button id="btn-solve" onclick="showSolution()">üí° Show Path</button>
    </div>
    
    <div class="instructions">Use Arrow Keys ‚¨ÖÔ∏è‚¨ÜÔ∏è‚¨áÔ∏è‚û°Ô∏è to move the smiley face! Watch out for the blobs!</div>

    <script>
        // --- Configuration ---
        const COLS = 20;
        const ROWS = 20;
        const CELL_SIZE = 25; // px
        const WALL_THICKNESS = 2;
        
        // --- Global Variables ---
        let draw;          // SVG.js instance
        let mazeData = []; // 2D array of cell data
        let player = { x: 0, y: 0, el: null };
        let monsters = [];
        let trails = [];
        let solutionLine = null;
        let trailTimer = null;
        let monsterTimer = null;
        let isGameOver = false;

        // --- Initialization ---
        window.onload = () => {
            // Initialize SVG canvas
            draw = SVG().addTo('#game-container').size(COLS * CELL_SIZE, ROWS * CELL_SIZE);
            initGame();
            
            // Keyboard Listeners
            document.addEventListener('keydown', handleInput);
        };

        function initGame() {
            // Clear previous game state
            draw.clear();
            clearInterval(trailTimer);
            clearInterval(monsterTimer);
            isGameOver = false;
            solutionLine = null;
            trails = [];
            monsters = [];

            // 1. Generate Maze Logic
            mazeData = generateMaze(COLS, ROWS);

            // 2. Draw Maze
            drawMazeVisuals();

            // 3. Draw End Goal
            drawGoal();

            // 4. Initialize Player
            player.x = 0;
            player.y = 0;
            drawPlayer();

            // 5. Initialize Monsters (Add 3 monsters at random spots far from start)
            for(let i=0; i<3; i++) {
                spawnMonster();
            }

            // 6. Start Timers
            // Drop a trail dot every 500ms
            trailTimer = setInterval(dropTrail, 500);
            // Move monsters every 600ms
            monsterTimer = setInterval(moveMonsters, 600);
        }

        // --- Maze Generation Algorithm (Recursive Backtracker) ---
        function generateMaze(cols, rows) {
            // Initialize grid
            let grid = [];
            for (let x = 0; x < cols; x++) {
                grid[x] = [];
                for (let y = 0; y < rows; y++) {
                    // walls: [top, right, bottom, left]
                    grid[x][y] = { x, y, visited: false, walls: [true, true, true, true] };
                }
            }

            let stack = [];
            let current = grid[0][0];
            current.visited = true;
            stack.push(current);

            while (stack.length > 0) {
                // Pop a cell from the stack and make it a current cell
                current = stack.pop();
                
                // Check neighbors (Up, Right, Down, Left)
                let neighbors = [];
                
                // Up
                if (current.y > 0 && !grid[current.x][current.y - 1].visited) neighbors.push({idx: 0, cell: grid[current.x][current.y - 1]});
                // Right
                if (current.x < cols - 1 && !grid[current.x + 1][current.y].visited) neighbors.push({idx: 1, cell: grid[current.x + 1][current.y]});
                // Down
                if (current.y < rows - 1 && !grid[current.x][current.y + 1].visited) neighbors.push({idx: 2, cell: grid[current.x][current.y + 1]});
                // Left
                if (current.x > 0 && !grid[current.x - 1][current.y].visited) neighbors.push({idx: 3, cell: grid[current.x - 1][current.y]});

                if (neighbors.length > 0) {
                    stack.push(current);
                    
                    // Choose random neighbor
                    let nextInfo = neighbors[Math.floor(Math.random() * neighbors.length)];
                    let next = nextInfo.cell;
                    
                    // Remove walls
                    // 0: Top, 1: Right, 2: Bottom, 3: Left
                    if (nextInfo.idx === 0) { // Next is Top
                        current.walls[0] = false;
                        next.walls[2] = false;
                    } else if (nextInfo.idx === 1) { // Next is Right
                        current.walls[1] = false;
                        next.walls[3] = false;
                    } else if (nextInfo.idx === 2) { // Next is Bottom
                        current.walls[2] = false;
                        next.walls[0] = false;
                    } else if (nextInfo.idx === 3) { // Next is Left
                        current.walls[3] = false;
                        next.walls[1] = false;
                    }

                    next.visited = true;
                    stack.push(next);
                }
            }
            return grid;
        }

        // --- Drawing Functions ---

        function drawMazeVisuals() {
            // Background
            draw.rect(COLS * CELL_SIZE, ROWS * CELL_SIZE).fill('#ffffff');

            const group = draw.group();
            const strokeStyle = { color: '#54a0ff', width: WALL_THICKNESS, linecap: 'round' };

            for (let x = 0; x < COLS; x++) {
                for (let y = 0; y < ROWS; y++) {
                    let cell = mazeData[x][y];
                    let px = x * CELL_SIZE;
                    let py = y * CELL_SIZE;

                    // Top
                    if (cell.walls[0]) group.line(px, py, px + CELL_SIZE, py).stroke(strokeStyle);
                    // Right
                    if (cell.walls[1]) group.line(px + CELL_SIZE, py, px + CELL_SIZE, py + CELL_SIZE).stroke(strokeStyle);
                    // Bottom
                    if (cell.walls[2]) group.line(px, py + CELL_SIZE, px + CELL_SIZE, py + CELL_SIZE).stroke(strokeStyle);
                    // Left
                    if (cell.walls[3]) group.line(px, py, px, py + CELL_SIZE).stroke(strokeStyle);
                }
            }
        }

        function drawPlayer() {
            // Create a group for the hero
            player.el = draw.group();
            
            // Face
            player.el.circle(CELL_SIZE * 0.7).fill('#feca57').stroke({color: '#ff9f43', width: 2}).center(CELL_SIZE/2, CELL_SIZE/2);
            
            // Eyes
            player.el.circle(3).fill('#333').move(CELL_SIZE*0.3, CELL_SIZE*0.3);
            player.el.circle(3).fill('#333').move(CELL_SIZE*0.6, CELL_SIZE*0.3);
            
            // Smile
            player.el.path(`M ${CELL_SIZE*0.3} ${CELL_SIZE*0.6} Q ${CELL_SIZE*0.5} ${CELL_SIZE*0.8} ${CELL_SIZE*0.7} ${CELL_SIZE*0.6}`).fill('none').stroke({color: '#333', width: 1.5, linecap: 'round'});

            updatePlayerPosition();
        }

        function drawGoal() {
            let px = (COLS - 1) * CELL_SIZE;
            let py = (ROWS - 1) * CELL_SIZE;
            
            let goal = draw.group().move(px, py);
            goal.rect(CELL_SIZE, CELL_SIZE).fill('#1dd1a1').opacity(0.3);
            goal.text('‚òÖ').font({size: 20, anchor: 'middle'}).center(CELL_SIZE/2, CELL_SIZE/2).fill('#10ac84');
        }

        function spawnMonster() {
            // Random position, but not too close to start (0,0)
            let mx, my;
            do {
                mx = Math.floor(Math.random() * COLS);
                my = Math.floor(Math.random() * ROWS);
            } while (mx < 5 && my < 5);

            let monsterEl = draw.group();
            // Cute blob body
            monsterEl.rect(CELL_SIZE * 0.6, CELL_SIZE * 0.6).radius(5).fill('#ff6b6b').center(CELL_SIZE/2, CELL_SIZE/2);
            // One eye
            monsterEl.circle(6).fill('white').center(CELL_SIZE/2, CELL_SIZE/2 - 2);
            monsterEl.circle(2).fill('black').center(CELL_SIZE/2, CELL_SIZE/2 - 2);
            
            let monster = { x: mx, y: my, el: monsterEl };
            updateEntityPosition(monster);
            monsters.push(monster);
        }

        function updatePlayerPosition() {
            player.el.animate(100).move(player.x * CELL_SIZE, player.y * CELL_SIZE);
            checkWin();
        }

        function updateEntityPosition(entity) {
            entity.el.animate(300).move(entity.x * CELL_SIZE, entity.y * CELL_SIZE);
        }

        function dropTrail() {
            if (isGameOver) return;
            
            // Don't drop if on start or end
            if ((player.x === 0 && player.y === 0) || (player.x === COLS-1 && player.y === ROWS-1)) return;

            // Visual adjustment to center the dot
            let cx = player.x * CELL_SIZE + CELL_SIZE / 2;
            let cy = player.y * CELL_SIZE + CELL_SIZE / 2;

            // Draw a small circle
            let dot = draw.circle(5).fill('#fab1a0').center(cx, cy).back();
            trails.push(dot);
        }

        // --- Game Logic ---

        function handleInput(e) {
            if (isGameOver) return;

            let currentCell = mazeData[player.x][player.y];
            let moved = false;

            // 0: Top, 1: Right, 2: Bottom, 3: Left
            switch(e.key) {
                case 'ArrowUp':
                    if (!currentCell.walls[0]) { player.y--; moved = true; }
                    break;
                case 'ArrowRight':
                    if (!currentCell.walls[1]) { player.x++; moved = true; }
                    break;
                case 'ArrowDown':
                    if (!currentCell.walls[2]) { player.y++; moved = true; }
                    break;
                case 'ArrowLeft':
                    if (!currentCell.walls[3]) { player.x--; moved = true; }
                    break;
            }

            if (moved) {
                e.preventDefault(); // Stop scrolling
                updatePlayerPosition();
                checkCollision();
            }
        }

        function checkWin() {
            if (player.x === COLS - 1 && player.y === ROWS - 1) {
                isGameOver = true;
                clearInterval(monsterTimer);
                clearInterval(trailTimer);
                alert("üéâ HOORAY! You finished the maze! üéâ");
            }
        }

        function moveMonsters() {
            if (isGameOver) return;

            monsters.forEach(m => {
                let currentCell = mazeData[m.x][m.y];
                let possibleMoves = [];

                // Check all 4 directions for walls
                if (!currentCell.walls[0]) possibleMoves.push({x: m.x, y: m.y - 1}); // Up
                if (!currentCell.walls[1]) possibleMoves.push({x: m.x + 1, y: m.y}); // Right
                if (!currentCell.walls[2]) possibleMoves.push({x: m.x, y: m.y + 1}); // Down
                if (!currentCell.walls[3]) possibleMoves.push({x: m.x - 1, y: m.y}); // Left

                // Pick a random valid move
                if (possibleMoves.length > 0) {
                    let move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    m.x = move.x;
                    m.y = move.y;
                    updateEntityPosition(m);
                }
            });

            checkCollision();
        }

        function checkCollision() {
            monsters.forEach(m => {
                if (m.x === player.x && m.y === player.y) {
                    gameOver();
                }
            });
        }

        function gameOver() {
            isGameOver = true;
            clearInterval(monsterTimer);
            clearInterval(trailTimer);
            
            // Visual feedback
            player.el.children()[0].fill('#ff6b6b'); // Turn face red
            
            setTimeout(() => {
                alert("Oh no! The blob got you! Try again!");
                initGame();
            }, 100);
        }

        // --- Solver Logic (BFS) ---
        function showSolution() {
            if (solutionLine) solutionLine.remove(); // Clear existing line
            
            let queue = [];
            let visited = new Set();
            let parentMap = new Map(); // To reconstruct path

            // Start at 0,0
            queue.push({x:0, y:0});
            visited.add(`0,0`);

            let endFound = false;

            while (queue.length > 0) {
                let curr = queue.shift();

                if (curr.x === COLS - 1 && curr.y === ROWS - 1) {
                    endFound = true;
                    break;
                }

                let cell = mazeData[curr.x][curr.y];

                // Check neighbors (0:Up, 1:Right, 2:Down, 3:Left)
                const moves = [
                    {x: curr.x, y: curr.y - 1},
                    {x: curr.x + 1, y: curr.y},
                    {x: curr.x, y: curr.y + 1},
                    {x: curr.x - 1, y: curr.y}
                ];

                for (let i = 0; i < 4; i++) {
                    // If no wall and not visited
                    if (!cell.walls[i]) {
                        let next = moves[i];
                        let key = `${next.x},${next.y}`;
                        if (!visited.has(key)) {
                            visited.add(key);
                            parentMap.set(key, curr);
                            queue.push(next);
                        }
                    }
                }
            }

            if (endFound) {
                // Reconstruct path
                let path = [];
                let curr = {x: COLS-1, y: ROWS-1};
                while (curr) {
                    path.push([curr.x * CELL_SIZE + CELL_SIZE/2, curr.y * CELL_SIZE + CELL_SIZE/2]);
                    let key = `${curr.x},${curr.y}`;
                    curr = parentMap.get(key);
                }

                // Draw the polyline
                solutionLine = draw.polyline(path).fill('none').stroke({ color: '#fdcb6e', width: 4, dasharray: '5,5' }).back();
            }
        }

    </script>
</body>
</html>