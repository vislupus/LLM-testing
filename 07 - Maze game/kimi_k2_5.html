<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kindergarten Maze Adventure</title>
    
    <!-- SVG.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2.0/dist/svg.min.js"></script>
    
    <style>
        /* Child-friendly styling with big buttons and pastel colors */
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Arial Rounded MT Bold', sans-serif;
            background: linear-gradient(135deg, #FFE5B4 0%, #E0F7FA 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            color: #FF6B6B;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 10px;
            font-size: 2.5em;
            text-align: center;
        }

        .instructions {
            color: #5D4E37;
            font-size: 1.2em;
            margin-bottom: 15px;
            text-align: center;
            background: rgba(255,255,255,0.8);
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #game-container {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            position: relative;
        }

        #maze-svg {
            border-radius: 15px;
            border: 4px solid #FFB6C1;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            font-family: inherit;
            font-size: 1.2em;
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }

        #help-btn {
            background: #FFE66D;
            color: #5D4E37;
        }

        #reset-btn {
            background: #FF6B6B;
            color: white;
        }

        #message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 30px;
            font-size: 2em;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            display: none;
            z-index: 1000;
            border: 5px solid #FF6B6B;
        }

        .emoji {
            font-size: 3em;
            display: block;
            margin-bottom: 10px;
        }

        /* Animation for the solution path */
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        .solution-path {
            animation: pulse 1s infinite;
        }
    </style>
</head>
<body>
    <h1>üåà Rainbow Maze Adventure üåà</h1>
    <div class="instructions">
        Use arrow keys to move the bunny! üê∞ Collect the carrot! ü•ï<br>
        Watch out for friendly monsters! üëæ
    </div>

    <div id="game-container">
        <!-- SVG will be drawn here -->
        <div id="maze-svg"></div>
        
        <div class="controls">
            <button id="help-btn" onclick="game.showSolution()">üîç Show Path</button>
            <button id="reset-btn" onclick="game.restart()">üîÑ New Game</button>
        </div>
    </div>

    <!-- Message overlay for win/lose -->
    <div id="message"></div>

    <script>
        /**
         * Kindergarten Maze Game
         * Features: Random maze generation, cute characters, trail effect, monsters
         */

        class MazeGame {
            constructor() {
                this.cellSize = 30; // Size of each maze cell
                this.cols = 20;     // Maze width
                this.rows = 20;     // Maze height
                this.wallWidth = 4; // Thickness of walls
                
                // Initialize SVG canvas
                this.draw = SVG().addTo('#maze-svg').size(
                    this.cols * this.cellSize + this.wallWidth, 
                    this.rows * this.cellSize + this.wallWidth
                );
                
                // Groups for layering
                this.mazeGroup = this.draw.group();      // Walls
                this.trailGroup = this.draw.group();     // Player trail
                this.monsterGroup = this.draw.group();   // Monsters
                this.playerGroup = this.draw.group();    // Hero
                
                // Game state
                this.grid = [];          // Maze grid
                this.player = { x: 0, y: 0 };    // Player position
                this.goal = { x: 19, y: 19 };    // Goal position
                this.monsters = [];      // Array of monster objects
                this.trailTimer = null;  // Timer for trail effect
                this.isGameOver = false;
                this.solutionPath = [];  // Stores solution for help button
                
                // Colors for child-friendly look
                this.colors = {
                    wall: '#FFB6C1',      // Light pink walls
                    wallStroke: '#FF69B4', // Hot pink stroke
                    background: '#FFF8DC', // Cornsilk background
                    trail: ['#FFD700', '#FF69B4', '#00CED1', '#98FB98'] // Rainbow trail
                };
                
                this.init();
            }

            /**
             * Initialize or restart the game
             */
            init() {
                this.isGameOver = false;
                this.hideMessage();
                this.draw.clear();
                
                // Recreate groups
                this.mazeGroup = this.draw.group();
                this.trailGroup = this.draw.group();
                this.monsterGroup = this.draw.group();
                this.playerGroup = this.draw.group();
                
                // Generate new maze
                this.generateMaze();
                
                // Find solution path
                this.findSolution();
                
                // Draw the maze
                this.drawMaze();
                
                // Place player at start
                this.player = { x: 0, y: 0 };
                this.drawPlayer();
                
                // Draw goal (carrot)
                this.drawGoal();
                
                // Create friendly monsters
                this.createMonsters();
                
                // Start trail effect
                this.startTrail();
                
                // Start monster movement
                this.startMonsters();
                
                // Keyboard controls
                this.setupControls();
            }

            /**
             * Generate maze using Recursive Backtracker algorithm
             * Guarantees exactly one solution (perfect maze)
             */
            generateMaze() {
                // Initialize grid with all walls
                this.grid = [];
                for (let y = 0; y < this.rows; y++) {
                    let row = [];
                    for (let x = 0; x < this.cols; x++) {
                        row.push({
                            x: x,
                            y: y,
                            visited: false,
                            walls: { top: true, right: true, bottom: true, left: true }
                        });
                    }
                    this.grid.push(row);
                }

                // DFS to carve paths
                let stack = [];
                let current = this.grid[0][0];
                current.visited = true;
                
                while (true) {
                    let neighbors = this.getUnvisitedNeighbors(current);
                    
                    if (neighbors.length > 0) {
                        // Choose random neighbor
                        let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                        stack.push(current);
                        
                        // Remove walls between current and next
                        this.removeWalls(current, next);
                        
                        next.visited = true;
                        current = next;
                    } else if (stack.length > 0) {
                        current = stack.pop();
                    } else {
                        break;
                    }
                }
            }

            /**
             * Get unvisited neighbor cells
             */
            getUnvisitedNeighbors(cell) {
                let neighbors = [];
                let { x, y } = cell;
                
                if (y > 0 && !this.grid[y-1][x].visited) neighbors.push(this.grid[y-1][x]);
                if (x < this.cols-1 && !this.grid[y][x+1].visited) neighbors.push(this.grid[y][x+1]);
                if (y < this.rows-1 && !this.grid[y+1][x].visited) neighbors.push(this.grid[y+1][x]);
                if (x > 0 && !this.grid[y][x-1].visited) neighbors.push(this.grid[y][x-1]);
                
                return neighbors;
            }

            /**
             * Remove walls between two cells
             */
            removeWalls(a, b) {
                let x = a.x - b.x;
                if (x === 1) { a.walls.left = false; b.walls.right = false; }
                else if (x === -1) { a.walls.right = false; b.walls.left = false; }
                
                let y = a.y - b.y;
                if (y === 1) { a.walls.top = false; b.walls.bottom = false; }
                else if (y === -1) { a.walls.bottom = false; b.walls.top = false; }
            }

            /**
             * Find solution path using BFS
             */
            findSolution() {
                let queue = [[{x: 0, y: 0}]];
                let visited = new Set(['0,0']);
                
                while (queue.length > 0) {
                    let path = queue.shift();
                    let current = path[path.length - 1];
                    
                    if (current.x === this.goal.x && current.y === this.goal.y) {
                        this.solutionPath = path;
                        return;
                    }
                    
                    // Check all directions
                    let cell = this.grid[current.y][current.x];
                    let directions = [
                        { dx: 0, dy: -1, wall: 'top' },
                        { dx: 1, dy: 0, wall: 'right' },
                        { dx: 0, dy: 1, wall: 'bottom' },
                        { dx: -1, dy: 0, wall: 'left' }
                    ];
                    
                    for (let dir of directions) {
                        if (!cell.walls[dir.wall]) {
                            let nx = current.x + dir.dx;
                            let ny = current.y + dir.dy;
                            let key = `${nx},${ny}`;
                            
                            if (!visited.has(key)) {
                                visited.add(key);
                                let newPath = [...path, {x: nx, y: ny}];
                                queue.push(newPath);
                            }
                        }
                    }
                }
            }

            /**
             * Draw the maze walls
             */
            drawMaze() {
                // Background
                this.draw.rect(this.cols * this.cellSize, this.rows * this.cellSize)
                    .fill(this.colors.background)
                    .radius(10);

                // Draw walls
                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        let cell = this.grid[y][x];
                        let cx = x * this.cellSize;
                        let cy = y * this.cellSize;
                        
                        // Top wall
                        if (cell.walls.top) {
                            this.mazeGroup.line(cx, cy, cx + this.cellSize, cy)
                                .stroke({ width: this.wallWidth, color: this.colors.wallStroke, linecap: 'round' });
                        }
                        
                        // Right wall
                        if (cell.walls.right) {
                            this.mazeGroup.line(cx + this.cellSize, cy, cx + this.cellSize, cy + this.cellSize)
                                .stroke({ width: this.wallWidth, color: this.colors.wallStroke, linecap: 'round' });
                        }
                        
                        // Bottom wall
                        if (cell.walls.bottom) {
                            this.mazeGroup.line(cx, cy + this.cellSize, cx + this.cellSize, cy + this.cellSize)
                                .stroke({ width: this.wallWidth, color: this.colors.wallStroke, linecap: 'round' });
                        }
                        
                        // Left wall
                        if (cell.walls.left) {
                            this.mazeGroup.line(cx, cy, cx, cy + this.cellSize)
                                .stroke({ width: this.wallWidth, color: this.colors.wallStroke, linecap: 'round' });
                        }
                    }
                }
            }

            /**
             * Draw the cute bunny player
             */
            drawPlayer() {
                this.playerGroup.clear();
                let cx = this.player.x * this.cellSize + this.cellSize/2;
                let cy = this.player.y * this.cellSize + this.cellSize/2;
                
                // Bunny body (white circle)
                this.playerGroup.circle(this.cellSize * 0.7)
                    .center(cx, cy)
                    .fill('#FFFFFF')
                    .stroke({ color: '#FFB6C1', width: 2 });
                
                // Ears
                this.playerGroup.ellipse(8, 15)
                    .center(cx - 8, cy - 12)
                    .fill('#FFFFFF')
                    .stroke({ color: '#FFB6C1', width: 2 });
                this.playerGroup.ellipse(8, 15)
                    .center(cx + 8, cy - 12)
                    .fill('#FFFFFF')
                    .stroke({ color: '#FFB6C1', width: 2 });
                
                // Eyes
                this.playerGroup.circle(3).center(cx - 5, cy - 2).fill('#333');
                this.playerGroup.circle(3).center(cx + 5, cy - 2).fill('#333');
                
                // Nose
                this.playerGroup.circle(2).center(cx, cy + 3).fill('#FF69B4');
                
                // Cute blush
                this.playerGroup.ellipse(4, 2).center(cx - 8, cy + 2).fill('#FFB6C1').opacity(0.6);
                this.playerGroup.ellipse(4, 2).center(cx + 8, cy + 2).fill('#FFB6C1').opacity(0.6);
            }

            /**
             * Draw the goal (carrot)
             */
            drawGoal() {
                let cx = this.goal.x * this.cellSize + this.cellSize/2;
                let cy = this.goal.y * this.cellSize + this.cellSize/2;
                
                let goalGroup = this.draw.group();
                
                // Carrot body
                goalGroup.path(`M ${cx} ${cy-10} L ${cx-8} ${cy+10} Q ${cx} ${cy+15} ${cx+8} ${cy+10} Z`)
                    .fill('#FF8C00')
                    .stroke({ color: '#FF6347', width: 2 });
                
                // Carrot leaves
                goalGroup.line(cx, cy-10, cx-5, cy-18).stroke({ color: '#32CD32', width: 3 });
                goalGroup.line(cx, cy-10, cx, cy-20).stroke({ color: '#32CD32', width: 3 });
                goalGroup.line(cx, cy-10, cx+5, cy-18).stroke({ color: '#32CD32', width: 3 });
                
                // Shine effect
                goalGroup.animate(1000).ease('<>')
                    .scale(1.1)
                    .loop(true, true);
            }

            /**
             * Create friendly monsters
             */
            createMonsters() {
                this.monsters = [];
                // Create 3 monsters at random positions away from start
                for (let i = 0; i < 3; i++) {
                    let x, y;
                    do {
                        x = Math.floor(Math.random() * this.cols);
                        y = Math.floor(Math.random() * this.rows);
                    } while (Math.abs(x - this.player.x) < 5 && Math.abs(y - this.player.y) < 5);
                    
                    let monster = {
                        x: x,
                        y: y,
                        id: i,
                        direction: Math.floor(Math.random() * 4),
                        color: ['#9370DB', '#20B2AA', '#FF69B4'][i] // Purple, turquoise, pink
                    };
                    this.monsters.push(monster);
                    this.drawMonster(monster);
                }
            }

            /**
             * Draw a cute monster
             */
            drawMonster(monster) {
                let cx = monster.x * this.cellSize + this.cellSize/2;
                let cy = monster.y * this.cellSize + this.cellSize/2;
                
                let mGroup = this.monsterGroup.group().id(`monster-${monster.id}`);
                
                // Body (round and soft)
                mGroup.circle(this.cellSize * 0.6)
                    .center(cx, cy)
                    .fill(monster.color)
                    .stroke({ color: 'white', width: 2 });
                
                // Eyes (big and cute)
                mGroup.circle(5).center(cx - 5, cy - 2).fill('white');
                mGroup.circle(5).center(cx + 5, cy - 2).fill('white');
                mGroup.circle(2).center(cx - 5, cy - 2).fill('black');
                mGroup.circle(2).center(cx + 5, cy - 2).fill('black');
                
                // Smile
                mGroup.path(`M ${cx-5} ${cy+5} Q ${cx} ${cy+10} ${cx+5} ${cy+5}`)
                    .fill('none')
                    .stroke({ color: 'white', width: 2 });
                
                // Little horns or antenna
                mGroup.line(cx-5, cy-10, cx-8, cy-15).stroke({ color: monster.color, width: 3 });
                mGroup.circle(3).center(cx-8, cy-15).fill(monster.color);
                mGroup.line(cx+5, cy-10, cx+8, cy-15).stroke({ color: monster.color, width: 3 });
                mGroup.circle(3).center(cx+8, cy-15).fill(monster.color);
            }

            /**
             * Start the trail effect
             */
            startTrail() {
                this.trailTimer = setInterval(() => {
                    if (!this.isGameOver && (this.lastX !== this.player.x || this.lastY !== this.player.y)) {
                        this.dropTrailCircle();
                        this.lastX = this.player.x;
                        this.lastY = this.player.y;
                    }
                }, 200);
                
                this.lastX = this.player.x;
                this.lastY = this.player.y;
            }

            /**
             * Drop a colorful trail circle
             */
            dropTrailCircle() {
                let cx = this.player.x * this.cellSize + this.cellSize/2;
                let cy = this.player.y * this.cellSize + this.cellSize/2;
                let color = this.colors.trail[Math.floor(Math.random() * this.colors.trail.length)];
                
                let circle = this.trailGroup.circle(8)
                    .center(cx, cy)
                    .fill(color)
                    .opacity(0.8);
                
                // Fade out and remove
                circle.animate(1000).opacity(0).after(() => {
                    circle.remove();
                });
            }

            /**
             * Move monsters automatically
             */
            startMonsters() {
                this.monsterInterval = setInterval(() => {
                    if (this.isGameOver) return;
                    
                    this.monsters.forEach(monster => {
                        this.moveMonster(monster);
                    });
                    
                    this.checkCollisions();
                }, 800); // Move every 800ms (slow for kids)
            }

            /**
             * Move monster in valid direction
             */
            moveMonster(monster) {
                let cell = this.grid[monster.y][monster.x];
                let directions = [];
                
                // Check which directions are valid (no walls)
                if (!cell.walls.top) directions.push({dx: 0, dy: -1});
                if (!cell.walls.right) directions.push({dx: 1, dy: 0});
                if (!cell.walls.bottom) directions.push({dx: 0, dy: 1});
                if (!cell.walls.left) directions.push({dx: -1, dy: 0});
                
                if (directions.length > 0) {
                    // 70% chance to continue direction, 30% random turn
                    let move;
                    if (Math.random() > 0.3 && monster.lastDir) {
                        // Try to continue same direction if valid
                        let canContinue = directions.find(d => d.dx === monster.lastDir.dx && d.dy === monster.lastDir.dy);
                        move = canContinue || directions[Math.floor(Math.random() * directions.length)];
                    } else {
                        move = directions[Math.floor(Math.random() * directions.length)];
                    }
                    
                    monster.lastDir = move;
                    monster.x += move.dx;
                    monster.y += move.dy;
                    
                    // Boundary check
                    monster.x = Math.max(0, Math.min(this.cols-1, monster.x));
                    monster.y = Math.max(0, Math.min(this.rows-1, monster.y));
                    
                    // Update visual
                    let mGroup = this.monsterGroup.find(`#monster-${monster.id}`);
                    if (mGroup) {
                        mGroup.animate(300).ease('<>')
                            .move(monster.x * this.cellSize, monster.y * this.cellSize);
                    }
                }
            }

            /**
             * Setup keyboard controls
             */
            setupControls() {
                // Remove old listener if exists
                if (this.keyHandler) {
                    document.removeEventListener('keydown', this.keyHandler);
                }
                
                this.keyHandler = (e) => {
                    if (this.isGameOver) return;
                    
                    let dx = 0, dy = 0;
                    switch(e.key) {
                        case 'ArrowUp': dy = -1; e.preventDefault(); break;
                        case 'ArrowDown': dy = 1; e.preventDefault(); break;
                        case 'ArrowLeft': dx = -1; e.preventDefault(); break;
                        case 'ArrowRight': dx = 1; e.preventDefault(); break;
                        default: return;
                    }
                    
                    this.movePlayer(dx, dy);
                };
                
                document.addEventListener('keydown', this.keyHandler);
            }

            /**
             * Move player if no wall
             */
            movePlayer(dx, dy) {
                let cell = this.grid[this.player.y][this.player.x];
                let canMove = false;
                
                // Check walls
                if (dy === -1 && !cell.walls.top) canMove = true;
                if (dy === 1 && !cell.walls.bottom) canMove = true;
                if (dx === -1 && !cell.walls.left) canMove = true;
                if (dx === 1 && !cell.walls.right) canMove = true;
                
                if (canMove) {
                    this.player.x += dx;
                    this.player.y += dy;
                    this.drawPlayer();
                    this.checkWin();
                }
            }

            /**
             * Check if player reached goal
             */
            checkWin() {
                if (this.player.x === this.goal.x && this.player.y === this.goal.y) {
                    this.gameOver(true);
                }
            }

            /**
             * Check if monster caught player
             */
            checkCollisions() {
                for (let monster of this.monsters) {
                    if (monster.x === this.player.x && monster.y === this.player.y) {
                        this.gameOver(false);
                        return;
                    }
                }
            }

            /**
             * Game over handling
             */
            gameOver(won) {
                this.isGameOver = true;
                clearInterval(this.trailTimer);
                clearInterval(this.monsterInterval);
                
                let msg = document.getElementById('message');
                if (won) {
                    msg.innerHTML = `
                        <span class="emoji">üéâ</span>
                        <div>You Won!</div>
                        <div style="font-size: 0.5em; margin-top: 10px;">The bunny got the carrot!</div>
                    `;
                    msg.style.borderColor = '#32CD32';
                } else {
                    msg.innerHTML = `
                        <span class="emoji">üò¢</span>
                        <div>Oh no! A monster got you!</div>
                        <div style="font-size: 0.5em; margin-top: 10px;">Try again!</div>
                    `;
                    msg.style.borderColor = '#FF6B6B';
                }
                
                msg.style.display = 'block';
                
                setTimeout(() => {
                    if (!won) this.restart();
                }, 2000);
            }

            hideMessage() {
                document.getElementById('message').style.display = 'none';
            }

            /**
             * Show solution path
             */
            showSolution() {
                // Clear previous solution drawings
                this.draw.find('.solution-path').remove();
                
                let pathStr = "M ";
                this.solutionPath.forEach((point, i) => {
                    let cx = point.x * this.cellSize + this.cellSize/2;
                    let cy = point.y * this.cellSize + this.cellSize/2;
                    pathStr += `${cx} ${cy} `;
                    if (i < this.solutionPath.length - 1) pathStr += "L ";
                });
                
                // Draw dotted path
                this.draw.path(pathStr)
                    .fill('none')
                    .stroke({ 
                        color: '#FFD700', 
                        width: 4, 
                        dasharray: '5,5',
                        opacity: 0.8 
                    })
                    .addClass('solution-path')
                    .insertBefore(this.playerGroup); // Put behind player
                
                // Auto-hide after 3 seconds
                setTimeout(() => {
                    this.draw.find('.solution-path').animate(500).opacity(0).after(function() {
                        this.remove();
                    });
                }, 3000);
            }

            restart() {
                clearInterval(this.trailTimer);
                clearInterval(this.monsterInterval);
                this.init();
            }
        }

        // Start the game when page loads
        let game;
        window.onload = () => {
            game = new MazeGame();
        };
    </script>
</body>
</html>