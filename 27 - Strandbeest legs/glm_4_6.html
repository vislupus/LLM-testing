<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolutionary Strandbeest - Genetic Algorithm Demo</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            overflow: hidden;
            color: #e0e0ff;
        }

        #renderCanvas {
            width: 100%;
            height: 100vh;
            display: block;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            max-width: 350px;
            transition: transform 0.3s ease;
        }

        .controls.hidden {
            transform: translateX(-380px);
        }

        .controls h3 {
            margin: 0 0 15px 0;
            color: #64b5f6;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(100, 180, 255, 0.5);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 12px;
            color: #b0c4ff;
        }

        .slider {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #64b5f6;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(100, 180, 255, 0.6);
        }

        .slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #64b5f6;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(100, 180, 255, 0.6);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 6px;
            font-size: 11px;
        }

        .stat-label {
            color: #8a92b2;
            font-size: 10px;
        }

        .stat-value {
            font-weight: bold;
            font-size: 14px;
            margin-top: 2px;
            color: #4fc3f7;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            flex: 1;
            padding: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn.danger {
            background: linear-gradient(135deg, #f56565, #e53e3e);
        }

        .btn.success {
            background: linear-gradient(135deg, #48bb78, #38a169);
        }

        .toggle-btn {
            position: absolute;
            top: 20px;
            left: 380px;
            background: rgba(20, 20, 35, 0.95);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .toggle-btn.shifted {
            left: 20px;
        }

        .info-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(20, 20, 35, 0.95);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            max-width: 300px;
        }

        .info-panel h4 {
            margin: 0 0 10px 0;
            color: #64b5f6;
            font-size: 14px;
        }

        .info-panel p {
            font-size: 11px;
            line-height: 1.4;
            color: #b0c4ff;
            margin: 5px 0;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4fc3f7, #64b5f6);
            transition: width 0.3s ease;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <div class="controls" id="controls">
        <h3>ðŸ§¬ Evolution Controls</h3>
        
        <div class="control-group">
            <label>Population Size: <span id="popSizeValue">20</span></label>
            <input type="range" class="slider" id="popSize" min="10" max="50" step="5" value="20">
        </div>
        
        <div class="control-group">
            <label>Mutation Rate: <span id="mutationRateValue">0.1</span></label>
            <input type="range" class="slider" id="mutationRate" min="0" max="0.5" step="0.05" value="0.1">
        </div>
        
        <div class="control-group">
            <label>Cycle Duration: <span id="cycleDurationValue">3.0</span>s</label>
            <input type="range" class="slider" id="cycleDuration" min="1" max="10" step="0.5" value="3">
        </div>
        
        <div class="control-group">
            <label>Number of Legs: <span id="numLegsValue">4</span></label>
            <input type="range" class="slider" id="numLegs" min="2" max="8" step="1" value="4">
        </div>
        
        <div class="control-group">
            <label>Leg Segments: <span id="legSegmentsValue">3</span></label>
            <input type="range" class="slider" id="legSegments" min="2" max="5" step="1" value="3">
        </div>
        
        <div class="stats-grid">
            <div class="stat-item">
                <div class="stat-label">Generation</div>
                <div class="stat-value" id="generation">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Best Fitness</div>
                <div class="stat-value" id="bestFitness">0.0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Avg Fitness</div>
                <div class="stat-value" id="avgFitness">0.0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Evaluating</div>
                <div class="stat-value" id="evaluating">0/0</div>
            </div>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
        
        <div class="action-buttons">
            <button class="btn success" onclick="evolution.startEvolution()">Start</button>
            <button class="btn" onclick="evolution.pauseEvolution()">Pause</button>
            <button class="btn danger" onclick="evolution.reset()">Reset</button>
        </div>
    </div>
    
    <button class="toggle-btn" id="toggleBtn" onclick="toggleControls()">â—€</button>
    
    <div class="info-panel">
        <h4>ðŸ¦¾ Strandbeest Evolution</h4>
        <p><strong>Genome Structure:</strong> Each creature's DNA encodes leg segment lengths, joint positions, and phase offsets for walking cycles.</p>
        <p><strong>Fitness Function:</strong> Distance traveled forward in 10 seconds while maintaining stability.</p>
        <p><strong>Selection:</strong> Tournament selection with crossover and mutation.</p>
        <p><strong>Tip:</strong> Watch as creatures evolve from random walkers to efficient walkers!</p>
    </div>

    <script>
        // Genome structure for Strandbeest creature
        class Genome {
            constructor(numLegs = 4, segmentsPerLeg = 3) {
                this.numLegs = numLegs;
                this.segmentsPerLeg = segmentsPerLeg;
                this.genes = [];
                this.generateRandomGenes();
            }
            
            generateRandomGenes() {
                this.genes = [];
                
                // Body dimensions
                this.genes.push(random(0.5, 2.0)); // Body width
                this.genes.push(random(0.3, 1.0)); // Body height
                this.genes.push(random(0.5, 1.5)); // Body length
                
                // For each leg
                for (let leg = 0; leg < this.numLegs; leg++) {
                    // Leg attachment position on body
                    this.genes.push(random(-0.5, 0.5)); // X position
                    this.genes.push(random(-0.25, 0.25)); // Y position
                    this.genes.push(random(-0.5, 0.5)); // Z position
                    
                    // Phase offset for walking cycle
                    this.genes.push(random(0, TWO_PI));
                    
                    // Segment lengths
                    for (let seg = 0; seg < this.segmentsPerLeg; seg++) {
                        this.genes.push(random(0.3, 1.0)); // Length
                    }
                    
                    // Joint angle limits
                    for (let seg = 0; seg < this.segmentsPerLeg - 1; seg++) {
                        this.genes.push(random(-PI/4, PI/4)); // Min angle
                        this.genes.push(random(-PI/4, PI/4)); // Max angle
                    }
                }
            }
            
            crossover(partner) {
                const child = new Genome(this.numLegs, this.segmentsPerLeg);
                child.genes = [];
                
                for (let i = 0; i < this.genes.length; i++) {
                    child.genes.push(random() < 0.5 ? this.genes[i] : partner.genes[i]);
                }
                
                return child;
            }
            
            mutate(mutationRate) {
                for (let i = 0; i < this.genes.length; i++) {
                    if (random() < mutationRate) {
                        this.genes[i] += randomGaussian(0, 0.1);
                        
                        // Clamp values to reasonable ranges
                        if (i < 3) { // Body dimensions
                            this.genes[i] = constrain(this.genes[i], 0.1, 3.0);
                        } else if (i % (7 + this.segmentsPerLeg * 3) < 3) { // Position
                            this.genes[i] = constrain(this.genes[i], -1, 1);
                        } else if (i % (7 + this.segmentsPerLeg * 3) === 3) { // Phase
                            this.genes[i] = constrain(this.genes[i], 0, TWO_PI);
                        } else if (i % (7 + this.segmentsPerLeg * 3) < 4 + this.segmentsPerLeg) { // Lengths
                            this.genes[i] = constrain(this.genes[i], 0.1, 2.0);
                        } else { // Angles
                            this.genes[i] = constrain(this.genes[i], -PI/2, PI/2);
                        }
                    }
                }
            }
            
            clone() {
                const clone = new Genome(this.numLegs, this.segmentsPerLeg);
                clone.genes = [...this.genes];
                return clone;
            }
        }
        
        // Creature class that builds from genome
        class Creature {
            constructor(genome, scene, id) {
                this.genome = genome;
                this.scene = scene;
                this.id = id;
                this.meshes = [];
                this.joints = [];
                this.initialPosition = null;
                this.fitness = 0;
                this.time = 0;
                this.isStable = true;
                this.distanceTraveled = 0;
                this.lastPosition = null;
                
                this.build();
            }
            
            build() {
                const genes = this.genome.genes;
                let geneIndex = 0;
                
                // Create body
                const bodyWidth = genes[geneIndex++];
                const bodyHeight = genes[geneIndex++];
                const bodyLength = genes[geneIndex++];
                
                const body = BABYLON.MeshBuilder.CreateBox(
                    `body_${this.id}`,
                    { width: bodyWidth, height: bodyHeight, depth: bodyLength },
                    this.scene
                );
                
                const bodyMaterial = new BABYLON.StandardMaterial(`bodyMat_${this.id}`, this.scene);
                bodyMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.6, 0.9);
                bodyMaterial.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                body.material = bodyMaterial;
                
                this.meshes.push(body);
                this.body = body;
                
                // Create legs
                this.legs = [];
                for (let leg = 0; leg < this.genome.numLegs; leg++) {
                    const legData = this.createLeg(geneIndex, leg);
                    geneIndex += 7 + this.genome.segmentsPerLeg * 3;
                    this.legs.push(legData);
                }
                
                // Position creature
                body.position = new BABYLON.Vector3(0, 1, 0);
                this.initialPosition = body.position.clone();
                this.lastPosition = body.position.clone();
            }
            
            createLeg(startGeneIndex, legIndex) {
                const genes = this.genome.genes;
                let geneIndex = startGeneIndex;
                
                // Attachment point
                const attachX = genes[geneIndex++];
                const attachY = genes[geneIndex++];
                const attachZ = genes[geneIndex++];
                const phaseOffset = genes[geneIndex++];
                
                // Create leg segments
                const segments = [];
                const joints = [];
                
                for (let seg = 0; seg < this.genome.segmentsPerLeg; seg++) {
                    const length = genes[geneIndex++];
                    
                    const segment = BABYLON.MeshBuilder.CreateCylinder(
                        `leg_${this.id}_${legIndex}_${seg}`,
                        { height: length, diameter: 0.1 },
                        this.scene
                    );
                    
                    const segMaterial = new BABYLON.StandardMaterial(`legMat_${this.id}_${legIndex}_${seg}`, this.scene);
                    segMaterial.diffuseColor = new BABYLON.Color3(0.7, 0.4, 0.2);
                    segment.material = segMaterial;
                    
                    this.meshes.push(segment);
                    segments.push(segment);
                    
                    if (seg < this.genome.segmentsPerLeg - 1) {
                        const minAngle = genes[geneIndex++];
                        const maxAngle = genes[geneIndex++];
                        joints.push({ minAngle, maxAngle });
                    }
                }
                
                return {
                    segments,
                    joints,
                    attachX,
                    attachY,
                    attachZ,
                    phaseOffset
                };
            }
            
            update(deltaTime, cycleDuration) {
                this.time += deltaTime;
                
                // Update leg positions
                for (let legIndex = 0; legIndex < this.legs.length; legIndex++) {
                    const leg = this.legs[legIndex];
                    const phase = (this.time / cycleDuration) * TWO_PI + leg.phaseOffset;
                    
                    // Calculate leg positions using forward kinematics
                    this.updateLeg(leg, phase);
                }
                
                // Simple physics - move body based on leg contacts
                this.updatePhysics(deltaTime);
                
                // Calculate fitness
                const currentPos = this.body.position;
                const distance = Math.sqrt(
                    Math.pow(currentPos.x - this.initialPosition.x, 2) +
                    Math.pow(currentPos.z - this.initialPosition.z, 2)
                );
                
                this.distanceTraveled = distance;
                
                // Fitness = distance + stability bonus
                this.fitness = distance + (this.isStable ? 10 : 0);
            }
            
            updateLeg(leg, phase) {
                const genes = this.genome.genes;
                
                // Position first segment at attachment point
                const attachPoint = new BABYLON.Vector3(
                    leg.attachX,
                    leg.attachY,
                    leg.attachZ
                );
                
                let parentPos = this.body.position.clone();
                let parentRot = this.body.rotation.clone();
                
                for (let seg = 0; seg < leg.segments.length; seg++) {
                    const segment = leg.segments[seg];
                    
                    // Position segment
                    segment.position = parentPos.clone();
                    segment.rotation = parentRot.clone();
                    
                    // Apply joint rotation
                    if (seg < leg.joints.length) {
                        const joint = leg.joints[seg];
                        const angle = map(sin(phase), -1, 1, joint.minAngle, joint.maxAngle);
                        segment.rotation.x += angle;
                    }
                    
                    // Update parent for next segment
                    if (seg < leg.segments.length - 1) {
                        const nextLength = genes[7 + seg + 1];
                        parentPos = new BABYLON.Vector3(
                            parentPos.x + Math.sin(segment.rotation.x) * nextLength / 2,
                            parentPos.y - Math.cos(segment.rotation.x) * nextLength / 2,
                            parentPos.z
                        );
                        parentRot = segment.rotation.clone();
                    }
                }
            }
            
            updatePhysics(deltaTime) {
                // Simple forward movement based on leg positions
                let totalForce = new BABYLON.Vector3(0, 0, 0);
                
                for (const leg of this.legs) {
                    // Calculate force from each leg
                    for (let seg = 0; seg < leg.segments.length; seg++) {
                        const segment = leg.segments[seg];
                        
                        // Check if segment is touching ground (simplified)
                        if (segment.position.y <= 0.2) {
                            const force = new BABYLON.Vector3(0, 0, 0.1);
                            force.rotateAroundWorldAxis(segment.rotation.x, new BABYLON.Vector3(1, 0, 0));
                            totalForce.addInPlace(force);
                        }
                    }
                }
                
                // Apply force to body
                this.body.position.addInPlace(totalForce.scale(deltaTime));
                
                // Keep body above ground
                if (this.body.position.y < 0.5) {
                    this.body.position.y = 0.5;
                }
                
                // Check stability
                this.isStable = Math.abs(this.body.position.x) < 10 && 
                               Math.abs(this.body.position.y - 1) < 2;
            }
            
            reset() {
                this.body.position = this.initialPosition.clone();
                this.body.rotation = new BABYLON.Vector3(0, 0, 0);
                this.time = 0;
                this.fitness = 0;
                this.distanceTraveled = 0;
                this.lastPosition = this.initialPosition.clone();
            }
            
            dispose() {
                for (const mesh of this.meshes) {
                    mesh.dispose();
                }
            }
        }
        
        // Genetic Algorithm
        class GeneticAlgorithm {
            constructor(populationSize = 20, mutationRate = 0.1) {
                this.populationSize = populationSize;
                this.mutationRate = mutationRate;
                this.population = [];
                this.generation = 0;
                this.bestFitness = 0;
                this.averageFitness = 0;
                this.bestIndividual = null;
                
                this.initializePopulation();
            }
            
            initializePopulation() {
                this.population = [];
                for (let i = 0; i < this.populationSize; i++) {
                    const genome = new Genome(
                        parseInt(document.getElementById('numLegs').value),
                        parseInt(document.getElementById('legSegments').value)
                    );
                    this.population.push(genome);
                }
            }
            
            evaluatePopulation(creatures) {
                let totalFitness = 0;
                let bestFitness = 0;
                let bestIndex = 0;
                
                for (let i = 0; i < creatures.length; i++) {
                    const fitness = creatures[i].fitness;
                    totalFitness += fitness;
                    
                    if (fitness > bestFitness) {
                        bestFitness = fitness;
                        bestIndex = i;
                    }
                }
                
                this.averageFitness = totalFitness / creatures.length;
                this.bestFitness = bestFitness;
                this.bestIndividual = this.population[bestIndex].clone();
                
                return bestIndex;
            }
            
            selectParents() {
                // Tournament selection
                const tournamentSize = 3;
                const parents = [];
                
                for (let i = 0; i < 2; i++) {
                    let best = null;
                    let bestFitness = -Infinity;
                    
                    for (let j = 0; j < tournamentSize; j++) {
                        const candidate = this.population[Math.floor(random(this.population.length))];
                        if (candidate.fitness > bestFitness) {
                            best = candidate;
                            bestFitness = candidate.fitness;
                        }
                    }
                    
                    parents.push(best);
                }
                
                return parents;
            }
            
            evolve() {
                const newPopulation = [];
                
                // Keep best individual (elitism)
                if (this.bestIndividual) {
                    newPopulation.push(this.bestIndividual.clone());
                }
                
                // Generate new population
                while (newPopulation.length < this.populationSize) {
                    const parents = this.selectParents();
                    const child = parents[0].crossover(parents[1]);
                    child.mutate(this.mutationRate);
                    newPopulation.push(child);
                }
                
                this.population = newPopulation;
                this.generation++;
            }
            
            reset() {
                this.generation = 0;
                this.bestFitness = 0;
                this.averageFitness = 0;
                this.bestIndividual = null;
                this.initializePopulation();
            }
        }
        
        // Main Evolution Controller
        class EvolutionController {
            constructor() {
                this.scene = null;
                this.engine = null;
                this.camera = null;
                this.ga = null;
                this.creatures = [];
                this.currentCreatureIndex = 0;
                this.evaluationTime = 10000; // 10 seconds per creature
                this.currentEvaluationTime = 0;
                this.isRunning = false;
                this.isPaused = false;
                this.showingBest = false;
                
                this.init();
            }
            
            init() {
                // Create canvas and engine
                const canvas = document.getElementById('renderCanvas');
                this.engine = new BABYLON.Engine(canvas, true);
                this.scene = new BABYLON.Scene(this.engine);
                
                // Setup camera
                this.camera = new BABYLON.ArcRotateCamera(
                    "camera",
                    Math.PI / 4,
                    Math.PI / 3,
                    20,
                    new BABYLON.Vector3(0, 2, 0),
                    this.scene
                );
                this.camera.attachControl(canvas, true);
                
                // Setup lighting
                const light = new BABYLON.HemisphericLight(
                    "light",
                    new BABYLON.Vector3(0, 1, 0),
                    this.scene
                );
                light.intensity = 0.8;
                
                const dirLight = new BABYLON.DirectionalLight(
                    "dirLight",
                    new BABYLON.Vector3(-1, -2, -1),
                    this.scene
                );
                dirLight.intensity = 0.5;
                
                // Create ground
                const ground = BABYLON.MeshBuilder.CreateGround(
                    "ground",
                    { width: 20, height: 20 },
                    this.scene
                );
                const groundMaterial = new BABYLON.StandardMaterial("groundMat", this.scene);
                groundMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.5, 0.3);
                ground.material = groundMaterial;
                
                // Initialize GA
                this.ga = new GeneticAlgorithm(
                    parseInt(document.getElementById('popSize').value),
                    parseFloat(document.getElementById('mutationRate').value)
                );
                
                // Create initial creatures
                this.createCreatures();
                
                // Start render loop
                this.engine.runRenderLoop(() => this.render());
                
                // Handle resize
                window.addEventListener('resize', () => {
                    this.engine.resize();
                });
            }
            
            createCreatures() {
                // Clear existing creatures
                for (const creature of this.creatures) {
                    creature.dispose();
                }
                this.creatures = [];
                
                // Create new creatures from genomes
                for (let i = 0; i < this.ga.population.length; i++) {
                    const creature = new Creature(this.ga.population[i], this.scene, i);
                    creature.meshes.forEach(mesh => mesh.setEnabled(false));
                    this.creatures.push(creature);
                }
                
                // Enable first creature
                if (this.creatures.length > 0) {
                    this.creatures[0].meshes.forEach(mesh => mesh.setEnabled(true));
                }
            }
            
            startEvolution() {
                this.isRunning = true;
                this.isPaused = false;
            }
            
            pauseEvolution() {
                this.isPaused = !this.isPaused;
            }
            
            reset() {
                this.isRunning = false;
                this.isPaused = false;
                this.currentCreatureIndex = 0;
                this.currentEvaluationTime = 0;
                this.ga.reset();
                this.createCreatures();
                this.updateStats();
            }
            
            update(deltaTime) {
                if (!this.isRunning || this.isPaused) return;
                
                const cycleDuration = parseFloat(document.getElementById('cycleDuration').value);
                
                // Update current creature
                const currentCreature = this.creatures[this.currentCreatureIndex];
                if (currentCreature) {
                    currentCreature.update(deltaTime / 1000, cycleDuration);
                    this.currentEvaluationTime += deltaTime;
                    
                    // Check if evaluation time is complete
                    if (this.currentEvaluationTime >= this.evaluationTime) {
                        // Move to next creature
                        currentCreature.meshes.forEach(mesh => mesh.setEnabled(false));
                        this.currentCreatureIndex++;
                        this.currentEvaluationTime = 0;
                        
                        if (this.currentCreatureIndex >= this.creatures.length) {
                            // Generation complete - evolve
                            this.evaluateAndEvolve();
                            this.currentCreatureIndex = 0;
                        }
                        
                        // Enable next creature
                        if (this.creatures[this.currentCreatureIndex]) {
                            this.creatures[this.currentCreatureIndex].reset();
                            this.creatures[this.currentCreatureIndex].meshes.forEach(mesh => mesh.setEnabled(true));
                        }
                    }
                    
                    // Camera follow
                    this.camera.setTarget(currentCreature.body.position);
                }
                
                this.updateStats();
            }
            
            evaluateAndEvolve() {
                // Evaluate population
                for (let i = 0; i < this.creatures.length; i++) {
                    this.ga.population[i].fitness = this.creatures[i].fitness;
                }
                
                // Evolve
                this.ga.evolve();
                
                // Recreate creatures with new genomes
                this.createCreatures();
            }
            
            updateStats() {
                document.getElementById('generation').textContent = this.ga.generation;
                document.getElementById('bestFitness').textContent = this.ga.bestFitness.toFixed(2);
                document.getElementById('avgFitness').textContent = this.ga.averageFitness.toFixed(2);
                document.getElementById('evaluating').textContent = 
                    `${this.currentCreatureIndex + 1}/${this.creatures.length}`;
                
                const progress = ((this.currentEvaluationTime / this.evaluationTime) * 100) + 
                               (this.currentCreatureIndex / this.creatures.length) * 100;
                document.getElementById('progressFill').style.width = `${progress % 100}%`;
            }
            
            render() {
                const deltaTime = this.engine.getDeltaTime();
                this.update(deltaTime);
                this.scene.render();
            }
        }
        
        // Initialize evolution controller
        let evolution;
        
        window.addEventListener('DOMContentLoaded', () => {
            evolution = new EvolutionController();
            
            // Setup controls
            setupControls();
        });
        
        function setupControls() {
            // Population size
            document.getElementById('popSize').addEventListener('input', (e) => {
                document.getElementById('popSizeValue').textContent = e.target.value;
                evolution.ga.populationSize = parseInt(e.target.value);
            });
            
            // Mutation rate
            document.getElementById('mutationRate').addEventListener('input', (e) => {
                document.getElementById('mutationRateValue').textContent = e.target.value;
                evolution.ga.mutationRate = parseFloat(e.target.value);
            });
            
            // Cycle duration
            document.getElementById('cycleDuration').addEventListener('input', (e) => {
                document.getElementById('cycleDurationValue').textContent = e.target.value;
            });
            
            // Number of legs
            document.getElementById('numLegs').addEventListener('input', (e) => {
                document.getElementById('numLegsValue').textContent = e.target.value;
            });
            
            // Leg segments
            document.getElementById('legSegments').addEventListener('input', (e) => {
                document.getElementById('legSegmentsValue').textContent = e.target.value;
            });
        }
        
        function toggleControls() {
            const controls = document.getElementById('controls');
            const toggleBtn = document.getElementById('toggleBtn');
            controls.classList.toggle('hidden');
            toggleBtn.classList.toggle('shifted');
            toggleBtn.textContent = controls.classList.contains('hidden') ? 'â–¶' : 'â—€';
        }
    </script>
</body>
</html>