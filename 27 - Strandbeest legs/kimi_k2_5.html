<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Strandbeest Genetic Algorithm Evolver</title>
   
   <!-- Tailwind CSS -->
   <script src="https://cdn.tailwindcss.com"></script>
   
   <!-- Babylon.js Core -->
   <script src="https://cdn.babylonjs.com/babylon.js"></script>
   <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

   <style>
       body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #0f172a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
       #renderCanvas { width: 100%; height: 100%; touch-action: none; outline: none; }
       
       /* Custom Scrollbar */
       ::-webkit-scrollbar { width: 6px; }
       ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
       ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
       
       .glass-panel {
           background: rgba(15, 23, 42, 0.85);
           backdrop-filter: blur(12px);
           border-right: 1px solid rgba(255, 255, 255, 0.1);
           box-shadow: 4px 0 24px rgba(0,0,0,0.5);
       }

       .stat-value { font-variant-numeric: tabular-nums; }
       
       input[type=range] {
           -webkit-appearance: none; width: 100%; background: transparent;
       }
       input[type=range]::-webkit-slider-thumb {
           -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: #38bdf8; cursor: pointer; margin-top: -5px;
       }
       input[type=range]::-webkit-slider-runnable-track {
           width: 100%; height: 4px; cursor: pointer; background: rgba(255,255,255,0.2); border-radius: 2px;
       }
   </style>
</head>
<body>

   <!-- UI Overlay -->
   <div class="absolute top-0 left-0 h-full w-80 glass-panel z-10 flex flex-col p-6 text-gray-100 overflow-y-auto">
       <h1 class="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-cyan-400 to-emerald-400 mb-2">Strandbeest GA</h1>
       <p class="text-xs text-gray-400 mb-6">Evolutionary Kinematics Simulation</p>

       <!-- Stats -->
       <div class="grid grid-cols-2 gap-3 mb-6">
           <div class="bg-white/5 p-3 rounded-lg border border-white/10">
               <div class="text-xs text-gray-400 uppercase tracking-wider">Generation</div>
               <div id="stat-gen" class="text-xl font-bold text-cyan-300 stat-value">0</div>
           </div>
           <div class="bg-white/5 p-3 rounded-lg border border-white/10">
               <div class="text-xs text-gray-400 uppercase tracking-wider">Best Dist</div>
               <div id="stat-best" class="text-xl font-bold text-emerald-300 stat-value">0.0</div>
           </div>
           <div class="bg-white/5 p-3 rounded-lg border border-white/10 col-span-2">
               <div class="text-xs text-gray-400 uppercase tracking-wider">Avg Fitness</div>
               <div class="w-full bg-gray-700 h-1.5 rounded-full mt-2 overflow-hidden">
                   <div id="bar-avg" class="bg-blue-400 h-full" style="width: 0%"></div>
               </div>
           </div>
       </div>

       <!-- Controls -->
       <div class="space-y-5 flex-grow">
           
           <!-- Playback -->
           <div class="flex gap-2">
               <button id="btn-toggle" class="flex-1 bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-2 px-4 rounded transition shadow-lg shadow-cyan-500/30 flex items-center justify-center gap-2">
                   <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                   <span>Start</span>
               </button>
               <button id="btn-reset" class="flex-1 bg-slate-600 hover:bg-slate-500 text-white font-bold py-2 px-4 rounded transition">
                   Reset
               </button>
           </div>

           <hr class="border-white/10">

           <!-- GA Parameters -->
           <div>
               <div class="flex justify-between text-sm mb-1">
                   <span class="text-gray-300">Population Size</span>
                   <span id="val-pop" class="text-cyan-400 font-mono">20</span>
               </div>
               <input type="range" id="input-pop" min="5" max="50" value="20">
           </div>

           <div>
               <div class="flex justify-between text-sm mb-1">
                   <span class="text-gray-300">Mutation Rate</span>
                   <span id="val-mut" class="text-cyan-400 font-mono">10%</span>
               </div>
               <input type="range" id="input-mut" min="0" max="50" value="10">
           </div>

           <div>
               <div class="flex justify-between text-sm mb-1">
                   <span class="text-gray-300">Sim Speed</span>
                   <span id="val-speed" class="text-cyan-400 font-mono">1.0x</span>
               </div>
               <input type="range" id="input-speed" min="0.1" max="3.0" step="0.1" value="1.0">
           </div>

           <hr class="border-white/10">

           <!-- Camera/Debug -->
           <div class="flex items-center justify-between">
               <span class="text-sm text-gray-300">Follow Best</span>
               <label class="relative inline-flex items-center cursor-pointer">
                   <input type="checkbox" id="check-follow" class="sr-only peer" checked>
                   <div class="w-9 h-5 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-emerald-500"></div>
               </label>
           </div>
            <div class="flex items-center justify-between">
               <span class="text-sm text-gray-300">Show Ghosts</span>
               <label class="relative inline-flex items-center cursor-pointer">
                   <input type="checkbox" id="check-ghosts" class="sr-only peer" checked>
                   <div class="w-9 h-5 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-emerald-500"></div>
               </label>
           </div>
       </div>
       
       <div class="mt-6 text-[10px] text-gray-500 text-center">
           Drag to rotate â€¢ Scroll to zoom
       </div>
   </div>

   <canvas id="renderCanvas"></canvas>

   <script>
       // --- CONFIGURATION ---
       const CONFIG = {
           groundSize: 1000,
           simDuration: 300, // Frames per generation (~5 sec at 60fps)
           legPairs: 2, // Number of leg pairs (total legs * 2)
           segmentCount: 4, // Complexity of leg
           gravity: -0.5,
           bodyMass: 1.0
       };

       // --- GENETIC ALGORITHM CORE ---

       class Genome {
           constructor() {
               // Gene Map:
               // For each leg pair: [hipX, hipY, jointLen1, jointLen2, jointLen3, jointLen4, phaseOffset]
               // Weights are randomized
               this.genes = [];
               const geneSize = 7; 
               
               for(let i=0; i<CONFIG.legPairs; i++) {
                   // Hip placement relative to center
                   let hipX = (Math.random() - 0.5) * 2; 
                   let hipY = Math.random() * 2 + 1; // Height of hip joint
                   
                   // Segment lengths
                   let segs = [];
                   for(let j=0; j<CONFIG.segmentCount; j++) {
                       segs.push(Math.random() * 2 + 0.5);
                   }
                   
                   // Phase offset for walking cycle (alternating legs)
                   let phase = (i / CONFIG.legPairs) * Math.PI; // Alternating default

                   this.genes.push([hipX, hipY, ...segs, phase]);
               }
           }

           mutate(rate) {
               for(let leg of this.genes) {
                   for(let i=0; i<leg.length; i++) {
                       if(Math.random() < rate) {
                           // Perturb gene
                           let change = (Math.random() - 0.5) * 0.5;
                           leg[i] += change;
                           // Constraints
                           if(i >= 2 && i < 2 + CONFIG.segmentCount) {
                               // Segment lengths must be positive
                               leg[i] = Math.max(0.1, leg[i]);
                           }
                       }
                   }
               }
           }

           static crossover(p1, p2) {
               let child = new Genome();
               child.genes = [];
               for(let i=0; i<CONFIG.legPairs; i++) {
                   let newLeg = [];
                   for(let j=0; j<p1.genes[i].length; j++) {
                       // 50/50 chance of inheriting from either parent
                       newLeg.push(Math.random() > 0.5 ? p1.genes[i][j] : p2.genes[i][j]);
                   }
                   child.genes.push(newLeg);
               }
               return child;
           }
       }

       class Creature {
           constructor(scene, genome, id) {
               this.scene = scene;
               this.genome = genome;
               this.id = id;
               this.fitness = 0;
               this.startPos = new BABYLON.Vector3(0, 2, 0);
               this.mesh = null; // Root node
               this.legs = []; // Array of leg objects { pivot, segments[] }
               this.isBest = false;
               
               this.buildMesh();
               this.reset();
           }

           buildMesh() {
               // Root transform
               this.mesh = new BABYLON.TransformNode("creature_" + this.id, this.scene);
               
               // Material
               let mat = new BABYLON.StandardMaterial("mat_" + this.id, this.scene);
               let color = new BABYLON.Color3(0.3 + Math.random()*0.5, 0.3 + Math.random()*0.5, 0.8);
               mat.diffuseColor = color;
               mat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
               
               if(this.id === 0) mat.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.4); // Highlight best slightly

               // Body (Simple Box)
               let body = BABYLON.MeshBuilder.CreateBox("body", {width: 4, height: 1, depth: 2}, this.scene);
               body.material = mat;
               body.parent = this.mesh;
               body.position.y = 1;

               // Build Legs based on Genome
               this.genome.genes.forEach((gene, index) => {
                   let legGroup = new BABYLON.TransformNode("legGroup_" + index, this.scene);
                   legGroup.parent = this.mesh;
                   legGroup.position.x = gene[0];
                   legGroup.position.y = gene[1];
                   legGroup.position.z = (index % 2 === 0 ? 1 : -1) * 0.5; // Alternate sides roughly

                   let legObj = {
                       root: legGroup,
                       joints: [],
                       totalLen: 0
                   };

                   let currentParent = legGroup;
                   let cumulativeLen = 0;

                   for(let s=0; s<CONFIG.segmentCount; s++) {
                       let len = gene[2 + s];
                       cumulativeLen += len;

                       // Joint visual
                       let jointMesh = BABYLON.MeshBuilder.CreateSphere("j", {diameter: 0.3}, this.scene);
                       jointMesh.material = mat;
                       jointMesh.parent = currentParent;
                       
                       // Segment visual
                       let segment = BABYLON.MeshBuilder.CreateCylinder("seg", {height: len, diameter: 0.15}, this.scene);
                       segment.material = mat;
                       segment.parent = currentParent;
                       // Cylinder is created centered. Move it up by len/2 so pivot is at bottom
                       segment.position.y = -len / 2; 
                       
                       // Next pivot
                       let nextPivot = new BABYLON.TransformNode("pivot_" + s, this.scene);
                       nextPivot.parent = currentParent;
                       nextPivot.position.y = -len;

                       legObj.joints.push({ mesh: segment, pivot: nextPivot, len: len });
                       currentParent = nextPivot;
                   }
                   
                   legObj.totalLen = cumulativeLen;
                   this.legs.push(legObj);
               });
           }

           reset() {
               this.mesh.position.copyFrom(this.startPos);
               this.fitness = 0;
               // Reset rotation
               this.mesh.rotation = new BABYLON.Vector3(0, 0, 0);
               // Reset leg rotations
               this.legs.forEach(leg => {
                   leg.joints.forEach(j => {
                       j.pivot.rotation.x = 0;
                   });
               });
           }

           update(time, speedMultiplier) {
               // Walking Cycle Logic
               // We use a Sine wave to drive the leg angles
               // This is a simplified procedural animation based on the genome's phase and structure
               
               let t = time * speedMultiplier;

               this.legs.forEach((leg, i) => {
                   let gene = this.genome.genes[i];
                   let phase = gene[6]; // Phase offset
                   
                   // Cycle value -1 to 1
                   let cycle = Math.sin(t + phase);

                   // Distribute rotation across joints
                   // Strategy: Hip moves most, knee moves opposite, etc.
                   // This creates a "kicking" or "stepping" motion depending on phase alignment
                   
                   leg.joints.forEach((joint, j) => {
                       // Base amplitude for joint movement
                       let amp = 0.5; 
                       
                       // Different gait patterns based on joint index
                       // Odd/Even inversion for "knee" bending
                       let dir = (j % 2 === 0) ? 1 : -1;
                       
                       // Add some noise based on segment length to vary gait
                       let lenFactor = joint.len / 2;

                       joint.pivot.rotation.x = cycle * amp * dir + (Math.sin(t*2)*0.1);
                   });
               });

               // Physics Simulation (Simplified)
               // We calculate where the foot would be if the body was static, 
               // but we actually move the body based on the average "thrust" of the legs.
               
               // Simple heuristic for movement:
               // If legs are "pushing back" (rotation is positive and increasing), move forward.
               // This is a fake physics hack to make it look like walking without full joint IK solving ground contact.
               
               let avgRot = 0;
               this.legs.forEach(l => {
                   avgRot += l.joints[0].pivot.rotation.x;
               });
               avgRot /= this.legs.length;

               // Move forward if legs are swinging back
               let moveSpeed = Math.max(0, -avgRot) * 0.05 * speedMultiplier;
               
               // Add some noise/wobble
               this.mesh.position.x += moveSpeed;
               this.mesh.position.y = 2 + Math.sin(t*2)*0.05; // Bobbing

               // Calculate Fitness
               this.fitness = this.mesh.position.x;
           }

           dispose() {
               this.mesh.dispose();
           }
       }

       // --- MAIN APPLICATION ---

       class App {
           constructor() {
               this.canvas = document.getElementById("renderCanvas");
               this.engine = new BABYLON.Engine(this.canvas, true);
               this.scene = null;
               this.camera = null;
               
               this.population = [];
               this.generation = 0;
               this.isRunning = false;
               this.simFrame = 0;
               
               this.params = {
                   popSize: 20,
                   mutationRate: 0.1,
                   speed: 1.0,
                   followBest: true,
                   showGhosts: true
               };

               this.bestEver = { fitness: 0, genome: null };
               
               this.init();
           }

           init() {
               this.scene = this.createScene();
               
               // Bind UI
               this.setupUI();

               // Render Loop
               this.engine.runRenderLoop(() => {
                   if(this.isRunning) {
                       this.updateSimulation();
                   }
                   this.scene.render();
                   
                   // Camera follow logic
                   if(this.params.followBest && this.population.length > 0) {
                       let best = this.population.reduce((p, c) => p.fitness > c.fitness ? p : c);
                       // Smooth follow
                       let targetX = best.mesh.position.x;
                       this.camera.target.x = this.camera.target.x * 0.95 + targetX * 0.05;
                       this.camera.beta = Math.PI / 3; // Lock angle
                   }
               });

               window.addEventListener("resize", () => {
                   this.engine.resize();
               });

               this.createInitialPopulation();
           }

           createScene() {
               let scene = new BABYLON.Scene(this.engine);
               scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.1, 1);
               
               // Camera
               this.camera = new BABYLON.ArcRotateCamera("camera", -Math.PI/2, Math.PI/3, 20, BABYLON.Vector3.Zero(), scene);
               this.camera.attachControl(this.canvas, true);
               this.camera.lowerRadiusLimit = 5;
               this.camera.upperRadiusLimit = 50;
               this.camera.wheelPrecision = 50;

               // Light
               let light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
               light.intensity = 0.7;
               let dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
               dirLight.position = new BABYLON.Vector3(20, 40, 20);
               dirLight.intensity = 0.7;
               
               // Shadows
               let shadowGenerator = new BABYLON.ShadowGenerator(1024, dirLight);
               shadowGenerator.useBlurExponentialShadowMap = true;

               // Ground
               let ground = BABYLON.MeshBuilder.CreateGround("ground", {width: CONFIG.groundSize, height: CONFIG.groundSize}, scene);
               let groundMat = new BABYLON.StandardMaterial("groundMat", scene);
               groundMat.diffuseColor = new BABYLON.Color3(0.1, 0.12, 0.15);
               groundMat.specularColor = new BABYLON.Color3(0,0,0);
               
               // Grid texture for ground
               let gridTexture = new BABYLON.DynamicTexture("gridTex", 512, scene, true);
               let ctx = gridTexture.getContext();
               ctx.strokeStyle = "rgba(50, 70, 80, 0.5)";
               ctx.lineWidth = 2;
               for(let i=0; i<=512; i+=64) {
                   ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,512); ctx.stroke();
                   ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(512,i); ctx.stroke();
               }
               gridTexture.update();
               groundMat.diffuseTexture = gridTexture;
               groundMat.diffuseTexture.uScale = 50;
               groundMat.diffuseTexture.vScale = 50;
               
               ground.material = groundMat;
               ground.receiveShadows = true;

               return scene;
           }

           createInitialPopulation() {
               this.clearPopulation();
               this.generation = 0;
               this.simFrame = 0;
               this.updateStats();

               for(let i=0; i<this.params.popSize; i++) {
                   let genome = new Genome();
                   // Seed first one with slightly better logic? No, pure random.
                   let creature = new Creature(this.scene, genome, i);
                   this.population.push(creature);
               }
           }

           clearPopulation() {
               this.population.forEach(c => c.dispose());
               this.population = [];
           }

           updateSimulation() {
               // Update all creatures
               this.population.forEach(c => {
                   c.update(this.simFrame, this.params.speed);
                   
                   // Visibility control
                   if(!this.params.showGhosts && !c.isBest) {
                       c.mesh.setEnabled(false);
                   } else {
                       c.mesh.setEnabled(true);
                   }
               });

               // Highlight Best
               let currentBest = this.population.reduce((p, c) => p.fitness > c.fitness ? p : c);
               
               // Reset previous best visual
               this.population.forEach(c => {
                   if(c.isBest && c !== currentBest) {
                       c.isBest = false;
                       c.mesh.getChildren()[0].material.emissiveColor = new BABYLON.Color3(0,0,0);
                   }
               });

               // Set new best visual
               if(!currentBest.isBest) {
                   currentBest.isBest = true;
                   currentBest.mesh.getChildren()[0].material.emissiveColor = new BABYLON.Color3(0.2, 0.8, 0.2); // Green glow
               }

               this.simFrame++;

               // End of Generation
               if(this.simFrame >= CONFIG.simDuration) {
                   this.evolve();
               }
           }

           evolve() {
               // 1. Sort by fitness (descending)
               this.population.sort((a, b) => b.fitness - a.fitness);

               // 2. Stats
               let bestFitness = this.population[0].fitness;
               if(bestFitness > this.bestEver.fitness) {
                   this.bestEver = { fitness: bestFitness, genome: this.population[0].genome };
               }
               
               let avgFit = this.population.reduce((sum, c) => sum + c.fitness, 0) / this.population.length;
               
               // Update UI
               document.getElementById('stat-gen').innerText = this.generation;
               document.getElementById('stat-best').innerText = this.bestEver.fitness.toFixed(2);
               
               let maxDist = 50; // Arbitrary visual scale for bar
               let pct = Math.min(100, Math.max(0, (avgFit / maxDist) * 100));
               document.getElementById('bar-avg').style.width = pct + "%";

               // 3. Create New Generation
               let newPop = [];
               
               // Elitism: Keep top 2
               for(let i=0; i<2; i++) {
                   // Create new creature with same genome, but reset pos
                   let eliteGenome = this.population[i].genome;
                   newPop.push(new Creature(this.scene, eliteGenome, i));
                   newPop[i].isBest = (i===0);
                   newPop[i].mesh.getChildren()[0].material.emissiveColor = (i===0) ? new BABYLON.Color3(0.2, 0.8, 0.2) : new BABYLON.Color3(0,0,0);
               }

               // Generate rest
               while(newPop.length < this.params.popSize) {
                   // Selection: Tournament or Top Half
                   // Let's pick two random parents from top 50%
                   let idx1 = Math.floor(Math.random() * (this.population.length / 2));
                   let idx2 = Math.floor(Math.random() * (this.population.length / 2));
                   
                   let parent1 = this.population[idx1];
                   let parent2 = this.population[idx2];
                   
                   // Crossover
                   let childGenome = Genome.crossover(parent1.genome, parent2.genome);
                   
                   // Mutate
                   childGenome.mutate(this.params.mutationRate);
                   
                   newPop.push(new Creature(this.scene, childGenome, newPop.length));
               }

               // Cleanup old
               this.population.forEach(c => c.dispose());
               this.population = newPop;
               
               this.generation++;
               this.simFrame = 0;
           }

           setupUI() {
               const btnToggle = document.getElementById('btn-toggle');
               const btnReset = document.getElementById('btn-reset');
               
               btnToggle.addEventListener('click', () => {
                   this.isRunning = !this.isRunning;
                   btnToggle.innerHTML = this.isRunning ? 
                       `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg> <span>Pause</span>` : 
                       `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg> <span>Resume</span>`;
                   
                   btnToggle.classList.toggle('bg-cyan-600');
                   btnToggle.classList.toggle('bg-amber-600');
               });

               btnReset.addEventListener('click', () => {
                   this.createInitialPopulation();
                   this.isRunning = false;
                   btnToggle.innerHTML = `<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg> <span>Start</span>`;
                   btnToggle.classList.add('bg-cyan-600');
                   btnToggle.classList.remove('bg-amber-600');
               });

               // Inputs
               document.getElementById('input-pop').addEventListener('input', (e) => {
                   this.params.popSize = parseInt(e.target.value);
                   document.getElementById('val-pop').innerText = this.params.popSize;
                   // Don't reset immediately, apply on next gen
               });
               
               document.getElementById('input-mut').addEventListener('input', (e) => {
                   this.params.mutationRate = parseInt(e.target.value) / 100;
                   document.getElementById('val-mut').innerText = e.target.value + "%";
               });

               document.getElementById('input-speed').addEventListener('input', (e) => {
                   this.params.speed = parseFloat(e.target.value);
                   document.getElementById('val-speed').innerText = this.params.speed.toFixed(1) + "x";
               });

               document.getElementById('check-follow').addEventListener('change', (e) => {
                   this.params.followBest = e.target.checked;
               });
               
               document.getElementById('check-ghosts').addEventListener('change', (e) => {
                   this.params.showGhosts = e.target.checked;
               });
           }
           
           updateStats() {
               // Initial placeholder
           }
       }

       // Initialize App
       window.addEventListener('DOMContentLoaded', () => {
           new App();
       });

   </script>
</body>
</html>