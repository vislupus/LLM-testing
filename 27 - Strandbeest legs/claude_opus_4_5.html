<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolving Strandbeest Walker - Genetic Algorithm</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background: #1a1a2e;
            overflow: hidden;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100vh;
            display: block;
        }
        
        #controls {
            position: fixed;
            top: 15px;
            left: 15px;
            background: rgba(10, 15, 30, 0.95);
            padding: 20px;
            border-radius: 12px;
            color: #fff;
            width: 300px;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid rgba(100, 150, 255, 0.2);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        
        #controls h2 {
            color: #4fc3f7;
            font-size: 18px;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .section {
            margin-bottom: 18px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .section h3 {
            color: #ce93d8;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        
        .control-row {
            margin-bottom: 12px;
        }
        
        .control-row label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
        }
        
        .control-row label span {
            color: #4fc3f7;
            font-family: 'Consolas', monospace;
        }
        
        input[type="range"] {
            width: 100%;
            height: 5px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
            cursor: pointer;
        }
        
        .button-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        button {
            flex: 1;
            min-width: 80px;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }
        
        .btn-green {
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: #000;
        }
        
        .btn-red {
            background: linear-gradient(135deg, #f87171, #ef4444);
            color: #fff;
        }
        
        .btn-blue {
            background: linear-gradient(135deg, #60a5fa, #3b82f6);
            color: #fff;
        }
        
        .btn-purple {
            background: linear-gradient(135deg, #c084fc, #a855f7);
            color: #fff;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-box .value {
            font-size: 18px;
            font-weight: 700;
            color: #4fc3f7;
            font-family: 'Consolas', monospace;
        }
        
        .stat-box .label {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
            margin-top: 3px;
        }
        
        #fitnessGraph {
            width: 100%;
            height: 80px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .info-text {
            font-size: 10px;
            color: #666;
            line-height: 1.5;
            margin-top: 10px;
        }
        
        #status {
            position: fixed;
            bottom: 15px;
            left: 15px;
            background: rgba(10, 15, 30, 0.95);
            padding: 12px 20px;
            border-radius: 8px;
            color: #4fc3f7;
            font-size: 13px;
            border: 1px solid rgba(100, 150, 255, 0.2);
        }
        
        #genome-display {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            font-family: 'Consolas', monospace;
            font-size: 9px;
            color: #888;
            word-break: break-all;
            max-height: 60px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <div id="controls">
        <h2>ü¶ø Strandbeest Evolution</h2>
        
        <div class="section">
            <h3>üìä Statistics</h3>
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="value" id="genDisplay">0</div>
                    <div class="label">Generation</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="bestFitDisplay">0</div>
                    <div class="label">Best Fitness</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="avgFitDisplay">0</div>
                    <div class="label">Avg Fitness</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="popDisplay">20</div>
                    <div class="label">Population</div>
                </div>
            </div>
            <canvas id="fitnessGraph"></canvas>
        </div>
        
        <div class="section">
            <h3>‚öôÔ∏è GA Parameters</h3>
            <div class="control-row">
                <label>Population Size: <span id="popVal">20</span></label>
                <input type="range" id="popSize" min="10" max="50" step="2" value="20">
            </div>
            <div class="control-row">
                <label>Mutation Rate: <span id="mutVal">0.15</span></label>
                <input type="range" id="mutRate" min="0.01" max="0.5" step="0.01" value="0.15">
            </div>
            <div class="control-row">
                <label>Cycle Duration: <span id="cycleVal">300</span> frames</label>
                <input type="range" id="cycleDur" min="100" max="600" step="50" value="300">
            </div>
            <div class="control-row">
                <label>Elitism: <span id="eliteVal">2</span></label>
                <input type="range" id="eliteSize" min="1" max="5" step="1" value="2">
            </div>
        </div>
        
        <div class="section">
            <h3>üéÆ Controls</h3>
            <div class="button-row">
                <button class="btn-green" id="startBtn" onclick="toggleEvolution()">Start</button>
                <button class="btn-red" onclick="resetEvolution()">Reset</button>
            </div>
            <div class="button-row" style="margin-top: 8px;">
                <button class="btn-blue" onclick="showBest()">Show Best</button>
                <button class="btn-purple" onclick="stepGeneration()">Step Gen</button>
            </div>
        </div>
        
        <div class="section">
            <h3>üß¨ Best Genome</h3>
            <div id="genome-display">No evolved genome yet</div>
        </div>
        
        <div class="info-text">
            Creatures evolve leg mechanisms to walk forward.<br>
            Fitness = forward distance √ó stability bonus.<br>
            Legs use Strandbeest-style linkages.
        </div>
    </div>
    
    <div id="status">Status: Ready</div>

    <script>
        // ===================== CONFIGURATION =====================
        let POPULATION_SIZE = 20;
        let MUTATION_RATE = 0.15;
        let CYCLE_DURATION = 300;
        let ELITE_SIZE = 2;
        
        // ===================== BABYLON.JS SETUP =====================
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true);
        let scene, camera, ground;
        
        // ===================== GA STATE =====================
        let population = [];
        let generation = 0;
        let bestFitness = 0;
        let bestGenome = null;
        let avgFitness = 0;
        let fitnessHistory = [];
        let isEvolving = false;
        let currentCreatureIndex = 0;
        let frameCount = 0;
        let evaluatingPopulation = false;
        let currentCreature = null;
        
        // Graph canvas
        let graphCanvas, graphCtx;
        
        // ===================== GENOME STRUCTURE =====================
        // Each creature has 4 legs (2 pairs)
        // Each leg genome: [crankLength, segment1Length, segment2Length, crankOffsetX, crankOffsetY, phase]
        const GENES_PER_LEG = 6;
        const NUM_LEGS = 4;
        const GENOME_LENGTH = NUM_LEGS * GENES_PER_LEG;
        
        // Gene ranges
        const GENE_RANGES = {
            crankLength: { min: 0.3, max: 1.0 },
            segment1Length: { min: 0.8, max: 2.0 },
            segment2Length: { min: 0.8, max: 2.0 },
            crankOffsetX: { min: -0.5, max: 0.5 },
            crankOffsetY: { min: -0.3, max: 0.3 },
            phase: { min: 0, max: Math.PI * 2 }
        };
        
        function createRandomGenome() {
            const genome = [];
            for (let leg = 0; leg < NUM_LEGS; leg++) {
                genome.push(randomInRange(GENE_RANGES.crankLength));
                genome.push(randomInRange(GENE_RANGES.segment1Length));
                genome.push(randomInRange(GENE_RANGES.segment2Length));
                genome.push(randomInRange(GENE_RANGES.crankOffsetX));
                genome.push(randomInRange(GENE_RANGES.crankOffsetY));
                // Phase: front and back legs should be offset
                const basePhase = leg < 2 ? 0 : Math.PI;
                genome.push(basePhase + (Math.random() - 0.5) * 0.5);
            }
            return genome;
        }
        
        function randomInRange(range) {
            return range.min + Math.random() * (range.max - range.min);
        }
        
        // ===================== CREATURE CLASS =====================
        class Creature {
            constructor(genome, scene) {
                this.genome = genome;
                this.scene = scene;
                this.meshes = [];
                this.joints = [];
                this.legData = [];
                this.bodyMesh = null;
                this.startX = 0;
                this.fitness = 0;
                this.crankAngle = 0;
                this.isStable = true;
                this.groundContacts = 0;
                
                this.build();
            }
            
            decodeGene(legIndex, geneType) {
                const baseIndex = legIndex * GENES_PER_LEG;
                const geneIndex = ['crankLength', 'segment1Length', 'segment2Length', 
                                   'crankOffsetX', 'crankOffsetY', 'phase'].indexOf(geneType);
                return this.genome[baseIndex + geneIndex];
            }
            
            build() {
                // Create body
                this.bodyMesh = BABYLON.MeshBuilder.CreateBox("body", {
                    width: 2.5,
                    height: 0.5,
                    depth: 1.2
                }, this.scene);
                this.bodyMesh.position = new BABYLON.Vector3(0, 2, 0);
                
                const bodyMat = new BABYLON.StandardMaterial("bodyMat", this.scene);
                bodyMat.diffuseColor = new BABYLON.Color3(0.2, 0.6, 0.9);
                bodyMat.emissiveColor = new BABYLON.Color3(0.1, 0.3, 0.4);
                this.bodyMesh.material = bodyMat;
                this.meshes.push(this.bodyMesh);
                
                // Create legs
                const legPositions = [
                    { x: -0.8, z: 0.5 },   // Front left
                    { x: -0.8, z: -0.5 },  // Front right
                    { x: 0.8, z: 0.5 },    // Back left
                    { x: 0.8, z: -0.5 }    // Back right
                ];
                
                for (let i = 0; i < NUM_LEGS; i++) {
                    const legPos = legPositions[i];
                    const legData = this.createLeg(i, legPos.x, legPos.z);
                    this.legData.push(legData);
                }
                
                this.startX = this.bodyMesh.position.x;
            }
            
            createLeg(legIndex, offsetX, offsetZ) {
                const crankLen = this.decodeGene(legIndex, 'crankLength');
                const seg1Len = this.decodeGene(legIndex, 'segment1Length');
                const seg2Len = this.decodeGene(legIndex, 'segment2Length');
                const crankOffX = this.decodeGene(legIndex, 'crankOffsetX');
                const crankOffY = this.decodeGene(legIndex, 'crankOffsetY');
                const phase = this.decodeGene(legIndex, 'phase');
                
                // Crank (rotating part)
                const crank = BABYLON.MeshBuilder.CreateCylinder("crank" + legIndex, {
                    height: crankLen,
                    diameter: 0.12
                }, this.scene);
                const crankMat = new BABYLON.StandardMaterial("crankMat" + legIndex, this.scene);
                crankMat.diffuseColor = new BABYLON.Color3(0.9, 0.4, 0.4);
                crankMat.emissiveColor = new BABYLON.Color3(0.3, 0.1, 0.1);
                crank.material = crankMat;
                this.meshes.push(crank);
                
                // Upper leg segment
                const seg1 = BABYLON.MeshBuilder.CreateCylinder("seg1_" + legIndex, {
                    height: seg1Len,
                    diameter: 0.1
                }, this.scene);
                const seg1Mat = new BABYLON.StandardMaterial("seg1Mat" + legIndex, this.scene);
                seg1Mat.diffuseColor = new BABYLON.Color3(0.5, 0.8, 0.4);
                seg1Mat.emissiveColor = new BABYLON.Color3(0.15, 0.3, 0.1);
                seg1.material = seg1Mat;
                this.meshes.push(seg1);
                
                // Lower leg segment
                const seg2 = BABYLON.MeshBuilder.CreateCylinder("seg2_" + legIndex, {
                    height: seg2Len,
                    diameter: 0.08
                }, this.scene);
                const seg2Mat = new BABYLON.StandardMaterial("seg2Mat" + legIndex, this.scene);
                seg2Mat.diffuseColor = new BABYLON.Color3(0.9, 0.7, 0.3);
                seg2Mat.emissiveColor = new BABYLON.Color3(0.3, 0.2, 0.1);
                seg2.material = seg2Mat;
                this.meshes.push(seg2);
                
                // Foot (sphere)
                const foot = BABYLON.MeshBuilder.CreateSphere("foot" + legIndex, {
                    diameter: 0.15
                }, this.scene);
                const footMat = new BABYLON.StandardMaterial("footMat" + legIndex, this.scene);
                footMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                foot.material = footMat;
                this.meshes.push(foot);
                
                return {
                    crank, seg1, seg2, foot,
                    crankLen, seg1Len, seg2Len,
                    crankOffX, crankOffY, phase,
                    offsetX, offsetZ
                };
            }
            
            update(dt) {
                // Rotate crank
                this.crankAngle += 0.05;
                
                let totalForwardForce = 0;
                let minFootY = Infinity;
                this.groundContacts = 0;
                
                const bodyPos = this.bodyMesh.position;
                
                for (let i = 0; i < this.legData.length; i++) {
                    const leg = this.legData[i];
                    const angle = this.crankAngle + leg.phase;
                    
                    // Pivot point on body
                    const pivotX = bodyPos.x + leg.offsetX + leg.crankOffX;
                    const pivotY = bodyPos.y + leg.crankOffY;
                    const pivotZ = bodyPos.z + leg.offsetZ;
                    
                    // Crank end position
                    const crankEndX = pivotX + Math.cos(angle) * leg.crankLen;
                    const crankEndY = pivotY + Math.sin(angle) * leg.crankLen;
                    
                    // Position crank
                    leg.crank.position = new BABYLON.Vector3(
                        (pivotX + crankEndX) / 2,
                        (pivotY + crankEndY) / 2,
                        pivotZ
                    );
                    leg.crank.rotation.z = angle + Math.PI / 2;
                    
                    // Upper leg - connects crank end to knee
                    // Using simplified inverse kinematics
                    const targetFootY = 0.1; // Ground level
                    const targetFootX = crankEndX + leg.seg1Len * 0.3;
                    
                    // Calculate knee position using law of cosines
                    const dx = targetFootX - crankEndX;
                    const dy = targetFootY - crankEndY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    let kneeX, kneeY;
                    if (dist < leg.seg1Len + leg.seg2Len && dist > Math.abs(leg.seg1Len - leg.seg2Len)) {
                        // Valid triangle - compute knee position
                        const a = leg.seg1Len;
                        const b = leg.seg2Len;
                        const c = dist;
                        
                        const cosA = (a * a + c * c - b * b) / (2 * a * c);
                        const angleToTarget = Math.atan2(dy, dx);
                        const kneeAngle = angleToTarget - Math.acos(Math.max(-1, Math.min(1, cosA)));
                        
                        kneeX = crankEndX + Math.cos(kneeAngle) * leg.seg1Len;
                        kneeY = crankEndY + Math.sin(kneeAngle) * leg.seg1Len;
                    } else {
                        // Stretched or folded - just extend downward
                        kneeX = crankEndX;
                        kneeY = crankEndY - leg.seg1Len;
                    }
                    
                    // Position upper segment
                    leg.seg1.position = new BABYLON.Vector3(
                        (crankEndX + kneeX) / 2,
                        (crankEndY + kneeY) / 2,
                        pivotZ
                    );
                    leg.seg1.rotation.z = Math.atan2(kneeY - crankEndY, kneeX - crankEndX) + Math.PI / 2;
                    
                    // Foot position
                    const footX = kneeX;
                    const footY = Math.max(0.08, kneeY - leg.seg2Len);
                    
                    // Position lower segment
                    leg.seg2.position = new BABYLON.Vector3(
                        (kneeX + footX) / 2,
                        (kneeY + footY) / 2,
                        pivotZ
                    );
                    leg.seg2.rotation.z = Math.atan2(footY - kneeY, footX - kneeX) + Math.PI / 2;
                    
                    // Position foot
                    leg.foot.position = new BABYLON.Vector3(footX, footY, pivotZ);
                    
                    minFootY = Math.min(minFootY, footY);
                    
                    // Check ground contact and generate forward force
                    if (footY <= 0.15) {
                        this.groundContacts++;
                        // Forward force based on leg movement
                        const footVelX = Math.cos(angle) * leg.crankLen * 0.05;
                        if (footVelX < 0) { // Pushing backward = moving forward
                            totalForwardForce += Math.abs(footVelX) * 0.5;
                        }
                    }
                }
                
                // Apply movement based on ground contacts
                if (this.groundContacts >= 2) {
                    this.bodyMesh.position.x -= totalForwardForce * 0.3;
                }
                
                // Adjust body height based on leg positions
                const targetBodyY = minFootY + 1.8;
                this.bodyMesh.position.y += (targetBodyY - this.bodyMesh.position.y) * 0.1;
                
                // Stability check
                if (this.bodyMesh.position.y < 0.5 || this.bodyMesh.position.y > 4) {
                    this.isStable = false;
                }
                
                // Small sway for realism
                this.bodyMesh.rotation.z = Math.sin(this.crankAngle * 2) * 0.05;
            }
            
            calculateFitness() {
                const distance = this.startX - this.bodyMesh.position.x; // Negative X is forward
                const stabilityBonus = this.isStable ? 1.5 : 0.2;
                const groundBonus = Math.min(this.groundContacts / 2, 1);
                
                this.fitness = Math.max(0, distance * stabilityBonus * (0.5 + groundBonus * 0.5));
                return this.fitness;
            }
            
            dispose() {
                this.meshes.forEach(mesh => mesh.dispose());
                this.meshes = [];
                this.legData = [];
            }
        }
        
        // ===================== GENETIC ALGORITHM =====================
        function initPopulation() {
            population = [];
            for (let i = 0; i < POPULATION_SIZE; i++) {
                population.push({
                    genome: createRandomGenome(),
                    fitness: 0
                });
            }
        }
        
        function crossover(parent1, parent2) {
            const child = [];
            const crossPoint = Math.floor(Math.random() * GENOME_LENGTH);
            
            for (let i = 0; i < GENOME_LENGTH; i++) {
                if (i < crossPoint) {
                    child.push(parent1[i]);
                } else {
                    child.push(parent2[i]);
                }
            }
            
            // Blend crossover for some genes
            if (Math.random() < 0.3) {
                const blendIdx = Math.floor(Math.random() * GENOME_LENGTH);
                child[blendIdx] = (parent1[blendIdx] + parent2[blendIdx]) / 2;
            }
            
            return child;
        }
        
        function mutate(genome) {
            const mutated = [...genome];
            const geneRanges = [
                GENE_RANGES.crankLength,
                GENE_RANGES.segment1Length,
                GENE_RANGES.segment2Length,
                GENE_RANGES.crankOffsetX,
                GENE_RANGES.crankOffsetY,
                GENE_RANGES.phase
            ];
            
            for (let i = 0; i < mutated.length; i++) {
                if (Math.random() < MUTATION_RATE) {
                    const rangeIdx = i % GENES_PER_LEG;
                    const range = geneRanges[rangeIdx];
                    const mutation = (Math.random() - 0.5) * (range.max - range.min) * 0.3;
                    mutated[i] = Math.max(range.min, Math.min(range.max, mutated[i] + mutation));
                }
            }
            
            return mutated;
        }
        
        function tournamentSelect(tournamentSize = 3) {
            let best = null;
            for (let i = 0; i < tournamentSize; i++) {
                const idx = Math.floor(Math.random() * population.length);
                if (!best || population[idx].fitness > best.fitness) {
                    best = population[idx];
                }
            }
            return best;
        }
        
        function createNextGeneration() {
            // Sort by fitness
            population.sort((a, b) => b.fitness - a.fitness);
            
            // Update stats
            bestFitness = population[0].fitness;
            bestGenome = [...population[0].genome];
            avgFitness = population.reduce((s, p) => s + p.fitness, 0) / population.length;
            
            fitnessHistory.push(bestFitness);
            if (fitnessHistory.length > 50) fitnessHistory.shift();
            
            // Create new population
            const newPopulation = [];
            
            // Elitism - keep best individuals
            for (let i = 0; i < ELITE_SIZE; i++) {
                newPopulation.push({
                    genome: [...population[i].genome],
                    fitness: 0
                });
            }
            
            // Fill rest with crossover and mutation
            while (newPopulation.length < POPULATION_SIZE) {
                const parent1 = tournamentSelect();
                const parent2 = tournamentSelect();
                let childGenome = crossover(parent1.genome, parent2.genome);
                childGenome = mutate(childGenome);
                
                newPopulation.push({
                    genome: childGenome,
                    fitness: 0
                });
            }
            
            population = newPopulation;
            generation++;
            
            updateDisplay();
        }
        
        // ===================== SIMULATION =====================
        function evaluateCreature(creature) {
            if (currentCreature) {
                currentCreature.dispose();
            }
            
            currentCreature = new Creature(creature.genome, scene);
            frameCount = 0;
        }
        
        function simulationStep() {
            if (!evaluatingPopulation || !currentCreature) return;
            
            currentCreature.update(1);
            frameCount++;
            
            // Update camera to follow
            camera.target.x = currentCreature.bodyMesh.position.x;
            
            if (frameCount >= CYCLE_DURATION) {
                // Evaluation complete
                population[currentCreatureIndex].fitness = currentCreature.calculateFitness();
                currentCreatureIndex++;
                
                if (currentCreatureIndex >= population.length) {
                    // All evaluated - create next generation
                    evaluatingPopulation = false;
                    currentCreatureIndex = 0;
                    createNextGeneration();
                    
                    if (isEvolving) {
                        startEvaluating();
                    }
                } else {
                    // Evaluate next
                    evaluateCreature(population[currentCreatureIndex]);
                }
                
                updateStatus();
            }
        }
        
        function startEvaluating() {
            evaluatingPopulation = true;
            currentCreatureIndex = 0;
            evaluateCreature(population[0]);
            updateStatus();
        }
        
        // ===================== UI CONTROLS =====================
        function toggleEvolution() {
            isEvolving = !isEvolving;
            document.getElementById('startBtn').textContent = isEvolving ? 'Pause' : 'Start';
            document.getElementById('startBtn').className = isEvolving ? 'btn-red' : 'btn-green';
            
            if (isEvolving && !evaluatingPopulation) {
                startEvaluating();
            }
            
            updateStatus();
        }
        
        function resetEvolution() {
            isEvolving = false;
            evaluatingPopulation = false;
            generation = 0;
            bestFitness = 0;
            bestGenome = null;
            avgFitness = 0;
            fitnessHistory = [];
            
            if (currentCreature) {
                currentCreature.dispose();
                currentCreature = null;
            }
            
            initPopulation();
            
            document.getElementById('startBtn').textContent = 'Start';
            document.getElementById('startBtn').className = 'btn-green';
            updateDisplay();
            updateStatus();
        }
        
        function stepGeneration() {
            if (!evaluatingPopulation) {
                isEvolving = false;
                startEvaluating();
            }
        }
        
        function showBest() {
            if (bestGenome) {
                isEvolving = false;
                evaluatingPopulation = false;
                document.getElementById('startBtn').textContent = 'Start';
                document.getElementById('startBtn').className = 'btn-green';
                
                if (currentCreature) {
                    currentCreature.dispose();
                }
                
                currentCreature = new Creature(bestGenome, scene);
                frameCount = 0;
                
                // Just replay the best
                const replayLoop = () => {
                    if (currentCreature && !isEvolving) {
                        currentCreature.update(1);
                        camera.target.x = currentCreature.bodyMesh.position.x;
                    }
                };
                
                scene.onBeforeRenderObservable.add(replayLoop);
                updateStatus();
            }
        }
        
        function updateDisplay() {
            document.getElementById('genDisplay').textContent = generation;
            document.getElementById('bestFitDisplay').textContent = bestFitness.toFixed(2);
            document.getElementById('avgFitDisplay').textContent = avgFitness.toFixed(2);
            document.getElementById('popDisplay').textContent = POPULATION_SIZE;
            
            if (bestGenome) {
                document.getElementById('genome-display').textContent = 
                    bestGenome.map(g => g.toFixed(2)).join(', ');
            }
            
            drawGraph();
        }
        
        function updateStatus() {
            let statusText = 'Status: ';
            if (isEvolving) {
                statusText += `Evaluating Gen ${generation}, Individual ${currentCreatureIndex + 1}/${POPULATION_SIZE}`;
            } else if (currentCreature && !evaluatingPopulation) {
                statusText += 'Replaying best individual';
            } else {
                statusText += 'Ready';
            }
            document.getElementById('status').textContent = statusText;
        }
        
        function drawGraph() {
            if (!graphCtx) return;
            
            const w = graphCanvas.width;
            const h = graphCanvas.height;
            
            graphCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            graphCtx.fillRect(0, 0, w, h);
            
            if (fitnessHistory.length < 2) return;
            
            const maxFit = Math.max(...fitnessHistory, 1);
            
            graphCtx.strokeStyle = '#4fc3f7';
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();
            
            for (let i = 0; i < fitnessHistory.length; i++) {
                const x = (i / (fitnessHistory.length - 1)) * w;
                const y = h - (fitnessHistory[i] / maxFit) * h * 0.9;
                
                if (i === 0) graphCtx.moveTo(x, y);
                else graphCtx.lineTo(x, y);
            }
            graphCtx.stroke();
        }
        
        // ===================== BABYLON.JS SCENE =====================
        function createScene() {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.05, 0.08, 0.15, 1);
            
            // Camera
            camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 3, 15, 
                new BABYLON.Vector3(0, 1, 0), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 5;
            camera.upperRadiusLimit = 50;
            
            // Lighting
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;
            
            const dirLight = new BABYLON.DirectionalLight("dirLight", 
                new BABYLON.Vector3(-1, -2, -1), scene);
            dirLight.intensity = 0.5;
            
            // Ground
            ground = BABYLON.MeshBuilder.CreateGround("ground", {
                width: 200,
                height: 20
            }, scene);
            
            const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.15, 0.2, 0.15);
            groundMat.specularColor = new BABYLON.Color3(0, 0, 0);
            ground.material = groundMat;
            
            // Grid lines on ground
            for (let i = -100; i <= 100; i += 5) {
                const line = BABYLON.MeshBuilder.CreateLines("gridLine" + i, {
                    points: [
                        new BABYLON.Vector3(i, 0.01, -10),
                        new BABYLON.Vector3(i, 0.01, 10)
                    ]
                }, scene);
                line.color = new BABYLON.Color3(0.2, 0.3, 0.2);
            }
            
            // Start/finish markers
            const startMarker = BABYLON.MeshBuilder.CreateBox("start", {
                width: 0.1, height: 3, depth: 10
            }, scene);
            startMarker.position = new BABYLON.Vector3(0, 1.5, 0);
            const startMat = new BABYLON.StandardMaterial("startMat", scene);
            startMat.diffuseColor = new BABYLON.Color3(0, 1, 0);
            startMat.emissiveColor = new BABYLON.Color3(0, 0.3, 0);
            startMarker.material = startMat;
            
            return scene;
        }
        
        // ===================== INITIALIZATION =====================
        function init() {
            graphCanvas = document.getElementById('fitnessGraph');
            graphCanvas.width = graphCanvas.offsetWidth * 2;
            graphCanvas.height = graphCanvas.offsetHeight * 2;
            graphCtx = graphCanvas.getContext('2d');
            
            // Setup control listeners
            document.getElementById('popSize').addEventListener('input', function() {
                POPULATION_SIZE = parseInt(this.value);
                document.getElementById('popVal').textContent = POPULATION_SIZE;
            });
            
            document.getElementById('mutRate').addEventListener('input', function() {
                MUTATION_RATE = parseFloat(this.value);
                document.getElementById('mutVal').textContent = MUTATION_RATE.toFixed(2);
            });
            
            document.getElementById('cycleDur').addEventListener('input', function() {
                CYCLE_DURATION = parseInt(this.value);
                document.getElementById('cycleVal').textContent = CYCLE_DURATION;
            });
            
            document.getElementById('eliteSize').addEventListener('input', function() {
                ELITE_SIZE = parseInt(this.value);
                document.getElementById('eliteVal').textContent = ELITE_SIZE;
            });
            
            createScene();
            initPopulation();
            
            engine.runRenderLoop(() => {
                if (evaluatingPopulation) {
                    simulationStep();
                }
                scene.render();
            });
            
            window.addEventListener('resize', () => engine.resize());
            
            updateDisplay();
            updateStatus();
        }
        
        init();
    </script>
</body>
</html>