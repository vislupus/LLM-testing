<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Babylon.js GA Strandbeest-ish Walkers (Single File)</title>
  <style>
    html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; background: #0b0f14; color: #e8eef7; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #wrap { width: 100%; height: 100%; position: relative; }
    #renderCanvas { width: 100%; height: 100%; touch-action: none; display: block; }

    /* HUD */
    #hud {
      position: absolute; left: 12px; top: 12px;
      width: min(420px, calc(100% - 24px));
      background: rgba(8, 12, 18, 0.78);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
      padding: 12px 12px 10px;
      user-select: none;
    }
    #hud h1 { font-size: 14px; margin: 0 0 8px; font-weight: 700; letter-spacing: 0.2px; color: #d6e6ff; }
    .row { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; margin: 8px 0; }
    .row label { font-size: 12px; opacity: 0.9; }
    .row .val { font-variant-numeric: tabular-nums; font-size: 12px; opacity: 0.9; }
    input[type="range"] { width: 100%; }
    .buttons { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }
    button {
      appearance: none; border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: #e8eef7; padding: 8px 10px; border-radius: 10px;
      font-size: 12px; cursor: pointer;
    }
    button:hover { background: rgba(255,255,255,0.10); }
    button.primary { background: rgba(80,160,255,0.20); border-color: rgba(80,160,255,0.40); }
    button.danger  { background: rgba(255,100,100,0.14); border-color: rgba(255,100,100,0.35); }

    .stats {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.10);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px 10px;
      font-size: 12px;
    }
    .stats div { opacity: 0.92; }
    .stats b { font-variant-numeric: tabular-nums; opacity: 1.0; }

    .toggles { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 8px; }
    .toggle {
      display: inline-flex; align-items: center; gap: 6px;
      font-size: 12px; opacity: 0.95;
      padding: 6px 8px; border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
    }
    .toggle input { transform: translateY(1px); }

    #hint {
      margin-top: 8px;
      font-size: 11px;
      opacity: 0.75;
      line-height: 1.25;
    }

    /* Small screens: move HUD down a bit */
    @media (max-width: 520px) {
      #hud { left: 8px; top: 8px; padding: 10px; border-radius: 10px; }
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="renderCanvas"></canvas>

    <div id="hud">
      <h1>GA Strandbeest-ish Walkers (Babylon.js, single file)</h1>

      <div class="row">
        <label>Population size</label>
        <div class="val"><span id="popVal">48</span></div>
      </div>
      <input id="pop" type="range" min="10" max="200" step="1" value="48" />

      <div class="row">
        <label>Mutation rate</label>
        <div class="val"><span id="mutVal">0.12</span></div>
      </div>
      <input id="mut" type="range" min="0" max="0.5" step="0.01" value="0.12" />

      <div class="row">
        <label>Cycle duration (s)</label>
        <div class="val"><span id="cycVal">1.40</span></div>
      </div>
      <input id="cyc" type="range" min="0.5" max="3.0" step="0.05" value="1.40" />

      <div class="row">
        <label>Evaluation time (s)</label>
        <div class="val"><span id="evalVal">4.00</span></div>
      </div>
      <input id="eval" type="range" min="1.5" max="10.0" step="0.25" value="4.00" />

      <div class="toggles">
        <label class="toggle"><input id="highlight" type="checkbox" checked /> Highlight best</label>
        <label class="toggle"><input id="loopReplay" type="checkbox" checked /> Loop replay</label>
        <label class="toggle"><input id="followCam" type="checkbox" checked /> Camera follow</label>
      </div>

      <div class="buttons">
        <button id="start" class="primary">Start evolution</button>
        <button id="step">Step 1 generation</button>
        <button id="replay">Replay best</button>
        <button id="reset" class="danger">Reset population</button>
      </div>

      <div class="stats">
        <div>Generation: <b id="gen">0</b></div>
        <div>Best fitness: <b id="bestFit">—</b></div>
        <div>Best distance: <b id="bestDist">—</b></div>
        <div>Stability penalty: <b id="bestPen">—</b></div>
      </div>

      <div id="hint">
        Tip: Drag to orbit, scroll to zoom. Evolution evaluates offscreen; only the current best is drawn.
        Fitness ≈ forward distance − stability penalties (falls, extreme COM height, foot scraping).
      </div>
    </div>
  </div>

  <!-- Babylon.js from CDN -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>

  <script>
  (() => {
    "use strict";

    // =========================
    // Utility / Math
    // =========================
    const TAU = Math.PI * 2;

    function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
    function lerp(a, b, t) { return a + (b - a) * t; }

    // Gaussian noise (Box–Muller)
    function randn() {
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(TAU * v);
    }

    // Quaternion that rotates "from" unit vector to "to" unit vector
    function quatFromTo(from, to) {
      const v0 = from.normalize();
      const v1 = to.normalize();
      const d = BABYLON.Vector3.Dot(v0, v1);

      if (d > 0.999999) return BABYLON.Quaternion.Identity();

      if (d < -0.999999) {
        // opposite; pick a stable axis
        let axis = BABYLON.Vector3.Cross(BABYLON.Axis.X, v0);
        if (axis.lengthSquared() < 1e-6) axis = BABYLON.Vector3.Cross(BABYLON.Axis.Y, v0);
        axis.normalize();
        return BABYLON.Quaternion.RotationAxis(axis, Math.PI);
      }

      const c = BABYLON.Vector3.Cross(v0, v1);
      const s = Math.sqrt((1 + d) * 2);
      const invs = 1 / s;
      return new BABYLON.Quaternion(c.x * invs, c.y * invs, c.z * invs, s * 0.5);
    }

    // Forward kinematics for a 2-segment planar leg in x-y (y up).
    // Angle convention: angle=0 points straight DOWN. Positive swings forward (+x).
    function fk2(L1, L2, hipAngle, kneeAngle) {
      const s1 = Math.sin(hipAngle), c1 = Math.cos(hipAngle);
      const s2 = Math.sin(hipAngle + kneeAngle), c2 = Math.cos(hipAngle + kneeAngle);

      // Direction for angle=0 is down => (x,y) = (0,-1)
      const knee = { x: L1 * s1, y: -L1 * c1 };
      const foot = { x: knee.x + L2 * s2, y: knee.y - L2 * c2 };
      return { knee, foot };
    }

    // =========================
    // Genome definition
    // =========================
    // 4 legs: FrontLeft, FrontRight, BackLeft, BackRight (all in one plane; z just separates visually)
    const LEG_COUNT = 4;
    const GENES_PER_LEG = 10;

    // Gene layout per leg:
    // 0 hipOffsetX  [-0.75..0.75]
    // 1 hipOffsetY  [-0.25..0.15]
    // 2 upperLen    [0.25..1.20]
    // 3 lowerLen    [0.25..1.20]
    // 4 hipAmp      [0.00..1.60]
    // 5 hipBias     [-1.20..1.20]
    // 6 kneeAmp     [0.00..2.20]
    // 7 kneeBias    [-2.80..0.25]
    // 8 kneePhase   [0..TAU]
    // 9 phase       [0..TAU]
    const GENE_RANGES = [
      [-0.75, 0.75],
      [-0.25, 0.15],
      [ 0.25, 1.20],
      [ 0.25, 1.20],
      [ 0.00, 1.60],
      [-1.20, 1.20],
      [ 0.00, 2.20],
      [-2.80, 0.25],
      [ 0.00, TAU ],
      [ 0.00, TAU ],
    ];

    function randomGenome() {
      const genes = new Float32Array(LEG_COUNT * GENES_PER_LEG);
      for (let i = 0; i < genes.length; i++) {
        const r = GENE_RANGES[i % GENES_PER_LEG];
        genes[i] = lerp(r[0], r[1], Math.random());
      }
      return genes;
    }

    function cloneGenome(g) {
      const c = new Float32Array(g.length);
      c.set(g);
      return c;
    }

    function mutateGenome(genes, mutationRate) {
      // Add gaussian noise scaled by range; clamp to legal range.
      for (let i = 0; i < genes.length; i++) {
        if (Math.random() < mutationRate) {
          const r = GENE_RANGES[i % GENES_PER_LEG];
          const span = (r[1] - r[0]);
          const sigma = span * 0.08;        // tweakable
          genes[i] = clamp(genes[i] + randn() * sigma, r[0], r[1]);
        }
      }
    }

    function crossover(a, b) {
      // One-point crossover across the full genome
      const n = a.length;
      const cut = 1 + (Math.random() * (n - 2) | 0);
      const child = new Float32Array(n);
      for (let i = 0; i < n; i++) child[i] = (i < cut) ? a[i] : b[i];
      return child;
    }

    function decodeGenome(genes) {
      // Produce a phenotype structure convenient for simulation/rendering
      const legs = [];
      for (let li = 0; li < LEG_COUNT; li++) {
        const base = li * GENES_PER_LEG;
        legs.push({
          hipOffsetX: genes[base + 0],
          hipOffsetY: genes[base + 1],
          L1: genes[base + 2],
          L2: genes[base + 3],
          hipAmp: genes[base + 4],
          hipBias: genes[base + 5],
          kneeAmp: genes[base + 6],
          kneeBias: genes[base + 7],
          kneePhase: genes[base + 8],
          phase: genes[base + 9],
          // Visual side offset (not simulated in z)
          z: (li % 2 === 0) ? 0.28 : -0.28, // 0: FL,1:FR,2:BL,3:BR => left/right alternating
        });
      }
      return { legs };
    }

    // =========================
    // Kinematic "physics" simulation
    // =========================
    function makeSimState() {
      return {
        x: 0,
        y: 1.05,
        // per-leg contact memory
        legs: Array.from({ length: LEG_COUNT }, () => ({ planted: false, plantX: 0 })),
        unstableFrames: 0,
        scrapeFrames: 0,
        corrSum: 0,
        ySum: 0,
        steps: 0,
      };
    }

    function stepSim(state, phenotype, t, dt, cycleDuration) {
      // Constraint-ish kinematics:
      // - Legs have driven joint angles (sinusoid).
      // - When "stance", foot is treated as planted on ground (x fixed, y=0).
      // - We shift body (x,y) to satisfy planted foot constraints, averaging all stance legs.
      // This lets GA discover gaits that create net forward motion.

      const w = TAU / Math.max(0.001, cycleDuration);
      let errX = 0, errY = 0, c = 0;

      // A little "gravity" if no feet planted
      let anyPlanted = false;

      for (let i = 0; i < phenotype.legs.length; i++) {
        const leg = phenotype.legs[i];
        const ph = w * t + leg.phase;

        // stance half-cycle
        const stance = (Math.sin(ph) < 0);

        // driven angles
        const hipA  = leg.hipBias + leg.hipAmp  * Math.sin(ph);
        const kneeA = leg.kneeBias + leg.kneeAmp * Math.sin(ph + leg.kneePhase);

        const hipX = state.x + leg.hipOffsetX;
        const hipY = state.y + leg.hipOffsetY;

        const { foot } = fk2(leg.L1, leg.L2, hipA, kneeA);
        const footX = hipX + foot.x;
        const footY = hipY + foot.y;

        if (stance) {
          anyPlanted = true;
          if (!state.legs[i].planted) {
            state.legs[i].planted = true;
            state.legs[i].plantX = footX; // "touchdown" x
          }
          errX += (state.legs[i].plantX - footX);
          errY += (0 - footY);
          c++;
        } else {
          state.legs[i].planted = false;

          // Foot scraping penalty during swing
          if (footY < -0.02) state.scrapeFrames++;
        }
      }

      let corrX = 0, corrY = 0;
      if (c > 0) {
        // Apply averaged corrections (a soft constraint solver)
        corrX = (errX / c) * 0.70;
        corrY = (errY / c) * 0.70;

        // Dampen correction a bit to avoid teleporting/jitter
        state.x += corrX;
        state.y += corrY;
      } else {
        // airborne: fall a bit
        state.y -= 0.90 * dt;
      }

      // Keep above ground a tiny bit (body y is COM-ish, not actual collider)
      if (!anyPlanted) state.y = Math.max(state.y, 0.18);

      // Stability penalties
      if (state.y < 0.28) state.unstableFrames += 3; // "fell"
      if (state.y < 0.40) state.unstableFrames += 1; // low clearance
      if (state.y > 2.60) state.unstableFrames += 1; // wildly tall / jitter

      state.corrSum += Math.abs(corrX) + 0.35 * Math.abs(corrY);
      state.ySum += state.y;
      state.steps++;
    }

    function evaluateFitness(genes, simParams) {
      const pheno = decodeGenome(genes);
      const dt = 1 / 60;
      const steps = Math.max(1, Math.floor(simParams.evalTime / dt));
      const state = makeSimState();

      for (let s = 0; s < steps; s++) {
        const t = s * dt;
        stepSim(state, pheno, t, dt, simParams.cycleDuration);
      }

      const dist = state.x;
      const avgY = state.ySum / Math.max(1, state.steps);

      // Fitness: forward distance minus penalties
      const stabilityPenalty =
        (state.unstableFrames * 0.015) +
        (state.scrapeFrames * 0.004) +
        (state.corrSum * 0.0025) +
        (Math.abs(avgY - 1.05) * 0.25);

      let fit = dist - stabilityPenalty;

      // discourage backwards movers
      if (dist < 0) fit -= 0.5 + Math.abs(dist) * 0.5;

      return {
        fitness: fit,
        distance: dist,
        penalty: stabilityPenalty
      };
    }

    // =========================
    // Genetic Algorithm
    // =========================
    class GA {
      constructor() {
        this.population = [];
        this.generation = 0;
        this.best = null;
      }

      init(popSize) {
        this.population = [];
        for (let i = 0; i < popSize; i++) {
          this.population.push({ genes: randomGenome(), fitness: null, distance: 0, penalty: 0 });
        }
        this.generation = 0;
        this.best = null;
      }

      evaluateAll(simParams) {
        for (const ind of this.population) {
          const r = evaluateFitness(ind.genes, simParams);
          ind.fitness = r.fitness;
          ind.distance = r.distance;
          ind.penalty = r.penalty;
        }
        this.population.sort((a, b) => b.fitness - a.fitness);
        this.best = this.population[0];
      }

      tournamentSelect(k = 3) {
        let best = null;
        for (let i = 0; i < k; i++) {
          const cand = this.population[(Math.random() * this.population.length) | 0];
          if (!best || cand.fitness > best.fitness) best = cand;
        }
        return best;
      }

      nextGeneration(params) {
        // Ensure evaluated
        this.evaluateAll(params.sim);

        const popSize = params.popSize;
        const eliteCount = Math.max(1, Math.floor(popSize * 0.05)); // 5% elitism
        const newPop = [];

        for (let i = 0; i < eliteCount && i < this.population.length; i++) {
          newPop.push({
            genes: cloneGenome(this.population[i].genes),
            fitness: null,
            distance: 0,
            penalty: 0
          });
        }

        while (newPop.length < popSize) {
          const pA = this.tournamentSelect(3);
          const pB = this.tournamentSelect(3);
          const childGenes = crossover(pA.genes, pB.genes);
          mutateGenome(childGenes, params.mutationRate);
          newPop.push({ genes: childGenes, fitness: null, distance: 0, penalty: 0 });
        }

        this.population = newPop;
        this.generation++;
      }
    }

    // =========================
    // Babylon.js rendering rig
    // =========================
    class CreatureRig {
      constructor(scene) {
        this.scene = scene;
        this.root = new BABYLON.TransformNode("creatureRoot", scene);

        // Materials
        this.matBody = new BABYLON.StandardMaterial("matBody", scene);
        this.matBody.diffuseColor = new BABYLON.Color3(0.25, 0.65, 0.95);
        this.matBody.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

        this.matLeg = new BABYLON.StandardMaterial("matLeg", scene);
        this.matLeg.diffuseColor = new BABYLON.Color3(0.85, 0.85, 0.92);
        this.matLeg.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

        this.matJoint = new BABYLON.StandardMaterial("matJoint", scene);
        this.matJoint.diffuseColor = new BABYLON.Color3(0.98, 0.75, 0.25);
        this.matJoint.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);

        this.matBestGlow = new BABYLON.StandardMaterial("matBestGlow", scene);
        this.matBestGlow.diffuseColor = new BABYLON.Color3(0.30, 0.95, 0.55);
        this.matBestGlow.emissiveColor = new BABYLON.Color3(0.15, 0.55, 0.25);
        this.matBestGlow.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

        // Body
        this.body = BABYLON.MeshBuilder.CreateBox("body", { width: 1.35, height: 0.32, depth: 0.55 }, scene);
        this.body.parent = this.root;
        this.body.material = this.matBody;

        // Legs: 2 cylinders + 3 joints each
        this.legs = [];
        for (let i = 0; i < LEG_COUNT; i++) {
          const upper = BABYLON.MeshBuilder.CreateCylinder(`upper_${i}`, { height: 1, diameter: 0.09 }, scene);
          const lower = BABYLON.MeshBuilder.CreateCylinder(`lower_${i}`, { height: 1, diameter: 0.085 }, scene);
          upper.parent = this.root;
          lower.parent = this.root;
          upper.material = this.matLeg;
          lower.material = this.matLeg;

          const jHip  = BABYLON.MeshBuilder.CreateSphere(`jHip_${i}`, { diameter: 0.11 }, scene);
          const jKnee = BABYLON.MeshBuilder.CreateSphere(`jKnee_${i}`, { diameter: 0.10 }, scene);
          const jFoot = BABYLON.MeshBuilder.CreateSphere(`jFoot_${i}`, { diameter: 0.09 }, scene);
          jHip.parent = this.root; jKnee.parent = this.root; jFoot.parent = this.root;
          jHip.material = this.matJoint; jKnee.material = this.matJoint; jFoot.material = this.matJoint;

          this.legs.push({ upper, lower, jHip, jKnee, jFoot });
        }

        this.highlighted = true;
      }

      setHighlight(on) {
        this.highlighted = on;
        this.body.material = on ? this.matBestGlow : this.matBody;
      }

      updateFromState(phenotype, state, t, cycleDuration) {
        const w = TAU / Math.max(0.001, cycleDuration);

        // Place body
        this.body.position.set(state.x, state.y, 0);

        // Update each leg mesh from FK at the current time (same angles as sim)
        for (let i = 0; i < phenotype.legs.length; i++) {
          const leg = phenotype.legs[i];
          const ph = w * t + leg.phase;
          const hipA  = leg.hipBias + leg.hipAmp  * Math.sin(ph);
          const kneeA = leg.kneeBias + leg.kneeAmp * Math.sin(ph + leg.kneePhase);

          const hip = new BABYLON.Vector3(state.x + leg.hipOffsetX, state.y + leg.hipOffsetY, leg.z);
          const { knee, foot } = fk2(leg.L1, leg.L2, hipA, kneeA);
          const kneeP = new BABYLON.Vector3(hip.x + knee.x, hip.y + knee.y, leg.z);
          const footP = new BABYLON.Vector3(hip.x + foot.x, hip.y + foot.y, leg.z);

          // Clamp foot visually to ground if planted (to match the "stance" illusion)
          const planted = state.legs[i]?.planted;
          if (planted) {
            footP.x = state.legs[i].plantX;
            footP.y = 0;
          }

          // Joints
          const rig = this.legs[i];
          rig.jHip.position.copyFrom(hip);
          rig.jKnee.position.copyFrom(kneeP);
          rig.jFoot.position.copyFrom(footP);

          // Cylinders: align along segment vector (Y axis -> segment direction)
          this.alignCylinder(rig.upper, hip, kneeP, 0.09);
          this.alignCylinder(rig.lower, kneeP, footP, 0.085);
        }
      }

      alignCylinder(mesh, p1, p2, diameter) {
        const v = p2.subtract(p1);
        const len = Math.max(0.001, v.length());
        const mid = p1.add(p2).scale(0.5);

        mesh.position.copyFrom(mid);
        mesh.scaling.set(diameter / 0.09, len, diameter / 0.09); // base diameter ~0.09

        const dir = v.scale(1 / len);
        mesh.rotationQuaternion = quatFromTo(BABYLON.Axis.Y, dir);
      }
    }

    // =========================
    // Scene setup
    // =========================
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.04, 0.06, 0.09, 1.0);

    const camera = new BABYLON.ArcRotateCamera("cam",
      Math.PI * 0.15, Math.PI * 0.38, 8.5,
      new BABYLON.Vector3(0, 0.9, 0), scene
    );
    camera.attachControl(canvas, true);
    camera.wheelDeltaPercentage = 0.01;
    camera.lowerRadiusLimit = 2.8;
    camera.upperRadiusLimit = 30;

    const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
    hemi.intensity = 0.9;

    const dir = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-0.4, -1, 0.15), scene);
    dir.position = new BABYLON.Vector3(8, 12, -6);
    dir.intensity = 0.65;

    // Ground
    const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 200, height: 30, subdivisions: 2 }, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.12, 0.14, 0.17);
    groundMat.specularColor = new BABYLON.Color3(0.0, 0.0, 0.0);
    ground.material = groundMat;

    // Simple runway stripes
    const stripes = BABYLON.MeshBuilder.CreatePlane("stripes", { width: 200, height: 2.2, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
    stripes.rotation.x = Math.PI / 2;
    stripes.position.y = 0.001;
    const stripesMat = new BABYLON.StandardMaterial("stripesMat", scene);
    stripesMat.diffuseColor = new BABYLON.Color3(0.07, 0.08, 0.10);
    stripesMat.emissiveColor = new BABYLON.Color3(0.02, 0.02, 0.03);
    stripes.material = stripesMat;

    // Creature rig
    const rig = new CreatureRig(scene);

    // =========================
    // UI + App state
    // =========================
    const ui = {
      pop: document.getElementById("pop"),
      mut: document.getElementById("mut"),
      cyc: document.getElementById("cyc"),
      eval: document.getElementById("eval"),
      popVal: document.getElementById("popVal"),
      mutVal: document.getElementById("mutVal"),
      cycVal: document.getElementById("cycVal"),
      evalVal: document.getElementById("evalVal"),
      start: document.getElementById("start"),
      step: document.getElementById("step"),
      replay: document.getElementById("replay"),
      reset: document.getElementById("reset"),
      gen: document.getElementById("gen"),
      bestFit: document.getElementById("bestFit"),
      bestDist: document.getElementById("bestDist"),
      bestPen: document.getElementById("bestPen"),
      highlight: document.getElementById("highlight"),
      loopReplay: document.getElementById("loopReplay"),
      followCam: document.getElementById("followCam"),
    };

    const params = {
      popSize: parseInt(ui.pop.value, 10),
      mutationRate: parseFloat(ui.mut.value),
      sim: {
        cycleDuration: parseFloat(ui.cyc.value),
        evalTime: parseFloat(ui.eval.value),
      }
    };

    function syncUI() {
      ui.popVal.textContent = params.popSize.toString();
      ui.mutVal.textContent = params.mutationRate.toFixed(2);
      ui.cycVal.textContent = params.sim.cycleDuration.toFixed(2);
      ui.evalVal.textContent = params.sim.evalTime.toFixed(2);
    }
    syncUI();

    const ga = new GA();
    ga.init(params.popSize);

    let evolving = false;

    // Current best for rendering
    let bestGenes = cloneGenome(ga.population[0].genes);
    let bestPhenotype = decodeGenome(bestGenes);

    // Replay player state
    let playing = true;           // default: animate something
    let playLoop = ui.loopReplay.checked;
    let playTime = 0;
    let playState = makeSimState();
    let accumulator = 0;
    const fixedDt = 1 / 60;

    function setBestFromGA() {
      if (!ga.best) return;
      bestGenes = cloneGenome(ga.best.genes);
      bestPhenotype = decodeGenome(bestGenes);

      ui.gen.textContent = ga.generation.toString();
      ui.bestFit.textContent = ga.best.fitness.toFixed(3);
      ui.bestDist.textContent = ga.best.distance.toFixed(3);
      ui.bestPen.textContent = ga.best.penalty.toFixed(3);
    }

    function resetReplay() {
      playTime = 0;
      playState = makeSimState();
      accumulator = 0;
      playing = true;
      playLoop = ui.loopReplay.checked;
    }

    function restartPopulation() {
      ga.init(params.popSize);
      // Evaluate once so "best" isn't undefined
      ga.evaluateAll(params.sim);
      setBestFromGA();
      resetReplay();
    }

    // Start with one evaluation
    ga.evaluateAll(params.sim);
    setBestFromGA();

    // =========================
    // UI events
    // =========================
    ui.pop.addEventListener("input", () => {
      params.popSize = parseInt(ui.pop.value, 10);
      syncUI();
    });
    ui.pop.addEventListener("change", () => {
      // Changing population size restarts for sanity
      restartPopulation();
    });

    ui.mut.addEventListener("input", () => {
      params.mutationRate = parseFloat(ui.mut.value);
      syncUI();
    });

    ui.cyc.addEventListener("input", () => {
      params.sim.cycleDuration = parseFloat(ui.cyc.value);
      syncUI();
    });
    ui.cyc.addEventListener("change", () => {
      // Changing gait period changes fitness landscape; reevaluate
      ga.evaluateAll(params.sim);
      setBestFromGA();
      resetReplay();
    });

    ui.eval.addEventListener("input", () => {
      params.sim.evalTime = parseFloat(ui.eval.value);
      syncUI();
    });
    ui.eval.addEventListener("change", () => {
      ga.evaluateAll(params.sim);
      setBestFromGA();
      resetReplay();
    });

    ui.highlight.addEventListener("change", () => {
      rig.setHighlight(ui.highlight.checked);
    });
    rig.setHighlight(ui.highlight.checked);

    ui.loopReplay.addEventListener("change", () => {
      playLoop = ui.loopReplay.checked;
    });

    ui.start.addEventListener("click", () => {
      evolving = !evolving;
      ui.start.textContent = evolving ? "Pause evolution" : "Start evolution";
      ui.start.classList.toggle("primary", !evolving);
      // keep replay running even while evolving
    });

    ui.step.addEventListener("click", () => {
      ga.nextGeneration({ popSize: params.popSize, mutationRate: params.mutationRate, sim: params.sim });
      // after advancing, ga.best refers to previous evaluated pop (before new), so evaluate now:
      ga.evaluateAll(params.sim);
      setBestFromGA();
      resetReplay();
    });

    ui.replay.addEventListener("click", () => {
      // Evaluate first to ensure current best matches the latest parameters
      ga.evaluateAll(params.sim);
      setBestFromGA();
      resetReplay();
    });

    ui.reset.addEventListener("click", () => {
      evolving = false;
      ui.start.textContent = "Start evolution";
      restartPopulation();
    });

    // =========================
    // Render loop + evolution ticking
    // =========================
    let genBudgetAcc = 0; // a little throttling so we don't run 60 generations/sec by accident
    engine.runRenderLoop(() => {
      const dtMs = engine.getDeltaTime();
      const dt = dtMs / 1000;

      // Evolve at a controlled pace (about ~8 gens/sec by default)
      if (evolving) {
        genBudgetAcc += dt;
        const gensPerSecond = 8;
        const genInterval = 1 / gensPerSecond;
        while (genBudgetAcc >= genInterval) {
          genBudgetAcc -= genInterval;

          ga.nextGeneration({ popSize: params.popSize, mutationRate: params.mutationRate, sim: params.sim });
          // After producing new pop, evaluate to find new best
          ga.evaluateAll(params.sim);
          setBestFromGA();
          // Don't forcibly reset replay every generation; it looks nicer to keep motion continuous
          // but we do want to snap to the new best occasionally:
          resetReplay();
        }
      }

      // Sim playback (fixed timestep)
      if (playing) {
        accumulator += dt;
        const stopAt = params.sim.evalTime;

        while (accumulator >= fixedDt) {
          stepSim(playState, bestPhenotype, playTime, fixedDt, params.sim.cycleDuration);
          playTime += fixedDt;
          accumulator -= fixedDt;

          if (playTime >= stopAt) {
            if (playLoop) {
              resetReplay();
              break;
            } else {
              playing = false;
              break;
            }
          }
        }
      }

      // Update visuals from current sim state
      rig.updateFromState(bestPhenotype, playState, playTime, params.sim.cycleDuration);

      // Camera follow
      if (ui.followCam.checked) {
        const target = camera.target.clone();
        target.x = lerp(target.x, playState.x, 0.10);
        target.y = lerp(target.y, 0.85, 0.05);
        camera.target.copyFrom(target);
      }

      scene.render();
    });

    window.addEventListener("resize", () => engine.resize());

  })();
  </script>
</body>
</html>
