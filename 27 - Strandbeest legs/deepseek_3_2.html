<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genetic Algorithm: Evolving Strandbeest-Style Walkers</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #0d1b2a 0%, #1b263b 100%);
            color: #e0e1dd;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
            background: rgba(13, 27, 42, 0.8);
            border-radius: 12px;
            border: 1px solid rgba(64, 156, 255, 0.2);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #7bc8ff;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .subtitle {
            color: #a8d2ff;
            font-size: 1.1rem;
            max-width: 1000px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }

        .simulation-panel {
            flex: 3;
            min-width: 300px;
            height: 700px;
            position: relative;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
            outline: none;
        }

        .controls-panel {
            flex: 1;
            min-width: 300px;
            background: rgba(23, 42, 58, 0.8);
            border-radius: 12px;
            padding: 25px;
            border: 1px solid rgba(64, 156, 255, 0.15);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: 700px;
            overflow-y: auto;
        }

        .panel-section {
            background: rgba(33, 52, 73, 0.6);
            border-radius: 10px;
            padding: 18px;
            border-left: 4px solid #ff7b00;
        }

        .ga-section {
            border-left-color: #2ed573;
        }

        .visualization-section {
            border-left-color: #409cff;
        }

        h2 {
            color: #7bc8ff;
            font-size: 1.4rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        h2 i {
            font-size: 1.2rem;
        }

        .control-group {
            margin-bottom: 18px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #a8d2ff;
            font-weight: 500;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        input[type="range"] {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            background: rgba(64, 156, 255, 0.2);
            border-radius: 4px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #409cff;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(64, 156, 255, 0.8);
        }

        .value-display {
            min-width: 60px;
            text-align: center;
            background: rgba(13, 27, 42, 0.6);
            padding: 6px 10px;
            border-radius: 6px;
            color: #a8d2ff;
            font-weight: 600;
            border: 1px solid rgba(64, 156, 255, 0.2);
        }

        button {
            background: linear-gradient(to right, #ff7b00, #ff5500);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
        }

        button:hover {
            background: linear-gradient(to right, #ff5500, #ff3d00);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
        }

        button:active {
            transform: translateY(0);
        }

        .ga-button {
            background: linear-gradient(to right, #2ed573, #1fab58);
        }

        .ga-button:hover {
            background: linear-gradient(to right, #1fab58, #18944c);
        }

        .button-row {
            display: flex;
            gap: 10px;
        }

        .button-row button {
            flex: 1;
        }

        .stats-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 10px;
        }

        .stat-item {
            background: rgba(13, 27, 42, 0.6);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(64, 156, 255, 0.1);
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #7bc8ff;
            margin: 8px 0 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #a8d2ff;
        }

        .best-individual {
            background: rgba(46, 213, 115, 0.1);
            border: 1px solid rgba(46, 213, 115, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .best-individual h3 {
            color: #2ed573;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .generation-info {
            font-size: 0.9rem;
            color: #a8d2ff;
            line-height: 1.5;
        }

        .keyboard-hint {
            font-size: 0.85rem;
            color: #8ab4f8;
            margin-top: 8px;
            text-align: center;
            font-style: italic;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: #8ab4f8;
            font-size: 0.9rem;
            background: rgba(13, 27, 42, 0.8);
            border-radius: 12px;
            border: 1px solid rgba(64, 156, 255, 0.2);
        }

        @media (max-width: 1200px) {
            .content {
                flex-direction: column;
            }
            
            .simulation-panel, .controls-panel {
                width: 100%;
            }
        }

        @media (max-width: 600px) {
            .controls-panel {
                padding: 15px;
            }
            
            .stats-panel {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Genetic Algorithm: Evolving Strandbeest-Style Walkers</h1>
            <p class="subtitle">Watch as a genetic algorithm evolves 3D walking mechanisms inspired by Theo Jansen's Strandbeests. Each creature's leg mechanism is defined by a genome encoding joint lengths, pivot positions, and motion parameters. The fittest individuals (those that walk farthest) are selected to breed the next generation.</p>
        </header>
        
        <div class="content">
            <div class="simulation-panel">
                <canvas id="renderCanvas"></canvas>
            </div>
            
            <div class="controls-panel">
                <div class="panel-section">
                    <h2>Simulation Controls</h2>
                    
                    <div class="control-group">
                        <label for="sim-speed">Simulation Speed: <span id="sim-speed-value">1.0</span>x</label>
                        <div class="slider-container">
                            <input type="range" id="sim-speed" min="0.1" max="3" value="1.0" step="0.1">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label for="cycle-duration">Cycle Duration: <span id="cycle-duration-value">5.0</span>s</label>
                        <div class="slider-container">
                            <input type="range" id="cycle-duration" min="1" max="10" value="5.0" step="0.5">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <div class="button-row">
                            <button id="play-pause">
                                <span id="play-icon">â–¶</span>
                                <span id="play-text">Pause</span>
                            </button>
                            <button id="reset-button">Reset</button>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Camera View</label>
                        <div class="button-row">
                            <button id="view-side">Side View</button>
                            <button id="view-top">Top View</button>
                            <button id="view-follow">Follow Best</button>
                        </div>
                    </div>
                    
                    <div class="keyboard-hint">
                        Keyboard: Space = Play/Pause, R = Reset, 1/2/3 = Camera Views
                    </div>
                </div>
                
                <div class="panel-section ga-section">
                    <h2>Genetic Algorithm Controls</h2>
                    
                    <div class="control-group">
                        <label for="population-size">Population Size: <span id="population-size-value">12</span></label>
                        <div class="slider-container">
                            <input type="range" id="population-size" min="4" max="30" value="12" step="2">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label for="mutation-rate">Mutation Rate: <span id="mutation-rate-value">0.1</span></label>
                        <div class="slider-container">
                            <input type="range" id="mutation-rate" min="0.01" max="0.5" value="0.1" step="0.01">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label for="elitism">Elitism (Keep Best): <span id="elitism-value">2</span></label>
                        <div class="slider-container">
                            <input type="range" id="elitism" min="0" max="5" value="2" step="1">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <div class="button-row">
                            <button id="next-generation" class="ga-button">Next Generation</button>
                            <button id="evolve-continuous" class="ga-button">Evolve Continuously</button>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section visualization-section">
                    <h2>Evolution Statistics</h2>
                    
                    <div class="stats-panel">
                        <div class="stat-item">
                            <div class="stat-label">Generation</div>
                            <div class="stat-value" id="generation-value">0</div>
                        </div>
                        
                        <div class="stat-item">
                            <div class="stat-label">Best Fitness</div>
                            <div class="stat-value" id="best-fitness-value">0.00</div>
                            <div class="stat-label">(Distance)</div>
                        </div>
                        
                        <div class="stat-item">
                            <div class="stat-label">Avg Fitness</div>
                            <div class="stat-value" id="avg-fitness-value">0.00</div>
                        </div>
                        
                        <div class="stat-item">
                            <div class="stat-label">Total Evaluated</div>
                            <div class="stat-value" id="total-evaluated-value">0</div>
                        </div>
                    </div>
                    
                    <div class="best-individual">
                        <h3>ðŸ‘‘ Best Individual</h3>
                        <div class="generation-info">
                            <div>Generation: <span id="best-generation">0</span></div>
                            <div>Distance: <span id="best-distance">0.00</span> units</div>
                            <div>Stability: <span id="best-stability">0.00</span></div>
                            <div>Legs: <span id="best-legs">4</span></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>Genetic Algorithm Simulation | Evolves walking Strandbeest-style leg mechanisms in 3D using Babylon.js | Based on Theo Jansen's kinematic leg design</p>
        </footer>
    </div>

    <script>
// Main variables
let engine;
let scene;
let canvas;
let camera;
let ground;
let population = [];
let currentGeneration = 0;
let gaRunning = false;
let simulationRunning = true;
let currentBestIndividual = null;
let cameraMode = 'follow'; // 'follow', 'side', 'top'
let cameraTarget = null;
let totalEvaluated = 0;

// Genetic Algorithm parameters
let GA_PARAMS = {
    populationSize: 12,
    mutationRate: 0.1,
    elitism: 2,
    crossoverRate: 0.8
};

// Simulation parameters
let SIM_PARAMS = {
    speed: 1.0,
    cycleDuration: 5.0, // seconds for a full walking cycle
    evaluationTime: 10.0 // seconds to evaluate each individual
};

// Creature parameters
const CREATURE_PARAMS = {
    minLegs: 2,
    maxLegs: 6,
    minSegments: 3,
    maxSegments: 6,
    bodySize: { width: 3, height: 1, depth: 2 },
    legColors: [
        new BABYLON.Color3(0.2, 0.6, 1.0), // Blue
        new BABYLON.Color3(1.0, 0.4, 0.2), // Orange
        new BABYLON.Color3(0.4, 0.8, 0.2), // Green
        new BABYLON.Color3(0.8, 0.2, 0.8), // Purple
        new BABYLON.Color3(1.0, 0.8, 0.2), // Yellow
        new BABYLON.Color3(0.2, 0.8, 0.8)  // Cyan
    ]
};

// Genome definition for a leg mechanism
class LegGenome {
    constructor(randomize = true) {
        // Leg structure parameters
        this.segmentCount = randomize ? 
            Math.floor(Math.random() * (CREATURE_PARAMS.maxSegments - CREATURE_PARAMS.minSegments + 1)) + CREATURE_PARAMS.minSegments : 
            CREATURE_PARAMS.minSegments;
        
        // Segment lengths (normalized 0-1, will be scaled)
        this.segmentLengths = [];
        
        // Joint angles for the walking cycle (amplitudes in radians)
        this.jointAmplitudes = [];
        
        // Joint phase offsets (0 to 2Ï€)
        this.jointPhases = [];
        
        // Leg attachment position on body (x, z offset from center)
        this.attachmentX = 0;
        this.attachmentZ = 0;
        
        // Leg phase offset for gait coordination
        this.legPhaseOffset = 0;
        
        if (randomize) {
            this.randomize();
        }
    }
    
    randomize() {
        // Generate random segment lengths (sum to 1.0)
        let total = 0;
        this.segmentLengths = [];
        for (let i = 0; i < this.segmentCount; i++) {
            const length = 0.2 + Math.random() * 0.8;
            this.segmentLengths.push(length);
            total += length;
        }
        
        // Normalize
        for (let i = 0; i < this.segmentCount; i++) {
            this.segmentLengths[i] /= total;
        }
        
        // Generate random joint amplitudes (0 to Ï€/3 radians)
        this.jointAmplitudes = [];
        for (let i = 0; i < this.segmentCount; i++) {
            this.jointAmplitudes.push(Math.random() * Math.PI / 3);
        }
        
        // Generate random joint phases
        this.jointPhases = [];
        for (let i = 0; i < this.segmentCount; i++) {
            this.jointPhases.push(Math.random() * Math.PI * 2);
        }
        
        // Random attachment position
        this.attachmentX = (Math.random() - 0.5) * CREATURE_PARAMS.bodySize.width * 0.8;
        this.attachmentZ = (Math.random() - 0.5) * CREATURE_PARAMS.bodySize.depth * 0.8;
        
        // Random leg phase offset
        this.legPhaseOffset = Math.random() * Math.PI * 2;
    }
    
    // Create a mutated copy of this genome
    mutate(mutationRate) {
        const mutated = new LegGenome(false);
        mutated.segmentCount = this.segmentCount;
        mutated.segmentLengths = [...this.segmentLengths];
        mutated.jointAmplitudes = [...this.jointAmplitudes];
        mutated.jointPhases = [...this.jointPhases];
        mutated.attachmentX = this.attachmentX;
        mutated.attachmentZ = this.attachmentZ;
        mutated.legPhaseOffset = this.legPhaseOffset;
        
        // Apply mutations
        for (let i = 0; i < mutated.segmentLengths.length; i++) {
            if (Math.random() < mutationRate) {
                mutated.segmentLengths[i] = Math.max(0.1, mutated.segmentLengths[i] + (Math.random() - 0.5) * 0.2);
            }
        }
        
        // Normalize segment lengths
        let total = mutated.segmentLengths.reduce((a, b) => a + b, 0);
        for (let i = 0; i < mutated.segmentLengths.length; i++) {
            mutated.segmentLengths[i] /= total;
        }
        
        for (let i = 0; i < mutated.jointAmplitudes.length; i++) {
            if (Math.random() < mutationRate) {
                mutated.jointAmplitudes[i] = Math.max(0, Math.min(Math.PI/2, 
                    mutated.jointAmplitudes[i] + (Math.random() - 0.5) * 0.3));
            }
        }
        
        for (let i = 0; i < mutated.jointPhases.length; i++) {
            if (Math.random() < mutationRate) {
                mutated.jointPhases[i] = (mutated.jointPhases[i] + (Math.random() - 0.5) * 0.5) % (Math.PI * 2);
            }
        }
        
        if (Math.random() < mutationRate) {
            mutated.attachmentX = Math.max(-CREATURE_PARAMS.bodySize.width/2, 
                Math.min(CREATURE_PARAMS.bodySize.width/2, 
                mutated.attachmentX + (Math.random() - 0.5) * 0.5));
        }
        
        if (Math.random() < mutationRate) {
            mutated.legPhaseOffset = (mutated.legPhaseOffset + (Math.random() - 0.5) * 0.5) % (Math.PI * 2);
        }
        
        return mutated;
    }
    
    // Crossover two genomes
    static crossover(genomeA, genomeB) {
        const child = new LegGenome(false);
        
        // Take segment count from either parent
        child.segmentCount = Math.random() < 0.5 ? genomeA.segmentCount : genomeB.segmentCount;
        
        // For arrays, mix values from both parents
        const minSegments = Math.min(genomeA.segmentCount, genomeB.segmentCount);
        
        child.segmentLengths = [];
        child.jointAmplitudes = [];
        child.jointPhases = [];
        
        for (let i = 0; i < minSegments; i++) {
            child.segmentLengths.push(Math.random() < 0.5 ? genomeA.segmentLengths[i] : genomeB.segmentLengths[i]);
            child.jointAmplitudes.push(Math.random() < 0.5 ? genomeA.jointAmplitudes[i] : genomeB.jointAmplitudes[i]);
            child.jointPhases.push(Math.random() < 0.5 ? genomeA.jointPhases[i] : genomeB.jointPhases[i]);
        }
        
        // If one parent has more segments, add them
        if (genomeA.segmentCount > minSegments) {
            for (let i = minSegments; i < genomeA.segmentCount; i++) {
                child.segmentLengths.push(genomeA.segmentLengths[i]);
                child.jointAmplitudes.push(genomeA.jointAmplitudes[i]);
                child.jointPhases.push(genomeA.jointPhases[i]);
            }
        } else if (genomeB.segmentCount > minSegments) {
            for (let i = minSegments; i < genomeB.segmentCount; i++) {
                child.segmentLengths.push(genomeB.segmentLengths[i]);
                child.jointAmplitudes.push(genomeB.jointAmplitudes[i]);
                child.jointPhases.push(genomeB.jointPhases[i]);
            }
        }
        
        // Mix attachment and phase
        child.attachmentX = Math.random() < 0.5 ? genomeA.attachmentX : genomeB.attachmentX;
        child.attachmentZ = Math.random() < 0.5 ? genomeA.attachmentZ : genomeB.attachmentZ;
        child.legPhaseOffset = Math.random() < 0.5 ? genomeA.legPhaseOffset : genomeB.legPhaseOffset;
        
        return child;
    }
}

// Creature class representing a walking mechanism
class Creature {
    constructor(legGenomes, id, generation) {
        this.id = id;
        this.generation = generation;
        this.legGenomes = legGenomes; // Array of LegGenome objects
        this.legCount = legGenomes.length;
        
        // Physical properties
        this.body = null;
        this.legs = []; // Array of leg segments
        this.joints = []; // Array of joint rotation axes
        
        // Animation properties
        this.animationTime = 0;
        this.startPosition = new BABYLON.Vector3(0, 0, 0);
        this.currentPosition = new BABYLON.Vector3(0, 0, 0);
        this.footContacts = []; // Track which feet are in contact with ground
        
        // Fitness properties
        this.fitness = 0;
        this.distanceTraveled = 0;
        this.stability = 0; // How stable the walk is (based on body height variation)
        this.evaluated = false;
        
        // Visual properties
        this.color = CREATURE_PARAMS.legColors[id % CREATURE_PARAMS.legColors.length];
        this.highlighted = false;
        this.highlightMaterial = null;
    }
    
    // Build the 3D model in the scene
    build(scene) {
        // Create body
        const bodyMat = new BABYLON.StandardMaterial(`bodyMat_${this.id}`, scene);
        bodyMat.diffuseColor = this.color.scale(0.7);
        bodyMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
        
        this.body = BABYLON.MeshBuilder.CreateBox(`body_${this.id}`, {
            width: CREATURE_PARAMS.bodySize.width,
            height: CREATURE_PARAMS.bodySize.height,
            depth: CREATURE_PARAMS.bodySize.depth
        }, scene);
        
        this.body.material = bodyMat;
        this.body.position.y = CREATURE_PARAMS.bodySize.height / 2 + 0.5;
        
        // Create highlight material for best individual
        this.highlightMaterial = new BABYLON.StandardMaterial(`highlight_${this.id}`, scene);
        this.highlightMaterial.diffuseColor = new BABYLON.Color3(1, 1, 0.3);
        this.highlightMaterial.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0);
        this.highlightMaterial.specularColor = new BABYLON.Color3(1, 1, 0.5);
        
        // Create legs
        this.legs = [];
        this.joints = [];
        
        for (let legIndex = 0; legIndex < this.legCount; legIndex++) {
            const genome = this.legGenomes[legIndex];
            const legSegments = [];
            const legJoints = [];
            
            // Calculate total leg length for scaling
            const totalLegLength = 3.0; // Arbitrary scaling factor
            
            // Create segments for this leg
            let parentJoint = null;
            let currentY = 0;
            
            for (let segIndex = 0; segIndex < genome.segmentCount; segIndex++) {
                // Calculate segment length
                const segLength = genome.segmentLengths[segIndex] * totalLegLength;
                const segRadius = 0.1;
                
                // Create segment (cylinder)
                const segment = BABYLON.MeshBuilder.CreateCylinder(`leg_${this.id}_${legIndex}_${segIndex}`, {
                    height: segLength,
                    diameter: segRadius * 2
                }, scene);
                
                // Position and orient segment
                if (segIndex === 0) {
                    // First segment attaches to body
                    segment.position.x = genome.attachmentX;
                    segment.position.y = currentY - segLength/2;
                    segment.position.z = genome.attachmentZ;
                    
                    // Rotate to point downward
                    segment.rotation.x = Math.PI / 2;
                    
                    // Create joint at attachment point (horizontal axis)
                    const jointAxis = new BABYLON.Vector3(0, 0, 1); // Z-axis rotation for forward/backward motion
                    legJoints.push({
                        axis: jointAxis,
                        amplitude: genome.jointAmplitudes[segIndex],
                        phase: genome.jointPhases[segIndex] + genome.legPhaseOffset * legIndex
                    });
                    
                    parentJoint = segment;
                } else {
                    // Subsequent segments attach to previous segment
                    segment.position.x = 0;
                    segment.position.y = -segLength/2;
                    segment.position.z = 0;
                    
                    // Rotate to point downward
                    segment.rotation.x = Math.PI / 2;
                    
                    // Attach to parent
                    segment.parent = parentJoint;
                    
                    // Position at end of parent segment
                    segment.position.y = -genome.segmentLengths[segIndex-1] * totalLegLength / 2;
                    
                    // Create joint (horizontal axis, perpendicular to previous)
                    const jointAxis = new BABYLON.Vector3(0, 0, 1); // Z-axis rotation
                    legJoints.push({
                        axis: jointAxis,
                        amplitude: genome.jointAmplitudes[segIndex],
                        phase: genome.jointPhases[segIndex] + genome.legPhaseOffset * legIndex
                    });
                    
                    parentJoint = segment;
                }
                
                // Color the segment
                const segMat = new BABYLON.StandardMaterial(`legMat_${this.id}_${legIndex}_${segIndex}`, scene);
                segMat.diffuseColor = this.color;
                segMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                segment.material = segMat;
                
                legSegments.push(segment);
                currentY -= segLength;
            }
            
            // Store leg data
            this.legs.push(legSegments);
            this.joints.push(legJoints);
            
            // Parent first segment to body
            if (legSegments.length > 0) {
                legSegments[0].parent = this.body;
            }
            
            // Initialize foot contact tracking
            this.footContacts.push(false);
        }
        
        // Store starting position
        this.startPosition = this.body.position.clone();
        this.currentPosition = this.body.position.clone();
        
        return this;
    }
    
    // Update animation based on time
    update(deltaTime) {
        this.animationTime += deltaTime * SIM_PARAMS.speed;
        
        // Update leg positions based on sine waves
        for (let legIndex = 0; legIndex < this.legCount; legIndex++) {
            const legSegments = this.legs[legIndex];
            const legJoints = this.joints[legIndex];
            
            for (let jointIndex = 0; jointIndex < legJoints.length; jointIndex++) {
                const joint = legJoints[jointIndex];
                const segment = legSegments[jointIndex];
                
                // Calculate joint angle based on time
                const timeScale = (2 * Math.PI) / SIM_PARAMS.cycleDuration;
                const angle = joint.amplitude * Math.sin(this.animationTime * timeScale + joint.phase);
                
                // Apply rotation to joint
                if (jointIndex === 0) {
                    // First joint rotates around Z axis (attached to body)
                    segment.rotation.z = angle;
                } else {
                    // Subsequent joints also rotate around Z axis
                    segment.rotation.z = angle;
                }
            }
            
            // Check if foot is in contact with ground (simplified)
            if (legSegments.length > 0) {
                const lastSegment = legSegments[legSegments.length - 1];
                const worldPos = lastSegment.getAbsolutePosition();
                this.footContacts[legIndex] = worldPos.y < 0.3; // Simple ground contact detection
            }
        }
        
        // Move body based on foot contacts (simplified walking physics)
        let forwardForce = 0;
        let contactCount = 0;
        
        for (let i = 0; i < this.footContacts.length; i++) {
            if (this.footContacts[i]) {
                contactCount++;
                // Apply force based on leg motion phase
                const genome = this.legGenomes[i];
                const timeScale = (2 * Math.PI) / SIM_PARAMS.cycleDuration;
                const phase = this.animationTime * timeScale + genome.legPhaseOffset * i;
                
                // When foot is pushing backward, move body forward
                if (Math.sin(phase) > 0) {
                    forwardForce += 0.01 * SIM_PARAMS.speed;
                }
            }
        }
        
        // Apply movement if at least one foot is in contact
        if (contactCount > 0) {
            this.body.position.x += forwardForce / contactCount;
            
            // Simple stability: try to keep body level
            const targetHeight = CREATURE_PARAMS.bodySize.height / 2 + 0.5;
            const heightDiff = targetHeight - this.body.position.y;
            this.body.position.y += heightDiff * 0.1;
        }
        
        // Update current position
        this.currentPosition = this.body.position.clone();
        
        // Update fitness if being evaluated
        if (!this.evaluated) {
            this.distanceTraveled = this.body.position.x - this.startPosition.x;
            
            // Calculate stability (inverse of vertical movement)
            const verticalMovement = Math.abs(this.body.position.y - (CREATURE_PARAMS.bodySize.height / 2 + 0.5));
            this.stability = Math.max(0, 1 - verticalMovement * 2);
            
            // Fitness is distance traveled weighted by stability
            this.fitness = Math.max(0, this.distanceTraveled * this.stability);
        }
        
        return this;
    }
    
    // Highlight as best individual
    highlight(isBest) {
        this.highlighted = isBest;
        
        if (isBest && this.body) {
            this.body.material = this.highlightMaterial;
            
            // Also highlight leg segments
            for (let legIndex = 0; legIndex < this.legs.length; legIndex++) {
                const legSegments = this.legs[legIndex];
                for (let segment of legSegments) {
                    if (segment.material) {
                        segment.material = this.highlightMaterial;
                    }
                }
            }
        }
        
        return this;
    }
    
    // Clean up meshes
    dispose() {
        if (this.body) {
            this.body.dispose();
        }
        
        for (let legSegments of this.legs) {
            for (let segment of legSegments) {
                if (segment) {
                    segment.dispose();
                }
            }
        }
        
        if (this.highlightMaterial) {
            this.highlightMaterial.dispose();
        }
    }
}

// Genetic Algorithm manager
class GeneticAlgorithm {
    constructor() {
        this.population = [];
        this.currentGeneration = 0;
        this.bestIndividual = null;
        this.bestFitnessHistory = [];
        this.avgFitnessHistory = [];
    }
    
    // Initialize random population
    initializePopulation(size) {
        this.population = [];
        
        for (let i = 0; i < size; i++) {
            // Determine number of legs for this creature (2-6)
            const legCount = Math.floor(Math.random() * 
                (CREATURE_PARAMS.maxLegs - CREATURE_PARAMS.minLegs + 1)) + CREATURE_PARAMS.minLegs;
            
            // Create leg genomes
            const legGenomes = [];
            for (let j = 0; j < legCount; j++) {
                legGenomes.push(new LegGenome(true));
            }
            
            // Create creature
            const creature = new Creature(legGenomes, i, this.currentGeneration);
            this.population.push(creature);
        }
        
        return this.population;
    }
    
    // Evaluate all individuals in the population
    evaluatePopulation() {
        for (let creature of this.population) {
            creature.evaluated = true;
        }
        
        // Sort by fitness (descending)
        this.population.sort((a, b) => b.fitness - a.fitness);
        
        // Update best individual
        if (this.population.length > 0) {
            const currentBest = this.population[0];
            
            if (!this.bestIndividual || currentBest.fitness > this.bestIndividual.fitness) {
                this.bestIndividual = currentBest;
            }
        }
        
        // Record fitness statistics
        const totalFitness = this.population.reduce((sum, creature) => sum + creature.fitness, 0);
        const avgFitness = this.population.length > 0 ? totalFitness / this.population.length : 0;
        
        this.bestFitnessHistory.push(this.population.length > 0 ? this.population[0].fitness : 0);
        this.avgFitnessHistory.push(avgFitness);
        
        return this.population;
    }
    
    // Create next generation using selection, crossover, and mutation
    createNextGeneration(mutationRate, elitism) {
        const newPopulation = [];
        
        // Elitism: keep the best individuals
        for (let i = 0; i < Math.min(elitism, this.population.length); i++) {
            // Create a copy of the best individual
            const best = this.population[i];
            const copiedGenomes = best.legGenomes.map(genome => {
                const copy = new LegGenome(false);
                Object.assign(copy, JSON.parse(JSON.stringify(genome)));
                return copy;
            });
            
            const eliteCreature = new Creature(copiedGenomes, i, this.currentGeneration + 1);
            newPopulation.push(eliteCreature);
        }
        
        // Fill the rest of the population with offspring
        while (newPopulation.length < GA_PARAMS.populationSize) {
            // Tournament selection
            const parent1 = this.tournamentSelection(3);
            const parent2 = this.tournamentSelection(3);
            
            let childGenomes = [];
            
            // Crossover
            if (Math.random() < GA_PARAMS.crossoverRate && parent1 && parent2) {
                // Ensure both parents have the same number of legs for crossover
                const minLegs = Math.min(parent1.legGenomes.length, parent2.legGenomes.length);
                const legCount = Math.random() < 0.5 ? parent1.legGenomes.length : parent2.legGenomes.length;
                
                for (let i = 0; i < legCount; i++) {
                    const genome1 = parent1.legGenomes[Math.min(i, parent1.legGenomes.length - 1)];
                    const genome2 = parent2.legGenomes[Math.min(i, parent2.legGenomes.length - 1)];
                    
                    if (i < minLegs) {
                        // Crossover if we have both parents
                        childGenomes.push(LegGenome.crossover(genome1, genome2));
                    } else {
                        // Take from the parent with more legs
                        const sourceGenome = legCount === parent1.legGenomes.length ? genome1 : genome2;
                        const copy = new LegGenome(false);
                        Object.assign(copy, JSON.parse(JSON.stringify(sourceGenome)));
                        childGenomes.push(copy);
                    }
                }
            } else {
                // No crossover, clone a parent
                const parent = Math.random() < 0.5 ? parent1 : parent2;
                if (parent) {
                    childGenomes = parent.legGenomes.map(genome => {
                        const copy = new LegGenome(false);
                        Object.assign(copy, JSON.parse(JSON.stringify(genome)));
                        return copy;
                    });
                } else {
                    // Fallback: random individual
                    const legCount = Math.floor(Math.random() * 
                        (CREATURE_PARAMS.maxLegs - CREATURE_PARAMS.minLegs + 1)) + CREATURE_PARAMS.minLegs;
                    
                    for (let j = 0; j < legCount; j++) {
                        childGenomes.push(new LegGenome(true));
                    }
                }
            }
            
            // Apply mutation
            childGenomes = childGenomes.map(genome => genome.mutate(mutationRate));
            
            // Create child creature
            const child = new Creature(childGenomes, newPopulation.length, this.currentGeneration + 1);
            newPopulation.push(child);
        }
        
        // Dispose old population (clean up 3D resources)
        for (let creature of this.population) {
            creature.dispose();
        }
        
        // Update population and generation
        this.population = newPopulation;
        this.currentGeneration++;
        
        return this.population;
    }
    
    // Tournament selection
    tournamentSelection(tournamentSize) {
        if (this.population.length === 0) return null;
        
        let best = null;
        for (let i = 0; i < tournamentSize; i++) {
            const candidate = this.population[Math.floor(Math.random() * this.population.length)];
            if (!best || candidate.fitness > best.fitness) {
                best = candidate;
            }
        }
        
        return best;
    }
    
    // Get fitness statistics
    getFitnessStats() {
        if (this.population.length === 0) {
            return { best: 0, average: 0, worst: 0 };
        }
        
        const sorted = [...this.population].sort((a, b) => b.fitness - a.fitness);
        const totalFitness = sorted.reduce((sum, creature) => sum + creature.fitness, 0);
        
        return {
            best: sorted[0].fitness,
            average: totalFitness / sorted.length,
            worst: sorted[sorted.length - 1].fitness
        };
    }
}

// Main simulation class
class StrandbeestSimulation {
    constructor() {
        this.ga = new GeneticAlgorithm();
        this.scene = null;
        this.ground = null;
        this.lights = [];
        this.populationMeshes = [];
        this.bestCreature = null;
        this.lastEvaluationTime = 0;
        this.evaluationInterval = 10; // Evaluate every 10 seconds
        this.continuousEvolution = false;
        this.evolutionTimer = 0;
        
        // Initialize UI controls
        this.initControls();
    }
    
    // Initialize the 3D scene
    initScene() {
        // Get the canvas element
        canvas = document.getElementById("renderCanvas");
        
        // Create the Babylon.js engine
        engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
        
        // Create the scene
        scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0.05, 0.1, 0.15, 1.0);
        
        // Create camera
        camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 3, 25, 
            new BABYLON.Vector3(0, 3, 0), scene);
        camera.attachControl(canvas, true);
        camera.lowerRadiusLimit = 5;
        camera.upperRadiusLimit = 50;
        camera.wheelPrecision = 50;
        
        // Create lights
        const light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
        light1.intensity = 0.7;
        
        const light2 = new BABYLON.DirectionalLight("light2", new BABYLON.Vector3(-1, -2, -1), scene);
        light2.position = new BABYLON.Vector3(20, 40, 20);
        light2.intensity = 0.5;
        
        this.lights.push(light1, light2);
        
        // Create ground
        this.ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 100, height: 100 }, scene);
        const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
        groundMat.diffuseColor = new BABYLON.Color3(0.2, 0.3, 0.2);
        groundMat.specularColor = new BABYLON.Color3(0, 0, 0);
        this.ground.material = groundMat;
        this.ground.position.y = 0;
        
        // Add grid for reference
        const grid = BABYLON.MeshBuilder.CreateGround("grid", { width: 100, height: 100 }, scene);
        const gridMat = new BABYLON.GridMaterial("gridMat", scene);
        gridMat.majorUnitFrequency = 5;
        gridMat.minorUnitVisibility = 0.3;
        gridMat.gridRatio = 1;
        gridMat.mainColor = new BABYLON.Color3(0.2, 0.2, 0.2);
        gridMat.lineColor = new BABYLON.Color3(0.4, 0.4, 0.4);
        gridMat.opacity = 0.2;
        grid.material = gridMat;
        grid.position.y = 0.01; // Slightly above ground
        
        // Initialize genetic algorithm population
        this.ga.initializePopulation(GA_PARAMS.populationSize);
        
        // Build creatures in the scene
        this.buildPopulationInScene();
        
        // Handle window resize
        window.addEventListener("resize", () => {
            engine.resize();
        });
        
        // Run the render loop
        engine.runRenderLoop(() => {
            this.update();
            scene.render();
        });
        
        this.scene = scene;
        return scene;
    }
    
    // Build all creatures in the population
    buildPopulationInScene() {
        // Clear previous meshes
        for (let creature of this.populationMeshes) {
            creature.dispose();
        }
        this.populationMeshes = [];
        
        // Position creatures in a grid
        const gridSize = Math.ceil(Math.sqrt(GA_PARAMS.populationSize));
        const spacing = 8;
        
        for (let i = 0; i < this.ga.population.length; i++) {
            const creature = this.ga.population[i];
            
            // Calculate grid position
            const row = Math.floor(i / gridSize);
            const col = i % gridSize;
            
            const startX = -((gridSize - 1) * spacing) / 2;
            const startZ = -((gridSize - 1) * spacing) / 2;
            
            const x = startX + col * spacing;
            const z = startZ + row * spacing;
            
            // Build creature
            creature.build(this.scene);
            creature.body.position.x = x;
            creature.body.position.z = z;
            creature.startPosition = creature.body.position.clone();
            
            this.populationMeshes.push(creature);
        }
    }
    
    // Update simulation
    update() {
        if (!this.scene || !simulationRunning) return;
        
        const deltaTime = this.scene.getEngine().getDeltaTime() / 1000; // Convert to seconds
        
        // Update all creatures
        for (let creature of this.populationMeshes) {
            creature.update(deltaTime);
        }
        
        // Update camera based on mode
        this.updateCamera(deltaTime);
        
        // Handle continuous evolution
        if (this.continuousEvolution) {
            this.evolutionTimer += deltaTime;
            
            // Evaluate and evolve every evaluationInterval seconds
            if (this.evolutionTimer >= SIM_PARAMS.evaluationTime) {
                this.evolutionTimer = 0;
                this.evaluateAndEvolve();
            }
        }
        
        // Update UI
        this.updateUI();
    }
    
    // Update camera based on current mode
    updateCamera(deltaTime) {
        if (!camera) return;
        
        switch (cameraMode) {
            case 'side':
                camera.alpha = -Math.PI / 2;
                camera.beta = Math.PI / 4;
                camera.radius = 20;
                camera.target = new BABYLON.Vector3(0, 3, 0);
                break;
                
            case 'top':
                camera.alpha = -Math.PI / 2;
                camera.beta = Math.PI / 2.1; // Just below top-down
                camera.radius = 25;
                camera.target = new BABYLON.Vector3(0, 0, 0);
                break;
                
            case 'follow':
                if (this.bestCreature && this.bestCreature.body) {
                    // Follow the best creature
                    const targetPos = this.bestCreature.body.position.clone();
                    targetPos.y += 3;
                    
                    // Smooth camera movement
                    camera.target = BABYLON.Vector3.Lerp(
                        camera.target, 
                        targetPos, 
                        deltaTime * 2
                    );
                    
                    // Position camera behind and above the creature
                    const desiredAlpha = -Math.PI / 2;
                    const desiredBeta = Math.PI / 4;
                    const desiredRadius = 15;
                    
                    camera.alpha = BABYLON.Scalar.Lerp(camera.alpha, desiredAlpha, deltaTime * 2);
                    camera.beta = BABYLON.Scalar.Lerp(camera.beta, desiredBeta, deltaTime * 2);
                    camera.radius = BABYLON.Scalar.Lerp(camera.radius, desiredRadius, deltaTime * 2);
                }
                break;
        }
    }
    
    // Evaluate current generation and create next one
    evaluateAndEvolve() {
        // Evaluate current population
        this.ga.evaluatePopulation();
        
        // Update best creature
        if (this.ga.bestIndividual) {
            this.bestCreature = this.ga.bestIndividual;
            
            // Highlight best creature
            for (let creature of this.populationMeshes) {
                creature.highlight(creature === this.bestCreature);
            }
        }
        
        // Create next generation
        this.ga.createNextGeneration(GA_PARAMS.mutationRate, GA_PARAMS.elitism);
        
        // Rebuild population in scene
        this.buildPopulationInScene();
        
        // Highlight the new best creature
        if (this.ga.bestIndividual) {
            this.bestCreature = this.ga.bestIndividual;
            this.bestCreature.highlight(true);
        }
        
        totalEvaluated += GA_PARAMS.populationSize;
    }
    
    // Update UI elements
    updateUI() {
        document.getElementById('generation-value').textContent = this.ga.currentGeneration;
        document.getElementById('total-evaluated-value').textContent = totalEvaluated;
        
        // Update fitness stats
        const stats = this.ga.getFitnessStats();
        document.getElementById('best-fitness-value').textContent = stats.best.toFixed(2);
        document.getElementById('avg-fitness-value').textContent = stats.average.toFixed(2);
        
        // Update best individual info
        if (this.bestCreature) {
            document.getElementById('best-generation').textContent = this.bestCreature.generation;
            document.getElementById('best-distance').textContent = this.bestCreature.distanceTraveled.toFixed(2);
            document.getElementById('best-stability').textContent = this.bestCreature.stability.toFixed(2);
            document.getElementById('best-legs').textContent = this.bestCreature.legCount;
        }
    }
    
    // Initialize UI controls
    initControls() {
        // Simulation speed
        const simSpeedSlider = document.getElementById('sim-speed');
        const simSpeedValue = document.getElementById('sim-speed-value');
        
        simSpeedSlider.addEventListener('input', () => {
            SIM_PARAMS.speed = parseFloat(simSpeedSlider.value);
            simSpeedValue.textContent = SIM_PARAMS.speed.toFixed(1);
        });
        
        // Cycle duration
        const cycleDurationSlider = document.getElementById('cycle-duration');
        const cycleDurationValue = document.getElementById('cycle-duration-value');
        
        cycleDurationSlider.addEventListener('input', () => {
            SIM_PARAMS.cycleDuration = parseFloat(cycleDurationSlider.value);
            cycleDurationValue.textContent = SIM_PARAMS.cycleDuration.toFixed(1);
        });
        
        // Population size
        const populationSizeSlider = document.getElementById('population-size');
        const populationSizeValue = document.getElementById('population-size-value');
        
        populationSizeSlider.addEventListener('input', () => {
            GA_PARAMS.populationSize = parseInt(populationSizeSlider.value);
            populationSizeValue.textContent = GA_PARAMS.populationSize;
            
            // Reinitialize with new population size
            this.ga.initializePopulation(GA_PARAMS.populationSize);
            this.buildPopulationInScene();
        });
        
        // Mutation rate
        const mutationRateSlider = document.getElementById('mutation-rate');
        const mutationRateValue = document.getElementById('mutation-rate-value');
        
        mutationRateSlider.addEventListener('input', () => {
            GA_PARAMS.mutationRate = parseFloat(mutationRateSlider.value);
            mutationRateValue.textContent = GA_PARAMS.mutationRate.toFixed(2);
        });
        
        // Elitism
        const elitismSlider = document.getElementById('elitism');
        const elitismValue = document.getElementById('elitism-value');
        
        elitismSlider.addEventListener('input', () => {
            GA_PARAMS.elitism = parseInt(elitismSlider.value);
            elitismValue.textContent = GA_PARAMS.elitism;
        });
        
        // Play/Pause button
        const playPauseBtn = document.getElementById('play-pause');
        const playIcon = document.getElementById('play-icon');
        const playText = document.getElementById('play-text');
        
        playPauseBtn.addEventListener('click', () => {
            simulationRunning = !simulationRunning;
            playIcon.textContent = simulationRunning ? 'â¸' : 'â–¶';
            playText.textContent = simulationRunning ? 'Pause' : 'Play';
        });
        
        // Reset button
        document.getElementById('reset-button').addEventListener('click', () => {
            this.ga = new GeneticAlgorithm();
            this.ga.initializePopulation(GA_PARAMS.populationSize);
            this.buildPopulationInScene();
            this.bestCreature = null;
            currentGeneration = 0;
            totalEvaluated = 0;
            this.updateUI();
        });
        
        // Camera views
        document.getElementById('view-side').addEventListener('click', () => {
            cameraMode = 'side';
        });
        
        document.getElementById('view-top').addEventListener('click', () => {
            cameraMode = 'top';
        });
        
        document.getElementById('view-follow').addEventListener('click', () => {
            cameraMode = 'follow';
        });
        
        // Next generation button
        document.getElementById('next-generation').addEventListener('click', () => {
            this.evaluateAndEvolve();
        });
        
        // Evolve continuously button
        const evolveContinuousBtn = document.getElementById('evolve-continuous');
        evolveContinuousBtn.addEventListener('click', () => {
            this.continuousEvolution = !this.continuousEvolution;
            evolveContinuousBtn.textContent = this.continuousEvolution ? 
                'Stop Continuous Evolution' : 'Evolve Continuously';
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case ' ':
                    simulationRunning = !simulationRunning;
                    playIcon.textContent = simulationRunning ? 'â¸' : 'â–¶';
                    playText.textContent = simulationRunning ? 'Pause' : 'Play';
                    break;
                    
                case 'r':
                case 'R':
                    this.ga = new GeneticAlgorithm();
                    this.ga.initializePopulation(GA_PARAMS.populationSize);
                    this.buildPopulationInScene();
                    this.bestCreature = null;
                    currentGeneration = 0;
                    totalEvaluated = 0;
                    this.updateUI();
                    break;
                    
                case '1':
                    cameraMode = 'side';
                    break;
                    
                case '2':
                    cameraMode = 'top';
                    break;
                    
                case '3':
                    cameraMode = 'follow';
                    break;
                    
                case 'n':
                case 'N':
                    if (e.ctrlKey) {
                        this.evaluateAndEvolve();
                    }
                    break;
            }
        });
    }
}

// Initialize the simulation when the page loads
window.addEventListener('DOMContentLoaded', () => {
    const simulation = new StrandbeestSimulation();
    simulation.initScene();
});
    </script>
</body>
</html>