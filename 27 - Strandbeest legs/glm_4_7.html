<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genetic Algorithm: Evolving Walkers</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --accent: #00bcd4;
            --accent-hover: #00acc1;
            --danger: #ff5252;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            background-color: rgba(30, 30, 30, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            border: 1px solid #333;
            max-height: 90vh;
            overflow-y: auto;
            backdrop-filter: blur(5px);
        }

        h2 { margin-top: 0; font-size: 1.2rem; color: var(--accent); border-bottom: 1px solid #444; padding-bottom: 10px;}
        h3 { font-size: 1rem; margin: 15px 0 5px 0; color: #bbb; }

        .control-group {
            margin-bottom: 12px;
            display: flex;
            flex-direction: column;
        }

        label { font-size: 0.85rem; margin-bottom: 4px; display: flex; justify-content: space-between; }
        
        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

        button {
            background-color: var(--accent);
            color: #000;
            border: none;
            padding: 10px;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
            margin-top: 5px;
            width: 100%;
        }

        button:hover { background-color: var(--accent-hover); }
        button.secondary { background-color: #444; color: white; }
        button.secondary:hover { background-color: #555; }
        button.danger { background-color: var(--danger); color: white; }
        
        .stats {
            background: #000;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.85rem;
            margin-top: 10px;
            border: 1px solid #333;
        }
        .stat-row { display: flex; justify-content: space-between; }
        .val { color: var(--accent); }

        #overlay-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 20px;
            pointer-events: none;
            font-family: monospace;
            font-size: 1.2rem;
            color: #fff;
        }
    </style>
</head>
<body>

    <canvas id="renderCanvas"></canvas>
    
    <div id="controls">
        <h2>Evolution Controls</h2>
        
        <div class="stats">
            <div class="stat-row"><span>Generation:</span> <span id="statGen" class="val">0</span></div>
            <div class="stat-row"><span>Best Fitness:</span> <span id="statFit" class="val">0.00</span></div>
            <div class="stat-row"><span>Status:</span> <span id="statStatus" class="val">Idle</span></div>
        </div>

        <h3>Simulation</h3>
        <div class="control-group">
            <button id="btnStartPause">Start Evolution</button>
            <button id="btnReplay" class="secondary">Replay Best All-Time</button>
            <button id="btnReset" class="danger">Reset All</button>
        </div>

        <h3>Parameters</h3>
        <div class="control-group">
            <label>Sim Speed <span id="valSpeed">1x</span></label>
            <input type="range" id="sliderSpeed" min="1" max="20" value="1" step="1">
        </div>
        <div class="control-group">
            <label>Test Duration (s) <span id="valDur">5</span></label>
            <input type="range" id="sliderDur" min="2" max="15" value="5" step="1">
        </div>

        <h3>Genetic Algorithm</h3>
        <div class="control-group">
            <label>Population Size <span id="valPop">20</span></label>
            <input type="range" id="sliderPop" min="10" max="50" value="20" step="2">
        </div>
        <div class="control-group">
            <label>Mutation Rate <span id="valMut">5%</span></label>
            <input type="range" id="sliderMut" min="0" max="50" value="5" step="1">
        </div>

        <div style="font-size: 0.75rem; color: #777; margin-top: 10px; line-height: 1.4;">
            <strong>How it works:</strong><br>
            Creatures have 2-segment legs driven by sine waves (Strandbeest style). 
            <br>Fitness = distance traveled in X.
            <br>Red legs = Stance (pushing).
            <br>Green legs = Swing (recovering).
        </div>
    </div>

    <div id="overlay-info">
        Distance: <span id="liveDist">0.00</span>m
    </div>

<script>
    // --- CONFIGURATION & STATE ---
    const CONFIG = {
        groundSize: 100,
        numLegs: 4,
        legSpacing: 0.8,
        bodyWidth: 1.5,
        bodyHeight: 0.5,
        bodyDepth: 0.8,
        defaultThighLen: 1.0,
        defaultShinLen: 1.0,
        bodyY: 2.0 // Height of body center above ground
    };

    const STATE = {
        running: false,
        replaying: false,
        generation: 0,
        populationIndex: 0,
        simTime: 0,
        testDuration: 5, // seconds
        simSpeed: 1,
        population: [],
        bestEver: null,
        bestFitnessEver: -Infinity,
        currentFitness: 0
    };

    // Genome: [thighL, shinL, hipAmp, hipPhase, kneeAmp, kneePhase, freq, hipOffset, kneeOffset]
    // 9 Genes. 
    // Lengths: 0.5 to 2.0
    // Amps: 0 to PI
    // Phases: 0 to 2PI
    // Freq: 1 to 5
    
    // --- BABYLON.JS SETUP ---
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);
    
    let scene, camera, light, ground;
    let rigRoot; // The root node of the creature
    let meshes = {
        body: null,
        thighs: [],
        shins: []
    };

    const createScene = function () {
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color3(0.07, 0.07, 0.07);
        
        // Camera
        camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 3, 10, new BABYLON.Vector3(0, 2, 0), scene);
        camera.attachControl(canvas, true);
        camera.lowerRadiusLimit = 5;
        camera.upperRadiusLimit = 30;
        
        // Lighting
        const hemiLight = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
        hemiLight.intensity = 0.6;
        
        const dirLight = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-1, -2, -1), scene);
        dirLight.position = new BABYLON.Vector3(20, 40, 20);
        dirLight.intensity = 0.8;
        dirLight.shadowEnabled = true;

        // Ground
        ground = BABYLON.MeshBuilder.CreateGround("ground", {width: CONFIG.groundSize, height: CONFIG.groundSize}, scene);
        const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
        groundMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.15);
        groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
        // Grid texture
        const gridTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/tile1.jpg", scene);
        gridTexture.uScale = 20;
        gridTexture.vScale = 20;
        groundMat.diffuseTexture = gridTexture;
        ground.material = groundMat;

        // Initialize Rig (The Visual Creature)
        rigRoot = new BABYLON.TransformNode("rigRoot", scene);
        
        // Body
        meshes.body = BABYLON.MeshBuilder.CreateBox("body", {width: CONFIG.bodyWidth, height: CONFIG.bodyHeight, depth: CONFIG.bodyDepth}, scene);
        meshes.body.parent = rigRoot;
        meshes.body.position.y = 0; // Local center
        const bodyMat = new BABYLON.StandardMaterial("bodyMat", scene);
        bodyMat.diffuseColor = BABYLON.Color3.Gray();
        meshes.body.material = bodyMat;

        // Legs
        const legMat = new BABYLON.StandardMaterial("legMat", scene);
        legMat.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8);

        const shinMat = new BABYLON.StandardMaterial("shinMat", scene);
        shinMat.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.6);

        // Create 4 legs
        for(let i=0; i<CONFIG.numLegs; i++) {
            // Thigh
            const thigh = BABYLON.MeshBuilder.CreateBox("thigh"+i, {width: 0.2, height: 0.2, depth: 1}, scene); // Initial depth=1, will scale
            // Pivot correction: Box origin is center. We want it to rotate from top.
            // We'll just position it relative to body.
            
            // Better: Use a pivot node for the hip joint
            const hipPivot = new BABYLON.TransformNode("hipPivot"+i, scene);
            hipPivot.parent = rigRoot;
            
            // Position hip pivots on the body
            // FL(0), FR(1), BL(2), BR(3)
            // x: +/- width/2, z: +/- depth/2
            let xPos = (i % 2 === 0) ? -CONFIG.bodyWidth/2 : CONFIG.bodyWidth/2;
            let zPos = (i < 2) ? -CONFIG.bodyDepth/2 : CONFIG.bodyDepth/2;
            
            hipPivot.position = new BABYLON.Vector3(xPos, 0, zPos);
            
            thigh.material = legMat;
            thigh.parent = hipPivot;
            thigh.position.y = -0.1; // Slightly down so pivot is at top edge roughly
            // We will rotate thigh around Z axis (local)
            // Babylon box Y is up. We want the leg to swing in X plane.
            // Let's rotate the mesh so its length aligns with Y, then we rotate the PIVOT around Z? 
            // Simpler: Thigh length is along Y. We rotate pivot around X or Z.
            
            // Let's align thigh vertically (length along -Y)
            thigh.scaling = new BABYLON.Vector3(1, 1, 1); 
            
            // Shin
            const shin = BABYLON.MeshBuilder.CreateBox("shin"+i, {width: 0.15, height: 0.15, depth: 1}, scene);
            shin.material = shinMat;
            shin.parent = thigh;
            shin.position.y = -1; // Will be adjusted by genome length
            // We rotate shin relative to thigh.

            meshes.thighs.push({ mesh: thigh, pivot: hipPivot });
            meshes.shins.push(shin);
        }

        return scene;
    };

    scene = createScene();

    // --- GENETIC ALGORITHM LOGIC ---

    function randomGene(min, max) {
        return Math.random() * (max - min) + min;
    }

    function createGenome() {
        return [
            randomGene(0.5, 1.5),   // 0: Thigh Len
            randomGene(0.5, 1.5),   // 1: Shin Len
            randomGene(0, Math.PI), // 2: Hip Amp
            randomGene(0, Math.PI*2),// 3: Hip Phase
            randomGene(0, Math.PI), // 4: Knee Amp
            randomGene(0, Math.PI*2),// 5: Knee Phase
            randomGene(1.5, 4.0),   // 6: Frequency
            randomGene(-0.5, 0.5),  // 7: Hip Offset (droop)
            randomGene(-0.5, 2.0)   // 8: Knee Offset (bend)
        ];
    }

    function cloneGenome(g) {
        return [...g];
    }

    function mutateGenome(g, rate) {
        let newG = cloneGenome(g);
        for(let i=0; i<newG.length; i++) {
            if(Math.random() < rate) {
                // Gaussian-ish mutation
                let change = (Math.random() - 0.5) * 0.5; 
                // Adjust ranges based on gene type roughly
                if(i < 2) change *= 0.5; // Lengths
                if(i > 1 && i < 6) change *= 1.0; // Angles
                if(i === 6) change *= 0.5; // Freq
                
                newG[i] += change;
                // Clamp values
                if(i < 2) newG[i] = Math.max(0.3, Math.min(2.0, newG[i]));
                if(i >= 2 && i < 6) newG[i] = newG[i] % (Math.PI*2);
                if(i === 6) newG[i] = Math.max(0.5, Math.min(6.0, newG[i]));
            }
        }
        return newG;
    }

    function crossover(g1, g2) {
        let child = [];
        // Uniform crossover
        for(let i=0; i<g1.length; i++) {
            child.push(Math.random() > 0.5 ? g1[i] : g2[i]);
        }
        return child;
    }

    function initPopulation(size) {
        STATE.population = [];
        for(let i=0; i<size; i++) {
            STATE.population.push({ genome: createGenome(), fitness: 0 });
        }
        STATE.generation = 0;
        STATE.populationIndex = 0;
        STATE.bestEver = null;
        STATE.bestFitnessEver = -Infinity;
        updateStats();
    }

    function nextGeneration() {
        // Sort by fitness
        STATE.population.sort((a, b) => b.fitness - a.fitness);

        // Update best ever
        if(STATE.population[0].fitness > STATE.bestFitnessEver) {
            STATE.bestFitnessEver = STATE.population[0].fitness;
            STATE.bestEver = STATE.population[0];
        }

        // Elitism: Keep top 2
        let newPop = [STATE.population[0], STATE.population[1]];

        // Generate rest
        while(newPop.length < STATE.population.length) {
            // Tournament selection
            let p1 = tournamentSelect();
            let p2 = tournamentSelect();
            let childGenome = crossover(p1.genome, p2.genome);
            childGenome = mutateGenome(childGenome, parseFloat(sliderMut.value) / 100);
            newPop.push({ genome: childGenome, fitness: 0 });
        }

        STATE.population = newPop;
        STATE.generation++;
        STATE.populationIndex = 0;
        updateStats();
    }

    function tournamentSelect() {
        let k = 3;
        let best = null;
        for(let i=0; i<k; i++) {
            let ind = STATE.population[Math.floor(Math.random() * STATE.population.length)];
            if(best === null || ind.fitness > best.fitness) {
                best = ind;
            }
        }
        return best;
    }

    // --- PHYSICS & KINEMATICS ---

    function updateCreature(genome, dt) {
        // Decode Genome
        let [tLen, sLen, hAmp, hPhase, kAmp, kPhase, freq, hOff, kOff] = genome;

        // Update Visuals (Mesh scaling)
        meshes.body.scaling.y = CONFIG.bodyHeight; // Reset scale if needed
        
        let totalGroundForceX = 0;
        let legsInStance = 0;

        // Gait offsets: 
        // Front-Left (0): 0
        // Back-Right (3): 0 (Diagonal pair sync)
        // Front-Right (1): PI
        // Back-Left (2): PI
        let gaitOffsets = [0, Math.PI, Math.PI, 0]; 

        // Reset Rig X to current sim position
        // We simulate physics by moving the rigRoot.position.x
        // But we update joints based on time.

        let time = STATE.simTime;

        for(let i=0; i<CONFIG.numLegs; i++) {
            let legPhase = gaitOffsets[i];
            
            // Calculate Angles
            // Hip: rotates around Z axis of the pivot
            let thetaHip = hAmp * Math.sin(freq * time + hPhase + legPhase) + hOff;
            
            // Knee: rotates around Z axis relative to thigh
            let thetaKnee = kAmp * Math.sin(freq * time + kPhase + legPhase) + kOff;

            // Apply to Meshes
            meshes.thighs[i].pivot.rotation.z = thetaHip;
            meshes.thighs[i].scaling.y = tLen; // Scale length
            // Move mesh down so pivot is at top
            meshes.thighs[i].mesh.position.y = -tLen/2; 

            meshes.shins[i].rotation.z = thetaKnee;
            meshes.shins[i].scaling.y = sLen;
            meshes.shins[i].position.y = -tLen/2 - sLen/2;

            // --- Kinematics for Movement ---
            // Calculate local position of foot relative to Hip Pivot
            // Thigh vector: L_t * [sin(theta), -cos(theta)]
            // Knee vector: L_s * [sin(theta+phi), -cos(theta+phi)]
            // Note: In Babylon, Z is depth, X is width, Y is up.
            // We rotate around Z, so the leg moves in X-Y plane.
            
            let tx = tLen * Math.sin(thetaHip);
            let ty = -tLen * Math.cos(thetaHip);
            
            let kx = sLen * Math.sin(thetaHip + thetaKnee);
            let ky = -sLen * Math.cos(thetaHip + thetaKnee);

            let footLocalX = tx + kx;
            let footLocalY = ty + ky;

            // Global Foot Y (assuming body is at rigRoot.y)
            let globalFootY = rigRoot.position.y + footLocalY;

            // Check Ground Contact (y <= 0)
            // We add a small buffer for the foot radius (say 0.1)
            if(globalFootY <= 0.1) {
                // Leg is in contact
                // Calculate Velocity of foot in World X
                // v_foot = v_body + v_leg_relative
                // v_leg_relative_x = d(footLocalX)/dt
                
                // Analytical derivative is cleaner, but numerical is fine here
                // Let's use analytical for stability
                // d(theta)/dt = freq * amp * cos(...)
                let dThetaHip = hAmp * freq * Math.cos(freq * time + hPhase + legPhase);
                let dThetaKnee = kAmp * freq * Math.cos(freq * time + kPhase + legPhase);

                // d(tx)/dt = tL * cos(th) * dth
                let dtx = tLen * Math.cos(thetaHip) * dThetaHip;
                
                // d(kx)/dt = sL * cos(th+k) * (dth + dk)
                let dkx = sLen * Math.cos(thetaHip + thetaKnee) * (dThetaHip + dThetaKnee);

                let vLegX = dtx + dkx;

                // If vLegX < 0 (moving back), it pushes body forward
                // Friction model: Body moves to oppose foot motion
                if(vLegX < 0) {
                    totalGroundForceX += -vLegX;
                    legsInStance++;
                    
                    // Visual feedback: Color leg Red (Stance)
                    meshes.thighs[i].mesh.material.diffuseColor = new BABYLON.Color3(1, 0.3, 0.3);
                    meshes.shins[i].material.diffuseColor = new BABYLON.Color3(1, 0.3, 0.3);
                } else {
                     // Visual feedback: Green (Swing)
                    meshes.thighs[i].mesh.material.diffuseColor = new BABYLON.Color3(0.3, 1, 0.3);
                    meshes.shins[i].material.diffuseColor = new BABYLON.Color3(0.3, 1, 0.3);
                }
            } else {
                // Leg in air
                meshes.thighs[i].mesh.material.diffuseColor = new BABYLON.Color3(0.3, 1, 0.3);
                meshes.shins[i].material.diffuseColor = new BABYLON.Color3(0.3, 1, 0.3);
            }
        }

        // Apply movement
        // Simple kinematic walk: if there is at least one leg pushing, move body
        // Scale force by dt
        if(legsInStance > 0) {
            let avgPush = totalGroundForceX / legsInStance; // Average push per leg
            // Move body
            rigRoot.position.x += avgPush * dt * 0.5; // 0.5 is friction coefficient
        }

        // Gravity / Balance check
        // Simple "height maintenance": We keep body Y fixed in this simplified model, 
        // but if legs are too short to reach ground, we scale fitness down?
        // For now, we just measure X distance.
        
        // Camera tracking
        camera.target = new BABYLON.Vector3(rigRoot.position.x, 1, 0);
        camera.alpha = -Math.PI / 2; // Keep side view mostly
        
        return rigRoot.position.x;
    }

    // --- MAIN LOOP ---

    let currentGenome = null;

    engine.runRenderLoop(function () {
        let dt = engine.getDeltaTime() / 1000.0;
        
        // Apply Speed Multiplier
        let simDt = dt * STATE.simSpeed;

        if (STATE.running && !STATE.replaying) {
            // Evolution Mode
            
            if(currentGenome === null || STATE.simTime >= STATE.testDuration) {
                // End of test for current individual
                if(currentGenome !== null) {
                    // Record fitness
                    let dist = rigRoot.position.x;
                    // Penalty for tipping? Hard to detect without physics engine. 
                    // Just using distance for now.
                    STATE.population[STATE.populationIndex].fitness = dist;
                }

                // Next individual
                STATE.populationIndex++;
                if(STATE.populationIndex >= STATE.population.length) {
                    nextGeneration();
                }
                
                // Setup next individual
                currentGenome = STATE.population[STATE.populationIndex].genome;
                resetRig();
                STATE.simTime = 0;
            } else {
                // Update Current Individual
                STATE.simTime += simDt;
                let dist = updateCreature(currentGenome, simDt);
                STATE.currentFitness = dist;
            }
        } else if (STATE.replaying) {
             // Replay Mode
             if(STATE.simTime < STATE.testDuration) {
                 STATE.simTime += simDt;
                 updateCreature(STATE.bestEver.genome, simDt);
                 STATE.currentFitness = rigRoot.position.x;
             } else {
                 // Loop replay
                 STATE.simTime = 0;
                 resetRig();
             }
        }

        // Update UI Live
        document.getElementById('liveDist').innerText = rigRoot.position.x.toFixed(2);
        
        scene.render();
    });

    function resetRig() {
        rigRoot.position.x = 0;
        rigRoot.position.y = CONFIG.bodyY; // Reset height
        rigRoot.position.z = 0;
        rigRoot.rotation.set(0,0,0);
    }

    // --- UI HANDLERS ---

    const btnStartPause = document.getElementById('btnStartPause');
    const btnReplay = document.getElementById('btnReplay');
    const btnReset = document.getElementById('btnReset');
    
    const sliderSpeed = document.getElementById('sliderSpeed');
    const sliderDur = document.getElementById('sliderDur');
    const sliderPop = document.getElementById('sliderPop');
    const sliderMut = document.getElementById('sliderMut');

    // Stats
    const statGen = document.getElementById('statGen');
    const statFit = document.getElementById('statFit');
    const statStatus = document.getElementById('statStatus');

    function updateStats() {
        statGen.innerText = STATE.generation;
        statFit.innerText = STATE.bestFitnessEver.toFixed(2);
    }

    btnStartPause.onclick = () => {
        STATE.replaying = false;
        if(STATE.running) {
            STATE.running = false;
            btnStartPause.innerText = "Resume Evolution";
            statStatus.innerText = "Paused";
            statStatus.style.color = "yellow";
        } else {
            if(STATE.population.length === 0) initPopulation(parseInt(sliderPop.value));
            STATE.running = true;
            btnStartPause.innerText = "Pause Evolution";
            statStatus.innerText = "Running";
            statStatus.style.color = "#00bcd4";
        }
    };

    btnReplay.onclick = () => {
        if(STATE.bestEver) {
            STATE.running = false;
            STATE.replaying = true;
            btnStartPause.innerText = "Resume Evolution";
            statStatus.innerText = "Replaying Best";
            statStatus.style.color = "#ff5252";
            currentGenome = STATE.bestEver.genome;
            resetRig();
            STATE.simTime = 0;
        }
    };

    btnReset.onclick = () => {
        STATE.running = false;
        STATE.replaying = false;
        STATE.bestEver = null;
        STATE.bestFitnessEver = -Infinity;
        btnStartPause.innerText = "Start Evolution";
        statStatus.innerText = "Idle";
        statStatus.style.color = "#fff";
        initPopulation(parseInt(sliderPop.value));
        currentGenome = STATE.population[0].genome;
        resetRig();
    };

    sliderSpeed.oninput = () => {
        STATE.simSpeed = parseInt(sliderSpeed.value);
        document.getElementById('valSpeed').innerText = STATE.simSpeed + "x";
    };

    sliderDur.oninput = () => {
        STATE.testDuration = parseInt(sliderDur.value);
        document.getElementById('valDur').innerText = STATE.testDuration;
    };

    sliderPop.oninput = () => {
        document.getElementById('valPop').innerText = sliderPop.value;
        // Only applies on reset
    };

    sliderMut.oninput = () => {
        document.getElementById('valMut').innerText = sliderMut.value + "%";
    };

    // Initialize
    initPopulation(20);
    currentGenome = STATE.population[0].genome;
    resetRig();

    window.addEventListener("resize", function () {
        engine.resize();
    });

</script>
</body>
</html>