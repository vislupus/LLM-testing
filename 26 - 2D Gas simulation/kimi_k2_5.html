<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Statistical Mechanics: 2D Gas Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #0f172a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        
        /* Custom Scrollbar for GUI */
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: rgba(255,255,255,0.1); }
        .custom-scroll::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius: 3px; }
        
        .glass-panel {
            background: rgba(15, 23, 42, 0.75);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #38bdf8;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }
    </style>
</head>
<body>

    <!-- UI Overlay -->
    <div id="ui-container" class="absolute top-4 left-4 w-80 glass-panel rounded-xl p-5 text-white z-10 transition-opacity duration-300 custom-scroll max-h-[95vh] overflow-y-auto">
        <h1 class="text-xl font-bold mb-1 bg-clip-text text-transparent bg-gradient-to-r from-cyan-400 to-blue-500">Micro to Macro</h1>
        <p class="text-xs text-gray-400 mb-4">2D Ideal Gas & Statistical Mechanics</p>

        <!-- Stats Display -->
        <div class="grid grid-cols-2 gap-2 mb-5 text-sm">
            <div class="bg-white/5 p-2 rounded">
                <div class="text-gray-400 text-xs">Temperature</div>
                <div id="val-temp" class="font-mono text-cyan-300 text-lg">0 K</div>
            </div>
            <div class="bg-white/5 p-2 rounded">
                <div class="text-gray-400 text-xs">Pressure</div>
                <div id="val-press" class="font-mono text-pink-300 text-lg">0 Pa</div>
            </div>
            <div class="bg-white/5 p-2 rounded col-span-2">
                <div class="text-gray-400 text-xs">Total Kinetic Energy</div>
                <div id="val-energy" class="font-mono text-yellow-300">0 J</div>
            </div>
        </div>

        <hr class="border-white/10 mb-4">

        <!-- Controls -->
        <div class="space-y-4">
            <!-- Particle Count -->
            <div>
                <div class="flex justify-between text-xs mb-1">
                    <span>Particles (N)</span>
                    <span id="disp-n" class="text-cyan-400">200</span>
                </div>
                <input type="range" id="input-n" min="50" max="800" step="50" value="200">
            </div>

            <!-- Box Size -->
            <div>
                <div class="flex justify-between text-xs mb-1">
                    <span>Box Size</span>
                    <span id="disp-box" class="text-cyan-400">Medium</span>
                </div>
                <input type="range" id="input-box" min="200" max="600" step="50" value="400">
            </div>

            <!-- Temperature Control (Re-thermalize) -->
            <div>
                <div class="flex justify-between text-xs mb-1">
                    <span>Initial Temp (Speed)</span>
                    <span id="disp-temp" class="text-cyan-400">300 K</span>
                </div>
                <input type="range" id="input-temp" min="50" max="1000" step="10" value="300">
            </div>

            <!-- Mass Ratio -->
            <div>
                <div class="flex justify-between text-xs mb-1">
                    <span>Heavy Particle %</span>
                    <span id="disp-heavy" class="text-cyan-400">20%</span>
                </div>
                <input type="range" id="input-heavy" min="0" max="100" step="5" value="20">
                <div class="flex justify-between text-xs mt-1 px-1">
                    <span class="text-blue-400">● Light (m)</span>
                    <span class="text-red-400">● Heavy (4m)</span>
                </div>
            </div>

            <!-- Toggles -->
            <div class="flex items-center justify-between mt-2">
                <span class="text-sm">Enable Collisions</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="input-collisions" class="sr-only peer" checked>
                    <div class="w-11 h-6 bg-gray-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-cyan-600"></div>
                </label>
            </div>

            <div class="flex gap-2 mt-4">
                <button id="btn-reset" class="flex-1 bg-cyan-600 hover:bg-cyan-500 text-white text-xs font-bold py-2 px-4 rounded transition shadow-lg shadow-cyan-500/30">
                    Reset System
                </button>
                <button id="btn-add" class="flex-1 bg-pink-600 hover:bg-pink-500 text-white text-xs font-bold py-2 px-4 rounded transition shadow-lg shadow-pink-500/30">
                    Add Heat (+)
                </button>
            </div>
        </div>
        
        <div class="mt-4 text-[10px] text-gray-500 text-center">
            Click & Drag particles • Right Click to Remove
        </div>
    </div>

    <!-- P5.js Sketch -->
    <script>
        // --- Configuration & State ---
        const CONFIG = {
            particleRadius: 6,
            lightMass: 1,
            heavyMass: 4,
            baseSpeed: 2,
            gridSize: 40, // Spatial hashing grid size
            maxParticles: 800
        };

        let particles = [];
        let boxWidth = 400;
        let boxHeight = 400;
        let boxX, boxY;
        
        // Statistics
        let temperature = 0;
        let pressure = 0;
        let totalKE = 0;
        let wallImpulse = 0; // Accumulator for pressure calculation
        let speedHist = [];
        let histBins = 30;
        let maxSpeed = 0;

        // UI State
        let targetN = 200;
        let targetTemp = 300;
        let heavyRatio = 0.2;
        let collisionsEnabled = true;
        let paused = false;

        // --- P5.js Lifecycle ---

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(RGB);
            rectMode(CENTER);
            
            boxX = width / 2;
            boxY = height / 2;
            
            initParticles();
            
            // Bind UI
            bindUI();
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            boxX = width / 2;
            boxY = height / 2;
        }

        function draw() {
            background(15, 23, 42); // Slate-900

            // Draw Box
            noFill();
            stroke(255, 255, 255, 50);
            strokeWeight(2);
            rect(boxX, boxY, boxWidth, boxHeight);

            // Update Physics
            if (!paused) {
                // Clear spatial grid
                let grid = createSpatialGrid();
                
                // Resolve Collisions & Wall bounces
                handleCollisions(grid);
                
                // Update Positions
                for (let p of particles) {
                    p.update();
                }
                
                // Calculate Stats
                calculateStats();
            }

            // Draw Particles
            for (let p of particles) {
                p.display();
            }

            // Draw Histogram Overlay (Bottom Right)
            drawHistogram();
            
            // Draw Interactive Cursor
            drawCursor();

            // Update DOM UI
            updateDOM();
        }

        // --- Physics Classes ---

        class Particle {
            constructor(x, y, isHeavy) {
                this.pos = createVector(x, y);
                this.vel = p5.Vector.random2D();
                
                // Mass assignment
                this.mass = isHeavy ? CONFIG.heavyMass : CONFIG.lightMass;
                this.radius = isHeavy ? CONFIG.particleRadius * 1.3 : CONFIG.particleRadius;
                this.color = isHeavy ? color(244, 63, 94) : color(56, 189, 248); // Rose-500 vs Sky-400
                
                // Scale initial speed based on Temp (KE = 0.5mv^2 -> v = sqrt(2T/m))
                let speedScale = sqrt(targetTemp / 100); // arbitrary scaling
                this.vel.mult(CONFIG.baseSpeed * speedScale / sqrt(this.mass));
            }

            update() {
                this.pos.add(this.vel);
                this.handleWalls();
            }

            handleWalls() {
                let halfW = boxWidth / 2;
                let halfH = boxHeight / 2;
                let left = boxX - halfW;
                let right = boxX + halfW;
                let top = boxY - halfH;
                let bottom = boxY + halfH;

                // X Walls
                if (this.pos.x < left + this.radius) {
                    this.pos.x = left + this.radius;
                    this.vel.x *= -1;
                    wallImpulse += 2 * this.mass * abs(this.vel.x);
                } else if (this.pos.x > right - this.radius) {
                    this.pos.x = right - this.radius;
                    this.vel.x *= -1;
                    wallImpulse += 2 * this.mass * abs(this.vel.x);
                }

                // Y Walls
                if (this.pos.y < top + this.radius) {
                    this.pos.y = top + this.radius;
                    this.vel.y *= -1;
                    wallImpulse += 2 * this.mass * abs(this.vel.y);
                } else if (this.pos.y > bottom - this.radius) {
                    this.pos.y = bottom - this.radius;
                    this.vel.y *= -1;
                    wallImpulse += 2 * this.mass * abs(this.vel.y);
                }
            }

            display() {
                noStroke();
                fill(this.color);
                // Add a slight glow
                drawingContext.shadowBlur = 10;
                drawingContext.shadowColor = this.color;
                ellipse(this.pos.x, this.pos.y, this.radius * 2);
                drawingContext.shadowBlur = 0;
            }
        }

        // --- Collision System ---

        function createSpatialGrid() {
            let grid = {};
            let cols = Math.ceil(boxWidth / CONFIG.gridSize);
            let rows = Math.ceil(boxHeight / CONFIG.gridSize);
            
            for (let p of particles) {
                // Map position relative to box top-left to grid coords
                let gx = Math.floor((p.pos.x - (boxX - boxWidth/2)) / CONFIG.gridSize);
                let gy = Math.floor((p.pos.y - (boxY - boxHeight/2)) / CONFIG.gridSize);
                
                // Clamp to bounds just in case
                gx = constrain(gx, 0, cols-1);
                gy = constrain(gy, 0, rows-1);
                
                let key = `${gx},${gy}`;
                if (!grid[key]) grid[key] = [];
                grid[key].push(p);
            }
            return grid;
        }

        function handleCollisions(grid) {
            if (!collisionsEnabled) return;

            // Check neighbors in grid
            for (let key in grid) {
                let [gx, gy] = key.split(',').map(Number);
                let cellParticles = grid[key];
                
                // Neighbor offsets (including self)
                let neighbors = [
                    [0,0], [1,0], [1,1], [0,1], [-1,1],
                    [-1,0], [-1,-1], [0,-1], [1,-1]
                ];

                for (let p of cellParticles) {
                    for (let offset of neighbors) {
                        let nKey = `${gx + offset[0]},${gy + offset[1]}`;
                        if (grid[nKey]) {
                            for (let other of grid[nKey]) {
                                // Avoid double checking
                                if (p === other) continue;
                                if (p.idx < other.idx) continue; // Hack to ensure unique pair check if idx existed, 
                                                                  // but here we rely on spatial proximity
                                resolveCollision(p, other);
                            }
                        }
                    }
                }
            }
        }

        function resolveCollision(p1, p2) {
            let vRel = p5.Vector.sub(p2.pos, p1.pos);
            let dist = vRel.mag();
            let minDist = p1.radius + p2.radius;

            if (dist < minDist) {
                // 1. Position Correction (prevent sinking)
                let n = vRel.copy().normalize();
                let overlap = minDist - dist;
                let correction = n.copy().mult(overlap / 2);
                p1.pos.sub(correction);
                p2.pos.add(correction);

                // 2. Elastic Collision Velocity Update
                // Formula derived from conservation of momentum and kinetic energy
                // v1' = v1 - 2*m2/(m1+m2) * <v1-v2, n> * n
                // Using vector math for general 2D
                
                let relVel = p5.Vector.sub(p1.vel, p2.vel);
                let velAlongNormal = relVel.dot(n);

                // Do not resolve if velocities are separating
                if (velAlongNormal > 0) return;

                let restitution = 1; // Perfectly elastic
                let impulseScalar = -(1 + restitution) * velAlongNormal;
                impulseScalar /= (1 / p1.mass + 1 / p2.mass);

                let impulse = n.mult(impulseScalar);
                
                p1.vel.add(impulse.copy().div(p1.mass));
                p2.vel.sub(impulse.copy().div(p2.mass));
            }
        }

        // --- Statistics & Analysis ---

        function calculateStats() {
            totalKE = 0;
            let speeds = [];
            let speedSum = 0;

            for (let p of particles) {
                let vSq = p.vel.magSq();
                totalKE += 0.5 * p.mass * vSq;
                let v = sqrt(vSq);
                speeds.push(v);
                speedSum += v;
            }

            // Temperature (Avg KE per particle) in simulation units
            // <KE> = (1/2) * k * T (per degree of freedom). In 2D, total KE = N * k * T
            // So T = TotalKE / (N * k). We set k=1 for simulation units.
            if (particles.length > 0) {
                temperature = totalKE / particles.length; 
            } else {
                temperature = 0;
            }

            // Pressure = Force / Perimeter
            // We accumulate impulse over frames. 
            // P = (Sum of Impulses) / (Time * Perimeter)
            // Since we run per frame, time is constant. 
            // Let's smooth it.
            let perimeter = 2 * (boxWidth + boxHeight);
            let instantaneousPressure = wallImpulse / perimeter;
            pressure = lerp(pressure, instantaneousPressure, 0.1); // Smooth
            
            // Reset impulse accumulator
            wallImpulse = 0;

            // Histogram Data
            updateHistogram(speeds);
        }

        function updateHistogram(speeds) {
            if (speeds.length === 0) return;
            
            maxSpeed = max(speeds) * 1.2 || 10;
            let binWidth = maxSpeed / histBins;
            speedHist = new Array(histBins).fill(0);

            for (let s of speeds) {
                let binIdx = Math.floor(s / binWidth);
                if (binIdx >= histBins) binIdx = histBins - 1;
                speedHist[binIdx]++;
            }
        }

        function drawHistogram() {
            let hx = width - 220;
            let hy = height - 180;
            let hw = 200;
            let hh = 150;

            // Background
            fill(15, 23, 42, 200);
            stroke(100);
            rect(hx + hw/2, hy + hh/2, hw, hh);

            // Bars
            noStroke();
            fill(56, 189, 248, 150);
            
            let maxCount = Math.max(...speedHist, 1);
            let binW = hw / histBins;

            for (let i = 0; i < histBins; i++) {
                let h = map(speedHist[i], 0, maxCount, 0, hh - 20);
                rect(hx + i * binW + binW/2, hy + hh - h - 5, binW - 1, h);
            }

            // Maxwell-Boltzmann Curve (2D)
            // f(v) = (m*v / kT) * exp(-m*v^2 / 2kT)
            // In our units, we approximate m_avg ~ 1 or 2 depending on mix
            // Let's normalize the curve to fit the histogram height
            
            stroke(255, 100, 100);
            strokeWeight(2);
            noFill();
            beginShape();
            
            let avgMass = particles.reduce((acc, p) => acc + p.mass, 0) / particles.length || 1;
            let kT = temperature; // T is effectively kT in our units
            
            for (let i = 0; i < hw; i+=5) {
                let v = map(i, 0, hw, 0, maxSpeed);
                // 2D MB Distribution
                // P(v) = (v / (kT/m)) * exp(-v^2 / (2kT/m)) 
                // Wait, simpler form: f(v) = (m/kT) * v * exp(-mv^2/2kT)
                
                let term = (avgMass * v / kT) * Math.exp(-(avgMass * v * v) / (2 * kT));
                
                // Normalize visually
                let displayH = term * (particles.length / maxSpeed) * (hh / 3); 
                // The scaling factor is heuristic to match the visual density
                
                // Only draw if valid
                if (!isNaN(displayH)) {
                    vertex(hx + i, hy + hh - 5 - displayH);
                }
            }
            endShape();

            // Labels
            noStroke();
            fill(200);
            textSize(10);
            textAlign(CENTER);
            text("Speed Distribution", hx + hw/2, hy - 10);
            textAlign(LEFT);
            text("0", hx, hy + hh + 10);
            text(maxSpeed.toFixed(1), hx + hw - 20, hy + hh + 10);
        }

        // --- Interaction & Helpers ---

        function initParticles() {
            particles = [];
            let halfW = boxWidth / 2;
            let halfH = boxHeight / 2;
            let left = boxX - halfW;
            let top = boxY - halfH;

            for (let i = 0; i < targetN; i++) {
                let isHeavy = random() < heavyRatio;
                let x = random(left + 20, left + boxWidth - 20);
                let y = random(top + 20, top + boxHeight - 20);
                
                // Simple check to avoid spawning inside each other
                let safe = true;
                for(let p of particles) {
                    if (dist(x, y, p.pos.x, p.pos.y) < (isHeavy? CONFIG.particleRadius*1.3 : CONFIG.particleRadius) + p.radius + 2) {
                        safe = false;
                        break;
                    }
                }
                
                if(safe) particles.push(new Particle(x, y, isHeavy));
                else i--; // retry
            }
        }

        function mouseDragged() {
            // Check if dragging near a particle to fling it (simple interaction)
            for (let p of particles) {
                if (dist(mouseX, mouseY, p.pos.x, p.pos.y) < p.radius * 3) {
                    let force = createVector(mouseX - pmouseX, mouseY - pmouseY).mult(0.5);
                    p.vel.add(force);
                    // Cap speed to avoid instability
                    p.vel.limit(20);
                    return;
                }
            }
        }
        
        function mousePressed() {
            // Remove particle on right click
            if (mouseButton === RIGHT) {
                for (let i = particles.length - 1; i >= 0; i--) {
                    if (dist(mouseX, mouseY, particles[i].pos.x, particles[i].pos.y) < particles[i].radius * 2) {
                        particles.splice(i, 1);
                        return;
                    }
                }
            }
        }

        function drawCursor() {
            if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {
                noCursor();
                stroke(255, 200);
                noFill();
                ellipse(mouseX, mouseY, 20);
                
                if (mouseIsPressed && mouseButton === LEFT) {
                    line(mouseX, mouseY, pmouseX, pmouseY);
                }
            } else {
                cursor(ARROW);
            }
        }

        // --- UI Binding ---

        function bindUI() {
            const elN = document.getElementById('input-n');
            const elBox = document.getElementById('input-box');
            const elTemp = document.getElementById('input-temp');
            const elHeavy = document.getElementById('input-heavy');
            const elCol = document.getElementById('input-collisions');
            const btnReset = document.getElementById('btn-reset');
            const btnAdd = document.getElementById('btn-add');

            elN.addEventListener('input', (e) => {
                targetN = parseInt(e.target.value);
                document.getElementById('disp-n').innerText = targetN;
            });
            
            // Debounce reset for N changes to avoid spamming
            elN.addEventListener('change', initParticles);

            elBox.addEventListener('input', (e) => {
                let val = parseInt(e.target.value);
                boxWidth = val;
                boxHeight = val;
                document.getElementById('disp-box').innerText = val + "px";
                // Keep particles inside if box shrinks
                for(let p of particles) {
                    p.pos.x = constrain(p.pos.x, boxX - boxWidth/2 + p.radius, boxX + boxWidth/2 - p.radius);
                    p.pos.y = constrain(p.pos.y, boxY - boxHeight/2 + p.radius, boxY + boxHeight/2 - p.radius);
                }
            });

            elTemp.addEventListener('input', (e) => {
                targetTemp = parseInt(e.target.value);
                document.getElementById('disp-temp').innerText = targetTemp + " K";
            });

            elHeavy.addEventListener('input', (e) => {
                heavyRatio = parseInt(e.target.value) / 100;
                document.getElementById('disp-heavy').innerText = e.target.value + "%";
            });
            elHeavy.addEventListener('change', initParticles);

            elCol.addEventListener('change', (e) => {
                collisionsEnabled = e.target.checked;
            });

            btnReset.addEventListener('click', initParticles);

            btnAdd.addEventListener('click', () => {
                // Add thermal energy
                for (let p of particles) {
                    let boost = p5.Vector.random2D().mult(2);
                    p.vel.add(boost);
                }
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    paused = !paused;
                }
            });
        }

        function updateDOM() {
            // Only update DOM periodically to save performance
            if (frameCount % 5 === 0) {
                document.getElementById('val-temp').innerText = temperature.toFixed(1) + " K";
                document.getElementById('val-press').innerText = pressure.toFixed(2) + " u";
                document.getElementById('val-energy').innerText = totalKE.toFixed(1) + " J";
            }
        }

    </script>
</body>
</html>