<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Gas Simulation & Statistical Mechanics</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --panel-bg: #2d2d2d;
            --text-color: #e0e0e0;
            --accent-color: #4caf50;
            --highlight-color: #2196f3;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #canvas-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            position: relative;
        }

        #controls {
            width: 320px;
            background-color: var(--panel-bg);
            padding: 20px;
            box-shadow: -2px 0 10px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
        }

        h2, h3 { margin: 0 0 10px 0; border-bottom: 1px solid #444; padding-bottom: 5px; }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label { font-size: 0.9rem; font-weight: 600; }
        
        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

        .val-display {
            font-size: 0.8rem;
            color: #aaa;
            text-align: right;
        }

        button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        button:hover { background-color: #43a047; }
        button.secondary { background-color: #555; }
        button.secondary:hover { background-color: #666; }

        .stats-panel {
            background: #222;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9rem;
        }

        .stat-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .stat-val { color: var(--highlight-color); }

        canvas {
            background: #000;
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 4px;
        }

        /* Overlay stats on canvas if needed, but we use sidebar for stats */
    </style>
</head>
<body>

    <div id="canvas-container">
        <!-- p5.js canvas will be injected here -->
    </div>

    <div id="controls">
        <h2>Controls</h2>

        <div class="control-group">
            <label for="sliderN">Particle Count (N)</label>
            <input type="range" id="sliderN" min="10" max="300" value="100">
            <div class="val-display" id="valN">100</div>
        </div>

        <div class="control-group">
            <label for="sliderTemp">Initial Temperature (Speed)</label>
            <input type="range" id="sliderTemp" min="1" max="10" step="0.5" value="3">
            <div class="val-display" id="valTemp">3.0</div>
        </div>

        <div class="control-group">
            <label for="sliderRatio">Mass Ratio (Heavy/Light)</label>
            <input type="range" id="sliderRatio" min="1" max="10" step="1" value="1">
            <div class="val-display" id="valRatio">1:1 (Single Species)</div>
        </div>

        <div class="control-group">
            <label for="sliderBox">Box Width</label>
            <input type="range" id="sliderBox" min="200" max="600" step="10" value="500">
            <div class="val-display" id="valBox">500 px</div>
        </div>

        <div class="control-group">
            <button id="btnToggleCollisions" class="secondary">Collisions: ON</button>
            <button id="btnReset">Reset Simulation</button>
        </div>

        <h3>Real-time Stats</h3>
        <div class="stats-panel">
            <div class="stat-row"><span>Total Energy:</span> <span id="statEnergy" class="stat-val">0.0</span></div>
            <div class="stat-row"><span>Temperature (T):</span> <span id="statTemp" class="stat-val">0.0</span></div>
            <div class="stat-row"><span>Pressure (P):</span> <span id="statPressure" class="stat-val">0.0</span></div>
            <div class="stat-row"><span>Speed (Avg):</span> <span id="statSpeed" class="stat-val">0.0</span></div>
        </div>

        <div style="font-size: 0.8rem; color: #888; margin-top: 10px;">
            <strong>Legend:</strong><br>
            <span style="color: #4fc3f7">● Light Species</span><br>
            <span style="color: #ff5252">● Heavy Species</span><br>
            Yellow Line: Theoretical Maxwell-Boltzmann (2D)
        </div>
    </div>

    <script>
        // --- GLOBAL VARIABLES ---
        let particles = [];
        let boxWidth = 500;
        let boxHeight = 400; // Fixed height for the simulation box
        let canvasWidth = 800;
        let canvasHeight = 700; // Extra space for histogram
        
        // Physics Parameters
        let numParticles = 100;
        let baseSpeed = 3;
        let massRatio = 1;
        let collisionsEnabled = true;
        let baseMass = 1;
        let radius = 5;
        
        // Stats & Analysis
        let impulseAccumulator = 0; // For pressure calculation
        let historyLength = 60; // Frames to average pressure
        let impulseHistory = [];
        let totalKE = 0;
        let totalTemp = 0;
        
        // UI Elements
        let sliderN, sliderTemp, sliderRatio, sliderBox;
        let btnToggle, btnReset;
        let statEnergy, statTemp, statPressure, statSpeed;

        // --- P5.JS SETUP ---
        function setup() {
            // Create canvas in the container
            const container = document.getElementById('canvas-container');
            const cnv = createCanvas(canvasWidth, canvasHeight);
            cnv.parent('canvas-container');
            
            // Link UI elements
            sliderN = document.getElementById('sliderN');
            sliderTemp = document.getElementById('sliderTemp');
            sliderRatio = document.getElementById('sliderRatio');
            sliderBox = document.getElementById('sliderBox');
            btnToggle = document.getElementById('btnToggleCollisions');
            btnReset = document.getElementById('btnReset');
            
            // Stats elements
            statEnergy = document.getElementById('statEnergy');
            statTemp = document.getElementById('statTemp');
            statPressure = document.getElementById('statPressure');
            statSpeed = document.getElementById('statSpeed');

            // Event Listeners for UI
            sliderN.oninput = () => updateParam('N');
            sliderTemp.oninput = () => updateParam('Temp');
            sliderRatio.oninput = () => updateParam('Ratio');
            sliderBox.oninput = () => updateParam('Box');
            
            btnToggle.onclick = () => {
                collisionsEnabled = !collisionsEnabled;
                btnToggle.innerText = `Collisions: ${collisionsEnabled ? "ON" : "OFF"}`;
                btnToggle.style.backgroundColor = collisionsEnabled ? "#555" : "#d32f2f";
            };

            btnReset.onclick = initSimulation;

            initSimulation();
        }

        // --- INITIALIZATION ---
        function initSimulation() {
            particles = [];
            boxWidth = parseInt(sliderBox.value);
            numParticles = parseInt(sliderN.value);
            baseSpeed = parseFloat(sliderTemp.value);
            massRatio = parseInt(sliderRatio.value);
            
            // Update UI Labels
            document.getElementById('valN').innerText = numParticles;
            document.getElementById('valTemp').innerText = baseSpeed.toFixed(1);
            document.getElementById('valBox').innerText = boxWidth + " px";
            document.getElementById('valRatio').innerText = massRatio === 1 ? "1:1 (Single Species)" : `${massRatio}:1 (Mixture)`;

            // Create Particles
            for (let i = 0; i < numParticles; i++) {
                let isHeavy = (massRatio > 1) && (i % 2 === 0); // 50/50 split if ratio > 1
                let m = isHeavy ? baseMass * massRatio : baseMass;
                let r = isHeavy ? radius * 1.2 : radius; // Slightly larger visual for heavy
                let c = isHeavy ? color(255, 82, 82) : color(79, 195, 247); // Red vs Blue
                
                // Find non-overlapping position
                let x, y, overlap;
                let attempts = 0;
                do {
                    overlap = false;
                    x = random(r, boxWidth - r);
                    y = random(r, boxHeight - r);
                    for (let other of particles) {
                        let d = dist(x, y, other.pos.x, other.pos.y);
                        if (d < r + other.r) {
                            overlap = true;
                            break;
                        }
                    }
                    attempts++;
                } while (overlap && attempts < 100);

                // Initialize velocity randomly with direction and magnitude based on Temp
                // v ~ sqrt(T/m). We treat baseSpeed as a proxy for T.
                // Let's normalize speed distribution initially to be uniform direction, but magnitude ~ 1/sqrt(m) for same KE,
                // or same speed for simplicity. Let's do same KE roughly.
                // KE = 0.5 * m * v^2. v = sqrt(2*KE/m).
                // We assign a random unit vector.
                let angle = random(TWO_PI);
                let speed = baseSpeed / sqrt(m/baseMass) * random(0.8, 1.2); // Add some jitter
                let vx = cos(angle) * speed;
                let vy = sin(angle) * speed;

                particles.push(new Particle(x, y, vx, vy, m, r, c));
            }
            
            // Reset stats
            impulseHistory = new Array(historyLength).fill(0);
        }

        function updateParam(param) {
            if (param === 'Box') {
                boxWidth = parseInt(sliderBox.value);
                document.getElementById('valBox').innerText = boxWidth + " px";
                // Push particles inside if box shrinks
                particles.forEach(p => {
                    p.pos.x = constrain(p.pos.x, p.r, boxWidth - p.r);
                });
            } else if (param === 'N' || param === 'Temp' || param === 'Ratio') {
                // These require a reset to make sense physically without breaking the state
                initSimulation();
            }
        }

        // --- MAIN LOOP ---
        function draw() {
            background(20);
            
            // 1. Draw Simulation Box
            stroke(100);
            strokeWeight(2);
            noFill();
            rect(0, 0, boxWidth, boxHeight);
            
            // 2. Update and Draw Particles
            let currentKE = 0;
            let totalSpeed = 0;
            impulseAccumulator = 0;

            for (let p of particles) {
                p.move();
                p.checkWalls();
                currentKE += 0.5 * p.m * p.vel.magSq();
                totalSpeed += p.vel.mag();
                p.show();
            }

            // 3. Handle Particle-Particle Collisions
            if (collisionsEnabled) {
                handleCollisions();
            }

            // 4. Analysis & Stats
            totalKE = currentKE;
            // Temperature T is proportional to Average KE. 
            // In 2D: KE_avg = k_B * T. So we set k_B = 1 for display purposes.
            // T = TotalKE / N
            totalTemp = totalKE / numParticles;
            
            // Pressure: Average Force / Perimeter. Force = Impulse / Time.
            // We accumulate impulse over 1 frame.
            impulseHistory.push(impulseAccumulator);
            if (impulseHistory.length > historyLength) impulseHistory.shift();
            
            let avgImpulsePerFrame = impulseHistory.reduce((a, b) => a + b, 0) / impulseHistory.length;
            let perimeter = 2 * (boxWidth + boxHeight);
            let pressure = avgImpulsePerFrame / perimeter; // This is a dimensionless proxy for P

            // Update DOM elements
            statEnergy.innerText = totalKE.toFixed(1);
            statTemp.innerText = totalTemp.toFixed(2);
            statPressure.innerText = pressure.toFixed(3);
            statSpeed.innerText = (totalSpeed / numParticles).toFixed(2);

            // 5. Draw Histogram (Below the box)
            drawHistogram();
        }

        // --- PHYSICS FUNCTIONS ---

        class Particle {
            constructor(x, y, vx, vy, m, r, c) {
                this.pos = createVector(x, y);
                this.vel = createVector(vx, vy);
                this.m = m;
                this.r = r;
                this.c = c;
            }

            move() {
                this.pos.add(this.vel);
            }

            checkWalls() {
                let hit = false;
                let impulse = 0;

                // Left/Right Walls
                if (this.pos.x < this.r) {
                    this.pos.x = this.r;
                    this.vel.x *= -1;
                    hit = true;
                } else if (this.pos.x > boxWidth - this.r) {
                    this.pos.x = boxWidth - this.r;
                    this.vel.x *= -1;
                    hit = true;
                }

                // Top/Bottom Walls
                if (this.pos.y < this.r) {
                    this.pos.y = this.r;
                    this.vel.y *= -1;
                    hit = true;
                } else if (this.pos.y > boxHeight - this.r) {
                    this.pos.y = boxHeight - this.r;
                    this.vel.y *= -1;
                    hit = true;
                }

                if (hit) {
                    // Impulse = change in momentum = 2 * mass * velocity_perpendicular
                    // Since we reflect, delta_v = 2 * v. Delta_p = m * 2 * v.
                    // We approximate using total speed magnitude for simplicity in scalar pressure calc
                    // or use the component. Let's use the magnitude of the component that flipped.
                    // But actually, since we flipped velocity in the loop, we can't easily tell the previous component.
                    // However, J = |m(v_final - v_initial)|. |v_final| = |v_initial|.
                    // So J = 2 * m * |v_component|.
                    // Since we reversed one axis, |v_component| is just the abs of that axis velocity *before* flip.
                    // Wait, we already flipped it in the code above.
                    // Simple approximation: 2 * m * total_speed is an overestimate.
                    // Better: Use the component we just flipped. 
                    // Actually, easiest way: calculate impulse BEFORE flipping, or infer.
                    // Let's assume perfectly elastic: |v_out| = |v_in|.
                    // J = 2 * m * |v_in_perp|.
                    
                    // Let's accumulate a simplified impulse proportional to energy transfer
                    // In a hard wall bounce, the impulse on the wall is 2 * m * |v_normal|.
                    // Since we flipped it, let's just use 2 * m * (velocity magnitude of the axis flipped)
                    // We need to know which axis.
                    // If x flipped, add 2*m*|vx|.
                    
                    // To make this robust in this simple script, let's just use:
                    // Impulse added this frame = 2 * m * speed (rough upper bound) 
                    // OR, simpler logic: The code above flipped the velocity. 
                    // The component involved is the absolute value of the velocity (magnitude of that axis).
                    // Since we already flipped, we need to look at the absolute value.
                    
                    // Re-logic for accurate pressure:
                    // It's easier to calculate impulse before flipping, but for compactness:
                    // The change in momentum for the particle is -2 * m * v_perp.
                    // Wall gets +2 * m * v_perp.
                    // We can assume that on average, the energy is distributed equally to axes (equipartition).
                    // So we can estimate J = 2 * m * (v_mag / sqrt(2)).
                    // Let's just use J = 2 * m * speed for a simpler "Pressure" readout that correlates strongly with T.
                    impulse = 2 * this.m * this.vel.mag(); 
                    impulseAccumulator += impulse;
                }
            }

            show() {
                noStroke();
                fill(this.c);
                ellipse(this.pos.x, this.pos.y, this.r * 2);
            }
        }

        function handleCollisions() {
            // O(N^2) loop. Acceptable for N < 300 in JS.
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    let p1 = particles[i];
                    let p2 = particles[j];

                    // Check distance
                    let dx = p2.pos.x - p1.pos.x;
                    let dy = p2.pos.y - p1.pos.y;
                    let distSq = dx*dx + dy*dy;
                    let minDist = p1.r + p2.r;

                    if (distSq < minDist * minDist) {
                        let dist = sqrt(distSq);
                        
                        // Normal vector
                        let nx = dx / dist;
                        let ny = dy / dist;

                        // Relative velocity
                        let dvx = p1.vel.x - p2.vel.x;
                        let dvy = p1.vel.y - p2.vel.y;

                        // Velocity along normal
                        let vn = dvx * nx + dvy * ny;

                        // If moving away, don't resolve
                        if (vn > 0) continue;

                        // Elastic Collision Impulse (1D formula along normal)
                        // J = -(1 + e) * vn / (1/m1 + 1/m2)
                        // For elastic e=1
                        let impulseScalar = (-2 * vn) / (1/p1.m + 1/p2.m);

                        let impulseX = impulseScalar * nx;
                        let impulseY = impulseScalar * ny;

                        // Update velocities
                        p1.vel.x += impulseX / p1.m;
                        p1.vel.y += impulseY / p1.m;
                        p2.vel.x -= impulseX / p2.m;
                        p2.vel.y -= impulseY / p2.m;

                        // Positional Correction (prevent sticking)
                        // Move particles apart so they just touch
                        let overlap = minDist - dist;
                        let mTotal = p1.m + p2.m;
                        let moveRatio1 = p2.m / mTotal; // Inverse mass weighting? Actually simpler:
                        // Move lighter particle more.
                        // displacement = overlap * normal_vector
                        // p1 moves -disp * (m2 / sum)
                        // p2 moves +disp * (m1 / sum)
                        let d1 = overlap * (p2.m / mTotal);
                        let d2 = overlap * (p1.m / mTotal);
                        
                        p1.pos.x -= nx * d1;
                        p1.pos.y -= ny * d1;
                        p2.pos.x += nx * d2;
                        p2.pos.y += ny * d2;
                    }
                }
            }
        }

        // --- VISUALIZATION HELPER ---

        function drawHistogram() {
            // Setup histogram area below the box
            let histX = 50;
            let histY = boxHeight + 20;
            let histW = boxWidth;
            let histH = canvasHeight - boxHeight - 40;
            
            // Background
            fill(30);
            stroke(50);
            rect(histX, histY, histW, histH);
            
            // Axes
            stroke(200);
            line(histX, histY + histH, histX + histW, histY + histH); // X
            line(histX, histY, histX, histY + histH); // Y
            
            // Binning
            let numBins = 40;
            let maxSpeed = 15; // Fixed x-axis range for stability
            let bins = new Array(numBins).fill(0);
            let speeds = [];

            for (let p of particles) {
                let s = p.vel.mag();
                speeds.push(s);
                let binIdx = floor(map(s, 0, maxSpeed, 0, numBins));
                if (binIdx >= 0 && binIdx < numBins) {
                    bins[binIdx]++;
                }
            }

            // Find max bin for scaling
            let maxCount = 0;
            for (let b of bins) if (b > maxCount) maxCount = b;
            if (maxCount === 0) maxCount = 1;

            // Draw Bars
            let barW = (histW / numBins);
            noStroke();
            for (let i = 0; i < numBins; i++) {
                let h = map(bins[i], 0, maxCount * 1.2, 0, histH); // 1.2 padding
                let x = histX + i * barW;
                let y = histY + histH - h;
                
                // Gradient color based on speed
                let inter = map(i, 0, numBins, 0, 1);
                fill(lerpColor(color(79, 195, 247), color(255, 82, 82), inter));
                rect(x + 1, y, barW - 2, h);
            }

            // Draw Theoretical Curve (2D Maxwell-Boltzmann / Rayleigh Distribution)
            // PDF: f(v) = (m*v / (k*T)) * exp(-m*v^2 / (2*k*T))
            // In our units, k=1. m is average mass? Or specific?
            // Since we have a mixture, the histogram is a sum of distributions.
            // We will plot the theoretical curve for the AVERAGE mass of the system for visual reference.
            let avgMass = particles.reduce((sum, p) => sum + p.m, 0) / particles.length;
            // Avoid division by zero
            if (avgMass < 0.1) avgMass = 1; 
            if (totalTemp < 0.1) totalTemp = 1;

            stroke(255, 235, 59); // Yellow
            strokeWeight(2);
            noFill();
            beginShape();
            for (let i = 0; i < numBins; i++) {
                let v = map(i + 0.5, 0, numBins, 0, maxSpeed);
                
                // Theoretical probability density
                let lambda = 1 / totalTemp; // 1/kT
                let theoryY = (avgMass * v / totalTemp) * exp(-avgMass * v*v / (2 * totalTemp));
                
                // Scale theory to match histogram height
                // Histogram height is Count = TotalParticles * BinWidth * PDF(v)
                // BinWidth in speed units = maxSpeed / numBins
                let expectedCount = numParticles * (maxSpeed / numBins) * theoryY;
                
                let plotH = map(expectedCount, 0, maxCount * 1.2, 0, histH);
                let plotX = histX + i * barW + barW/2;
                let plotY = histY + histH - plotH;
                vertex(plotX, plotY);
            }
            endShape();
            
            // Labels
            fill(200);
            noStroke();
            textSize(12);
            textAlign(CENTER);
            text("Speed Distribution", histX + histW/2, histY - 10);
            text("0", histX, histY + histH + 15);
            text("Max Speed", histX + histW, histY + histH + 15);
        }

    </script>
</body>
</html>