<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2D Gas Simulation – p5.js Statistical Mechanics Demo</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #0b0f19;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #eee;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
      display: block;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(15, 20, 35, 0.88);
      border-radius: 8px;
      padding: 12px 14px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.45);
      font-size: 12px;
      max-width: 320px;
    }
    #controls h2 {
      margin: 0 0 6px 0;
      font-size: 15px;
      color: #ffcc66;
    }
    #controls .row {
      margin: 4px 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
    }
    #controls label {
      flex: 1 1 auto;
      font-size: 11px;
    }
    #controls input[type=range] {
      flex: 1 1 auto;
    }
    #controls input[type=checkbox] {
      margin-left: 4px;
    }
    #controls button {
      width: 100%;
      padding: 4px 0;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: #2d7dff;
      color: #fff;
      font-weight: 600;
      font-size: 12px;
    }
    #controls button:hover {
      background: #4e94ff;
    }
    #controls .small {
      font-size: 10px;
      color: #aaa;
      margin-top: 4px;
    }
    #controls .value {
      color: #80d4ff;
      font-variant-numeric: tabular-nums;
      padding-left: 4px;
    }
  </style>
</head>
<body>

<div id="controls">
  <h2>2D Gas – Elastic Collisions</h2>

  <div class="row">
    <label>Particles N: <span id="particlesLabel" class="value">200</span></label>
    <input type="range" id="particlesSlider" min="20" max="400" step="10" value="200">
  </div>

  <div class="row">
    <label>Initial temperature T₀: <span id="tempLabel" class="value">2.0</span></label>
    <input type="range" id="tempSlider" min="0.2" max="5" step="0.1" value="2.0">
  </div>

  <div class="row">
    <label>Box size (relative): <span id="boxLabel" class="value">0.80</span></label>
    <input type="range" id="boxSlider" min="0.4" max="1.0" step="0.05" value="0.8">
  </div>

  <div class="row">
    <label>Light mass m₁: <span id="mass1Label" class="value">1.0</span></label>
    <input type="range" id="mass1Slider" min="0.5" max="5" step="0.1" value="1.0">
  </div>

  <div class="row">
    <label>Mass ratio m₂/m₁: <span id="massRatioLabel" class="value">4.0</span></label>
    <input type="range" id="massRatioSlider" min="1" max="8" step="0.5" value="4">
  </div>

  <div class="row">
    <label>Radius (light): <span id="radiusLabel" class="value">5</span> px</label>
    <input type="range" id="radiusSlider" min="3" max="12" step="1" value="5">
  </div>

  <div class="row">
    <label>Collisions enabled</label>
    <input type="checkbox" id="collisionsCheckbox" checked>
  </div>

  <div class="row">
    <button id="resetButton">Reset / Apply parameters (R)</button>
  </div>

  <div class="row small">
    Keyboard: [R] reset, [C] toggle collisions, [Space] pause
  </div>
</div>

<script>
  // --- Global simulation parameters and state ---

  let particles = [];
  let numParticles = 200;
  let initialTemperature = 2.0; // dimensionless, k_B = 1
  let boxSizeFactor = 0.8;      // fraction of max square size
  let massLight = 1.0;
  let massRatio = 4.0;
  let radiusLight = 5;

  let boxLeft, boxTop, boxWidth, boxHeight;
  let histLeft, histTop, histWidth, histHeight;

  let collisionsEnabled = true;
  let paused = false;

  let totalKinetic = 0;
  let tempKinetic = 0;
  let totalImpulse = 0; // Sum of |Δp| on all walls
  let simTime = 0;
  let pressure = 0;

  let numLight = 0;
  let numHeavy = 0;

  // Histogram data
  const HIST_BINS = 40;
  let histCounts = new Array(HIST_BINS).fill(0);
  let histMax = 1;
  let histVmax = 1;
  let histUpdateCounter = 0;

  // UI elements
  let particlesSlider, tempSlider, boxSlider, mass1Slider, massRatioSlider,
      radiusSlider, collisionsCheckbox, resetButton;

  let particlesLabel, tempLabel, boxLabel, mass1Label, massRatioLabel, radiusLabel;

  // --- Particle class ---

  class Particle {
    constructor(x, y, vx, vy, r, m, type) {
      this.x = x;
      this.y = y;
      this.vx = vx;
      this.vy = vy;
      this.r = r;
      this.m = m;
      this.type = type; // 0 = light, 1 = heavy
    }
  }

  // --- Utility: Gaussian random (Box-Muller) ---

  function gaussianPair(sigma) {
    const u1 = Math.random();
    const u2 = Math.random();
    const mag = sigma * Math.sqrt(-2 * Math.log(u1));
    const z0 = mag * Math.cos(2 * Math.PI * u2);
    const z1 = mag * Math.sin(2 * Math.PI * u2);
    return [z0, z1];
  }

  // --- Layout for box and histogram panels ---

  function updateLayout() {
    const margin = 50;
    const panelGap = 40;

    const availW = windowWidth - 2 * margin;
    const availH = windowHeight - 2 * margin;

    // Square simulation box
    const maxBoxSide = Math.min(availW * 0.6, availH * 0.7);
    const side = maxBoxSide * boxSizeFactor;

    boxWidth = side;
    boxHeight = side;
    boxLeft = margin;
    boxTop = margin;

    // Default: histogram to the right of the box
    histLeft = boxLeft + boxWidth + panelGap;
    histTop = boxTop;
    histWidth = windowWidth - histLeft - margin;
    histHeight = boxHeight;

    // If not enough width, place histogram below
    if (histWidth < 160) {
      histLeft = margin;
      histTop = boxTop + boxHeight + panelGap;
      histWidth = windowWidth - 2 * margin;
      histHeight = Math.max(140, availH * 0.25);
    }
  }

  // --- Simulation reset / initialization ---

  function resetSimulation() {
    particles = [];
    totalKinetic = 0;
    tempKinetic = 0;
    totalImpulse = 0;
    simTime = 0;
    pressure = 0;

    numLight = Math.floor(numParticles / 2);
    numHeavy = numParticles - numLight;

    const massHeavy = massLight * massRatio;

    // Radii: scale heavy radius roughly with cube root of mass ratio
    const radiusHeavy = radiusLight * Math.cbrt(massRatio);

    // Make sure particles fit reasonably
    const maxRadius = Math.max(radiusLight, radiusHeavy);
    const minX = boxLeft + maxRadius + 1;
    const maxX = boxLeft + boxWidth - maxRadius - 1;
    const minY = boxTop + maxRadius + 1;
    const maxY = boxTop + boxHeight - maxRadius - 1;

    const T0 = initialTemperature; // dimensionless, k_B = 1

    // Precompute velocity std dev for each species (Maxwell-Boltzmann in 2D)
    const sigmaLight = Math.sqrt(T0 / massLight);
    const sigmaHeavy = Math.sqrt(T0 / massHeavy);

    function placeParticle(m, r, type) {
      let x, y;
      let attempts = 0;
      let ok = false;
      while (!ok && attempts < 2000) {
        x = minX + Math.random() * (maxX - minX);
        y = minY + Math.random() * (maxY - minY);
        ok = true;
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          const dx = x - p.x;
          const dy = y - p.y;
          const dist2 = dx * dx + dy * dy;
          const minDist = r + p.r;
          if (dist2 < minDist * minDist) {
            ok = false;
            break;
          }
        }
        attempts++;
      }
      if (!ok) {
        // Give up on non-overlap if too dense; collisions will sort it out
        x = minX + Math.random() * (maxX - minX);
        y = minY + Math.random() * (maxY - minY);
      }

      const sigma = type === 0 ? sigmaLight : sigmaHeavy;
      const [vx, vy] = gaussianPair(sigma);
      return new Particle(x, y, vx, vy, r, m, type);
    }

    // Create light particles
    for (let i = 0; i < numLight; i++) {
      particles.push(placeParticle(massLight, radiusLight, 0));
    }
    // Create heavy particles
    for (let i = 0; i < numHeavy; i++) {
      particles.push(placeParticle(massHeavy, radiusHeavy, 1));
    }

    updateHistogram();
  }

  // --- Physics step: walls + particle collisions ---

  function stepSimulation(dt) {
    simTime += dt;

    const left = boxLeft;
    const right = boxLeft + boxWidth;
    const top = boxTop;
    const bottom = boxTop + boxHeight;

    // Move and wall collisions
    for (let p of particles) {
      p.x += p.vx * dt;
      p.y += p.vy * dt;

      // Left/right walls (normal in x)
      if (p.x - p.r < left) {
        const vBefore = p.vx;
        p.x = left + p.r;
        p.vx = -p.vx;
        totalImpulse += 2 * p.m * Math.abs(vBefore);
      } else if (p.x + p.r > right) {
        const vBefore = p.vx;
        p.x = right - p.r;
        p.vx = -p.vx;
        totalImpulse += 2 * p.m * Math.abs(vBefore);
      }

      // Top/bottom walls (normal in y)
      if (p.y - p.r < top) {
        const vBefore = p.vy;
        p.y = top + p.r;
        p.vy = -p.vy;
        totalImpulse += 2 * p.m * Math.abs(vBefore);
      } else if (p.y + p.r > bottom) {
        const vBefore = p.vy;
        p.y = bottom - p.r;
        p.vy = -p.vy;
        totalImpulse += 2 * p.m * Math.abs(vBefore);
      }
    }

    // Particle-particle collisions
    if (collisionsEnabled) {
      const n = particles.length;
      for (let i = 0; i < n; i++) {
        const p1 = particles[i];
        for (let j = i + 1; j < n; j++) {
          const p2 = particles[j];
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const rad = p1.r + p2.r;
          const dist2 = dx * dx + dy * dy;
          if (dist2 < rad * rad) {
            const dist = Math.sqrt(dist2) || rad;
            const nx = dx / dist;
            const ny = dy / dist;

            // Relative velocity along normal
            const dvx = p1.vx - p2.vx;
            const dvy = p1.vy - p2.vy;
            const relVel = dvx * nx + dvy * ny;

            // Only resolve if approaching
            if (relVel > 0) continue;

            // Separate them to avoid sinking
            const overlap = rad - dist;
            const m1 = p1.m;
            const m2 = p2.m;
            const invMassSum = 1 / (m1 + m2);
            p1.x -= nx * overlap * (m2 * invMassSum);
            p1.y -= ny * overlap * (m2 * invMassSum);
            p2.x += nx * overlap * (m1 * invMassSum);
            p2.y += ny * overlap * (m1 * invMassSum);

            // Elastic collision along normal (conserving momentum & KE)
            const impulse = (2 * relVel) / (1 / m1 + 1 / m2); // negative
            p1.vx -= (impulse / m1) * nx;
            p1.vy -= (impulse / m1) * ny;
            p2.vx += (impulse / m2) * nx;
            p2.vy += (impulse / m2) * ny;
          }
        }
      }
    }

    updateMacros();
    if (histUpdateCounter++ % 3 === 0) {
      updateHistogram();
    }
  }

  // --- Macroscopic quantities: temperature and pressure ---

  function updateMacros() {
    totalKinetic = 0;
    for (let p of particles) {
      const v2 = p.vx * p.vx + p.vy * p.vy;
      totalKinetic += 0.5 * p.m * v2;
    }
    tempKinetic = particles.length > 0 ? totalKinetic / particles.length : 0; // 2D: ⟨K⟩ = k_B T, with k_B=1

    if (simTime > 0) {
      const perimeter = 2 * (boxWidth + boxHeight); // in px → arbitrary units
      pressure = totalImpulse / (simTime * perimeter);
    } else {
      pressure = 0;
    }
  }

  // --- Histogram of speed distribution ---

  function updateHistogram() {
    histCounts = new Array(HIST_BINS).fill(0);
    let maxSpeed = 0;

    if (particles.length === 0) {
      histMax = 1;
      histVmax = 1;
      return;
    }

    const speeds = [];
    for (let p of particles) {
      const v = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
      speeds.push(v);
      if (v > maxSpeed) maxSpeed = v;
    }

    if (maxSpeed < 1e-6) maxSpeed = 1;
    histVmax = maxSpeed;

    for (let v of speeds) {
      let idx = Math.floor((v / histVmax) * HIST_BINS);
      if (idx >= HIST_BINS) idx = HIST_BINS - 1;
      histCounts[idx]++;
    }

    histMax = 1;
    for (let c of histCounts) {
      if (c > histMax) histMax = c;
    }
  }

  // --- Drawing helpers ---

  function drawBox() {
    stroke(200);
    strokeWeight(2);
    noFill();
    rect(boxLeft, boxTop, boxWidth, boxHeight);
  }

  function drawParticles() {
    noStroke();
    for (let p of particles) {
      if (p.type === 0) {
        fill(90, 180, 255); // light
      } else {
        fill(255, 170, 90); // heavy
      }
      ellipse(p.x, p.y, 2 * p.r, 2 * p.r);
    }
  }

  function drawHistogram() {
    if (histWidth <= 0 || histHeight <= 0) return;

    const left = histLeft;
    const top = histTop;
    const w = histWidth;
    const h = histHeight;

    // Background
    noStroke();
    fill(10, 15, 30, 200);
    rect(left, top, w, h);

    // Axes
    stroke(160);
    strokeWeight(1);
    line(left, top + h - 18, left + w, top + h - 18); // x-axis (speed)
    line(left + 25, top + 5, left + 25, top + h - 18); // y-axis (counts)

    // Labels
    noStroke();
    fill(230);
    textSize(11);
    text("Speed distribution", left + 4, top + 14);
    textSize(9);
    text("speed", left + w - 36, top + h - 6);
    push();
    translate(left + 10, top + 60);
    rotate(-Math.PI / 2);
    text("counts", 0, 0);
    pop();

    if (!histCounts || histCounts.length === 0) return;

    // Bars
    const usableH = h - 30;
    const barAreaLeft = left + 25;
    const barAreaWidth = w - 35;
    const barWidth = barAreaWidth / HIST_BINS;

    for (let i = 0; i < HIST_BINS; i++) {
      const c = histCounts[i];
      const barH = (c / histMax) * usableH;
      const x = barAreaLeft + i * barWidth;
      const y = top + h - 18 - barH;
      noStroke();
      fill(100, 170, 255, 160);
      rect(x, y, barWidth, barH);
    }

    // Theoretical Maxwell–Boltzmann (2D) curve overlay
    if (tempKinetic > 1e-4 && histVmax > 1e-6) {
      const steps = 120;
      const dv = histVmax / steps;
      const T = tempKinetic; // with k_B = 1

      const m1 = massLight;
      const m2 = massLight * massRatio;
      const fracLight = numParticles > 0 ? numLight / numParticles : 0.5;
      const fracHeavy = 1 - fracLight;

      // Compute f(v) for mixture and find max
      const fVals = [];
      let fMax = 0;
      for (let i = 0; i <= steps; i++) {
        const v = dv * i;
        let f = 0;
        if (v >= 0) {
          const f1 = fracLight * (m1 / T) * v * Math.exp(-m1 * v * v / (2 * T));
          const f2 = fracHeavy * (m2 / T) * v * Math.exp(-m2 * v * v / (2 * T));
          f = f1 + f2;
        }
        fVals.push(f);
        if (f > fMax) fMax = f;
      }

      if (fMax > 0) {
        noFill();
        stroke(255, 90, 120);
        strokeWeight(2);
        beginShape();
        for (let i = 0; i <= steps; i++) {
          const v = dv * i;
          const f = fVals[i];
          const x = barAreaLeft + (v / histVmax) * barAreaWidth;
          const y = top + h - 18 - (f / fMax) * usableH;
          vertex(x, y);
        }
        endShape();
      }
    }
  }

  function drawOverlayText() {
    fill(240);
    noStroke();
    textSize(13);

    const x = boxLeft;
    const y = boxTop - 18;
    const N = particles.length;

    let lineY = y;
    text(`N = ${N}`, x, lineY);
    lineY += 15;
    text(`T (from ⟨K⟩) ≈ ${tempKinetic.toFixed(3)} (k_B = 1)`, x, lineY);
    lineY += 15;
    text(`Pressure (avg) ≈ ${pressure.toExponential(3)} (arbitrary units)`, x, lineY);
    lineY += 15;
    text(`Collisions: ${collisionsEnabled ? "ON" : "OFF"}   Time: ${simTime.toFixed(1)} s`, x, lineY);
    if (paused) {
      lineY += 18;
      fill(255, 200, 120);
      text("PAUSED", x, lineY);
    }
  }

  // --- p5.js lifecycle ---

  function setup() {
    createCanvas(windowWidth, windowHeight);
    frameRate(60);

    // Hook up UI
    particlesSlider = document.getElementById("particlesSlider");
    tempSlider = document.getElementById("tempSlider");
    boxSlider = document.getElementById("boxSlider");
    mass1Slider = document.getElementById("mass1Slider");
    massRatioSlider = document.getElementById("massRatioSlider");
    radiusSlider = document.getElementById("radiusSlider");
    collisionsCheckbox = document.getElementById("collisionsCheckbox");
    resetButton = document.getElementById("resetButton");

    particlesLabel = document.getElementById("particlesLabel");
    tempLabel = document.getElementById("tempLabel");
    boxLabel = document.getElementById("boxLabel");
    mass1Label = document.getElementById("mass1Label");
    massRatioLabel = document.getElementById("massRatioLabel");
    radiusLabel = document.getElementById("radiusLabel");

    function syncLabels() {
      particlesLabel.textContent = particlesSlider.value;
      tempLabel.textContent = parseFloat(tempSlider.value).toFixed(1);
      boxLabel.textContent = parseFloat(boxSlider.value).toFixed(2);
      mass1Label.textContent = parseFloat(mass1Slider.value).toFixed(1);
      massRatioLabel.textContent = parseFloat(massRatioSlider.value).toFixed(1);
      radiusLabel.textContent = radiusSlider.value;
    }

    syncLabels();

    particlesSlider.oninput = () => { syncLabels(); };
    tempSlider.oninput = () => { syncLabels(); };
    boxSlider.oninput = () => { syncLabels(); };
    mass1Slider.oninput = () => { syncLabels(); };
    massRatioSlider.oninput = () => { syncLabels(); };
    radiusSlider.oninput = () => { syncLabels(); };

    collisionsCheckbox.onchange = () => {
      collisionsEnabled = collisionsCheckbox.checked;
    };

    resetButton.onclick = () => {
      applyParametersFromUI();
      updateLayout();
      resetSimulation();
    };

    updateLayout();
    resetSimulation();
  }

  function applyParametersFromUI() {
    numParticles = parseInt(particlesSlider.value, 10);
    initialTemperature = parseFloat(tempSlider.value);
    boxSizeFactor = parseFloat(boxSlider.value);
    massLight = parseFloat(mass1Slider.value);
    massRatio = parseFloat(massRatioSlider.value);
    radiusLight = parseFloat(radiusSlider.value);
    collisionsEnabled = collisionsCheckbox.checked;
  }

  function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    updateLayout();
    // Keep particles inside if resized smaller
    for (let p of particles) {
      p.x = constrain(p.x, boxLeft + p.r, boxLeft + boxWidth - p.r);
      p.y = constrain(p.y, boxTop + p.r, boxTop + boxHeight - p.r);
    }
  }

  function draw() {
    background(10, 12, 20);

    if (!paused) {
      const dt = Math.min(0.05, deltaTime / 1000);
      stepSimulation(dt);
    }

    drawBox();
    drawParticles();
    drawHistogram();
    drawOverlayText();
  }

  function keyPressed() {
    if (key === ' ' || key === 'Spacebar') {
      paused = !paused;
    } else if (key === 'c' || key === 'C') {
      collisionsEnabled = !collisionsEnabled;
      collisionsCheckbox.checked = collisionsEnabled;
    } else if (key === 'r' || key === 'R') {
      applyParametersFromUI();
      updateLayout();
      resetSimulation();
    }
  }
</script>
</body>
</html>