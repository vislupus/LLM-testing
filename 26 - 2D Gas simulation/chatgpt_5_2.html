<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2D Gas Simulation - Statistical Mechanics</title>
  <style>
    body { margin: 0; font-family: sans-serif; background-color: #f0f0f0; }
    #canvas-container { display: flex; justify-content: center; margin-top: 20px; }
    #hud { 
      position: absolute; top: 20px; left: 20px; 
      background: rgba(0, 0, 0, 0.5); color: white; padding: 12px; 
      font-size: 14px; border-radius: 8px;
    }
    #hud input[type=range] {
      width: 100%;
    }
    #hud label { display: block; margin-top: 5px; }
    .stat { margin-top: 10px; font-size: 12px; }
  </style>
</head>
<body>
  <div id="canvas-container">
    <canvas id="defaultCanvas0"></canvas>
  </div>
  <div id="hud">
    <label>Number of Particles: <span id="numParticles">50</span></label>
    <input type="range" id="numParticlesRange" min="10" max="200" value="50">

    <label>Temperature (kT): <span id="tempValue">1.0</span></label>
    <input type="range" id="tempRange" min="0.1" max="3.0" value="1.0" step="0.1">

    <label>Particle Mass: <span id="massValue">1.0</span></label>
    <input type="range" id="massRange" min="0.1" max="3.0" value="1.0" step="0.1">

    <label>Particle Radius: <span id="radiusValue">5</span></label>
    <input type="range" id="radiusRange" min="2" max="10" value="5" step="1">

    <label>Wall Collision: <span id="wallCollision">Enabled</span></label>
    <input type="checkbox" id="wallCollisionCheckbox" checked>

    <div class="stat">Pressure: <span id="pressure">0.0</span></div>
    <div class="stat">Temperature: <span id="kineticTemp">0.0</span></div>
    <div class="stat">Kinetic Energy: <span id="kineticEnergy">0.0</span></div>
    <div class="stat">Avg Speed: <span id="avgSpeed">0.0</span></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>

  <script>
    let particles = [];
    let numParticles = 50;
    let particleRadius = 5;
    let particleMass = 1;
    let temperature = 1.0;
    let boxWidth = 600;
    let boxHeight = 400;
    let collisionsEnabled = true;

    function setup() {
      createCanvas(boxWidth, boxHeight);
      textAlign(CENTER, CENTER);
      noStroke();
      frameRate(60);

      // Initialize particles
      initializeParticles();

      // Event listeners for UI controls
      document.getElementById('numParticlesRange').addEventListener('input', (e) => {
        numParticles = parseInt(e.target.value);
        document.getElementById('numParticles').textContent = numParticles;
        initializeParticles();
      });

      document.getElementById('tempRange').addEventListener('input', (e) => {
        temperature = parseFloat(e.target.value);
        document.getElementById('tempValue').textContent = temperature.toFixed(1);
        initializeParticles();
      });

      document.getElementById('massRange').addEventListener('input', (e) => {
        particleMass = parseFloat(e.target.value);
        document.getElementById('massValue').textContent = particleMass.toFixed(1);
        initializeParticles();
      });

      document.getElementById('radiusRange').addEventListener('input', (e) => {
        particleRadius = parseInt(e.target.value);
        document.getElementById('radiusValue').textContent = particleRadius;
        initializeParticles();
      });

      document.getElementById('wallCollisionCheckbox').addEventListener('change', (e) => {
        collisionsEnabled = e.target.checked;
        document.getElementById('wallCollision').textContent = collisionsEnabled ? 'Enabled' : 'Disabled';
      });
    }

    function draw() {
      background(255);

      // Update and display particles
      particles.forEach(p => {
        p.update();
        p.display();
      });

      if (collisionsEnabled) {
        handleWallCollisions();
        handleParticleCollisions();
      }

      // Display macroscopic quantities
      displayStats();
    }

    function initializeParticles() {
      particles = [];
      for (let i = 0; i < numParticles; i++) {
        let p = new Particle(random(particleRadius, boxWidth - particleRadius), random(particleRadius, boxHeight - particleRadius), particleMass, particleRadius, temperature);
        particles.push(p);
      }
    }

    function displayStats() {
      let totalKineticEnergy = 0;
      let totalSpeed = 0;
      let totalMomentumX = 0;
      let totalMomentumY = 0;
      let totalPressure = 0;

      particles.forEach(p => {
        totalKineticEnergy += p.kineticEnergy();
        totalSpeed += p.speed();
        totalMomentumX += p.velocity.x * p.mass;
        totalMomentumY += p.velocity.y * p.mass;
      });

      let avgSpeed = totalSpeed / particles.length;
      let pressure = calculatePressure();

      // Update UI values
      document.getElementById('kineticTemp').textContent = (totalKineticEnergy / particles.length / (1.5 * numParticles)).toFixed(2);
      document.getElementById('kineticEnergy').textContent = totalKineticEnergy.toFixed(2);
      document.getElementById('avgSpeed').textContent = avgSpeed.toFixed(2);
      document.getElementById('pressure').textContent = pressure.toFixed(2);
    }

    function calculatePressure() {
      let pressure = 0;
      particles.forEach(p => {
        pressure += p.mass * (p.velocity.x * p.velocity.x + p.velocity.y * p.velocity.y);
      });
      return pressure / (boxWidth * boxHeight);
    }

    function handleWallCollisions() {
      particles.forEach(p => {
        if (p.position.x <= particleRadius || p.position.x >= boxWidth - particleRadius) {
          p.velocity.x = -p.velocity.x;
          p.position.x = constrain(p.position.x, particleRadius, boxWidth - particleRadius);
        }

        if (p.position.y <= particleRadius || p.position.y >= boxHeight - particleRadius) {
          p.velocity.y = -p.velocity.y;
          p.position.y = constrain(p.position.y, particleRadius, boxHeight - particleRadius);
        }
      });
    }

    function handleParticleCollisions() {
      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          let p1 = particles[i];
          let p2 = particles[j];
          let dist = p1.position.dist(p2.position);

          if (dist < particleRadius * 2) {
            // Handle elastic collision between particles
            let normal = p5.Vector.sub(p2.position, p1.position).normalize();
            let relativeVelocity = p5.Vector.sub(p2.velocity, p1.velocity);
            let velocityAlongNormal = relativeVelocity.dot(normal);

            if (velocityAlongNormal < 0) {
              let restitution = 1.0; // Perfectly elastic collision
              let impulseMagnitude = (2 * velocityAlongNormal) / (p1.mass + p2.mass);
              let impulse = p5.Vector.mult(normal, impulseMagnitude);

              p1.velocity.sub(impulse.mult(p1.mass));
              p2.velocity.add(impulse.mult(p2.mass));

              let overlap = particleRadius * 2 - dist;
              let correction = normal.mult(overlap * 0.5);
              p1.position.sub(correction);
              p2.position.add(correction);
            }
          }
        }
      }
    }

    class Particle {
      constructor(x, y, mass, radius, temperature) {
        this.position = createVector(x, y);
        this.velocity = createVector(random(-1, 1), random(-1, 1));
        this.mass = mass;
        this.radius = radius;

        // Maxwell-Boltzmann distribution to initialize speeds
        let speed = randomGaussian(0, Math.sqrt(temperature / this.mass));
        this.velocity.setMag(speed);

        this.color = color(random(255), random(255), random(255));
      }

      update() {
        this.position.add(this.velocity);
      }

      display() {
        fill(this.color);
        ellipse(this.position.x, this.position.y, this.radius * 2);
      }

      kineticEnergy() {
        return 0.5 * this.mass * this.velocity.magSq();
      }

      speed() {
        return this.velocity.mag();
      }
    }
  </script>
</body>
</html>
