<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Gas Simulation - Statistical Mechanics</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a1929, #0d1f33);
            color: #e0f7fa;
            overflow: hidden;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(25, 118, 210, 0.15);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 280px;
            z-index: 100;
        }
        
        #controls h3 {
            margin-top: 0;
            color: #4fc3f7;
            border-bottom: 1px solid rgba(79, 195, 247, 0.3);
            padding-bottom: 10px;
        }
        
        .control-group {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        label {
            font-size: 13px;
            color: #bbdefb;
            flex: 1;
        }
        
        input[type="range"] {
            width: 100px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            height: 6px;
            border: none;
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #2196F3;
        }
        
        button {
            background: linear-gradient(to right, #2196F3, #21CBF3);
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        .value-display {
            color: #4fc3f7;
            font-weight: 600;
            font-size: 13px;
            min-width: 40px;
            text-align: right;
        }
        
        #stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(25, 118, 210, 0.15);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 13px;
            min-width: 200px;
        }
        
        #stats h3 {
            margin-top: 0;
            color: #4fc3f7;
            border-bottom: 1px solid rgba(79, 195, 247, 0.3);
            padding-bottom: 10px;
        }
        
        .stat-line {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .stat-label {
            color: #bbdefb;
        }
        
        .stat-value {
            color: #4fc3f7;
            font-weight: 600;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(79, 195, 247, 0.8);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(79, 195, 247, 0.8);
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>Simulation Controls</h3>
        <div class="control-group">
            <label>Particles:</label>
            <input type="range" id="particleSlider" min="10" max="300" value="100">
            <span class="value-display" id="particleValue">100</span>
        </div>
        <div class="control-group">
            <label>Temperature:</label>
            <input type="range" id="tempSlider" min="50" max="500" value="200">
            <span class="value-display" id="tempValue">200</span>
        </div>
        <div class="control-group">
            <label>Box Size:</label>
            <input type="range" id="sizeSlider" min="200" max="500" value="400">
            <span class="value-display" id="sizeValue">400</span>
        </div>
        <div class="control-group">
            <label>Mass Ratio:</label>
            <input type="range" id="massSlider" min="1" max="10" value="1" step="0.1">
            <span class="value-display" id="massValue">1.0</span>
        </div>
        <div class="control-group">
            <label>Collisions:</label>
            <input type="checkbox" id="collisionToggle" checked>
        </div>
        <div class="control-group">
            <button id="resetBtn">Reset Simulation</button>
        </div>
        <div class="control-group">
            <button id="pauseBtn">Pause</button>
        </div>
    </div>
    
    <div id="stats">
        <h3>Macroscopic Quantities</h3>
        <div class="stat-line">
            <span class="stat-label">Temperature:</span>
            <span class="stat-value" id="temperature">0</span>
        </div>
        <div class="stat-line">
            <span class="stat-label">Pressure:</span>
            <span class="stat-value" id="pressure">0</span>
        </div>
        <div class="stat-line">
            <span class="stat-label">Avg Speed:</span>
            <span class="stat-value" id="avgSpeed">0</span>
        </div>
        <div class="stat-line">
            <span class="stat-label">Total KE:</span>
            <span class="stat-value" id="totalKE">0</span>
        </div>
        <div class="stat-line">
            <span class="stat-label">Collisions/s:</span>
            <span class="stat-value" id="collisionRate">0</span>
        </div>
    </div>

    <script>
        // Simulation parameters
        let sim = {
            particles: [],
            box: { x: 0, y: 0, width: 400, height: 400 },
            N: 100,
            temperature: 200,
            massRatio: 1.0,
            collisionsEnabled: true,
            isPaused: false,
            
            // Tracking
            wallImpulses: { left: 0, right: 0, top: 0, bottom: 0 },
            pressureUpdateInterval: 500, // ms
            lastPressureUpdate: 0,
            pressure: 0,
            collisionCount: 0,
            lastCollisionCount: 0,
            
            // Histogram
            speedHistogram: [],
            histogramBins: 30,
            histogramMaxSpeed: 0,
            
            // Physics constants (simplified units where k_B = 1)
            kB: 1.0
        };

        // Particle class
        class Particle {
            constructor(x, y, vx, vy, mass, radius, color) {
                this.pos = createVector(x, y);
                this.vel = createVector(vx, vy);
                this.mass = mass;
                this.radius = radius;
                this.color = color;
            }

            update() {
                if (!sim.isPaused) {
                    this.pos.add(this.vel);
                }
            }

            checkWallCollision() {
                if (this.pos.x - this.radius <= sim.box.x) {
                    this.vel.x = abs(this.vel.x);
                    this.pos.x = sim.box.x + this.radius;
                    sim.wallImpulses.left += 2 * this.mass * abs(this.vel.x);
                    sim.collisionCount++;
                }
                if (this.pos.x + this.radius >= sim.box.x + sim.box.width) {
                    this.vel.x = -abs(this.vel.x);
                    this.pos.x = sim.box.x + sim.box.width - this.radius;
                    sim.wallImpulses.right += 2 * this.mass * abs(this.vel.x);
                    sim.collisionCount++;
                }
                if (this.pos.y - this.radius <= sim.box.y) {
                    this.vel.y = abs(this.vel.y);
                    this.pos.y = sim.box.y + this.radius;
                    sim.wallImpulses.top += 2 * this.mass * abs(this.vel.y);
                    sim.collisionCount++;
                }
                if (this.pos.y + this.radius >= sim.box.y + sim.box.height) {
                    this.vel.y = -abs(this.vel.y);
                    this.pos.y = sim.box.y + sim.box.height - this.radius;
                    sim.wallImpulses.bottom += 2 * this.mass * abs(this.vel.y);
                    sim.collisionCount++;
                }
            }

            checkParticleCollision(other) {
                let d = p5.Vector.dist(this.pos, other.pos);
                let minDist = this.radius + other.radius;
                
                if (d < minDist && d > 0) {
                    // Collision normal
                    let n = p5.Vector.sub(this.pos, other.pos);
                    n.normalize();
                    
                    // Relative velocity
                    let vRel = p5.Vector.sub(this.vel, other.vel);
                    let vRelN = vRel.dot(n);
                    
                    // Already separating
                    if (vRelN > 0) return false;
                    
                    // Collision impulse
                    let impulse = 2 * vRelN / (1/this.mass + 1/other.mass);
                    
                    // Update velocities
                    this.vel.sub(p5.Vector.mult(n, impulse / this.mass));
                    other.vel.add(p5.Vector.mult(n, impulse / other.mass));
                    
                    // Separate particles to prevent overlap
                    let overlap = minDist - d;
                    let separation = p5.Vector.mult(n, overlap / 2 + 0.01);
                    this.pos.add(separation);
                    other.pos.sub(separation);
                    
                    sim.collisionCount++;
                    return true;
                }
                return false;
            }

            get speed() {
                return this.vel.mag();
            }

            get kineticEnergy() {
                return 0.5 * this.mass * this.vel.magSq();
            }
        }

        // Initialize particles with Maxwell-Boltzmann distribution
        function initParticles() {
            sim.particles = [];
            
            for (let i = 0; i < sim.N; i++) {
                let isHeavy = random() < 0.3; // 30% heavy particles
                let mass = isHeavy ? sim.massRatio : 1.0;
                let radius = isHeavy ? 4 : 3;
                let color = isHeavy ? color(255, 100, 100) : color(100, 200, 255);
                
                // Maxwell-Boltzmann speed distribution for 2D
                // Sample from Rayleigh distribution: v = sigma * sqrt(-2 * ln(1 - u))
                // where sigma = sqrt(k_B * T / m)
                let sigma = sqrt(sim.temperature / mass);
                let speed = sigma * sqrt(-2 * log(1 - random()));
                let angle = random(TWO_PI);
                let vx = speed * cos(angle);
                let vy = speed * sin(angle);
                
                // Place particle randomly in box with margin
                let margin = radius + 5;
                let x = random(sim.box.x + margin, sim.box.x + sim.box.width - margin);
                let y = random(sim.box.y + margin, sim.box.y + sim.box.height - margin);
                
                sim.particles.push(new Particle(x, y, vx, vy, mass, radius, color));
            }
        }

        // Update simulation
        function updateSimulation() {
            if (sim.isPaused) return;
            
            // Reset histogram
            sim.speedHistogram = new Array(sim.histogramBins).fill(0);
            sim.histogramMaxSpeed = sqrt(sim.temperature) * 4; // Adaptive max speed
            
            // Update particles and build collision grid
            for (let p of sim.particles) {
                p.update();
                p.checkWallCollision();
                
                // Update speed histogram
                let speed = p.speed;
                let bin = floor((speed / sim.histogramMaxSpeed) * sim.histogramBins);
                if (bin >= 0 && bin < sim.histogramBins) {
                    sim.speedHistogram[bin]++;
                }
            }
            
            // Particle-particle collisions with spatial grid optimization
            if (sim.collisionsEnabled) {
                let cellSize = 20;
                let grid = new Map();
                
                // Assign particles to grid cells
                for (let p of sim.particles) {
                    let cellX = floor(p.pos.x / cellSize);
                    let cellY = floor(p.pos.y / cellSize);
                    let key = `${cellX},${cellY}`;
                    if (!grid.has(key)) grid.set(key, []);
                    grid.get(key).push(p);
                }
                
                // Check collisions in adjacent cells
                for (let [key, cell] of grid) {
                    let [cx, cy] = key.split(',').map(Number);
                    let neighbors = [];
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            let nkey = `${cx + dx},${cy + dy}`;
                            if (grid.has(nkey)) neighbors.push(...grid.get(nkey));
                        }
                    }
                    
                    // Check collisions within combined cell
                    for (let i = 0; i < cell.length; i++) {
                        for (let j = i + 1; j < neighbors.length; j++) {
                            cell[i].checkParticleCollision(neighbors[j]);
                        }
                    }
                }
            }
            
            // Update pressure periodically
            if (millis() - sim.lastPressureUpdate > sim.pressureUpdateInterval) {
                let totalImpulse = sim.wallImpulses.left + sim.wallImpulses.right + 
                                 sim.wallImpulses.top + sim.wallImpulses.bottom;
                let wallLength = 2 * (sim.box.width + sim.box.height); // perimeter
                sim.pressure = totalImpulse / (wallLength * sim.pressureUpdateInterval / 1000);
                
                // Reset impulses
                sim.wallImpulses = { left: 0, right: 0, top: 0, bottom: 0 };
                sim.lastPressureUpdate = millis();
                
                // Update collision rate
                sim.lastCollisionCount = sim.collisionCount;
                sim.collisionCount = 0;
            }
        }

        // Draw Maxwell-Boltzmann theoretical curve
        function drawMBCurve() {
            push();
            translate(sim.box.x + sim.box.width + 50, sim.box.y + 20);
            
            // Histogram title
            fill(200);
            textAlign(LEFT, CENTER);
            textSize(12);
            text('Speed Distribution', 0, -5);
            
            // Draw axes
            stroke(100);
            strokeWeight(1);
            line(0, 0, 0, 150);
            line(0, 150, 200, 150);
            
            // Draw histogram bars
            let barWidth = 200 / sim.histogramBins;
            noStroke();
            for (let i = 0; i < sim.histogramBins; i++) {
                let h = (sim.speedHistogram[i] / max(sim.N / 10, 1)) * 150;
                fill(100, 150, 255, 150);
                rect(i * barWidth, 150 - h, barWidth - 1, h);
            }
            
            // Draw theoretical Maxwell-Boltzmann curve
            stroke(255, 100, 100);
            strokeWeight(2);
            noFill();
            
            let mass = 1.0; // Use average mass for curve
            let sigma = sqrt(sim.temperature / mass);
            
            beginShape();
            for (let x = 0; x < 200; x++) {
                let v = (x / 200) * sim.histogramMaxSpeed;
                // 2D Maxwell-Boltzmann distribution
                let f = (v / (sigma * sigma)) * exp(-v * v / (2 * sigma * sigma));
                // Scale for visualization
                let y = 150 - f * 50 * sigma;
                vertex(x, y);
            }
            endShape();
            
            // Labels
            fill(200);
            noStroke();
            textAlign(CENTER, TOP);
            text('Speed', 100, 155);
            
            pop();
        }

        // Draw everything
        function draw() {
            background(10, 15, 25);
            
            // Update simulation
            updateSimulation();
            
            // Draw box
            push();
            noFill();
            stroke(100, 150, 255);
            strokeWeight(2);
            rect(sim.box.x, sim.box.y, sim.box.width, sim.box.height);
            
            // Draw particles
            noStroke();
            for (let p of sim.particles) {
                fill(p.color);
                circle(p.pos.x, p.pos.y, p.radius * 2);
            }
            pop();
            
            // Draw speed distribution histogram
            drawMBCurve();
            
            // Update statistics display
            updateStats();
        }

        // Calculate and display statistics
        function updateStats() {
            // Temperature (average kinetic energy per particle, k_B = 1)
            let totalKE = 0;
            let totalSpeed = 0;
            for (let p of sim.particles) {
                totalKE += p.kineticEnergy;
                totalSpeed += p.speed;
            }
            
            let temp = totalKE / sim.N; // In 2D: T = KE_avg
            let avgSpeed = totalSpeed / sim.N;
            
            document.getElementById('temperature').textContent = temp.toFixed(2) + ' K';
            document.getElementById('pressure').textContent = sim.pressure.toFixed(3) + ' N/m';
            document.getElementById('avgSpeed').textContent = avgSpeed.toFixed(2) + ' m/s';
            document.getElementById('totalKE').textContent = totalKE.toFixed(1) + ' J';
            
            let collisionRate = (sim.lastCollisionCount / sim.pressureUpdateInterval * 1000).toFixed(1);
            document.getElementById('collisionRate').textContent = collisionRate + '/s';
        }

        // UI Event handlers
        function setupControls() {
            // Particle slider
            document.getElementById('particleSlider').addEventListener('input', function(e) {
                sim.N = parseInt(e.target.value);
                document.getElementById('particleValue').textContent = sim.N;
                resetSimulation();
            });
            
            // Temperature slider
            document.getElementById('tempSlider').addEventListener('input', function(e) {
                sim.temperature = parseFloat(e.target.value);
                document.getElementById('tempValue').textContent = sim.temperature;
                // Rescale velocities to new temperature
                rescaleVelocities();
            });
            
            // Box size slider
            document.getElementById('sizeSlider').addEventListener('input', function(e) {
                let newSize = parseInt(e.target.value);
                document.getElementById('sizeValue').textContent = newSize;
                sim.box.width = newSize;
                sim.box.height = newSize;
                resetSimulation();
            });
            
            // Mass ratio slider
            document.getElementById('massSlider').addEventListener('input', function(e) {
                sim.massRatio = parseFloat(e.target.value);
                document.getElementById('massValue').textContent = sim.massRatio.toFixed(1);
                resetSimulation();
            });
            
            // Collision toggle
            document.getElementById('collisionToggle').addEventListener('change', function(e) {
                sim.collisionsEnabled = e.target.checked;
            });
            
            // Reset button
            document.getElementById('resetBtn').addEventListener('click', resetSimulation);
            
            // Pause button
            document.getElementById('pauseBtn').addEventListener('click', function() {
                sim.isPaused = !sim.isPaused;
                this.textContent = sim.isPaused ? 'Resume' : 'Pause';
            });
        }

        function resetSimulation() {
            sim.isPaused = false;
            document.getElementById('pauseBtn').textContent = 'Pause';
            initParticles();
            sim.wallImpulses = { left: 0, right: 0, top: 0, bottom: 0 };
            sim.pressure = 0;
            sim.collisionCount = 0;
            sim.lastCollisionCount = 0;
        }

        function rescaleVelocities() {
            // Rescale velocities to match new temperature while preserving direction
            for (let p of sim.particles) {
                let currentSpeed = p.speed;
                if (currentSpeed > 0) {
                    let mass = p.mass;
                    let targetSigma = sqrt(sim.temperature / mass);
                    let targetSpeed = targetSigma * sqrt(-2 * log(1 - random()));
                    let scale = targetSpeed / currentSpeed;
                    p.vel.mult(scale);
                }
            }
        }

        // p5.js setup and draw
        function setup() {
            createCanvas(windowWidth, windowHeight);
            sim.box.x = 50;
            sim.box.y = (height - sim.box.height) / 2;
            initParticles();
            setupControls();
        }

        function draw() {
            draw();
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            sim.box.y = (height - sim.box.height) / 2;
        }
    </script>
</body>
</html>