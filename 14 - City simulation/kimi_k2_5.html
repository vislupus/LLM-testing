<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Growing City Simulation</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100vh;
            touch-action: none;
            outline: none;
        }
        
        #ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(20, 20, 30, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            color: white;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h2 {
            margin: 0 0 20px 0;
            font-size: 18px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #4fc3f7;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            color: #bbb;
            display: flex;
            justify-content: space-between;
        }
        
        .value-display {
            color: #4fc3f7;
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #333;
            outline: none;
            border-radius: 3px;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #4fc3f7;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        
        .stats {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            color: #888;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4fc3f7;
            font-size: 24px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="loading">Generating City...</div>
    <div id="ui-panel">
        <h2>City Controls</h2>
        <div class="control-group">
            <label>Population Density <span class="value-display" id="val-density">50%</span></label>
            <input type="range" id="density" min="0" max="100" value="50">
        </div>
        <div class="control-group">
            <label>Traffic Intensity <span class="value-display" id="val-traffic">30%</span></label>
            <input type="range" id="traffic" min="0" max="100" value="30">
        </div>
        <div class="control-group">
            <label>Development Speed <span class="value-display" id="val-speed">50%</span></label>
            <input type="range" id="speed" min="0" max="100" value="50">
        </div>
        <div class="stats">
            <div class="stat-row"><span>Population:</span> <span id="stat-pop">0</span></div>
            <div class="stat-row"><span>Buildings:</span> <span id="stat-buildings">0</span></div>
            <div class="stat-row"><span>Active Cars:</span> <span id="stat-cars">0</span></div>
            <div class="stat-row"><span>Pedestrians:</span> <span id="stat-people">0</span></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        
        // Simulation Parameters
        const params = {
            density: 50,      // Percentage of plots filled
            traffic: 30,      // Number of cars active (normalized)
            speed: 50         // Building growth speed
        };
        
        // Update params from sliders
        document.getElementById('density').oninput = function() {
            params.density = parseInt(this.value);
            document.getElementById('val-density').textContent = params.density + '%';
        };
        document.getElementById('traffic').oninput = function() {
            params.traffic = parseInt(this.value);
            document.getElementById('val-traffic').textContent = params.traffic + '%';
        };
        document.getElementById('speed').oninput = function() {
            params.speed = parseInt(this.value);
            document.getElementById('val-speed').textContent = params.speed + '%';
        };

        const createScene = () => {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.05, 0.05, 0.1);
            
            // Camera
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI/2, Math.PI/3, 150, 
                new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 20;
            camera.upperRadiusLimit = 300;
            
            // Lighting
            const hemiLight = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
            hemiLight.intensity = 0.6;
            hemiLight.diffuse = new BABYLON.Color3(0.8, 0.9, 1);
            
            const dirLight = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-1, -2, -1), scene);
            dirLight.position = new BABYLON.Vector3(100, 200, 100);
            dirLight.intensity = 0.8;
            dirLight.shadowMinZ = 1;
            dirLight.shadowMaxZ = 500;
            
            // Shadows
            const shadowGenerator = new BABYLON.ShadowGenerator(2048, dirLight);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;
            
            // Materials
            const groundMat = new BABYLON.StandardMaterial("ground", scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.2, 0.3, 0.2);
            groundMat.specularColor = new BABYLON.Color3(0, 0, 0);
            
            const roadMat = new BABYLON.StandardMaterial("road", scene);
            roadMat.diffuseColor = new BABYLON.Color3(0.15, 0.15, 0.15);
            roadMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            
            const sidewalkMat = new BABYLON.StandardMaterial("sidewalk", scene);
            sidewalkMat.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.65);
            
            // Building materials (windows glow at night)
            const buildingMats = [];
            for(let i = 0; i < 5; i++) {
                const mat = new BABYLON.StandardMaterial("building" + i, scene);
                mat.diffuseColor = BABYLON.Color3.FromHSV(i * 0.1, 0.4, 0.8);
                mat.emissiveColor = new BABYLON.Color3(0.05, 0.05, 0.1);
                buildingMats.push(mat);
            }
            
            // Grid Setup
            const gridSize = 12;
            const cellSize = 10;
            const roadWidth = 3;
            
            // Create ground
            const ground = BABYLON.MeshBuilder.CreateGround("ground", {
                width: gridSize * cellSize * 1.5,
                height: gridSize * cellSize * 1.5
            }, scene);
            ground.material = groundMat;
            ground.receiveShadows = true;
            ground.position.y = -0.1;
            
            // Generate Road Network
            const roads = [];
            const intersectionPoints = [];
            
            for(let i = 0; i <= gridSize; i++) {
                const pos = (i - gridSize/2) * cellSize;
                
                // X-axis roads
                const roadX = BABYLON.MeshBuilder.CreateBox("roadX"+i, {
                    width: gridSize * cellSize, 
                    height: 0.2, 
                    depth: roadWidth
                }, scene);
                roadX.position.z = pos;
                roadX.position.y = 0.05;
                roadX.material = roadMat;
                roadX.receiveShadows = true;
                
                // Z-axis roads
                const roadZ = BABYLON.MeshBuilder.CreateBox("roadZ"+i, {
                    width: roadWidth, 
                    height: 0.2, 
                    depth: gridSize * cellSize
                }, scene);
                roadZ.position.x = pos;
                roadZ.position.y = 0.05;
                roadZ.material = roadMat;
                roadZ.receiveShadows = true;
                
                // Store intersection points for traffic
                for(let j = 0; j <= gridSize; j++) {
                    intersectionPoints.push(new BABYLON.Vector3(
                        (j - gridSize/2) * cellSize,
                        0.5,
                        (i - gridSize/2) * cellSize
                    ));
                }
            }
            
            // Building Plots
            const plots = [];
            for(let x = 0; x < gridSize; x++) {
                for(let z = 0; z < gridSize; z++) {
                    const centerX = ((x - gridSize/2) * cellSize) + cellSize/2;
                    const centerZ = ((z - gridSize/2) * cellSize) + cellSize/2;
                    
                    // Sidewalk
                    const sw = BABYLON.MeshBuilder.CreateGround("sw"+x+z, {
                        width: cellSize - roadWidth,
                        height: cellSize - roadWidth
                    }, scene);
                    sw.position = new BABYLON.Vector3(centerX, 0.1, centerZ);
                    sw.material = sidewalkMat;
                    sw.receiveShadows = true;
                    
                    plots.push({
                        x: centerX,
                        z: centerZ,
                        occupied: false,
                        building: null
                    });
                }
            }
            
            // Buildings Array
            const buildings = [];
            const buildingQueue = [];
            
            // Traffic System
            const cars = [];
            const carPool = [];
            const maxCars = 100;
            
            // Car material ( headlights )
            const carMat = new BABYLON.StandardMaterial("car", scene);
            carMat.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
            const carMat2 = new BABYLON.StandardMaterial("car2", scene);
            carMat2.diffuseColor = new BABYLON.Color3(0.2, 0.6, 0.9);
            const carMaterials = [carMat, carMat2];
            
            // Initialize car pool
            for(let i = 0; i < maxCars; i++) {
                const carGroup = new BABYLON.TransformNode("car"+i, scene);
                
                const body = BABYLON.MeshBuilder.CreateBox("body", {width: 1.5, height: 1, depth: 3}, scene);
                body.position.y = 0.5;
                body.parent = carGroup;
                body.material = carMaterials[i % 2];
                shadowGenerator.addShadowCaster(body);
                
                // Headlights glow
                const lightL = BABYLON.MeshBuilder.CreatePlane("hl"+i, {size: 0.3}, scene);
                lightL.position = new BABYLON.Vector3(-0.5, 0.5, 1.51);
                lightL.parent = carGroup;
                lightL.rotation.y = Math.PI;
                const hlMat = new BABYLON.StandardMaterial("hl", scene);
                hlMat.emissiveColor = new BABYLON.Color3(1, 1, 0.8);
                lightL.material = hlMat;
                
                const lightR = lightL.clone("hlr"+i);
                lightR.position.x = 0.5;
                lightR.parent = carGroup;
                
                carGroup.isVisible = false;
                carPool.push({
                    mesh: carGroup,
                    active: false,
                    direction: new BABYLON.Vector3(0, 0, 1),
                    speed: 0.2 + Math.random() * 0.2,
                    target: null
                });
            }
            
            // Pedestrian System
            const pedestrians = [];
            const pedMax = 200;
            const pedPool = [];
            
            const pedMat = new BABYLON.StandardMaterial("ped", scene);
            pedMat.diffuseColor = new BABYLON.Color3(0.9, 0.7, 0.5);
            
            for(let i = 0; i < pedMax; i++) {
                const pedGroup = new BABYLON.TransformNode("ped"+i, scene);
                
                const body = BABYLON.MeshBuilder.CreateCapsule("body", {height: 1.5, radius: 0.3}, scene);
                body.position.y = 0.75;
                body.parent = pedGroup;
                body.material = pedMat;
                
                const head = BABYLON.MeshBuilder.CreateSphere("head", {diameter: 0.4}, scene);
                head.position.y = 1.6;
                head.parent = pedGroup;
                head.material = pedMat;
                
                pedGroup.isVisible = false;
                pedPool.push({
                    mesh: pedGroup,
                    active: false,
                    target: null,
                    speed: 0.05 + Math.random() * 0.05,
                    x: 0,
                    z: 0
                });
            }
            
            // City Development Logic
            let lastBuildTime = 0;
            let buildingIndex = 0;
            
            // Building creation function
            function createBuilding(plot) {
                const type = Math.floor(Math.random() * 3); // 0: Res, 1: Com, 2: Sky
                let height = 3 + Math.random() * 5;
                
                if(type === 1) height = 8 + Math.random() * 10;
                if(type === 2) height = 20 + Math.random() * 30;
                
                // Scale height by density setting
                height *= (0.3 + (params.density / 100) * 0.7);
                
                const width = (cellSize - roadWidth) * 0.8;
                const depth = (cellSize - roadWidth) * 0.8;
                
                const building = BABYLON.MeshBuilder.CreateBox("bld"+buildingIndex++, {
                    width: width,
                    height: height,
                    depth: depth
                }, scene);
                
                building.position = new BABYLON.Vector3(plot.x, height/2, plot.z);
                building.material = buildingMats[type];
                building.scaling.y = 0.01; // Start small
                building.isVisible = true;
                shadowGenerator.addShadowCaster(building);
                
                // Add emissive windows
                const windowMat = new BABYLON.StandardMaterial("win", scene);
                windowMat.emissiveColor = new BABYLON.Color3(0.2, 0.3, 0.4);
                
                plot.building = building;
                plot.targetHeight = height;
                plot.currentHeight = 0.01;
                plot.occupied = true;
                buildings.push(plot);
            }
            
            // Main simulation loop
            scene.registerBeforeRender(() => {
                // Building Growth
                const now = Date.now();
                const growInterval = 2000 / (0.5 + params.speed / 20); // Speed affects spawn rate
                
                if(now - lastBuildTime > growInterval) {
                    // Find unoccupied plots based on density
                    const available = plots.filter(p => !p.occupied);
                    if(available.length > 0) {
                        // Density determines fill percentage
                        const targetFilled = Math.floor(plots.length * (params.density / 100));
                        if(buildings.length < targetFilled) {
                            const plot = available[Math.floor(Math.random() * available.length)];
                            createBuilding(plot);
                        }
                    }
                    lastBuildTime = now;
                }
                
                // Animate building growth
                buildings.forEach(plot => {
                    if(plot.building && plot.currentHeight < plot.targetHeight) {
                        const growth = (plot.targetHeight * 0.02) * (params.speed / 50);
                        plot.currentHeight += growth;
                        if(plot.currentHeight > plot.targetHeight) plot.currentHeight = plot.targetHeight;
                        plot.building.scaling.y = plot.currentHeight / plot.targetHeight;
                        plot.building.position.y = plot.currentHeight / 2;
                    }
                });
                
                // Traffic Management
                const targetCars = Math.floor((params.traffic / 100) * maxCars);
                let activeCount = 0;
                
                carPool.forEach((car, idx) => {
                    if(car.active) {
                        activeCount++;
                        
                        // Movement
                        car.mesh.position.addInPlace(car.direction.scale(car.speed));
                        
                        // Check if at intersection (roughly)
                        const atIntersection = intersectionPoints.some(ip => {
                            return BABYLON.Vector3.Distance(ip, car.mesh.position) < 2;
                        });
                        
                        if(atIntersection && !car.turning) {
                            car.turning = true;
                            // Random turn
                            if(Math.random() > 0.3) {
                                const turns = [
                                    new BABYLON.Vector3(1, 0, 0),
                                    new BABYLON.Vector3(-1, 0, 0),
                                    new BABYLON.Vector3(0, 0, 1),
                                    new BABYLON.Vector3(0, 0, -1)
                                ];
                                const newDir = turns[Math.floor(Math.random() * turns.length)];
                                car.direction = newDir;
                                
                                // Rotate mesh to face direction
                                const angle = Math.atan2(newDir.x, newDir.z);
                                car.mesh.rotation.y = angle;
                            }
                        } else if(!atIntersection) {
                            car.turning = false;
                        }
                        
                        // Bounds check - recycle car
                        if(Math.abs(car.mesh.position.x) > gridSize * cellSize/2 + 5 ||
                           Math.abs(car.mesh.position.z) > gridSize * cellSize/2 + 5) {
                            car.active = false;
                            car.mesh.isVisible = false;
                        }
                    } else if(activeCount < targetCars && Math.random() < 0.01) {
                        // Spawn car
                        car.active = true;
                        car.mesh.isVisible = true;
                        const side = Math.floor(Math.random() * 4);
                        const pos = (Math.random() - 0.5) * gridSize * cellSize;
                        switch(side) {
                            case 0: car.mesh.position = new BABYLON.Vector3(pos, 0.5, -gridSize*cellSize/2); car.direction = new BABYLON.Vector3(0,0,1); break;
                            case 1: car.mesh.position = new BABYLON.Vector3(pos, 0.5, gridSize*cellSize/2); car.direction = new BABYLON.Vector3(0,0,-1); break;
                            case 2: car.mesh.position = new BABYLON.Vector3(-gridSize*cellSize/2, 0.5, pos); car.direction = new BABYLON.Vector3(1,0,0); break;
                            case 3: car.mesh.position = new BABYLON.Vector3(gridSize*cellSize/2, 0.5, pos); car.direction = new BABYLON.Vector3(-1,0,0); break;
                        }
                        const angle = Math.atan2(car.direction.x, car.direction.z);
                        car.mesh.rotation.y = angle;
                    }
                });
                
                // Pedestrian Management
                const targetPeds = Math.floor((params.density / 100) * pedMax);
                let activePeds = 0;
                
                pedPool.forEach(ped => {
                    if(ped.active) {
                        activePeds++;
                        if(!ped.target || BABYLON.Vector3.Distance(ped.mesh.position, ped.target) < 0.5) {
                            // New random target on sidewalk
                            ped.target = new BABYLON.Vector3(
                                (Math.random() - 0.5) * gridSize * cellSize,
                                0,
                                (Math.random() - 0.5) * gridSize * cellSize
                            );
                        }
                        
                        const dir = ped.target.subtract(ped.mesh.position).normalize();
                        dir.y = 0;
                        ped.mesh.position.addInPlace(dir.scale(ped.speed));
                        ped.mesh.lookAt(ped.target);
                    } else if(activePeds < targetPeds && Math.random() < 0.02) {
                        ped.active = true;
                        ped.mesh.isVisible = true;
                        ped.mesh.position = new BABYLON.Vector3(
                            (Math.random() - 0.5) * gridSize * cellSize,
                            0,
                            (Math.random() - 0.5) * gridSize * cellSize
                        );
                        ped.target = new BABYLON.Vector3(
                            (Math.random() - 0.5) * gridSize * cellSize,
                            0,
                            (Math.random() - 0.5) * gridSize * cellSize
                        );
                    }
                });
                
                // Update stats
                document.getElementById('stat-buildings').textContent = buildings.length;
                document.getElementById('stat-cars').textContent = activeCount;
                document.getElementById('stat-people').textContent = activePeds;
                document.getElementById('stat-pop').textContent = 
                    Math.floor(buildings.length * 50 + activePeds * 10);
            });
            
            // Remove loading text
            document.getElementById('loading').style.display = 'none';
            
            return scene;
        };

        const scene = createScene();

        engine.runRenderLoop(function () {
            scene.render();
        });

        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>