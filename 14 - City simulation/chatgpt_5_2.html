<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Growing City Simulator ‚Äî Babylon.js (Single File)</title>
  <style>
    html, body { height:100%; margin:0; overflow:hidden; background:#06101f; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; }
    #c { width:100%; height:100%; display:block; touch-action:none; }

    .hud {
      position:fixed; left:14px; top:14px; z-index:10;
      display:grid; gap:10px;
      color:#eef6ff; user-select:none;
      pointer-events:none;
    }
    .panel{
      pointer-events:auto;
      width:min(420px, 92vw);
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.16);
      border-radius:16px;
      padding:10px 12px;
      backdrop-filter: blur(8px);
      box-shadow:0 18px 70px rgba(0,0,0,.45);
    }
    .row { display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap; }
    .title { font-weight:950; letter-spacing:.2px; }
    .muted { opacity:.78; font-weight:700; font-size:12px; line-height:1.25; }
    .pill {
      display:inline-block; padding:2px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.16); background:rgba(0,0,0,.22);
      font-weight:900; font-size:12px;
    }
    .grid { display:grid; gap:10px; margin-top:8px; }
    .control { display:grid; gap:6px; }
    .control label { font-weight:850; font-size:12px; opacity:.92; display:flex; justify-content:space-between; }
    input[type="range"]{ width:100%; }
    button{
      border:1px solid rgba(255,255,255,.20);
      background:rgba(255,255,255,.10);
      color:#eef6ff;
      font-weight:900;
      padding:8px 10px;
      border-radius:12px;
      cursor:pointer;
    }
    button:hover{ background:rgba(255,255,255,.14); }
    .kbd{
      display:inline-block;padding:2px 8px;border-radius:999px;
      border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.08);
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-weight:900
    }
    .legend{
      display:flex; gap:8px; flex-wrap:wrap;
      margin-top:8px;
      font-weight:800; font-size:12px; opacity:.85;
    }
    .sw{ width:10px; height:10px; border-radius:3px; display:inline-block; border:1px solid rgba(255,255,255,.22); }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="panel">
      <div class="row">
        <div class="title">üèôÔ∏è Growing City Simulator</div>
        <div class="pill" id="status">Running</div>
      </div>
      <div class="muted" style="margin-top:6px">
        Orbit: mouse ‚Ä¢ Zoom: wheel ‚Ä¢ Pan: right-drag<br/>
        Toggle pause: <span class="kbd">P</span> ‚Ä¢ Reset: <span class="kbd">R</span>
      </div>

      <div class="grid">
        <div class="control">
          <label>
            <span>City size / density</span>
            <span class="pill"><span id="vDensity">55</span>%</span>
          </label>
          <input id="density" type="range" min="10" max="95" value="55" />
          <div class="muted">More lots become buildings, taller skyline, more people/vehicles.</div>
        </div>

        <div class="control">
          <label>
            <span>Traffic intensity</span>
            <span class="pill"><span id="vTraffic">55</span>%</span>
          </label>
          <input id="traffic" type="range" min="0" max="100" value="55" />
          <div class="muted">Controls how many vehicles & pedestrians are spawned and kept active.</div>
        </div>

        <div class="control">
          <label>
            <span>Development speed</span>
            <span class="pill"><span id="vDev">55</span>%</span>
          </label>
          <input id="dev" type="range" min="0" max="100" value="55" />
          <div class="muted">How quickly roads form & buildings appear/upgrade over time.</div>
        </div>

        <div class="row">
          <button id="btnPause">Pause</button>
          <button id="btnReset">Reset City</button>
          <button id="btnCenter">Recenter Camera</button>
        </div>

        <div class="row">
          <div class="muted">Pop: <b id="pop">0</b></div>
          <div class="muted">Buildings: <b id="bld">0</b></div>
          <div class="muted">Cars: <b id="cars">0</b> ‚Ä¢ People: <b id="people">0</b></div>
        </div>

        <div class="legend">
          <span><span class="sw" style="background:#2c2c32"></span> roads</span>
          <span><span class="sw" style="background:#67b3ff"></span> offices</span>
          <span><span class="sw" style="background:#35d39f"></span> homes</span>
          <span><span class="sw" style="background:#ffd166"></span> shops</span>
          <span><span class="sw" style="background:#ff6b87"></span> landmarks</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Babylon.js (CDN allowed). No external assets used. -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>

  <script>
  (() => {
    // ============================================================
    // Single-file Growing City Simulation (procedural)
    // - Grid-based city layout: roads, lots, buildings
    // - Development: roads "unlock", buildings appear and upgrade
    // - Traffic: cars follow roads, people walk sidewalks
    // - Sliders: density, traffic, development speed (live update)
    // ============================================================

    const canvas = document.getElementById("c");
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer:true, stencil:true });

    const ui = {
      status:  document.getElementById("status"),
      density: document.getElementById("density"),
      traffic: document.getElementById("traffic"),
      dev:     document.getElementById("dev"),
      vDensity:document.getElementById("vDensity"),
      vTraffic:document.getElementById("vTraffic"),
      vDev:    document.getElementById("vDev"),
      btnPause:document.getElementById("btnPause"),
      btnReset:document.getElementById("btnReset"),
      btnCenter:document.getElementById("btnCenter"),
      pop:     document.getElementById("pop"),
      bld:     document.getElementById("bld"),
      cars:    document.getElementById("cars"),
      people:  document.getElementById("people"),
    };

    // ---------- RNG (seeded) ----------
    function xorshift32(seed){
      let x = seed >>> 0;
      return () => {
        x ^= x << 13; x >>>= 0;
        x ^= x >> 17; x >>>= 0;
        x ^= x << 5;  x >>>= 0;
        return (x >>> 0) / 4294967296;
      };
    }

    // ---------- Helpers ----------
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp = (a,b,t)=>a+(b-a)*t;

    // Smoothstep
    function smooth(t){ return t*t*(3-2*t); }

    // ---------- Scene setup ----------
    let scene, camera, pipeline;
    let rng = xorshift32((Date.now() ^ (Math.random()*1e9))>>>0);

    function makeParticleTexture(scene){
      const size = 64;
      const dt = new BABYLON.DynamicTexture("ptex", { width:size, height:size }, scene, false);
      const c = dt.getContext();
      const g = c.createRadialGradient(size/2, size/2, 2, size/2, size/2, size/2);
      g.addColorStop(0, "rgba(255,255,255,1)");
      g.addColorStop(0.35, "rgba(255,255,255,0.7)");
      g.addColorStop(1, "rgba(255,255,255,0)");
      c.fillStyle = g;
      c.fillRect(0,0,size,size);
      dt.update();
      return dt;
    }

    function explosion(scene, pos, tint = new BABYLON.Color3(1,0.8,0.5), size=1){
      const ps = new BABYLON.ParticleSystem("spark", 120, scene);
      ps.particleTexture = scene._ptex;
      ps.emitter = pos.clone();
      ps.minEmitBox = new BABYLON.Vector3(-0.2, 0, -0.2).scale(size);
      ps.maxEmitBox = new BABYLON.Vector3( 0.2, 0,  0.2).scale(size);
      ps.color1 = new BABYLON.Color4(tint.r, tint.g, tint.b, 1.0);
      ps.color2 = new BABYLON.Color4(1,1,1,1);
      ps.colorDead = new BABYLON.Color4(0,0,0,0);
      ps.minSize = 0.2*size; ps.maxSize = 0.8*size;
      ps.minLifeTime = 0.15; ps.maxLifeTime = 0.55;
      ps.emitRate = 900;
      ps.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
      ps.gravity = new BABYLON.Vector3(0, -8, 0);
      ps.direction1 = new BABYLON.Vector3(-1, 1.2, -1);
      ps.direction2 = new BABYLON.Vector3( 1, 2.2,  1);
      ps.minEmitPower = 2.5*size; ps.maxEmitPower = 6.5*size;
      ps.updateSpeed = 0.016;
      ps.start();
      setTimeout(()=>ps.stop(), 80);
      setTimeout(()=>ps.dispose(), 800);
    }

    // ---------- City model ----------
    // Grid layout:
    // - Roads on certain rows/cols (major avenues + minor streets that "unlock")
    // - Lots in between roads can develop into buildings.
    //
    // We keep:
    //  roads: boolean arrays for vertical/horizontal road lines (grid lines)
    //  lots: per-cell building state (none / type / level / mesh)
    //
    const CITY = {
      N: 30,           // grid cells (NxN)
      cell: 6.2,       // world size of each lot cell
      roadW: 2.5,      // road half width
      sideW: 1.1,      // sidewalk width hint
      baseY: 0,
    };

    const TYPES = [
      { name:"homes",   color:new BABYLON.Color3(0.21, 0.83, 0.62) },
      { name:"offices", color:new BABYLON.Color3(0.40, 0.70, 1.00) },
      { name:"shops",   color:new BABYLON.Color3(1.00, 0.82, 0.40) },
      { name:"landmark",color:new BABYLON.Color3(1.00, 0.42, 0.55) },
    ];

    // city state
    let roadsH = []; // horizontal roads at row boundaries (0..N)
    let roadsV = []; // vertical roads at col boundaries (0..N)
    let lots = [];   // NxN
    let buildingCount = 0;

    // agents
    let cars = [];
    let people = [];

    // progression
    let paused = false;
    let time = 0;
    let devProgress = 0; // 0..1-ish
    let targetDensity = 0.55; // slider
    let trafficLevel = 0.55;
    let devSpeed = 0.55;

    // ---------- Materials ----------
    let mats = {};

    function makeMaterials(scene){
      mats = {};

      mats.ground = new BABYLON.PBRMaterial("ground", scene);
      mats.ground.albedoColor = new BABYLON.Color3(0.08, 0.10, 0.14);
      mats.ground.roughness = 1.0; mats.ground.metallic = 0.0;

      mats.road = new BABYLON.PBRMaterial("road", scene);
      mats.road.albedoColor = new BABYLON.Color3(0.16, 0.16, 0.19);
      mats.road.roughness = 0.98; mats.road.metallic = 0.0;

      mats.sidewalk = new BABYLON.PBRMaterial("sidewalk", scene);
      mats.sidewalk.albedoColor = new BABYLON.Color3(0.23, 0.23, 0.26);
      mats.sidewalk.roughness = 0.99; mats.sidewalk.metallic = 0.0;

      mats.lane = new BABYLON.StandardMaterial("lane", scene);
      mats.lane.emissiveColor = new BABYLON.Color3(1.0, 0.92, 0.55);
      mats.lane.diffuseColor = new BABYLON.Color3(0,0,0);
      mats.lane.alpha = 0.55;

      mats.glass = new BABYLON.PBRMaterial("glass", scene);
      mats.glass.albedoColor = new BABYLON.Color3(0.50, 0.75, 1.0);
      mats.glass.metallic = 0.0;
      mats.glass.roughness = 0.10;
      mats.glass.alpha = 0.55;

      mats.roof = new BABYLON.PBRMaterial("roof", scene);
      mats.roof.albedoColor = new BABYLON.Color3(0.18, 0.18, 0.22);
      mats.roof.roughness = 0.95; mats.roof.metallic = 0.0;

      mats.accent = new BABYLON.StandardMaterial("accent", scene);
      mats.accent.emissiveColor = new BABYLON.Color3(0.20, 0.45, 0.85);
      mats.accent.diffuseColor = new BABYLON.Color3(0,0,0);

      mats.car = new BABYLON.PBRMaterial("car", scene);
      mats.car.albedoColor = new BABYLON.Color3(0.95, 0.95, 0.98);
      mats.car.roughness = 0.35; mats.car.metallic = 0.15;

      mats.person = new BABYLON.PBRMaterial("person", scene);
      mats.person.albedoColor = new BABYLON.Color3(0.95, 0.60, 0.35);
      mats.person.roughness = 0.9; mats.person.metallic = 0.0;

      // per-type building mats
      mats.building = TYPES.map((t, i) => {
        const m = new BABYLON.PBRMaterial("b_"+t.name, scene);
        m.albedoColor = t.color;
        m.roughness = 0.72;
        m.metallic = 0.05;
        return m;
      });
    }

    // ---------- Build base scene (ground + lights + camera) ----------
    function buildScene(){
      scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0.03, 0.05, 0.08, 1);

      camera = new BABYLON.ArcRotateCamera("cam", -Math.PI/2.2, Math.PI/2.8, 360, new BABYLON.Vector3(0, 12, 0), scene);
      camera.attachControl(canvas, true);
      camera.wheelDeltaPercentage = 0.01;
      camera.panningSensibility = 60;
      camera.lowerRadiusLimit = 110;
      camera.upperRadiusLimit = 1200;
      camera.lowerBetaLimit = 0.18;
      camera.upperBetaLimit = 1.45;

      // Soft lights
      const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0.2, 1, 0.1), scene);
      hemi.intensity = 0.75;

      const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.35, -1, -0.2), scene);
      sun.position = new BABYLON.Vector3(220, 320, 220);
      sun.intensity = 1.0;

      // Shadows for depth
      const shadowGen = new BABYLON.ShadowGenerator(2048, sun);
      shadowGen.useBlurExponentialShadowMap = true;
      shadowGen.blurKernel = 22;
      shadowGen.setDarkness(0.35);
      scene._shadowGen = shadowGen;

      // PostFX
      pipeline = new BABYLON.DefaultRenderingPipeline("pipe", true, scene, [camera]);
      pipeline.fxaaEnabled = true;
      pipeline.bloomEnabled = true;
      pipeline.bloomThreshold = 0.83;
      pipeline.bloomWeight = 0.18;
      pipeline.bloomKernel = 64;
      pipeline.imageProcessingEnabled = true;
      scene.imageProcessingConfiguration.contrast = 1.18;
      scene.imageProcessingConfiguration.exposure = 1.02;
      scene.imageProcessingConfiguration.toneMappingEnabled = true;
      scene.imageProcessingConfiguration.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_ACES;

      // Fog
      scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
      scene.fogDensity = 0.0022;
      scene.fogColor = new BABYLON.Color3(0.07, 0.10, 0.14);

      // Sky dome
      const sky = BABYLON.MeshBuilder.CreateSphere("sky", { diameter: 3000, segments: 24 }, scene);
      sky.isPickable = false;
      sky.infiniteDistance = true;
      const skyMat = new BABYLON.StandardMaterial("skyMat", scene);
      skyMat.backFaceCulling = false;
      skyMat.disableLighting = true;
      skyMat.emissiveColor = new BABYLON.Color3(0.06, 0.12, 0.20);
      sky.material = skyMat;

      // Particle texture
      scene._ptex = makeParticleTexture(scene);

      makeMaterials(scene);

      // Ground plane
      const size = CITY.N * CITY.cell;
      const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: size+60, height: size+60, subdivisions: 2 }, scene);
      ground.position.y = CITY.baseY;
      ground.material = mats.ground;
      ground.receiveShadows = true;

      // Subtle "grid glow" (helpful for reading the simulation)
      const grid = BABYLON.MeshBuilder.CreateGround("grid", { width: size+60, height: size+60, subdivisions: 1 }, scene);
      grid.position.y = CITY.baseY + 0.01;
      const gridMat = new BABYLON.StandardMaterial("gridMat", scene);
      gridMat.emissiveColor = new BABYLON.Color3(0.20, 0.45, 0.85);
      gridMat.alpha = 0.05;
      grid.material = gridMat;

      // City root
      scene._root = new BABYLON.TransformNode("cityRoot", scene);

      // Initialize city state
      resetCity();

      // Update loop
      scene.onBeforeRenderObservable.add(() => {
        const dt = Math.min(0.05, engine.getDeltaTime()/1000);
        if (!paused){
          time += dt;
          simulate(dt);
        }
        updateUI();
      });

      return scene;
    }

    // ---------- Build / Reset City ----------
    function resetCity(){
      // Dispose old meshes under root
      if (scene._root){
        scene._root.getChildren().forEach(n => {
          if (n.dispose) n.dispose();
        });
      }

      // Clear agents
      cars = [];
      people = [];
      buildingCount = 0;
      devProgress = 0;
      time = 0;

      // Setup roads arrays
      roadsH = new Array(CITY.N+1).fill(false);
      roadsV = new Array(CITY.N+1).fill(false);

      // Major avenues always on (every 6 cells)
      for (let i=0;i<=CITY.N;i++){
        if (i % 6 === 0) { roadsH[i] = true; roadsV[i] = true; }
      }

      // Downtown "core" thick cross
      roadsH[Math.floor(CITY.N/2)] = true;
      roadsV[Math.floor(CITY.N/2)] = true;

      // Lots
      lots = Array.from({length:CITY.N}, (_,r) =>
        Array.from({length:CITY.N}, (_,c)=>({
          state:0, // 0 empty, 1 building
          type:0,
          level:0,
          mesh:null,
          targetHeight:0,
          curHeight:0,
          footprint: 1, // mostly 1; occasional 2 for landmarks
        }))
      );

      // Build road meshes for currently active roads
      buildRoadMeshes();

      // Seed a few initial buildings
      for (let k=0;k<18;k++){
        tryDevelopOne(true);
      }

      // Spawn initial traffic
      refreshTrafficTargets(true);

      recenterCamera();
    }

    // ---------- Coordinates helpers ----------
    function cellToWorld(r,c){
      const size = CITY.N*CITY.cell;
      const x0 = -size/2 + CITY.cell/2;
      const z0 = -size/2 + CITY.cell/2;
      return new BABYLON.Vector3(x0 + c*CITY.cell, CITY.baseY, z0 + r*CITY.cell);
    }
    function roadLineWorldX(col){ // vertical road along Z at boundary col
      const size = CITY.N*CITY.cell;
      const x0 = -size/2;
      return x0 + col*CITY.cell;
    }
    function roadLineWorldZ(row){ // horizontal road along X at boundary row
      const size = CITY.N*CITY.cell;
      const z0 = -size/2;
      return z0 + row*CITY.cell;
    }

    // ---------- Road mesh building ----------
    let roadMeshes = [];
    function disposeRoadMeshes(){
      roadMeshes.forEach(m => m.dispose());
      roadMeshes = [];
    }

    function buildRoadMeshes(){
      disposeRoadMeshes();
      const root = scene._root;
      const size = CITY.N * CITY.cell;
      const roadW = CITY.roadW;

      // Roads (vertical lines)
      for (let c=0;c<=CITY.N;c++){
        if (!roadsV[c]) continue;
        const x = roadLineWorldX(c);
        const m = BABYLON.MeshBuilder.CreateBox("roadV", { width: roadW*2.1, height: 0.35, depth: size }, scene);
        m.position.set(x, CITY.baseY + 0.18, 0);
        m.material = mats.road;
        m.parent = root;
        m.receiveShadows = true;
        roadMeshes.push(m);

        // Sidewalk strips
        const s1 = BABYLON.MeshBuilder.CreateBox("sw", { width: 0.9, height: 0.22, depth: size }, scene);
        s1.position.set(x + roadW + 0.65, CITY.baseY + 0.12, 0);
        s1.material = mats.sidewalk; s1.parent = root; s1.receiveShadows = true;
        roadMeshes.push(s1);

        const s2 = s1.clone("sw2");
        s2.position.x = x - roadW - 0.65;
        s2.parent = root;
        roadMeshes.push(s2);

        // Lane marks (thin emissive planes)
        const lane = BABYLON.MeshBuilder.CreatePlane("lane", { width: 0.15, height: size }, scene);
        lane.rotation.x = Math.PI/2;
        lane.position.set(x, CITY.baseY + 0.36, 0);
        lane.material = mats.lane;
        lane.parent = root;
        roadMeshes.push(lane);
      }

      // Roads (horizontal)
      for (let r=0;r<=CITY.N;r++){
        if (!roadsH[r]) continue;
        const z = roadLineWorldZ(r);
        const m = BABYLON.MeshBuilder.CreateBox("roadH", { width: size, height: 0.35, depth: roadW*2.1 }, scene);
        m.position.set(0, CITY.baseY + 0.18, z);
        m.material = mats.road;
        m.parent = root;
        m.receiveShadows = true;
        roadMeshes.push(m);

        const s1 = BABYLON.MeshBuilder.CreateBox("sw", { width: size, height: 0.22, depth: 0.9 }, scene);
        s1.position.set(0, CITY.baseY + 0.12, z + roadW + 0.65);
        s1.material = mats.sidewalk; s1.parent = root; s1.receiveShadows = true;
        roadMeshes.push(s1);

        const s2 = s1.clone("sw2");
        s2.position.z = z - roadW - 0.65;
        s2.parent = root;
        roadMeshes.push(s2);

        const lane = BABYLON.MeshBuilder.CreatePlane("lane", { width: size, height: 0.15 }, scene);
        lane.rotation.x = Math.PI/2;
        lane.position.set(0, CITY.baseY + 0.36, z);
        lane.material = mats.lane;
        lane.parent = root;
        roadMeshes.push(lane);
      }

      // Slight outline for diorama readability
      roadMeshes.forEach(m => {
        m.renderOutline = true;
        m.outlineWidth = 0.02;
        m.outlineColor = new BABYLON.Color3(0.03,0.04,0.06);
      });
    }

    // ---------- Building creation ----------
    function pickBuildingType(r,c){
      // Downtown biases: center more offices/shops; edges more homes
      const mid = (CITY.N-1)/2;
      const dx = (c-mid)/(mid), dz = (r-mid)/(mid);
      const d = Math.sqrt(dx*dx + dz*dz); // 0 center, ~1 edge
      const t = clamp(1 - d, 0, 1);

      const u = rng();
      // Landmark rare near center
      if (t > 0.72 && u < 0.05) return 3;
      // offices more central
      if (u < lerp(0.18, 0.42, t)) return 1;
      // shops around center-mid
      if (u < lerp(0.40, 0.70, t)) return 2;
      // otherwise homes
      return 0;
    }

    function desiredLevel(r,c){
      // taller toward center + density
      const mid = (CITY.N-1)/2;
      const dx = (c-mid)/(mid), dz = (r-mid)/(mid);
      const d = Math.sqrt(dx*dx + dz*dz);
      const centerBoost = clamp(1 - d, 0, 1);
      // base level ~ 1..6 plus density
      const base = 1 + Math.floor(centerBoost*5.2 + targetDensity*3.0 + rng()*1.2);
      return clamp(base, 1, 8);
    }

    function makeBuildingMesh(r,c, typeIdx, level, footprint=1){
      const root = scene._root;
      const pos = cellToWorld(r,c);

      // lot size
      const lot = CITY.cell * 0.92;
      const w = lot * (footprint === 2 ? 1.95 : 1.0);
      const d = lot * (footprint === 2 ? 1.45 : 1.0);

      const h = 3.5 + level * 3.2;

      // tower
      const tower = BABYLON.MeshBuilder.CreateBox("b", { width: w, depth: d, height: h }, scene);
      tower.position.set(pos.x, CITY.baseY + h/2 + 0.35, pos.z);
      tower.material = mats.building[typeIdx];
      tower.parent = root;
      tower.receiveShadows = true;
      scene._shadowGen.addShadowCaster(tower);

      // glass accent for offices
      if (typeIdx === 1){
        const band = BABYLON.MeshBuilder.CreateBox("glassBand", { width: w*0.92, depth: d*0.92, height: h*0.65 }, scene);
        band.position.set(pos.x, CITY.baseY + h*0.55, pos.z);
        band.material = mats.glass;
        band.parent = root;
        band.receiveShadows = false;
      }

      // roof cap
      const cap = BABYLON.MeshBuilder.CreateBox("cap", { width: w*0.96, depth: d*0.96, height: 0.6 }, scene);
      cap.position.set(pos.x, CITY.baseY + h + 0.65, pos.z);
      cap.material = mats.roof;
      cap.parent = root;
      cap.receiveShadows = true;
      scene._shadowGen.addShadowCaster(cap);

      // tiny rooftop ‚ÄúHVAC‚Äù cubes
      for (let i=0;i<3;i++){
        if (rng() < 0.25) continue;
        const hv = BABYLON.MeshBuilder.CreateBox("hv", { width: 0.9, depth: 0.9, height: 0.6 }, scene);
        hv.position.set(pos.x + (rng()-0.5)*w*0.5, CITY.baseY + h + 1.1, pos.z + (rng()-0.5)*d*0.5);
        hv.material = mats.roof;
        hv.parent = root;
      }

      // outline for readability
      [tower, cap].forEach(m => {
        m.renderOutline = true;
        m.outlineWidth = 0.02;
        m.outlineColor = new BABYLON.Color3(0.03,0.04,0.06);
      });

      // initial scale for "growing" animation
      tower.scaling.y = 0.01;
      cap.scaling.y = 0.01;

      // store references
      return { tower, cap, height:h, pos };
    }

    // ---------- Development step ----------
    function isRoadAdjacent(r,c){
      // Adjacent to any active road boundary around the cell
      return roadsH[r] || roadsH[r+1] || roadsV[c] || roadsV[c+1];
    }

    function tryDevelopOne(initial=false){
      // Choose a random lot; prefer adjacency to roads
      // and avoid lots inside road strips
      for (let attempts=0; attempts<140; attempts++){
        const r = (rng()*CITY.N)|0;
        const c = (rng()*CITY.N)|0;
        const L = lots[r][c];

        // already developed?
        if (L.state !== 0 && !initial) {
          // maybe upgrade
          if (rng() < 0.35) continue;
        }

        // must have road adjacency or early seed (initial)
        if (!initial && !isRoadAdjacent(r,c)) continue;

        // density check: chance to develop depends on slider + distance to center
        const mid = (CITY.N-1)/2;
        const dx = (c-mid)/(mid), dz = (r-mid)/(mid);
        const d = Math.sqrt(dx*dx + dz*dz);
        const centerBoost = clamp(1 - d, 0, 1);

        const chance = clamp(0.15 + targetDensity*0.75 + centerBoost*0.25, 0, 1);
        if (!initial && rng() > chance) continue;

        // Determine footprint: landmarks sometimes occupy 2x1, but avoid collisions
        let footprint = 1;
        const typeIdx = pickBuildingType(r,c);
        if (typeIdx === 3 && c < CITY.N-1 && lots[r][c+1].state === 0 && rng() < 0.55){
          footprint = 2;
        }

        const targetLvl = desiredLevel(r,c);
        if (L.state === 0){
          // create new building
          const mesh = makeBuildingMesh(r,c,typeIdx, targetLvl, footprint);
          L.state = 1;
          L.type = typeIdx;
          L.level = 1;               // starts low and grows
          L.targetLevel = targetLvl;
          L.mesh = mesh;
          L.curHeight = 0.01;
          L.targetHeight = mesh.height;
          L.footprint = footprint;
          buildingCount++;

          // reserve adjacent cell if footprint=2 (simple reservation)
          if (footprint === 2){
            const R = lots[r][c+1];
            R.state = 2; // reserved
            R.mesh = null;
          }

          if (!initial && rng() < 0.08){
            explosion(scene, new BABYLON.Vector3(mesh.pos.x, CITY.baseY+1.0, mesh.pos.z), new BABYLON.Color3(0.55,0.85,1.0), 0.9);
          }
          return true;
        } else if (L.state === 1){
          // upgrade existing building
          if (L.targetLevel < targetLvl) L.targetLevel = targetLvl;
          return true;
        }
      }
      return false;
    }

    function unlockRoads(dt){
      // As devProgress increases, enable more minor streets.
      // We'll "pulse" unlock new roads based on devSpeed and density.
      const pulse = dt * (0.10 + devSpeed*1.3);
      devProgress += pulse * (0.25 + targetDensity*0.75);

      // Aim: number of unlocked minor roads scales with devProgress
      const targetExtra = Math.floor(devProgress * 10 * (0.35 + targetDensity*0.75));

      // Candidate minor roads: not already active and not major (not %6==0)
      let activated = 0;
      for (let k=0;k<targetExtra;k++){
        // random choose H or V
        const horizontal = rng() < 0.5;
        const idx = 1 + ((rng()*(CITY.N-1))|0);
        if (idx % 6 === 0) continue; // major already
        if (horizontal){
          if (!roadsH[idx]) { roadsH[idx] = true; activated++; }
        } else {
          if (!roadsV[idx]) { roadsV[idx] = true; activated++; }
        }
      }

      if (activated > 0){
        buildRoadMeshes();
      }
    }

    // ---------- Building growth animation ----------
    function updateBuildings(dt){
      const growRate = (0.35 + devSpeed*1.8); // scaling rate
      const upgradeRate = (0.18 + devSpeed*1.1);

      for (let r=0;r<CITY.N;r++){
        for (let c=0;c<CITY.N;c++){
          const L = lots[r][c];
          if (L.state !== 1 || !L.mesh) continue;

          // Decide target height based on targetLevel (recompute smoothly)
          const targetH = 3.5 + L.targetLevel * 3.2;
          L.targetHeight = targetH;

          // Current displayed scale toward 1 (growth) and height changes
          const m = L.mesh;

          // Grow from ground
          const sY = m.tower.scaling.y;
          const to = clamp(sY + dt*growRate, 0.01, 1);
          m.tower.scaling.y = to;
          m.cap.scaling.y = to;

          // Smoothly adjust actual height by scaling Y (simple)
          // Additionally, introduce gradual "upgrades" that increase the mesh height illusion
          // by slightly stretching Y while keeping base anchored.
          const desired = L.targetLevel;
          if (L.level < desired){
            // chance to upgrade depends on speed + density
            if (rng() < dt * upgradeRate * (0.4 + targetDensity*0.8)){
              L.level++;
              // make a little celebration sparkle
              if (rng() < 0.12) explosion(scene, m.pos.add(new BABYLON.Vector3(0, 2.0, 0)), TYPES[L.type].color, 0.75);
            }
          }

          // Recompute tower & cap heights for the new level (stretch rather than rebuild)
          const newH = 3.5 + L.level * 3.2;
          const scaleY = newH / m.height;
          m.tower.scaling.y *= (0.85 + 0.15*scaleY);
          m.cap.position.y = CITY.baseY + newH + 0.65;
        }
      }
    }

    // ---------- Traffic / People ----------
    // We simulate cars and people as agents moving along road centerlines.
    // They follow a simple "lane graph": choose direction and turn at intersections.
    function randomRoadNode(){
      // pick an intersection where both roads are active
      for (let tries=0; tries<200; tries++){
        const r = (rng()*(CITY.N+1))|0;
        const c = (rng()*(CITY.N+1))|0;
        if (roadsH[r] && roadsV[c]) return { r, c };
      }
      // fallback: center
      return { r: Math.floor(CITY.N/2), c: Math.floor(CITY.N/2) };
    }

    function nodeToWorld(n){
      return new BABYLON.Vector3(roadLineWorldX(n.c), CITY.baseY + 0.35, roadLineWorldZ(n.r));
    }

    function neighbors(n){
      const out = [];
      // up/down (change r)
      if (n.r > 0 && roadsH[n.r-1] && roadsV[n.c]) out.push({ r:n.r-1, c:n.c });
      if (n.r < CITY.N && roadsH[n.r+1] && roadsV[n.c]) out.push({ r:n.r+1, c:n.c });
      // left/right (change c)
      if (n.c > 0 && roadsV[n.c-1] && roadsH[n.r]) out.push({ r:n.r, c:n.c-1 });
      if (n.c < CITY.N && roadsV[n.c+1] && roadsH[n.r]) out.push({ r:n.r, c:n.c+1 });
      return out;
    }

    function spawnCar(){
      const n0 = randomRoadNode();
      const n1 = pickNext(n0, null);

      const m = BABYLON.MeshBuilder.CreateBox("car", { width: 1.2, height: 0.7, depth: 2.1 }, scene);
      m.material = mats.car;
      m.parent = scene._root;
      m.renderOutline = true;
      m.outlineWidth = 0.02;
      m.outlineColor = new BABYLON.Color3(0.03,0.04,0.06);
      scene._shadowGen.addShadowCaster(m);

      // headlight glow (small emissive plane)
      const glow = BABYLON.MeshBuilder.CreatePlane("glow", { width: 0.8, height: 0.2 }, scene);
      glow.rotation.x = Math.PI/2;
      glow.position.y = 0.36;
      glow.material = mats.lane;
      glow.parent = m;

      // random car paint tint
      if (rng() < 0.6){
        const tint = new BABYLON.Color3(0.6 + rng()*0.4, 0.6 + rng()*0.4, 0.6 + rng()*0.4);
        const mat = m.material.clone("carClone");
        mat.albedoColor = tint;
        m.material = mat;
      }

      const a = {
        mesh: m,
        cur: n0,
        next: n1,
        t: 0,
        speed: 6 + rng()*5 + trafficLevel*5,
        laneOffset: (rng()<0.5 ? -1 : 1) * 0.65, // keep two ‚Äúlanes‚Äù
      };
      cars.push(a);
    }

    function spawnPerson(){
      // walk near sidewalks: choose road node then offset
      const n0 = randomRoadNode();
      const n1 = pickNext(n0, null);

      const m = BABYLON.MeshBuilder.CreateCapsule("p", { height: 1.6, radius: 0.35, tessellation: 10, capSubdivisions: 4 }, scene);
      m.material = mats.person;
      m.parent = scene._root;
      m.renderOutline = true;
      m.outlineWidth = 0.02;
      m.outlineColor = new BABYLON.Color3(0.03,0.04,0.06);
      scene._shadowGen.addShadowCaster(m);

      // random outfit hue
      const mat = m.material.clone("pClone");
      const hue = rng();
      mat.albedoColor = new BABYLON.Color3(0.45 + hue*0.4, 0.35 + (1-hue)*0.4, 0.25 + rng()*0.4);
      m.material = mat;

      const a = {
        mesh: m,
        cur: n0,
        next: n1,
        t: 0,
        speed: 2.0 + rng()*1.6 + trafficLevel*1.0,
        sideOffset: (rng()<0.5 ? -1 : 1) * (CITY.roadW + 0.95),
      };
      people.push(a);
    }

    function pickNext(cur, prev){
      const nbs = neighbors(cur);
      if (nbs.length === 0) return cur;

      // avoid immediate backtracking if possible
      let choices = nbs;
      if (prev){
        choices = nbs.filter(n => !(n.r === prev.r && n.c === prev.c));
        if (choices.length === 0) choices = nbs;
      }

      // slight bias: toward center (downtown)
      const mid = CITY.N/2;
      const score = (n) => {
        const dx = (n.c - mid), dz = (n.r - mid);
        const dist = Math.sqrt(dx*dx + dz*dz);
        return -dist + (rng()-0.5)*2.0;
      };

      let best = choices[0], bestS = score(best);
      for (let i=1;i<choices.length;i++){
        const s = score(choices[i]);
        if (s > bestS){ bestS = s; best = choices[i]; }
      }
      return best;
    }

    function refreshTrafficTargets(initial=false){
      // target agent counts based on traffic & density
      const base = CITY.N*CITY.N;
      const densityFactor = 0.35 + targetDensity*0.95;
      const t = trafficLevel;

      const targetCars = Math.floor((base/28) * densityFactor * (t/100) * 1.35);
      const targetPeople = Math.floor((base/20) * densityFactor * (t/100) * 1.20);

      // For intuitive slider mapping (traffic slider 0..100)
      // We'll store trafficLevel as 0..100.
      // If initial, spawn a small number even if t is low.
      const minCars = initial ? 6 : 0;
      const minPeople = initial ? 10 : 0;

      const wantCars = Math.max(minCars, targetCars);
      const wantPeople = Math.max(minPeople, targetPeople);

      // Add or remove cars
      while (cars.length < wantCars) spawnCar();
      while (cars.length > wantCars){
        const a = cars.pop();
        a.mesh.dispose();
      }

      while (people.length < wantPeople) spawnPerson();
      while (people.length > wantPeople){
        const a = people.pop();
        a.mesh.dispose();
      }
    }

    function updateAgents(dt){
      // Cars
      for (let i=cars.length-1;i>=0;i--){
        const a = cars[i];
        a.t += dt * (a.speed / CITY.cell);

        let p0 = nodeToWorld(a.cur);
        let p1 = nodeToWorld(a.next);

        // lane offset perpendicular to segment
        const dir = p1.subtract(p0); dir.y = 0;
        const len = dir.length();
        if (len > 0.001) dir.scaleInPlace(1/len);
        const right = new BABYLON.Vector3(dir.z, 0, -dir.x);

        p0 = p0.add(right.scale(a.laneOffset));
        p1 = p1.add(right.scale(a.laneOffset));

        // Move
        const t = clamp(a.t, 0, 1);
        const pos = BABYLON.Vector3.Lerp(p0, p1, smooth(t));
        a.mesh.position.set(pos.x, CITY.baseY + 0.55, pos.z);

        // Face direction
        a.mesh.rotation.y = Math.atan2(dir.x, dir.z);

        // Segment done
        if (a.t >= 1){
          const prev = a.cur;
          a.cur = a.next;
          a.next = pickNext(a.cur, prev);
          a.t = 0;

          // occasional honk sparkle to show life
          if (rng() < 0.01 * (trafficLevel/100)){
            explosion(scene, a.mesh.position.clone(), new BABYLON.Color3(0.55,0.85,1.0), 0.55);
          }
        }
      }

      // People
      for (let i=people.length-1;i>=0;i--){
        const a = people[i];
        a.t += dt * (a.speed / CITY.cell);

        let p0 = nodeToWorld(a.cur);
        let p1 = nodeToWorld(a.next);
        const dir = p1.subtract(p0); dir.y = 0;
        const len = dir.length();
        if (len > 0.001) dir.scaleInPlace(1/len);
        const right = new BABYLON.Vector3(dir.z, 0, -dir.x);

        // sidewalk offset
        p0 = p0.add(right.scale(a.sideOffset));
        p1 = p1.add(right.scale(a.sideOffset));

        const t = clamp(a.t, 0, 1);
        const pos = BABYLON.Vector3.Lerp(p0, p1, smooth(t));
        a.mesh.position.set(pos.x, CITY.baseY + 0.9, pos.z);

        a.mesh.rotation.y = Math.atan2(dir.x, dir.z);

        // bobbing walk animation
        a.mesh.position.y += Math.abs(Math.sin(time*6.0 + i))*0.05;

        if (a.t >= 1){
          const prev = a.cur;
          a.cur = a.next;
          a.next = pickNext(a.cur, prev);
          a.t = 0;
        }
      }
    }

    // ---------- Main simulate ----------
    function simulate(dt){
      // Update development params from sliders
      // density slider stored as 10..95 (%)
      targetDensity = ui.density.value / 100;
      trafficLevel = Number(ui.traffic.value); // 0..100
      devSpeed = ui.dev.value / 100;

      // Roads expand
      unlockRoads(dt);

      // Develop/upgrade buildings
      // number of develop attempts scales with devSpeed + density
      const attempts = Math.floor(1 + devSpeed*6 + targetDensity*3);
      for (let i=0;i<attempts;i++){
        if (rng() < 0.55) tryDevelopOne(false);
      }
      updateBuildings(dt);

      // Traffic refresh occasionally (so slider feels responsive but not expensive every frame)
      if (!scene._trafficTimer) scene._trafficTimer = 0;
      scene._trafficTimer += dt;
      if (scene._trafficTimer > 0.35){
        scene._trafficTimer = 0;
        refreshTrafficTargets(false);
      }

      // Move agents
      updateAgents(dt);
    }

    // ---------- UI ----------
    function updateUI(){
      ui.vDensity.textContent = ui.density.value;
      ui.vTraffic.textContent = ui.traffic.value;
      ui.vDev.textContent = ui.dev.value;

      ui.status.textContent = paused ? "Paused" : "Running";
      ui.btnPause.textContent = paused ? "Resume" : "Pause";

      // Approx population: buildingCount * factor based on density and building levels
      let pop = 0;
      for (let r=0;r<CITY.N;r++){
        for (let c=0;c<CITY.N;c++){
          const L = lots[r][c];
          if (L.state !== 1) continue;
          const base = (L.type === 0 ? 32 : (L.type === 1 ? 60 : (L.type === 2 ? 40 : 120)));
          pop += base * (0.5 + L.level*0.18);
        }
      }
      pop = Math.floor(pop * (0.35 + targetDensity*0.85));

      ui.pop.textContent = pop.toLocaleString();
      ui.bld.textContent = buildingCount.toString();
      ui.cars.textContent = cars.length.toString();
      ui.people.textContent = people.length.toString();
    }

    function recenterCamera(){
      const size = CITY.N*CITY.cell;
      camera.target = new BABYLON.Vector3(0, 10, 0);
      camera.radius = Math.max(240, size*0.95);
      camera.alpha = -Math.PI/2.2;
      camera.beta = Math.PI/2.9;
    }

    // ---------- Controls ----------
    ui.btnPause.addEventListener("click", () => { paused = !paused; });
    ui.btnReset.addEventListener("click", () => resetCity());
    ui.btnCenter.addEventListener("click", () => recenterCamera());

    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k === "p"){ paused = !paused; }
      if (k === "r"){ resetCity(); }
    });

    // Keep sliders live-update even when paused (UI still updates)
    ["input","change"].forEach(evt => {
      ui.density.addEventListener(evt, ()=>updateUI());
      ui.traffic.addEventListener(evt, ()=>updateUI());
      ui.dev.addEventListener(evt, ()=>updateUI());
    });

    // ---------- Boot ----------
    buildScene();

    engine.runRenderLoop(() => scene.render());
    window.addEventListener("resize", () => engine.resize());

  })();
  </script>
</body>
</html>
