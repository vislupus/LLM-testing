<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Growing City Simulation</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #0c2461, #1e3799);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            padding: 20px 30px;
            background: rgba(0, 0, 0, 0.8);
            border-bottom: 3px solid #3498db;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            z-index: 10;
        }

        .title-container {
            flex: 1;
        }

        .title {
            font-size: 32px;
            font-weight: bold;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
        }

        .subtitle {
            font-size: 14px;
            color: #bdc3c7;
            opacity: 0.9;
        }

        .stats-container {
            display: flex;
            gap: 20px;
            font-size: 14px;
        }

        .stat {
            background: rgba(52, 152, 219, 0.2);
            padding: 8px 15px;
            border-radius: 10px;
            border: 1px solid rgba(52, 152, 219, 0.5);
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #2ecc71;
        }

        /* Main Content */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Canvas */
        #renderCanvas {
            flex: 1;
            width: 70%;
            height: calc(100vh - 160px);
            display: block;
            touch-action: none;
        }

        /* Control Panel */
        .control-panel {
            width: 30%;
            background: rgba(0, 0, 0, 0.85);
            padding: 25px;
            overflow-y: auto;
            border-left: 2px solid #3498db;
            backdrop-filter: blur(10px);
        }

        .control-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section-title {
            font-size: 20px;
            color: #3498db;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title i {
            font-size: 22px;
        }

        /* Slider Controls */
        .slider-container {
            margin-bottom: 20px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .slider-value {
            color: #2ecc71;
            font-weight: bold;
        }

        .slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
        }

        .slider::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
        }

        /* Buttons */
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: #3498db;
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.reset {
            background: #e74c3c;
        }

        .btn.reset:hover {
            background: #c0392b;
        }

        .btn.pause {
            background: #f39c12;
        }

        .btn.pause:hover {
            background: #d35400;
        }

        .btn.speed {
            background: #9b59b6;
        }

        .btn.speed:hover {
            background: #8e44ad;
        }

        /* Legend */
        .legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }

        /* Camera Controls */
        .camera-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .camera-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #3498db;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s;
        }

        .camera-btn:hover {
            background: #3498db;
            transform: scale(1.1);
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0c2461, #1e3799);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loading-title {
            font-size: 42px;
            color: #3498db;
            margin-bottom: 20px;
            text-align: center;
        }

        .loading-progress-container {
            width: 300px;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            width: 0%;
            transition: width 0.3s ease;
        }

        .loading-text {
            font-size: 16px;
            color: #ecf0f1;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .main-content {
                flex-direction: column;
            }
            
            #renderCanvas {
                width: 100%;
                height: 60vh;
            }
            
            .control-panel {
                width: 100%;
                height: 40vh;
            }
            
            .header {
                padding: 15px;
            }
            
            .title {
                font-size: 24px;
            }
        }

        /* Simulation Time */
        .simulation-time {
            position: absolute;
            top: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #3498db;
            font-size: 18px;
            font-weight: bold;
            z-index: 10;
        }

        /* Traffic Stats */
        .traffic-stats {
            position: absolute;
            top: 150px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #e74c3c;
            font-size: 14px;
            z-index: 10;
            max-width: 200px;
        }

        .traffic-stat {
            margin: 5px 0;
        }
    </style>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-title">3D City Growth Simulation</div>
        <div class="loading-progress-container">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
        <div class="loading-text" id="loadingText">Initializing simulation engine...</div>
    </div>

    <!-- Header -->
    <div class="header">
        <div class="title-container">
            <div class="title">Dynamic City Growth Simulator</div>
            <div class="subtitle">Watch as a city evolves from a small settlement to a bustling metropolis</div>
        </div>
        <div class="stats-container">
            <div class="stat">
                <div>Population</div>
                <div class="stat-value" id="populationStat">0</div>
            </div>
            <div class="stat">
                <div>Buildings</div>
                <div class="stat-value" id="buildingStat">0</div>
            </div>
            <div class="stat">
                <div>Vehicles</div>
                <div class="stat-value" id="vehicleStat">0</div>
            </div>
            <div class="stat">
                <div>Road Length</div>
                <div class="stat-value" id="roadStat">0 km</div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Canvas -->
        <canvas id="renderCanvas"></canvas>

        <!-- Control Panel -->
        <div class="control-panel">
            <!-- City Development Controls -->
            <div class="control-section">
                <div class="section-title">
                    <i class="fas fa-city"></i>
                    City Development
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>City Size / Density</span>
                        <span class="slider-value" id="sizeValue">50%</span>
                    </div>
                    <input type="range" min="10" max="100" value="50" class="slider" id="sizeSlider">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Development Speed</span>
                        <span class="slider-value" id="speedValue">Normal</span>
                    </div>
                    <input type="range" min="1" max="10" value="5" class="slider" id="speedSlider">
                </div>
                
                <div class="button-group">
                    <button class="btn pause" id="pauseBtn">
                        <i class="fas fa-pause"></i> Pause
                    </button>
                    <button class="btn reset" id="resetBtn">
                        <i class="fas fa-redo"></i> Reset
                    </button>
                </div>
            </div>

            <!-- Traffic Controls -->
            <div class="control-section">
                <div class="section-title">
                    <i class="fas fa-car"></i>
                    Traffic & Population
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Traffic Intensity</span>
                        <span class="slider-value" id="trafficValue">50%</span>
                    </div>
                    <input type="range" min="10" max="100" value="50" class="slider" id="trafficSlider">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Pedestrian Activity</span>
                        <span class="slider-value" id="pedestrianValue">50%</span>
                    </div>
                    <input type="range" min="10" max="100" value="50" class="slider" id="pedestrianSlider">
                </div>
                
                <div class="button-group">
                    <button class="btn" id="rushHourBtn">
                        <i class="fas fa-clock"></i> Rush Hour
                    </button>
                    <button class="btn" id="nightModeBtn">
                        <i class="fas fa-moon"></i> Night Mode
                    </button>
                </div>
            </div>

            <!-- Building Types -->
            <div class="control-section">
                <div class="section-title">
                    <i class="fas fa-building"></i>
                    Building Distribution
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Residential Buildings</span>
                        <span class="slider-value" id="residentialValue">60%</span>
                    </div>
                    <input type="range" min="10" max="90" value="60" class="slider" id="residentialSlider">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Commercial Buildings</span>
                        <span class="slider-value" id="commercialValue">30%</span>
                    </div>
                    <input type="range" min="5" max="50" value="30" class="slider" id="commercialSlider">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Industrial Buildings</span>
                        <span class="slider-value" id="industrialValue">10%</span>
                    </div>
                    <input type="range" min="1" max="30" value="10" class="slider" id="industrialSlider">
                </div>
            </div>

            <!-- Legend -->
            <div class="control-section">
                <div class="section-title">
                    <i class="fas fa-key"></i>
                    Legend
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>Residential</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2ecc71;"></div>
                        <span>Commercial</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>Industrial</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f1c40f;"></div>
                        <span>Public/Service</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #95a5a6;"></div>
                        <span>Roads</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2c3e50;"></div>
                        <span>Parks/Green</span>
                    </div>
                </div>
            </div>

            <!-- Info -->
            <div class="control-section">
                <div class="section-title">
                    <i class="fas fa-info-circle"></i>
                    Simulation Info
                </div>
                <p style="font-size: 13px; line-height: 1.5; color: #bdc3c7;">
                    This simulation shows the organic growth of a city over time. 
                    Adjust the sliders to see how different factors affect urban development, 
                    traffic patterns, and population distribution.
                </p>
            </div>
        </div>
    </div>

    <!-- Simulation Time Display -->
    <div class="simulation-time" id="simulationTime">
        Year: 2024 | Time: 08:00 AM
    </div>

    <!-- Traffic Stats -->
    <div class="traffic-stats">
        <div class="traffic-stat">Traffic Flow: <span id="trafficFlow">Normal</span></div>
        <div class="traffic-stat">Avg. Speed: <span id="avgSpeed">45 km/h</span></div>
        <div class="traffic-stat">Congestion: <span id="congestionLevel">Low</span></div>
    </div>

    <!-- Camera Controls -->
    <div class="camera-controls">
        <button class="camera-btn" id="cameraTop" title="Top View">
            <i class="fas fa-satellite"></i>
        </button>
        <button class="camera-btn" id="cameraDefault" title="Default View">
            <i class="fas fa-home"></i>
        </button>
        <button class="camera-btn" id="cameraFollow" title="Follow Vehicle">
            <i class="fas fa-car-side"></i>
        </button>
    </div>

    <script>
        // =====================
        // CITY SIMULATION ENGINE
        // =====================
        
        // Global variables
        let scene, engine, camera, light;
        let city = {
            grid: [],
            buildings: [],
            roads: [],
            vehicles: [],
            pedestrians: [],
            gridSize: 50,
            cellSize: 4,
            time: {
                year: 2024,
                hour: 8,
                minute: 0,
                day: 1,
                paused: false,
                speed: 1
            },
            stats: {
                population: 0,
                buildings: 0,
                vehicles: 0,
                roadLength: 0
            },
            params: {
                citySize: 50,
                trafficIntensity: 50,
                developmentSpeed: 5,
                pedestrianActivity: 50,
                residentialRatio: 60,
                commercialRatio: 30,
                industrialRatio: 10
            },
            isNightMode: false,
            isRushHour: false
        };

        // Building types with colors and properties
        const buildingTypes = {
            residential: {
                name: "Residential",
                color: new BABYLON.Color3(0.2, 0.6, 0.9), // Blue
                minHeight: 2,
                maxHeight: 8,
                populationPerUnit: 10,
                probability: 0.6
            },
            commercial: {
                name: "Commercial",
                color: new BABYLON.Color3(0.2, 0.8, 0.4), // Green
                minHeight: 3,
                maxHeight: 12,
                populationPerUnit: 5,
                probability: 0.3
            },
            industrial: {
                name: "Industrial",
                color: new BABYLON.Color3(0.9, 0.3, 0.2), // Red
                minHeight: 2,
                maxHeight: 6,
                populationPerUnit: 2,
                probability: 0.1
            },
            service: {
                name: "Service",
                color: new BABYLON.Color3(0.95, 0.8, 0.1), // Yellow
                minHeight: 1,
                maxHeight: 4,
                populationPerUnit: 1,
                probability: 0.05
            }
        };

        // Initialize Babylon.js
        const initEngine = () => {
            updateLoading("Initializing 3D engine...", 10);
            
            const canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, { 
                preserveDrawingBuffer: true, 
                stencil: true 
            });
            scene = new BABYLON.Scene(engine);
            
            updateLoading("Setting up camera and lighting...", 20);
            
            // Create camera
            createCamera();
            
            // Create lighting
            createLighting();
            
            // Create environment
            createEnvironment();
            
            // Initialize city grid
            initCityGrid();
            
            // Create initial city
            createInitialCity();
            
            // Setup UI controls
            setupControls();
            
            updateLoading("Starting simulation...", 90);
            
            // Start render loop
            engine.runRenderLoop(() => {
                if (!city.time.paused) {
                    updateSimulation();
                }
                scene.render();
            });
            
            // Handle resize
            window.addEventListener('resize', () => {
                engine.resize();
            });
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loadingScreen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    updateLoading("Simulation ready!", 100);
                }, 500);
            }, 1500);
        };

        // Create camera
        const createCamera = () => {
            // Arc rotate camera for orbiting around city
            camera = new BABYLON.ArcRotateCamera("camera", 
                -Math.PI / 3, Math.PI / 3, 150, 
                new BABYLON.Vector3(city.gridSize * city.cellSize / 2, 10, city.gridSize * city.cellSize / 2), 
                scene);
            
            camera.attachControl(engine.getRenderingCanvas(), true);
            camera.lowerRadiusLimit = 50;
            camera.upperRadiusLimit = 500;
            camera.wheelPrecision = 50;
            camera.panningSensibility = 100;
            camera.inertia = 0.9;
            camera.panningInertia = 0.9;
            
            // Add post-processing for visual appeal
            const fx = new BABYLON.DefaultRenderingPipeline("fx", true, scene, [camera]);
            fx.samples = 4;
            fx.bloomEnabled = true;
            fx.bloomThreshold = 0.8;
            fx.bloomWeight = 0.3;
            fx.bloomKernel = 32;
            fx.bloomScale = 0.5;
        };

        // Create lighting
        const createLighting = () => {
            // Hemispheric light for ambient
            const hemiLight = new BABYLON.HemisphericLight("hemiLight", 
                new BABYLON.Vector3(0, 1, 0), scene);
            hemiLight.intensity = 0.7;
            hemiLight.groundColor = new BABYLON.Color3(0.3, 0.6, 0.9);
            hemiLight.diffuse = new BABYLON.Color3(0.9, 0.8, 0.7);
            
            // Directional light for sun
            window.sunLight = new BABYLON.DirectionalLight("sun", 
                new BABYLON.Vector3(-1, -2, -1), scene);
            window.sunLight.intensity = 0.9;
            window.sunLight.position = new BABYLON.Vector3(50, 100, 50);
            window.sunLight.diffuse = new BABYLON.Color3(1, 0.95, 0.85);
            
            // Add shadows
            window.sunLight.shadowEnabled = true;
            const shadowGenerator = new BABYLON.ShadowGenerator(1024, window.sunLight);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;
            
            // Point lights for night mode
            window.streetLights = [];
        };

        // Create environment
        const createEnvironment = () => {
            // Ground
            const ground = BABYLON.MeshBuilder.CreateGround("ground", {
                width: city.gridSize * city.cellSize + 100,
                height: city.gridSize * city.cellSize + 100
            }, scene);
            
            const groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
            groundMaterial.diffuseColor = new BABYLON.Color3(0.1, 0.15, 0.1);
            groundMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            
            // Add some grass texture effect
            const grassTexture = new BABYLON.Texture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAFElEQVQYV2NkYGD4z4AASDKKUQIAOw4BAQUhK78AAAAASUVORK5CYII=", scene);
            grassTexture.uScale = 20;
            grassTexture.vScale = 20;
            groundMaterial.diffuseTexture = grassTexture;
            
            ground.material = groundMaterial;
            ground.position.y = -0.1;
            
            // Skybox with gradient
            const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 5000 }, scene);
            const skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
            skyboxMaterial.backFaceCulling = false;
            
            // Create gradient sky
            const vertexShader = `
                precision highp float;
                attribute vec3 position;
                uniform mat4 worldViewProjection;
                varying vec3 vPosition;
                void main(void) {
                    gl_Position = worldViewProjection * vec4(position, 1.0);
                    vPosition = position;
                }
            `;
            
            const fragmentShader = `
                precision highp float;
                varying vec3 vPosition;
                void main(void) {
                    float gradient = clamp(vPosition.y / 2500.0 + 0.5, 0.0, 1.0);
                    vec3 skyColor = mix(vec3(0.4, 0.6, 1.0), vec3(0.7, 0.8, 1.0), gradient);
                    gl_FragColor = vec4(skyColor, 1.0);
                }
            `;
            
            const shaderMaterial = new BABYLON.ShaderMaterial("skyShader", scene, {
                vertexSource: vertexShader,
                fragmentSource: fragmentShader
            }, {
                attributes: ["position"],
                uniforms: ["worldViewProjection"]
            });
            
            skybox.material = shaderMaterial;
            
            // Add fog for depth
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
            scene.fogDensity = 0.002;
            scene.fogColor = new BABYLON.Color3(0.7, 0.8, 1.0);
        };

        // Initialize city grid
        const initCityGrid = () => {
            updateLoading("Creating city grid...", 40);
            
            city.grid = [];
            for (let x = 0; x < city.gridSize; x++) {
                city.grid[x] = [];
                for (let z = 0; z < city.gridSize; z++) {
                    // Initialize grid cells as empty
                    city.grid[x][z] = {
                        type: 'empty',
                        building: null,
                        road: null,
                        occupied: false
                    };
                }
            }
        };

        // Create initial city
        const createInitialCity = () => {
            updateLoading("Generating initial city...", 60);
            
            // Create central road network
            createRoadNetwork();
            
            // Create initial buildings
            createInitialBuildings();
            
            // Create initial vehicles
            createInitialVehicles();
            
            // Create initial pedestrians
            createInitialPedestrians();
            
            // Update stats
            updateStats();
            updateUI();
        };

        // Create road network
        const createRoadNetwork = () => {
            // Create main roads in a grid pattern
            const roadSpacing = 8; // Every 8 cells
            
            for (let x = 0; x < city.gridSize; x++) {
                for (let z = 0; z < city.gridSize; z++) {
                    if (x % roadSpacing === 0 || z % roadSpacing === 0) {
                        createRoad(x, z);
                    }
                }
            }
            
            // Add some diagonal roads for variety
            for (let i = 0; i < city.gridSize; i += 12) {
                if (i < city.gridSize && i * 1.5 < city.gridSize) {
                    createRoad(i, Math.floor(i * 1.5));
                }
            }
        };

        // Create a road segment
        const createRoad = (x, z) => {
            if (x < 0 || x >= city.gridSize || z < 0 || z >= city.gridSize) return;
            if (city.grid[x][z].occupied) return;
            
            const road = BABYLON.MeshBuilder.CreateBox(`road_${x}_${z}`, {
                width: city.cellSize,
                height: 0.1,
                depth: city.cellSize
            }, scene);
            
            road.position.x = x * city.cellSize;
            road.position.z = z * city.cellSize;
            road.position.y = 0;
            
            const roadMaterial = new BABYLON.StandardMaterial(`roadMat_${x}_${z}`, scene);
            roadMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            roadMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            
            // Add road markings
            if ((x % 8 === 0 && z % 2 === 0) || (z % 8 === 0 && x % 2 === 0)) {
                const lineMaterial = new BABYLON.StandardMaterial(`lineMat_${x}_${z}`, scene);
                lineMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
                
                const line = BABYLON.MeshBuilder.CreateBox(`line_${x}_${z}`, {
                    width: city.cellSize * 0.8,
                    height: 0.11,
                    depth: 0.2
                }, scene);
                
                line.position.x = x * city.cellSize;
                line.position.z = z * city.cellSize;
                line.position.y = 0.11;
                line.material = lineMaterial;
                
                if (x % 8 === 0) {
                    line.rotation.y = Math.PI / 2;
                }
            }
            
            road.material = roadMaterial;
            city.grid[x][z].type = 'road';
            city.grid[x][z].road = road;
            city.grid[x][z].occupied = true;
            city.roads.push(road);
            city.stats.roadLength += city.cellSize;
        };

        // Create initial buildings
        const createInitialBuildings = () => {
            const initialBuildings = 50;
            
            for (let i = 0; i < initialBuildings; i++) {
                let placed = false;
                let attempts = 0;
                
                while (!placed && attempts < 100) {
                    const x = Math.floor(Math.random() * city.gridSize);
                    const z = Math.floor(Math.random() * city.gridSize);
                    
                    if (!city.grid[x][z].occupied) {
                        createBuilding(x, z);
                        placed = true;
                    }
                    attempts++;
                }
            }
        };

        // Create a building
        const createBuilding = (x, z) => {
            if (x < 0 || x >= city.gridSize || z < 0 || z >= city.gridSize) return;
            if (city.grid[x][z].occupied) return;
            
            // Determine building type based on ratios
            const rand = Math.random() * 100;
            let buildingType;
            
            if (rand < city.params.residentialRatio) {
                buildingType = 'residential';
            } else if (rand < city.params.residentialRatio + city.params.commercialRatio) {
                buildingType = 'commercial';
            } else {
                buildingType = 'industrial';
            }
            
            const type = buildingTypes[buildingType];
            const height = type.minHeight + Math.random() * (type.maxHeight - type.minHeight);
            
            // Create building
            const building = BABYLON.MeshBuilder.CreateBox(`building_${x}_${z}`, {
                width: city.cellSize * 0.9,
                height: height,
                depth: city.cellSize * 0.9
            }, scene);
            
            building.position.x = x * city.cellSize;
            building.position.z = z * city.cellSize;
            building.position.y = height / 2;
            
            // Create building material
            const buildingMaterial = new BABYLON.StandardMaterial(`buildingMat_${x}_${z}`, scene);
            buildingMaterial.diffuseColor = type.color;
            buildingMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            
            // Add windows
            const windowMaterial = new BABYLON.StandardMaterial(`windowMat_${x}_${z}`, scene);
            windowMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.9, 1.0);
            windowMaterial.emissiveColor = city.isNightMode ? 
                new BABYLON.Color3(0.5, 0.6, 0.8) : 
                new BABYLON.Color3(0, 0, 0);
            
            // Add window details for taller buildings
            if (height > 4) {
                const windowRows = Math.floor(height / 2);
                for (let row = 0; row < windowRows; row++) {
                    const window = BABYLON.MeshBuilder.CreateBox(`window_${x}_${z}_${row}`, {
                        width: city.cellSize * 0.1,
                        height: 0.5,
                        depth: city.cellSize * 0.7
                    }, scene);
                    
                    window.position.x = x * city.cellSize + (Math.random() - 0.5) * city.cellSize * 0.5;
                    window.position.z = z * city.cellSize + (Math.random() - 0.5) * city.cellSize * 0.5;
                    window.position.y = row * 2 + 1;
                    window.material = windowMaterial;
                }
            }
            
            building.material = buildingMaterial;
            
            // Add to city
            city.grid[x][z].type = 'building';
            city.grid[x][z].building = {
                mesh: building,
                type: buildingType,
                height: height,
                population: Math.floor(height * type.populationPerUnit)
            };
            city.grid[x][z].occupied = true;
            city.buildings.push(building);
            city.stats.buildings++;
            city.stats.population += city.grid[x][z].building.population;
            
            return building;
        };

        // Create initial vehicles
        const createInitialVehicles = () => {
            const initialVehicles = Math.floor(city.params.trafficIntensity / 5);
            
            for (let i = 0; i < initialVehicles; i++) {
                createVehicle();
            }
        };

        // Create a vehicle
        const createVehicle = () => {
            // Find a road to place the vehicle
            let roadX, roadZ;
            let attempts = 0;
            
            do {
                roadX = Math.floor(Math.random() * city.gridSize);
                roadZ = Math.floor(Math.random() * city.gridSize);
                attempts++;
            } while (city.grid[roadX][roadZ].type !== 'road' && attempts < 100);
            
            if (attempts >= 100) return;
            
            // Vehicle types
            const vehicleTypes = [
                { color: new BABYLON.Color3(0.9, 0.2, 0.2), size: 1.5, speed: 0.5 }, // Red car
                { color: new BABYLON.Color3(0.2, 0.2, 0.9), size: 2, speed: 0.3 }, // Blue truck
                { color: new BABYLON.Color3(0.1, 0.1, 0.1), size: 1.2, speed: 0.6 }, // Black car
                { color: new BABYLON.Color3(0.9, 0.9, 0.2), size: 1, speed: 0.7 }, // Yellow taxi
                { color: new BABYLON.Color3(0.8, 0.8, 0.8), size: 1.8, speed: 0.4 } // Gray bus
            ];
            
            const type = vehicleTypes[Math.floor(Math.random() * vehicleTypes.length)];
            
            // Create vehicle
            const vehicle = BABYLON.MeshBuilder.CreateBox(`vehicle_${city.vehicles.length}`, {
                width: type.size,
                height: 0.5,
                depth: type.size * 1.5
            }, scene);
            
            vehicle.position.x = roadX * city.cellSize + (Math.random() - 0.5) * city.cellSize * 0.8;
            vehicle.position.z = roadZ * city.cellSize + (Math.random() - 0.5) * city.cellSize * 0.8;
            vehicle.position.y = 0.5;
            
            // Create vehicle material
            const vehicleMaterial = new BABYLON.StandardMaterial(`vehicleMat_${city.vehicles.length}`, scene);
            vehicleMaterial.diffuseColor = type.color;
            vehicleMaterial.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            
            vehicle.material = vehicleMaterial;
            
            // Add vehicle data
            const vehicleData = {
                mesh: vehicle,
                speed: type.speed * (city.isRushHour ? 0.7 : 1),
                direction: Math.random() * Math.PI * 2,
                roadX: roadX,
                roadZ: roadZ,
                type: type
            };
            
            city.vehicles.push(vehicleData);
            city.stats.vehicles++;
            
            return vehicleData;
        };

        // Create initial pedestrians
        const createInitialPedestrians = () => {
            const initialPedestrians = Math.floor(city.params.pedestrianActivity / 10);
            
            for (let i = 0; i < initialPedestrians; i++) {
                createPedestrian();
            }
        };

        // Create a pedestrian
        const createPedestrian = () => {
            // Find a spot near a building
            let x, z;
            let attempts = 0;
            
            do {
                x = Math.floor(Math.random() * city.gridSize);
                z = Math.floor(Math.random() * city.gridSize);
                attempts++;
            } while (!city.grid[x][z].occupied && attempts < 100);
            
            if (attempts >= 100) return;
            
            // Create pedestrian (small cylinder for body, sphere for head)
            const body = BABYLON.MeshBuilder.CreateCylinder(`ped_body_${city.pedestrians.length}`, {
                height: 1.2,
                diameter: 0.3
            }, scene);
            
            const head = BABYLON.MeshBuilder.CreateSphere(`ped_head_${city.pedestrians.length}`, {
                diameter: 0.4
            }, scene);
            
            body.position.x = x * city.cellSize + (Math.random() - 0.5) * city.cellSize * 0.5;
            body.position.z = z * city.cellSize + (Math.random() - 0.5) * city.cellSize * 0.5;
            body.position.y = 0.6;
            
            head.position.x = body.position.x;
            head.position.z = body.position.z;
            head.position.y = 1.5;
            
            // Create materials
            const bodyMaterial = new BABYLON.StandardMaterial(`pedBodyMat_${city.pedestrians.length}`, scene);
            bodyMaterial.diffuseColor = new BABYLON.Color3(
                Math.random() * 0.5 + 0.5,
                Math.random() * 0.5 + 0.5,
                Math.random() * 0.5 + 0.5
            );
            
            const headMaterial = new BABYLON.StandardMaterial(`pedHeadMat_${city.pedestrians.length}`, scene);
            headMaterial.diffuseColor = new BABYLON.Color3(0.9, 0.8, 0.7);
            
            body.material = bodyMaterial;
            head.material = headMaterial;
            
            // Add pedestrian data
            const pedestrianData = {
                body: body,
                head: head,
                speed: 0.1 + Math.random() * 0.2,
                direction: Math.random() * Math.PI * 2,
                x: x,
                z: z
            };
            
            city.pedestrians.push(pedestrianData);
            
            return pedestrianData;
        };

        // Update simulation
        const updateSimulation = () => {
            // Update time
            updateTime();
            
            // Grow city based on development speed
            if (Math.random() < city.params.developmentSpeed / 500) {
                growCity();
            }
            
            // Update vehicles
            updateVehicles();
            
            // Update pedestrians
            updatePedestrians();
            
            // Update traffic based on time of day
            updateTrafficPatterns();
            
            // Update UI
            updateUI();
        };

        // Update time
        const updateTime = () => {
            city.time.minute += city.time.speed;
            
            if (city.time.minute >= 60) {
                city.time.minute = 0;
                city.time.hour++;
                
                if (city.time.hour >= 24) {
                    city.time.hour = 0;
                    city.time.day++;
                    
                    if (city.time.day > 365) {
                        city.time.day = 1;
                        city.time.year++;
                    }
                }
            }
        };

        // Grow city
        const growCity = () => {
            // Determine what to add based on probabilities
            const rand = Math.random();
            
            if (rand < 0.6) {
                // Add a building
                addRandomBuilding();
            } else if (rand < 0.85) {
                // Extend road
                extendRoad();
            } else if (rand < 0.95) {
                // Add a vehicle
                if (city.vehicles.length < city.params.trafficIntensity * 2) {
                    createVehicle();
                }
            } else {
                // Add a pedestrian
                if (city.pedestrians.length < city.params.pedestrianActivity) {
                    createPedestrian();
                }
            }
            
            // Update stats
            updateStats();
        };

        // Add a random building
        const addRandomBuilding = () => {
            // Try to find an empty spot near existing roads or buildings
            let x, z;
            let attempts = 0;
            let found = false;
            
            while (!found && attempts < 200) {
                x = Math.floor(Math.random() * city.gridSize);
                z = Math.floor(Math.random() * city.gridSize);
                
                // Check if spot is empty and near something
                if (!city.grid[x][z].occupied) {
                    // Check adjacent cells for roads or buildings
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            const nx = x + dx;
                            const nz = z + dz;
                            
                            if (nx >= 0 && nx < city.gridSize && nz >= 0 && nz < city.gridSize) {
                                if (city.grid[nx][nz].type === 'road' || city.grid[nx][nz].type === 'building') {
                                    found = true;
                                    break;
                                }
                            }
                        }
                        if (found) break;
                    }
                }
                attempts++;
            }
            
            if (found) {
                createBuilding(x, z);
            }
        };

        // Extend road
        const extendRoad = () => {
            // Find a road endpoint
            let startX, startZ;
            let attempts = 0;
            let found = false;
            
            while (!found && attempts < 100) {
                startX = Math.floor(Math.random() * city.gridSize);
                startZ = Math.floor(Math.random() * city.gridSize);
                
                if (city.grid[startX][startZ].type === 'road') {
                    // Check if it's an endpoint (has fewer than 4 road neighbors)
                    let roadNeighbors = 0;
                    
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            if (Math.abs(dx) + Math.abs(dz) !== 1) continue;
                            
                            const nx = startX + dx;
                            const nz = startZ + dz;
                            
                            if (nx >= 0 && nx < city.gridSize && nz >= 0 && nz < city.gridSize) {
                                if (city.grid[nx][nz].type === 'road') {
                                    roadNeighbors++;
                                }
                            }
                        }
                    }
                    
                    if (roadNeighbors <= 2) {
                        found = true;
                    }
                }
                attempts++;
            }
            
            if (found) {
                // Extend in a random direction
                const directions = [[1,0], [-1,0], [0,1], [0,-1]];
                const [dx, dz] = directions[Math.floor(Math.random() * directions.length)];
                
                let length = Math.floor(Math.random() * 5) + 1;
                
                for (let i = 1; i <= length; i++) {
                    const nx = startX + dx * i;
                    const nz = startZ + dz * i;
                    
                    if (nx >= 0 && nx < city.gridSize && nz >= 0 && nz < city.gridSize) {
                        if (!city.grid[nx][nz].occupied) {
                            createRoad(nx, nz);
                        } else {
                            break;
                        }
                    } else {
                        break;
                    }
                }
            }
        };

        // Update vehicles
        const updateVehicles = () => {
            city.vehicles.forEach((vehicle, index) => {
                // Update position based on direction and speed
                const speed = vehicle.speed * (city.isRushHour ? 0.7 : 1) * city.time.speed;
                vehicle.mesh.position.x += Math.cos(vehicle.direction) * speed;
                vehicle.mesh.position.z += Math.sin(vehicle.direction) * speed;
                
                // Update rotation to face direction
                vehicle.mesh.rotation.y = vehicle.direction;
                
                // Check if vehicle is still on a road
                const gridX = Math.floor(vehicle.mesh.position.x / city.cellSize);
                const gridZ = Math.floor(vehicle.mesh.position.z / city.cellSize);
                
                if (gridX >= 0 && gridX < city.gridSize && gridZ >= 0 && gridZ < city.gridSize) {
                    if (city.grid[gridX][gridZ].type !== 'road') {
                        // Turn to find a road
                        vehicle.direction += Math.PI / 2 + (Math.random() - 0.5) * Math.PI / 4;
                    }
                } else {
                    // Turn around if leaving the city
                    vehicle.direction += Math.PI;
                }
                
                // Randomly change direction occasionally
                if (Math.random() < 0.01) {
                    vehicle.direction += (Math.random() - 0.5) * Math.PI / 2;
                }
                
                // Keep vehicle on ground
                vehicle.mesh.position.y = 0.5;
                
                // Update light for night mode
                if (city.isNightMode && Math.random() < 0.1) {
                    const light = new BABYLON.PointLight(`vehicleLight_${index}`, 
                        vehicle.mesh.position, scene);
                    light.diffuse = new BABYLON.Color3(1, 0.9, 0.7);
                    light.intensity = 0.5;
                    light.range = 5;
                    
                    setTimeout(() => {
                        light.dispose();
                    }, 100);
                }
            });
        };

        // Update pedestrians
        const updatePedestrians = () => {
            city.pedestrians.forEach((pedestrian, index) => {
                const speed = 0.1 * city.time.speed;
                pedestrian.body.position.x += Math.cos(pedestrian.direction) * speed;
                pedestrian.body.position.z += Math.sin(pedestrian.direction) * speed;
                pedestrian.head.position.x = pedestrian.body.position.x;
                pedestrian.head.position.z = pedestrian.body.position.z;
                
                // Randomly change direction
                if (Math.random() < 0.02) {
                    pedestrian.direction += (Math.random() - 0.5) * Math.PI;
                }
                
                // Keep pedestrians within bounds
                if (pedestrian.body.position.x < 0 || pedestrian.body.position.x > city.gridSize * city.cellSize ||
                    pedestrian.body.position.z < 0 || pedestrian.body.position.z > city.gridSize * city.cellSize) {
                    pedestrian.direction += Math.PI;
                }
                
                // Simple walking animation
                const bounce = Math.sin(Date.now() * 0.01 + index) * 0.05;
                pedestrian.body.position.y = 0.6 + bounce;
                pedestrian.head.position.y = 1.5 + bounce;
            });
        };

        // Update traffic patterns based on time of day
        const updateTrafficPatterns = () => {
            // Check for rush hour (8-9 AM and 5-6 PM)
            const isMorningRush = city.time.hour === 8;
            const isEveningRush = city.time.hour === 17;
            
            city.isRushHour = isMorningRush || isEveningRush;
            
            // Update night mode
            city.isNightMode = city.time.hour >= 20 || city.time.hour < 6;
            
            // Update lighting for night mode
            if (city.isNightMode) {
                window.sunLight.intensity = 0.2;
                scene.ambientColor = new BABYLON.Color3(0.1, 0.1, 0.2);
                
                // Add street lights if needed
                if (window.streetLights.length < city.roads.length / 50) {
                    addStreetLights();
                }
            } else {
                window.sunLight.intensity = 0.9;
                scene.ambientColor = new BABYLON.Color3(0.7, 0.7, 0.7);
            }
        };

        // Add street lights for night mode
        const addStreetLights = () => {
            // Find a road to add a light
            for (let i = 0; i < 10; i++) {
                const x = Math.floor(Math.random() * city.gridSize);
                const z = Math.floor(Math.random() * city.gridSize);
                
                if (city.grid[x][z].type === 'road') {
                    const light = new BABYLON.PointLight(`streetLight_${window.streetLights.length}`, 
                        new BABYLON.Vector3(x * city.cellSize, 10, z * city.cellSize), scene);
                    light.diffuse = new BABYLON.Color3(1, 0.95, 0.8);
                    light.intensity = 0.8;
                    light.range = 15;
                    
                    // Create light pole
                    const pole = BABYLON.MeshBuilder.CreateCylinder(`lightPole_${window.streetLights.length}`, {
                        height: 8,
                        diameter: 0.3
                    }, scene);
                    
                    pole.position.x = x * city.cellSize;
                    pole.position.z = z * city.cellSize;
                    pole.position.y = 4;
                    
                    const poleMaterial = new BABYLON.StandardMaterial(`poleMat_${window.streetLights.length}`, scene);
                    poleMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                    pole.material = poleMaterial;
                    
                    window.streetLights.push(light);
                    break;
                }
            }
        };

        // Update stats
        const updateStats = () => {
            // Calculate traffic flow based on vehicle count and speed
            const avgSpeed = city.vehicles.length > 0 ? 
                city.vehicles.reduce((sum, v) => sum + v.speed, 0) / city.vehicles.length : 0;
            
            // Update DOM elements
            document.getElementById('populationStat').textContent = Math.floor(city.stats.population).toLocaleString();
            document.getElementById('buildingStat').textContent = city.stats.buildings;
            document.getElementById('vehicleStat').textContent = city.vehicles.length;
            document.getElementById('roadStat').textContent = Math.floor(city.stats.roadLength / 1000 * 10) / 10 + ' km';
            
            // Update traffic stats
            document.getElementById('avgSpeed').textContent = Math.floor(avgSpeed * 80) + ' km/h';
            document.getElementById('trafficFlow').textContent = city.isRushHour ? 'Heavy' : 'Normal';
            
            const congestion = city.vehicles.length / (city.params.trafficIntensity * 2);
            document.getElementById('congestionLevel').textContent = 
                congestion > 0.8 ? 'High' : congestion > 0.5 ? 'Medium' : 'Low';
            
            // Update simulation time
            const ampm = city.time.hour >= 12 ? 'PM' : 'AM';
            const displayHour = city.time.hour % 12 || 12;
            const displayMinute = Math.floor(city.time.minute).toString().padStart(2, '0');
            
            document.getElementById('simulationTime').textContent = 
                `Year: ${city.time.year} | Time: ${displayHour}:${displayMinute} ${ampm}`;
        };

        // Update UI based on slider values
        const updateUI = () => {
            // Update slider value displays
            document.getElementById('sizeValue').textContent = city.params.citySize + '%';
            document.getElementById('speedValue').textContent = 
                city.params.developmentSpeed <= 3 ? 'Slow' : 
                city.params.developmentSpeed <= 7 ? 'Normal' : 'Fast';
            document.getElementById('trafficValue').textContent = city.params.trafficIntensity + '%';
            document.getElementById('pedestrianValue').textContent = city.params.pedestrianActivity + '%';
            document.getElementById('residentialValue').textContent = city.params.residentialRatio + '%';
            document.getElementById('commercialValue').textContent = city.params.commercialRatio + '%';
            document.getElementById('industrialValue').textContent = city.params.industrialRatio + '%';
            
            // Update button states
            const pauseBtn = document.getElementById('pauseBtn');
            pauseBtn.innerHTML = city.time.paused ? 
                '<i class="fas fa-play"></i> Play' : 
                '<i class="fas fa-pause"></i> Pause';
        };

        // Setup UI controls
        const setupControls = () => {
            // City Size Slider
            document.getElementById('sizeSlider').addEventListener('input', (e) => {
                city.params.citySize = parseInt(e.target.value);
                // Adjust grid visibility based on size
                const activeSize = Math.floor(city.gridSize * (city.params.citySize / 100));
                // We could hide/show parts of the city here
                updateUI();
            });
            
            // Development Speed Slider
            document.getElementById('speedSlider').addEventListener('input', (e) => {
                city.params.developmentSpeed = parseInt(e.target.value);
                city.time.speed = city.params.developmentSpeed / 5;
                updateUI();
            });
            
            // Traffic Intensity Slider
            document.getElementById('trafficSlider').addEventListener('input', (e) => {
                city.params.trafficIntensity = parseInt(e.target.value);
                
                // Add or remove vehicles based on traffic intensity
                const targetVehicles = Math.floor(city.params.trafficIntensity * 2);
                
                if (targetVehicles > city.vehicles.length) {
                    // Add vehicles
                    const toAdd = targetVehicles - city.vehicles.length;
                    for (let i = 0; i < toAdd; i++) {
                        createVehicle();
                    }
                } else if (targetVehicles < city.vehicles.length) {
                    // Remove vehicles
                    const toRemove = city.vehicles.length - targetVehicles;
                    for (let i = 0; i < toRemove; i++) {
                        if (city.vehicles.length > 0) {
                            const vehicle = city.vehicles.pop();
                            vehicle.mesh.dispose();
                            city.stats.vehicles--;
                        }
                    }
                }
                
                updateUI();
            });
            
            // Pedestrian Activity Slider
            document.getElementById('pedestrianSlider').addEventListener('input', (e) => {
                city.params.pedestrianActivity = parseInt(e.target.value);
                
                // Add or remove pedestrians
                const targetPedestrians = Math.floor(city.params.pedestrianActivity);
                
                if (targetPedestrians > city.pedestrians.length) {
                    const toAdd = targetPedestrians - city.pedestrians.length;
                    for (let i = 0; i < toAdd; i++) {
                        createPedestrian();
                    }
                } else if (targetPedestrians < city.pedestrians.length) {
                    const toRemove = city.pedestrians.length - targetPedestrians;
                    for (let i = 0; i < toRemove; i++) {
                        if (city.pedestrians.length > 0) {
                            const pedestrian = city.pedestrians.pop();
                            pedestrian.body.dispose();
                            pedestrian.head.dispose();
                        }
                    }
                }
                
                updateUI();
            });
            
            // Building Distribution Sliders
            document.getElementById('residentialSlider').addEventListener('input', (e) => {
                city.params.residentialRatio = parseInt(e.target.value);
                updateUI();
            });
            
            document.getElementById('commercialSlider').addEventListener('input', (e) => {
                city.params.commercialRatio = parseInt(e.target.value);
                updateUI();
            });
            
            document.getElementById('industrialSlider').addEventListener('input', (e) => {
                city.params.industrialRatio = parseInt(e.target.value);
                updateUI();
            });
            
            // Control Buttons
            document.getElementById('pauseBtn').addEventListener('click', () => {
                city.time.paused = !city.time.paused;
                updateUI();
            });
            
            document.getElementById('resetBtn').addEventListener('click', () => {
                // Clear current city
                city.buildings.forEach(building => building.dispose());
                city.roads.forEach(road => road.dispose());
                city.vehicles.forEach(vehicle => vehicle.mesh.dispose());
                city.pedestrians.forEach(pedestrian => {
                    pedestrian.body.dispose();
                    pedestrian.head.dispose();
                });
                
                // Reset city data
                city.buildings = [];
                city.roads = [];
                city.vehicles = [];
                city.pedestrians = [];
                city.stats = {
                    population: 0,
                    buildings: 0,
                    vehicles: 0,
                    roadLength: 0
                };
                
                // Reinitialize grid
                initCityGrid();
                
                // Create new city
                createInitialCity();
                
                // Reset time
                city.time = {
                    year: 2024,
                    hour: 8,
                    minute: 0,
                    day: 1,
                    paused: false,
                    speed: 1
                };
                
                updateUI();
            });
            
            document.getElementById('rushHourBtn').addEventListener('click', () => {
                city.isRushHour = !city.isRushHour;
                const btn = document.getElementById('rushHourBtn');
                btn.innerHTML = city.isRushHour ? 
                    '<i class="fas fa-clock"></i> Normal Traffic' : 
                    '<i class="fas fa-clock"></i> Rush Hour';
            });
            
            document.getElementById('nightModeBtn').addEventListener('click', () => {
                city.isNightMode = !city.isNightMode;
                const btn = document.getElementById('nightModeBtn');
                btn.innerHTML = city.isNightMode ? 
                    '<i class="fas fa-sun"></i> Day Mode' : 
                    '<i class="fas fa-moon"></i> Night Mode';
                
                // Immediately update lighting
                updateTrafficPatterns();
            });
            
            // Camera Controls
            document.getElementById('cameraTop').addEventListener('click', () => {
                camera.alpha = -Math.PI / 2;
                camera.beta = Math.PI / 2;
                camera.radius = 200;
            });
            
            document.getElementById('cameraDefault').addEventListener('click', () => {
                camera.alpha = -Math.PI / 3;
                camera.beta = Math.PI / 3;
                camera.radius = 150;
                camera.target = new BABYLON.Vector3(city.gridSize * city.cellSize / 2, 10, city.gridSize * city.cellSize / 2);
            });
            
            document.getElementById('cameraFollow').addEventListener('click', () => {
                if (city.vehicles.length > 0) {
                    const randomVehicle = city.vehicles[Math.floor(Math.random() * city.vehicles.length)];
                    camera.target = randomVehicle.mesh.position;
                    camera.radius = 20;
                }
            });
        };

        // Update loading progress
        const updateLoading = (text, progress) => {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingProgress').style.width = `${progress}%`;
        };

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', () => {
            initEngine();
        });
    </script>
</body>
</html>