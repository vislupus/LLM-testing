<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Ray Tracing Simulation - Metallic Spheres</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
        }

        #renderCanvas {
            width: 100%;
            height: 100vh;
            display: block;
            touch-action: none;
        }

        /* Control Panel */
        .control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 320px;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 20px;
            padding: 20px;
            color: #fff;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        .panel-title {
            font-size: 1.3rem;
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(78, 205, 196, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sphere-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .sphere-title {
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sphere-blue {
            color: #4ecdc4;
        }

        .sphere-red {
            color: #e94560;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }

        .control-value {
            color: #f7b731;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .slider-reflectivity {
            background: linear-gradient(90deg, #3498db, #9b59b6, #e94560);
        }

        .slider-roughness {
            background: linear-gradient(90deg, #2ecc71, #f39c12, #e74c3c);
        }

        .slider-metallic {
            background: linear-gradient(90deg, #95a5a6, #f1c40f, #e67e22);
        }

        .slider-color {
            background: linear-gradient(90deg, #3498db, #9b59b6, #e74c3c, #f1c40f, #2ecc71);
        }

        /* Environment Controls */
        .environment-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .env-title {
            font-weight: bold;
            color: #f7b731;
            margin-bottom: 15px;
            font-size: 1rem;
        }

        /* Presets */
        .presets-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .presets-title {
            font-weight: bold;
            color: #aaa;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .preset-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .preset-btn {
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.3s ease;
        }

        .preset-btn:hover {
            background: rgba(78, 205, 196, 0.3);
            border-color: #4ecdc4;
        }

        /* Scene Info */
        .scene-info {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            font-size: 0.8rem;
            color: #aaa;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .info-value {
            color: #4ecdc4;
            font-weight: bold;
        }

        /* Title Overlay */
        .title-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 100;
        }

        .title-text {
            font-size: 1.8rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
            letter-spacing: 2px;
        }

        .subtitle-text {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 5px;
        }

        /* Controls Hint */
        .controls-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            padding: 12px 25px;
            border-radius: 25px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 100;
        }

        /* Color Picker */
        .color-picker-group {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }

        .color-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .color-btn:hover, .color-btn.active {
            transform: scale(1.15);
            border-color: #fff;
        }

        /* Toggle Switch */
        .toggle-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .toggle-label {
            font-size: 0.85rem;
            color: #aaa;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-switch.active {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
        }

        .toggle-knob {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .toggle-switch.active .toggle-knob {
            left: 27px;
        }
    </style>
</head>
<body>
    <!-- Main Canvas -->
    <canvas id="renderCanvas"></canvas>

    <!-- Title Overlay -->
    <div class="title-overlay">
        <div class="title-text">üîÆ Ray Tracing Simulation</div>
        <div class="subtitle-text">PBR Metallic Spheres in Street Scene</div>
    </div>

    <!-- Control Panel -->
    <div class="control-panel">
        <div class="panel-title">
            ‚öôÔ∏è Material Controls
        </div>

        <!-- Sphere 1 (Left) -->
        <div class="sphere-section">
            <div class="sphere-title sphere-blue">
                üîµ Sphere 1 (Left)
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Reflectivity</span>
                    <span class="control-value" id="sphere1-reflect-value">0.95</span>
                </div>
                <input type="range" class="slider slider-reflectivity" id="sphere1-reflect"
                       min="0" max="100" value="95">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Roughness</span>
                    <span class="control-value" id="sphere1-rough-value">0.05</span>
                </div>
                <input type="range" class="slider slider-roughness" id="sphere1-rough"
                       min="0" max="100" value="5">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Metallic</span>
                    <span class="control-value" id="sphere1-metallic-value">1.00</span>
                </div>
                <input type="range" class="slider slider-metallic" id="sphere1-metallic"
                       min="0" max="100" value="100">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Base Color</span>
                </div>
                <div class="color-picker-group">
                    <button class="color-btn active" data-color="#4ecdc4" data-sphere="1" style="background: #4ecdc4;"></button>
                    <button class="color-btn" data-color="#3498db" data-sphere="1" style="background: #3498db;"></button>
                    <button class="color-btn" data-color="#9b59b6" data-sphere="1" style="background: #9b59b6;"></button>
                    <button class="color-btn" data-color="#e74c3c" data-sphere="1" style="background: #e74c3c;"></button>
                    <button class="color-btn" data-color="#f1c40f" data-sphere="1" style="background: #f1c40f;"></button>
                    <button class="color-btn" data-color="#2ecc71" data-sphere="1" style="background: #2ecc71;"></button>
                    <button class="color-btn" data-color="#e67e22" data-sphere="1" style="background: #e67e22;"></button>
                    <button class="color-btn" data-color="#ffffff" data-sphere="1" style="background: #ffffff;"></button>
                </div>
            </div>
        </div>

        <!-- Sphere 2 (Right) -->
        <div class="sphere-section">
            <div class="sphere-title sphere-red">
                üî¥ Sphere 2 (Right)
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Reflectivity</span>
                    <span class="control-value" id="sphere2-reflect-value">0.90</span>
                </div>
                <input type="range" class="slider slider-reflectivity" id="sphere2-reflect"
                       min="0" max="100" value="90">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Roughness</span>
                    <span class="control-value" id="sphere2-rough-value">0.15</span>
                </div>
                <input type="range" class="slider slider-roughness" id="sphere2-rough"
                       min="0" max="100" value="15">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Metallic</span>
                    <span class="control-value" id="sphere2-metallic-value">1.00</span>
                </div>
                <input type="range" class="slider slider-metallic" id="sphere2-metallic"
                       min="0" max="100" value="100">
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Base Color</span>
                </div>
                <div class="color-picker-group">
                    <button class="color-btn" data-color="#4ecdc4" data-sphere="2" style="background: #4ecdc4;"></button>
                    <button class="color-btn active" data-color="#e94560" data-sphere="2" style="background: #e94560;"></button>
                    <button class="color-btn" data-color="#9b59b6" data-sphere="2" style="background: #9b59b6;"></button>
                    <button class="color-btn" data-color="#e74c3c" data-sphere="2" style="background: #e74c3c;"></button>
                    <button class="color-btn" data-color="#f1c40f" data-sphere="2" style="background: #f1c40f;"></button>
                    <button class="color-btn" data-color="#2ecc71" data-sphere="2" style="background: #2ecc71;"></button>
                    <button class="color-btn" data-color="#e67e22" data-sphere="2" style="background: #e67e22;"></button>
                    <button class="color-btn" data-color="#ffffff" data-sphere="2" style="background: #ffffff;"></button>
                </div>
            </div>
        </div>

        <!-- Environment Controls -->
        <div class="environment-section">
            <div class="env-title">üåç Environment</div>

            <div class="toggle-group">
                <span class="toggle-label">Night Mode</span>
                <div class="toggle-switch" id="nightToggle" onclick="toggleNightMode()">
                    <div class="toggle-knob">‚òÄÔ∏è</div>
                </div>
            </div>

            <div class="toggle-group">
                <span class="toggle-label">Reflection Probes</span>
                <div class="toggle-switch active" id="probeToggle" onclick="toggleProbes()">
                    <div class="toggle-knob">üîÑ</div>
                </div>
            </div>

            <div class="control-group" style="margin-top: 15px;">
                <div class="control-label">
                    <span>Environment Intensity</span>
                    <span class="control-value" id="env-intensity-value">1.00</span>
                </div>
                <input type="range" class="slider" id="env-intensity"
                       min="0" max="100" value="100">
            </div>
        </div>

        <!-- Presets -->
        <div class="presets-section">
            <div class="presets-title">üìã Material Presets</div>
            <div class="preset-buttons">
                <button class="preset-btn" onclick="applyPreset('chrome')">‚ú® Chrome</button>
                <button class="preset-btn" onclick="applyPreset('gold')">ü•á Gold</button>
                <button class="preset-btn" onclick="applyPreset('copper')">ü•â Copper</button>
                <button class="preset-btn" onclick="applyPreset('mirror')">ü™û Mirror</button>
                <button class="preset-btn" onclick="applyPreset('brushed')">üßπ Brushed Metal</button>
                <button class="preset-btn" onclick="applyPreset('plastic')">üßä Plastic</button>
            </div>
        </div>

        <!-- Scene Info -->
        <div class="scene-info">
            <div class="info-row">
                <span>Reflection Quality</span>
                <span class="info-value" id="probe-quality">512px</span>
            </div>
            <div class="info-row">
                <span>Frame Rate</span>
                <span class="info-value" id="fps-counter">60 FPS</span>
            </div>
            <div class="info-row">
                <span>Environment</span>
                <span class="info-value">Procedural Street</span>
            </div>
        </div>
    </div>

    <!-- Controls Hint -->
    <div class="controls-hint">
        üñ±Ô∏è Drag to Rotate &nbsp;|&nbsp; Scroll to Zoom &nbsp;|&nbsp; Right-click Drag to Pan
    </div>

    <!-- Babylon.js -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <script>
        // ==================== CONFIGURATION ====================
        const CONFIG = {
            sphere: {
                diameter: 3,
                position1: new BABYLON.Vector3(-4, 4, 0),
                position2: new BABYLON.Vector3(4, 4, 0)
            },
            reflectionProbe: {
                size: 512,
                refreshRate: 1
            },
            animation: {
                speedMultiplier: 1
            }
        };

        // ==================== GAME STATE ====================
        let gameState = {
            sphere1: { reflectivity: 0.95, roughness: 0.05, metallic: 1.0, color: '#4ecdc4' },
            sphere2: { reflectivity: 0.90, roughness: 0.15, metallic: 1.0, color: '#e94560' },
            isNight: false,
            probesEnabled: true,
            envIntensity: 1.0
        };

        // ==================== BABYLON SETUP ====================
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
        let scene, camera, sphere1, sphere2, reflectionProbe1, reflectionProbe2, pbrPipeline;

        // ==================== CREATE SCENE ====================
        const createScene = () => {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.1, 1);

            // Camera
            camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 3, 25, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 10;
            camera.upperRadiusLimit = 50;
            camera.lowerBetaLimit = 0.1;
            camera.upperBetaLimit = Math.PI / 2;
            camera.wheelPrecision = 20;
            camera.panningSensibility = 80;
            camera.minZ = 0.1;

            // Lighting
            setupLighting();

            // Create environment (street scene)
            createStreetEnvironment();

            // Create spheres with PBR materials
            createSpheres();

            // Setup reflection probes for real-time reflections
            setupReflectionProbes();

            // Setup PBR pipeline
            setupPBRPipeline();

            // Add floating animation
            setupFloatingAnimation();

            return scene;
        };

        // ==================== LIGHTING SETUP ====================
        let hemiLight, dirLight, nightLights = [];

        function setupLighting() {
            // Hemisphere light
            hemiLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
            hemiLight.intensity = 0.6;
            hemiLight.diffuse = new BABYLON.Color3(0.9, 0.9, 1);
            hemiLight.groundColor = new BABYLON.Color3(0.3, 0.3, 0.35);

            // Directional light (sun)
            dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-0.5, -1, -0.3), scene);
            dirLight.position = new BABYLON.Vector3(30, 50, 20);
            dirLight.intensity = 1.2;
            dirLight.diffuse = new BABYLON.Color3(1, 0.98, 0.9);

            // Shadow generator
            const shadowGenerator = new BABYLON.ShadowGenerator(2048, dirLight);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;
            shadowGenerator.bias = 0.001;

            // Night lights
            for (let i = 0; i < 4; i++) {
                const nightLight = new BABYLON.PointLight("nightLight" + i, new BABYLON.Vector3(0, 10, 0), scene);
                nightLight.intensity = 0;
                nightLight.diffuse = new BABYLON.Color3(1, 0.8, 0.5);
                nightLight.range = 25;
                nightLights.push(nightLight);
            }
        }

        function updateLighting() {
            if (gameState.isNight) {
                // Night mode
                hemiLight.intensity = 0.15;
                hemiLight.diffuse = new BABYLON.Color3(0.1, 0.1, 0.25);
                hemiLight.groundColor = new BABYLON.Color3(0.05, 0.05, 0.1);
                dirLight.intensity = 0.1;
                scene.clearColor = new BABYLON.Color4(0.02, 0.02, 0.05, 1);

                // Enable night lights
                const lightPositions = [
                    new BABYLON.Vector3(-8, 8, 5),
                    new BABYLON.Vector3(8, 8, 5),
                    new BABYLON.Vector3(-8, 8, -5),
                    new BABYLON.Vector3(8, 8, -5)
                ];
                nightLights.forEach((light, i) => {
                    light.position = lightPositions[i];
                    light.intensity = 1.5;
                });
            } else {
                // Day mode
                hemiLight.intensity = 0.6;
                hemiLight.diffuse = new BABYLON.Color3(0.9, 0.9, 1);
                hemiLight.groundColor = new BABYLON.Color3(0.3, 0.3, 0.35);
                dirLight.intensity = 1.2;
                scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.1, 1);

                // Disable night lights
                nightLights.forEach(light => {
                    light.intensity = 0;
                });
            }
        }

        // ==================== STREET ENVIRONMENT ====================
        function createStreetEnvironment() {
            const shadowGenerator = scene.getLightByName("dirLight").getShadowGenerator();

            // Ground (street)
            const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 60, height: 30 }, scene);
            const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.15, 0.15, 0.18);
            groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            ground.material = groundMat;
            ground.receiveShadows = true;

            // Sidewalks
            const sidewalkMat = new BABYLON.StandardMaterial("sidewalkMat", scene);
            sidewalkMat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            sidewalkMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const leftSidewalk = BABYLON.MeshBuilder.CreateBox("leftSidewalk", { width: 5, height: 0.15, depth: 30 }, scene);
            leftSidewalk.position = new BABYLON.Vector3(-17.5, 0.075, 0);
            leftSidewalk.material = sidewalkMat;
            leftSidewalk.receiveShadows = true;

            const rightSidewalk = BABYLON.MeshBuilder.CreateBox("rightSidewalk", { width: 5, height: 0.15, depth: 30 }, scene);
            rightSidewalk.position = new BABYLON.Vector3(17.5, 0.075, 0);
            rightSidewalk.material = sidewalkMat;
            rightSidewalk.receiveShheres = true;

            // Buildings
            createBuildings(shadowGenerator);

            // Street lamps
            createStreetLamps(shadowGenerator);

            // Road markings
            createRoadMarkings();

            // Trees
            createTrees(shadowGenerator);
        }

        function createBuildings(shadowGenerator) {
            const buildingMat = new BABYLON.StandardMaterial("buildingMat", scene);
            buildingMat.diffuseColor = new BABYLON.Color3(0.6, 0.55, 0.5);
            buildingMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            const windowMat = new BABYLON.StandardMaterial("windowMat", scene);
            windowMat.diffuseColor = new BABYLON.Color3(0.3, 0.4, 0.5);
            windowMat.emissiveColor = new BABYLON.Color3(0.1, 0.15, 0.2);
            windowMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);

            const windowLitMat = new BABYLON.StandardMaterial("windowLitMat", scene);
            windowLitMat.diffuseColor = new BABYLON.Color3(0.9, 0.8, 0.5);
            windowLitMat.emissiveColor = new BABYLON.Color3(0.5, 0.4, 0.2);
            windowLitMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);

            // Left buildings
            for (let i = 0; i < 6; i++) {
                const building = BABYLON.MeshBuilder.CreateBox("buildingL" + i, {
                    width: 6 + Math.random() * 3,
                    height: 8 + Math.random() * 12,
                    depth: 8 + Math.random() * 4
                }, scene);
                building.position = new BABYLON.Vector3(
                    -22 - Math.random() * 3,
                    building.scaling.y * 5,
                    -12 + i * 5 + Math.random() * 2
                );
                building.material = buildingMat;
                shadowGenerator.addShadowCaster(building);

                // Add windows
                addWindowsToBuilding(building, windowMat, windowLitMat, true);
            }

            // Right buildings
            for (let i = 0; i < 6; i++) {
                const building = BABYLON.MeshBuilder.CreateBox("buildingR" + i, {
                    width: 6 + Math.random() * 3,
                    height: 8 + Math.random() * 12,
                    depth: 8 + Math.random() * 4
                }, scene);
                building.position = new BABYLON.Vector3(
                    22 + Math.random() * 3,
                    building.scaling.y * 5,
                    -12 + i * 5 + Math.random() * 2
                );
                building.material = buildingMat;
                shadowGenerator.addShadowCaster(building);

                // Add windows
                addWindowsToBuilding(building, windowMat, windowLitMat, false);
            }
        }

        function addWindowsToBuilding(building, windowMat, windowLitMat, isLeft) {
            const height = building.scaling.y * 10;
            const width = building.scaling.x;
            const depth = building.scaling.z;

            for (let row = 0; row < Math.floor(height / 2.5); row++) {
                for (let col = 0; col < Math.floor(width / 1.5); col++) {
                    if (Math.random() > 0.3) {
                        const window = BABYLON.MeshBuilder.CreatePlane("window", {
                            width: 0.8,
                            height: 1.2
                        }, scene);

                        const xPos = -width / 2 + 0.8 + col * 1.5;
                        const yPos = -height / 2 + 1.5 + row * 2.5;

                        window.position = new BABYLON.Vector3(
                            isLeft ? -depth / 2 - 0.01 : depth / 2 + 0.01,
                            yPos,
                            xPos
                        );
                        window.rotation.y = isLeft ? Math.PI : 0;
                        window.material = Math.random() > 0.7 ? windowLitMat : windowMat;
                    }
                }
            }
        }

        function createStreetLamps(shadowGenerator) {
            const lampMat = new BABYLON.StandardMaterial("lampMat", scene);
            lampMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            lampMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);

            const lampLightMat = new BABYLON.StandardMaterial("lampLightMat", scene);
            lampLightMat.emissiveColor = new BABYLON.Color3(1, 0.9, 0.7);

            const positions = [
                { x: -15, z: -10 },
                { x: -15, z: 10 },
                { x: 15, z: -10 },
                { x: 15, z: 10 }
            ];

            positions.forEach((pos, i) => {
                // Pole
                const pole = BABYLON.MeshBuilder.CreateCylinder("lampPole" + i, {
                    height: 6,
                    diameter: 0.2
                }, scene);
                pole.position = new BABYLON.Vector3(pos.x, 3, pos.z);
                pole.material = lampMat;
                shadowGenerator.addShadowCaster(pole);

                // Lamp head
                const lampHead = BABYLON.MeshBuilder.CreateBox("lampHead" + i, {
                    width: 0.8,
                    height: 0.4,
                    depth: 0.6
                }, scene);
                lampHead.position = new BABYLON.Vector3(pos.x, 6.2, pos.z);
                lampHead.material = lampMat;
                shadowGenerator.addShadowCaster(lampHead);

                // Light glow
                const lampGlow = BABYLON.MeshBuilder.CreatePlane("lampGlow" + i, {
                    width: 0.6,
                    height: 0.4
                }, scene);
                lampGlow.position = new BABYLON.Vector3(pos.x, 6.1, pos.z);
                lampGlow.rotation.x = Math.PI / 2;
                lampGlow.material = lampLightMat;

                // Point light
                const lampLight = new BABYLON.PointLight("lampLight" + i, new BABYLON.Vector3(pos.x, 5.5, pos.z), scene);
                lampLight.diffuse = new BABYLON.Color3(1, 0.9, 0.7);
                lampLight.intensity = 0;
                lampLight.range = 15;

                if (gameState.isNight) {
                    lampLight.intensity = 2;
                }
            });
        }

        function createRoadMarkings() {
            const lineMat = new BABYLON.StandardMaterial("lineMat", scene);
            lineMat.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.3);
            lineMat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.1);

            // Center dashed line
            for (let i = -12; i < 12; i += 3) {
                const line = BABYLON.MeshBuilder.CreateBox("line" + i, {
                    width: 0.15,
                    height: 0.02,
                    depth: 1.5
                }, scene);
                line.position = new BABYLON.Vector3(0, 0.01, i);
                line.material = lineMat;
            }
        }

        function createTrees(shadowGenerator) {
            const trunkMat = new BABYLON.StandardMaterial("trunkMat", scene);
            trunkMat.diffuseColor = new BABYLON.Color3(0.4, 0.3, 0.2);

            const leavesMat = new BABYLON.StandardMaterial("leavesMat", scene);
            leavesMat.diffuseColor = new BABYLON.Color3(0.2, 0.4, 0.2);

            const positions = [
                { x: -20, z: -8 },
                { x: -20, z: 8 },
                { x: 20, z: -8 },
                { x: 20, z: 8 }
            ];

            positions.forEach((pos, i) => {
                // Trunk
                const trunk = BABYLON.MeshBuilder.CreateCylinder("treeTrunk" + i, {
                    height: 4,
                    diameter: 0.5
                }, scene);
                trunk.position = new BABYLON.Vector3(pos.x, 2, pos.z);
                trunk.material = trunkMat;
                shadowGenerator.addShadowCaster(trunk);

                // Leaves (multiple spheres)
                for (let j = 0; j < 3; j++) {
                    const leaves = BABYLON.MeshBuilder.CreateSphere("leaves" + i + "_" + j, {
                        diameter: 2 - j * 0.4,
                        segments: 8
                    }, scene);
                    leaves.position = new BABYLON.Vector3(pos.x, 4 + j * 1.2, pos.z);
                    leaves.scaling = new BABYLON.Vector3(1, 0.8, 1);
                    leaves.material = leavesMat;
                    shadowGenerator.addShadowCaster(leaves);
                }
            });
        }

        // ==================== SPHERES ====================
        function createSpheres() {
            // Sphere 1 (Left)
            sphere1 = BABYLON.MeshBuilder.CreateSphere("sphere1", {
                diameter: CONFIG.sphere.diameter,
                segments: 64
            }, scene);
            sphere1.position = CONFIG.sphere.position1.clone();

            const pbr1 = new BABYLON.PBRMaterial("pbr1", scene);
            pbr1.albedoColor = BABYLON.Color3.FromHexString(gameState.sphere1.color);
            pbr1.metallic = gameState.sphere1.metallic;
            pbr1.roughness = gameState.sphere1.roughness;
            pbr1.reflectivityColor = new BABYLON.Color3(gameState.sphere1.reflectivity);
            pbr1.environmentIntensity = gameState.envIntensity;
            pbr1.microSurface = 1 - gameState.sphere1.roughness;
            pbr1.reflectivity = gameState.sphere1.reflectivity;
            sphere1.material = pbr1;

            // Sphere 2 (Right)
            sphere2 = BABYLON.MeshBuilder.CreateSphere("sphere2", {
                diameter: CONFIG.sphere.diameter,
                segments: 64
            }, scene);
            sphere2.position = CONFIG.sphere.position2.clone();

            const pbr2 = new BABYLON.PBRMaterial("pbr2", scene);
            pbr2.albedoColor = BABYLON.Color3.FromHexString(gameState.sphere2.color);
            pbr2.metallic = gameState.sphere2.metallic;
            pbr2.roughness = gameState.sphere2.roughness;
            pbr2.reflectivityColor = new BABYLON.Color3(gameState.sphere2.reflectivity);
            pbr2.environmentIntensity = gameState.envIntensity;
            pbr2.microSurface = 1 - gameState.sphere2.roughness;
            pbr2.reflectivity = gameState.sphere2.reflectivity;
            sphere2.material = pbr2;
        }

        // ==================== REFLECTION PROBES ====================
        function setupReflectionProbes() {
            if (!gameState.probesEnabled) return;

            // Reflection probe for sphere 1
            reflectionProbe1 = new BABYLON.ReflectionProbe("probe1", CONFIG.reflectionProbe.size, scene);
            reflectionProbe1.refreshRate = CONFIG.reflectionProbe.refreshRate;
            reflectionProbe1.position = CONFIG.sphere.position1;
            reflectionProbe1.renderList.push(sphere2);
            addEnvironmentToProbe(reflectionProbe1);

            // Reflection probe for sphere 2
            reflectionProbe2 = new BABYLON.ReflectionProbe("probe2", CONFIG.reflectionProbe.size, scene);
            reflectionProbe2.refreshRate = CONFIG.reflectionProbe.refreshRate;
            reflectionProbe2.position = CONFIG.sphere.position2;
            reflectionProbe2.renderList.push(sphere1);
            addEnvironmentToProbe(reflectionProbe2);

            // Apply reflection textures to spheres
            sphere1.material.reflectionTexture = reflectionProbe1.cubeTexture;
            sphere1.material.realTimeFiltering = true;
            sphere1.material.realTimeFilteringQuality = BABYLON.Constants.TEXTURE_FILTERING_QUALITY_HIGH;

            sphere2.material.reflectionTexture = reflectionProbe2.cubeTexture;
            sphere2.material.realTimeFiltering = true;
            sphere2.material.realTimeFilteringQuality = BABYLON.Constants.TEXTURE_FILTERING_QUALITY_HIGH;
        }

        function addEnvironmentToProbe(probe) {
            // Add all environment meshes to reflection probe
            scene.meshes.forEach(mesh => {
                if (mesh.name !== "sphere1" && mesh.name !== "sphere2" && mesh.parent === null) {
                    try {
                        probe.renderList.push(mesh);
                    } catch (e) {
                        // Skip if can't be added
                    }
                }
            });
        }

        function toggleProbes() {
            gameState.probesEnabled = !gameState.probesEnabled;
            const toggle = document.getElementById('probeToggle');
            toggle.classList.toggle('active');

            if (gameState.probesEnabled) {
                setupReflectionProbes();
                document.getElementById('probe-quality').textContent = '512px';
            } else {
                if (reflectionProbe1) reflectionProbe1.dispose();
                if (reflectionProbe2) reflectionProbe2.dispose();
                sphere1.material.reflectionTexture = null;
                sphere2.material.reflectionTexture = null;
                document.getElementById('probe-quality').textContent = 'Off';
            }
        }

        // ==================== PBR PIPELINE ====================
        function setupPBRPipeline() {
            pbrPipeline = new BABYLON.DefaultRenderingPipeline(
                "defaultPipeline",
                true,
                scene,
                [camera]
            );

            pbrPipeline.bloomEnabled = true;
            pbrPipeline.bloomThreshold = 0.8;
            pbrPipeline.bloomWeight = 0.3;
            pbrPipeline.bloomKernel = 64;
            pbrPipeline.bloomScale = 0.5;

            pbrPipeline.toneMappingEnabled = true;
            pbrPipeline.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_ACES;
            pbrPipeline.exposure = 1.2;

            pbrPipeline.fxaaEnabled = true;
            pbrPipeline.imageProcessingEnabled = true;
            pbrPipeline.imageProcessing.contrast = 1.1;
            pbrPipeline.imageProcessing.exposure = 1.0;
        }

        // ==================== FLOATING ANIMATION ====================
        function setupFloatingAnimation() {
            let time = 0;

            scene.registerBeforeRender(() => {
                time += 0.01 * CONFIG.animation.speedMultiplier;

                // Gentle floating motion
                sphere1.position.y = CONFIG.sphere.position1.y + Math.sin(time) * 0.3;
                sphere2.position.y = CONFIG.sphere.position2.y + Math.sin(time + Math.PI) * 0.3;

                // Subtle rotation
                sphere1.rotation.y += 0.002;
                sphere2.rotation.y -= 0.002;

                // Update reflection probe positions
                if (gameState.probesEnabled && reflectionProbe1) {
                    reflectionProbe1.position = sphere1.position;
                }
                if (gameState.probesEnabled && reflectionProbe2) {
                    reflectionProbe2.position = sphere2.position;
                }
            });
        }

        // ==================== MATERIAL UPDATE ====================
        function updateSphereMaterial(sphereNum) {
            const state = gameState['sphere' + sphereNum];
            const sphere = sphereNum === 1 ? sphere1 : sphere2;
            const material = sphere.material;

            material.albedoColor = BABYLON.Color3.FromHexString(state.color);
            material.metallic = state.metallic;
            material.roughness = state.roughness;
            material.reflectivityColor = new BABYLON.Color3(state.reflectivity);
            material.microSurface = 1 - state.roughness;
            material.reflectivity = state.reflectivity;
            material.environmentIntensity = gameState.envIntensity;
        }

        // ==================== UI CONTROLS ====================
        function setupUIControls() {
            // Sphere 1 controls
            document.getElementById('sphere1-reflect').addEventListener('input', (e) => {
                gameState.sphere1.reflectivity = e.target.value / 100;
                document.getElementById('sphere1-reflect-value').textContent = (e.target.value / 100).toFixed(2);
                updateSphereMaterial(1);
            });

            document.getElementById('sphere1-rough').addEventListener('input', (e) => {
                gameState.sphere1.roughness = e.target.value / 100;
                document.getElementById('sphere1-rough-value').textContent = (e.target.value / 100).toFixed(2);
                updateSphereMaterial(1);
            });

            document.getElementById('sphere1-metallic').addEventListener('input', (e) => {
                gameState.sphere1.metallic = e.target.value / 100;
                document.getElementById('sphere1-metallic-value').textContent = (e.target.value / 100).toFixed(2);
                updateSphereMaterial(1);
            });

            // Sphere 2 controls
            document.getElementById('sphere2-reflect').addEventListener('input', (e) => {
                gameState.sphere2.reflectivity = e.target.value / 100;
                document.getElementById('sphere2-reflect-value').textContent = (e.target.value / 100).toFixed(2);
                updateSphereMaterial(2);
            });

            document.getElementById('sphere2-rough').addEventListener('input', (e) => {
                gameState.sphere2.roughness = e.target.value / 100;
                document.getElementById('sphere2-rough-value').textContent = (e.target.value / 100).toFixed(2);
                updateSphereMaterial(2);
            });

            document.getElementById('sphere2-metallic').addEventListener('input', (e) => {
                gameState.sphere2.metallic = e.target.value / 100;
                document.getElementById('sphere2-metallic-value').textContent = (e.target.value / 100).toFixed(2);
                updateSphereMaterial(2);
            });

            // Color buttons
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const sphereNum = parseInt(btn.dataset.sphere);
                    const color = btn.dataset.color;

                    // Update state
                    gameState['sphere' + sphereNum].color = color;

                    // Update active state
                    btn.parentElement.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Update material
                    updateSphereMaterial(sphereNum);
                });
            });

            // Environment intensity
            document.getElementById('env-intensity').addEventListener('input', (e) => {
                gameState.envIntensity = e.target.value / 100;
                document.getElementById('env-intensity-value').textContent = (e.target.value / 100).toFixed(2);
                if (sphere1.material) sphere1.material.environmentIntensity = gameState.envIntensity;
                if (sphere2.material) sphere2.material.environmentIntensity = gameState.envIntensity;
            });
        }

        function toggleNightMode() {
            gameState.isNight = !gameState.isNight;
            const toggle = document.getElementById('nightToggle');
            toggle.classList.toggle('active');
            toggle.querySelector('.toggle-knob').textContent = gameState.isNight ? 'üåô' : '‚òÄÔ∏è';
            updateLighting();
        }

        function applyPreset(preset) {
            const presets = {
                chrome: { reflect: 100, rough: 0, metal: 100, color1: '#c0c0c0', color2: '#e0e0e0' },
                gold: { reflect: 100, rough: 5, metal: 100, color1: '#ffd700', color2: '#ffb700' },
                copper: { reflect: 95, rough: 10, metal: 100, color1: '#b87333', color2: '#cd7f32' },
                mirror: { reflect: 100, rough: 0, metal: 0, color1: '#ffffff', color2: '#f0f0f0' },
                brushed: { reflect: 70, rough: 40, metal: 90, color1: '#a0a0a0', color2: '#909090' },
                plastic: { reflect: 50, rough: 30, metal: 0, color1: '#4ecdc4', color2: '#e94560' }
            };

            const p = presets[preset];
            if (p) {
                // Apply to sphere 1
                gameState.sphere1.reflectivity = p.reflect / 100;
                gameState.sphere1.roughness = p.rough / 100;
                gameState.sphere1.metallic = p.metal / 100;
                gameState.sphere1.color = p.color1;

                // Apply to sphere 2
                gameState.sphere2.reflectivity = p.reflect / 100;
                gameState.sphere2.roughness = p.rough / 100;
                gameState.sphere2.metallic = p.metal / 100;
                gameState.sphere2.color = p.color2;

                // Update UI
                updateUIFromState();
                updateSphereMaterial(1);
                updateSphereMaterial(2);
            }
        }

        function updateUIFromState() {
            // Sphere 1
            document.getElementById('sphere1-reflect').value = gameState.sphere1.reflectivity * 100;
            document.getElementById('sphere1-reflect-value').textContent = gameState.sphere1.reflectivity.toFixed(2);
            document.getElementById('sphere1-rough').value = gameState.sphere1.roughness * 100;
            document.getElementById('sphere1-rough-value').textContent = gameState.sphere1.roughness.toFixed(2);
            document.getElementById('sphere1-metallic').value = gameState.sphere1.metallic * 100;
            document.getElementById('sphere1-metallic-value').textContent = gameState.sphere1.metallic.toFixed(2);

            // Sphere 2
            document.getElementById('sphere2-reflect').value = gameState.sphere2.reflectivity * 100;
            document.getElementById('sphere2-reflect-value').textContent = gameState.sphere2.reflectivity.toFixed(2);
            document.getElementById('sphere2-rough').value = gameState.sphere2.roughness * 100;
            document.getElementById('sphere2-rough-value').textContent = gameState.sphere2.roughness.toFixed(2);
            document.getElementById('sphere2-metallic').value = gameState.sphere2.metallic * 100;
            document.getElementById('sphere2-metallic-value').textContent = gameState.sphere2.metallic.toFixed(2);
        }

        // ==================== FPS COUNTER ====================
        let frameCount = 0;
        let lastFpsUpdate = 0;

        engine.runRenderLoop(() => {
            scene.render();

            frameCount++;
            const now = performance.now();
            if (now - lastFpsUpdate >= 1000) {
                document.getElementById('fps-counter').textContent = frameCount + ' FPS';
                frameCount = 0;
                lastFpsUpdate = now;
            }
        });

        // ==================== INITIALIZATION ====================
        scene = createScene();
        setupUIControls();

        window.addEventListener('resize', () => {
            engine.resize();
        });

        console.log('Ray Tracing Simulation loaded successfully!');
    </script>
</body>
</html>