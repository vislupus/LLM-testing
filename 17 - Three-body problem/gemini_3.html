<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaotic Gravity Mission</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #E0E0E0; /* matches 220 gray */
            font-family: 'Courier New', Courier, monospace;
        }
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            color: #333;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <h3>Mission Telemetry</h3>
    <div id="status">Status: PRE-LAUNCH</div>
    <div id="distance">Dist to Target: --</div>
</div>

<script>
let sun, earth, jupiter, ship;
let bodies = [];
// Changed const to var to prevent redeclaration errors on reload
var G = 1.5; 
var SOFTENING = 5; 
let particles = []; 

// Mission States
var M_PRELAUNCH = 0;
var M_SUNDIVE = 1;
var M_COASTING = 2;
var M_INTERCEPT = 3;
var M_ARRIVAL = 4;
let missionState = M_PRELAUNCH;
let missionTimer = 0;

function setup() {
    createCanvas(windowWidth, windowHeight);
    noStroke();
    
    // Initialize Bodies (Mass, X, Y, VX, VY, Color)
    // Positions and velocities tuned for a bounded, chaotic 3-body dance
    
    // Sun: Heavy, central
    sun = new Body(1000, 0, 0, 0.2, -0.1, color(255, 204, 0)); 
    
    // Earth: Light, closer
    earth = new Body(40, 200, 0, 0, 2.2, color(0, 100, 255)); 
    
    // Jupiter: Heavy enough to perturb Earth, further out
    jupiter = new Body(300, -350, -100, 0.5, -1.2, color(200, 100, 50)); 

    bodies = [sun, earth, jupiter];
    
    // Initialize Ship on Earth
    ship = new Ship();
}

function draw() {
    background(220);
    
    // Calculate Physics
    // 1. Gravity between celestial bodies
    for (let i = 0; i < bodies.length; i++) {
        for (let j = 0; j < bodies.length; j++) {
            if (i !== j) {
                let force = calculateGravity(bodies[i], bodies[j]);
                bodies[i].applyForce(force);
            }
        }
    }
    
    // 2. Gravity on Ship
    let shipForce = createVector(0, 0);
    for (let b of bodies) {
        let f = calculateGravity(ship, b);
        ship.applyForce(f);
    }

    // Update Positions
    for (let b of bodies) b.update();
    ship.update();
    ship.runMissionLogic();

    // Camera Handling: Center view on the Center of Mass
    let com = getCenterOfMass();
    push();
    translate(width / 2 - com.x, height / 2 - com.y);

    // Draw Trails
    for (let b of bodies) b.drawTrail();
    ship.drawTrail();

    // Draw Particles (Thrusters)
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        particles[i].show();
        if (particles[i].isDead()) particles.splice(i, 1);
    }

    // Draw Bodies
    for (let b of bodies) b.show();
    ship.show();

    pop();

    // UI Update
    updateUI();
}

function calculateGravity(body1, body2) {
    let force = p5.Vector.sub(body2.pos, body1.pos);
    let distance = force.mag();
    distance = constrain(distance, 5, 1000); // Clamp distance
    
    // F = G * m1 * m2 / r^2
    // Added softening to denominator to prevent slingshotting to infinity
    let strength = (G * body1.mass * body2.mass) / (distance * distance + SOFTENING);
    force.setMag(strength);
    return force;
}

function getCenterOfMass() {
    let num = createVector(0,0);
    let den = 0;
    for(let b of bodies) {
        num.add(p5.Vector.mult(b.pos, b.mass));
        den += b.mass;
    }
    return num.div(den);
}

class Body {
    constructor(m, x, y, vx, vy, c) {
        this.mass = m;
        this.pos = createVector(x, y);
        this.vel = createVector(vx, vy);
        this.acc = createVector(0, 0);
        this.col = c;
        this.r = sqrt(this.mass) * 1.5; // Radius proportional to mass
        this.trail = [];
        this.maxTrail = 200;
    }

    applyForce(force) {
        let f = p5.Vector.div(force, this.mass);
        this.acc.add(f);
    }

    update() {
        this.vel.add(this.acc);
        this.pos.add(this.vel);
        this.acc.mult(0); // Reset acceleration
        
        // Update Trail
        if (frameCount % 3 === 0) {
            this.trail.push(this.pos.copy());
            if (this.trail.length > this.maxTrail) {
                this.trail.shift();
            }
        }
    }

    show() {
        fill(this.col);
        noStroke();
        ellipse(this.pos.x, this.pos.y, this.r * 2);
    }

    drawTrail() {
        noFill();
        stroke(red(this.col), green(this.col), blue(this.col), 100);
        strokeWeight(2);
        beginShape();
        for (let p of this.trail) {
            vertex(p.x, p.y);
        }
        endShape();
        noStroke();
    }
}

class Ship extends Body {
    constructor() {
        super(1, earth.pos.x, earth.pos.y, earth.vel.x, earth.vel.y, color(50));
        this.r = 8;
        this.fuel = 100;
    }

    thrust(forceVec) {
        this.applyForce(forceVec);
        // Visuals
        for(let i=0; i<3; i++) {
            let pVel = forceVec.copy().mult(-5).rotate(random(-0.5, 0.5));
            particles.push(new Particle(this.pos.x, this.pos.y, pVel));
        }
    }

    runMissionLogic() {
        missionTimer++;
        
        // Distance Calculations
        let dSun = p5.Vector.dist(this.pos, sun.pos);
        let dJup = p5.Vector.dist(this.pos, jupiter.pos);

        switch(missionState) {
            case M_PRELAUNCH:
                // Stick to Earth for a moment
                this.pos = earth.pos.copy();
                this.vel = earth.vel.copy();
                if (missionTimer > 100) {
                    missionState = M_SUNDIVE;
                    document.getElementById('status').innerText = "Status: SUN DIVE MANEUVER";
                }
                break;

            case M_SUNDIVE:
                // Burn retrograde relative to Earth to drop towards Sun
                // But add a tangential component to ensure we loop, not crash
                let burnDir = p5.Vector.sub(sun.pos, this.pos);
                burnDir.normalize();
                burnDir.mult(2.5); // Strength of burn
                
                // Add some sideways motion so we don't hit the sun directly
                let side = burnDir.copy().rotate(HALF_PI).mult(0.5);
                burnDir.add(side);
                
                this.vel.add(burnDir); // Impulse burn
                this.thrust(burnDir);
                
                missionState = M_COASTING;
                break;

            case M_COASTING:
                // Wait until we are close to the sun (Perihelion)
                // And ensuring we have left Earth's immediate area
                if (dSun < 120 && missionTimer > 200) {
                    missionState = M_INTERCEPT;
                    document.getElementById('status').innerText = "Status: JUPITER INTERCEPT BURN";
                }
                break;

            case M_INTERCEPT:
                // Calculate intercept vector
                let targetDir = p5.Vector.sub(jupiter.pos, this.pos);
                targetDir.normalize();
                targetDir.mult(1.2); // Burn velocity magnitude
                
                this.vel.add(targetDir); // Impulse burn
                this.thrust(targetDir);
                
                missionState = M_ARRIVAL;
                document.getElementById('status').innerText = "Status: TRANSIT TO JUPITER";
                break;

            case M_ARRIVAL:
                // If very close to Jupiter, try to orbit (simple dampen)
                if (dJup < 50) {
                    document.getElementById('status').innerText = "Status: JUPITER ENCOUNTER";
                    // Visualize arrival
                    fill(255, 255, 255, 50);
                    ellipse(this.pos.x, this.pos.y, 40);
                }
                break;
        }
    }
}

class Particle {
    constructor(x, y, v) {
        this.pos = createVector(x, y);
        this.vel = v;
        this.life = 255;
    }
    update() {
        this.pos.add(this.vel);
        this.life -= 10;
    }
    show() {
        fill(0, 0, 0, this.life);
        ellipse(this.pos.x, this.pos.y, 4);
    }
    isDead() {
        return this.life < 0;
    }
}

function updateUI() {
    if(ship && jupiter) {
        let d = p5.Vector.dist(ship.pos, jupiter.pos);
        document.getElementById('distance').innerText = "Dist to Jupiter: " + d.toFixed(0);
    }
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
}
</script>

</body>
</html>