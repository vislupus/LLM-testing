<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Shooter - Asteroid Fields</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Orbitron', 'Segoe UI', sans-serif;
        }

        #gameCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
        }

        .ui-panel {
            background: rgba(0, 20, 40, 0.8);
            border: 2px solid #0ff;
            border-radius: 10px;
            padding: 15px 25px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3), inset 0 0 20px rgba(0, 255, 255, 0.1);
        }

        .score-display {
            font-size: 24px;
            font-weight: bold;
        }

        .score-label {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .health-bar-container {
            width: 200px;
            height: 20px;
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #f00;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .health-bar {
            height: 100%;
            background: linear-gradient(90deg, #f00, #ff0);
            transition: width 0.3s;
            box-shadow: 0 0 10px #f00;
        }

        .shield-bar-container {
            width: 200px;
            height: 15px;
            background: rgba(0, 100, 255, 0.2);
            border: 2px solid #00f;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
        }

        .shield-bar {
            height: 100%;
            background: linear-gradient(90deg, #00f, #0ff);
            transition: width 0.3s;
            box-shadow: 0 0 10px #00f;
        }

        .wave-display {
            font-size: 18px;
        }

        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 100;
        }

        .game-title {
            font-size: 72px;
            color: #0ff;
            text-shadow: 0 0 30px #0ff, 0 0 60px #0ff;
            margin-bottom: 20px;
            letter-spacing: 10px;
            animation: pulse 2s infinite;
        }

        .subtitle {
            font-size: 24px;
            color: #f0f;
            text-shadow: 0 0 20px #f0f;
            margin-bottom: 50px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.02); }
        }

        .start-btn {
            padding: 20px 60px;
            font-size: 24px;
            background: linear-gradient(135deg, #0ff, #00f);
            border: none;
            border-radius: 50px;
            color: #fff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 5px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            transition: all 0.3s;
            pointer-events: auto;
        }

        .start-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.8);
        }

        .controls-info {
            margin-top: 40px;
            color: #888;
            text-align: center;
            line-height: 2;
        }

        .controls-info span {
            color: #0ff;
            font-weight: bold;
        }

        .final-score {
            font-size: 48px;
            color: #ff0;
            text-shadow: 0 0 20px #ff0;
            margin: 20px 0;
        }

        .high-score {
            font-size: 24px;
            color: #0f0;
            margin-bottom: 30px;
        }

        #powerupIndicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
        }

        .powerup-slot {
            width: 50px;
            height: 50px;
            background: rgba(0, 20, 40, 0.8);
            border: 2px solid #444;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            opacity: 0.5;
            transition: all 0.3s;
        }

        .powerup-slot.active {
            border-color: #0ff;
            opacity: 1;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .combo-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #ff0;
            text-shadow: 0 0 30px #ff0;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
        }

        .combo-display.show {
            opacity: 1;
            animation: comboAnim 0.5s ease-out;
        }

        @keyframes comboAnim {
            0% { transform: translate(-50%, -50%) scale(0.5); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui" class="hidden">
        <div class="ui-panel">
            <div class="score-label">SCORE</div>
            <div class="score-display" id="scoreDisplay">0</div>
            <div class="health-bar-container">
                <div class="health-bar" id="healthBar"></div>
            </div>
            <div class="shield-bar-container">
                <div class="shield-bar" id="shieldBar"></div>
            </div>
        </div>
        <div class="ui-panel">
            <div class="score-label">WAVE</div>
            <div class="wave-display" id="waveDisplay">1</div>
        </div>
    </div>

    <div id="powerupIndicator" class="hidden">
        <div class="powerup-slot" id="rapidFire">‚ö°</div>
        <div class="powerup-slot" id="tripleShot">üî±</div>
        <div class="powerup-slot" id="shield">üõ°Ô∏è</div>
    </div>

    <div class="combo-display" id="comboDisplay"></div>

    <div id="startScreen">
        <div class="game-title">STELLAR ASSAULT</div>
        <div class="subtitle">Navigate the Asteroid Fields</div>
        <button class="start-btn" onclick="startGame()">START MISSION</button>
        <div class="controls-info">
            <span>WASD</span> or <span>Arrow Keys</span> - Move<br>
            <span>SPACE</span> or <span>Click</span> - Fire<br>
            <span>SHIFT</span> - Boost
        </div>
    </div>

    <div id="gameOverScreen" class="hidden">
        <div class="game-title" style="font-size:48px">MISSION FAILED</div>
        <div class="final-score">Score: <span id="finalScore">0</span></div>
        <div class="high-score">High Score: <span id="highScore">0</span></div>
        <button class="start-btn" onclick="startGame()">TRY AGAIN</button>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        let gameRunning = false;
        let score = 0;
        let wave = 1;
        let highScore = localStorage.getItem('spaceShooterHighScore') || 0;
        let combo = 0;
        let comboTimer = 0;
        let lastTime = 0;

        // Player
        const player = {
            x: 0,
            y: 0,
            width: 50,
            height: 60,
            speed: 400,
            boostSpeed: 700,
            health: 100,
            maxHealth: 100,
            shield: 0,
            maxShield: 100,
            fireRate: 150,
            lastFire: 0,
            invincible: 0,
            rapidFire: 0,
            tripleShot: 0,
            angle: 0,
            thrusterParticles: []
        };

        // Game objects
        let bullets = [];
        let enemyBullets = [];
        let enemies = [];
        let asteroids = [];
        let particles = [];
        let powerups = [];
        let stars = [];
        let nebulae = [];

        // Input
        const keys = {};
        let mouseX = 0;
        let mouseY = 0;
        let mouseDown = false;

        // Initialize stars and nebulae
        function initBackground() {
            stars = [];
            nebulae = [];

            // Create stars
            for (let i = 0; i < 300; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    speed: Math.random() * 100 + 50,
                    brightness: Math.random()
                });
            }

            // Create nebulae
            for (let i = 0; i < 5; i++) {
                nebulae.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 200 + 100,
                    color: `hsla(${Math.random() * 60 + 200}, 70%, 50%, 0.1)`,
                    speed: Math.random() * 20 + 10
                });
            }
        }

        // Particle system
        class Particle {
            constructor(x, y, vx, vy, color, size, life, type = 'normal') {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.size = size;
                this.life = life;
                this.maxLife = life;
                this.type = type;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 10;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= dt;
                this.rotation += this.rotationSpeed * dt;

                if (this.type === 'spark') {
                    this.vy += 200 * dt; // gravity
                }
            }

            draw() {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                if (this.type === 'spark') {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-this.size / 2, -this.size * 2, this.size, this.size * 4);
                } else if (this.type === 'smoke') {
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                    gradient.addColorStop(0, this.color);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * (2 - alpha), 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * alpha, 0, Math.PI * 2);
                    ctx.fill();

                    // Glow effect
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = this.color;
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        // Create explosion
        function createExplosion(x, y, color, count = 30, speed = 300, size = 5) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                const velocity = speed * (0.5 + Math.random() * 0.5);
                particles.push(new Particle(
                    x, y,
                    Math.cos(angle) * velocity,
                    Math.sin(angle) * velocity,
                    color,
                    size * (0.5 + Math.random()),
                    0.5 + Math.random() * 0.5,
                    'normal'
                ));
            }

            // Add sparks
            for (let i = 0; i < count / 2; i++) {
                const angle = Math.random() * Math.PI * 2;
                const velocity = speed * 1.5 * Math.random();
                particles.push(new Particle(
                    x, y,
                    Math.cos(angle) * velocity,
                    Math.sin(angle) * velocity,
                    '#fff',
                    2,
                    0.3 + Math.random() * 0.3,
                    'spark'
                ));
            }

            // Add smoke
            for (let i = 0; i < count / 3; i++) {
                const angle = Math.random() * Math.PI * 2;
                const velocity = speed * 0.3 * Math.random();
                particles.push(new Particle(
                    x, y,
                    Math.cos(angle) * velocity,
                    Math.sin(angle) * velocity,
                    'rgba(100, 100, 100, 0.5)',
                    size * 2,
                    1 + Math.random(),
                    'smoke'
                ));
            }
        }

        // Enemy class
        class Enemy {
            constructor(type = 'basic') {
                this.type = type;
                this.x = canvas.width + 50;
                this.y = Math.random() * (canvas.height - 100) + 50;
                this.angle = 0;

                switch (type) {
                    case 'basic':
                        this.width = 40;
                        this.height = 40;
                        this.health = 20;
                        this.speed = 150;
                        this.score = 100;
                        this.color = '#f00';
                        this.fireRate = 2000;
                        break;
                    case 'fast':
                        this.width = 30;
                        this.height = 30;
                        this.health = 10;
                        this.speed = 300;
                        this.score = 150;
                        this.color = '#f0f';
                        this.fireRate = 3000;
                        break;
                    case 'heavy':
                        this.width = 60;
                        this.height = 60;
                        this.health = 50;
                        this.speed = 80;
                        this.score = 300;
                        this.color = '#ff0';
                        this.fireRate = 1500;
                        break;
                    case 'boss':
                        this.width = 120;
                        this.height = 100;
                        this.health = 500;
                        this.maxHealth = 500;
                        this.speed = 50;
                        this.score = 2000;
                        this.color = '#f00';
                        this.fireRate = 500;
                        this.pattern = 0;
                        this.patternTime = 0;
                        break;
                }

                this.lastFire = Date.now();
                this.vx = -this.speed;
                this.vy = 0;
            }

            update(dt) {
                if (this.type === 'boss') {
                    this.patternTime += dt;
                    
                    // Boss movement patterns
                    if (this.x > canvas.width - 200) {
                        this.x -= this.speed * dt;
                    } else {
                        this.y += Math.sin(this.patternTime * 2) * 100 * dt;
                        this.y = Math.max(this.height, Math.min(canvas.height - this.height, this.y));
                    }

                    // Boss firing patterns
                    if (Date.now() - this.lastFire > this.fireRate) {
                        this.lastFire = Date.now();
                        this.pattern = (this.pattern + 1) % 3;

                        switch (this.pattern) {
                            case 0: // Spread shot
                                for (let i = -2; i <= 2; i++) {
                                    enemyBullets.push({
                                        x: this.x - this.width / 2,
                                        y: this.y,
                                        vx: -400,
                                        vy: i * 100,
                                        size: 8,
                                        color: '#f00',
                                        damage: 15
                                    });
                                }
                                break;
                            case 1: // Aimed shot
                                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                                for (let i = 0; i < 3; i++) {
                                    setTimeout(() => {
                                        enemyBullets.push({
                                            x: this.x - this.width / 2,
                                            y: this.y,
                                            vx: Math.cos(angle) * 500,
                                            vy: Math.sin(angle) * 500,
                                            size: 10,
                                            color: '#ff0',
                                            damage: 20
                                        });
                                    }, i * 200);
                                }
                                break;
                            case 2: // Circle shot
                                for (let i = 0; i < 12; i++) {
                                    const a = (Math.PI * 2 * i) / 12;
                                    enemyBullets.push({
                                        x: this.x,
                                        y: this.y,
                                        vx: Math.cos(a) * 300,
                                        vy: Math.sin(a) * 300,
                                        size: 6,
                                        color: '#f0f',
                                        damage: 10
                                    });
                                }
                                break;
                        }
                    }
                } else {
                    // Regular enemy movement
                    if (this.type === 'fast') {
                        this.angle += dt * 5;
                        this.y += Math.sin(this.angle) * 150 * dt;
                    }

                    this.x += this.vx * dt;
                    this.y += this.vy * dt;

                    // Boundary check
                    this.y = Math.max(this.height / 2, Math.min(canvas.height - this.height / 2, this.y));

                    // Shooting
                    if (Date.now() - this.lastFire > this.fireRate && this.x < canvas.width - 100) {
                        this.lastFire = Date.now();
                        const angle = Math.atan2(player.y - this.y, player.x - this.x);
                        enemyBullets.push({
                            x: this.x - this.width / 2,
                            y: this.y,
                            vx: Math.cos(angle) * 350,
                            vy: Math.sin(angle) * 350,
                            size: 5,
                            color: this.color,
                            damage: 10
                        });
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                if (this.type === 'boss') {
                    // Boss ship
                    ctx.fillStyle = '#400';
                    ctx.beginPath();
                    ctx.moveTo(-this.width / 2, 0);
                    ctx.lineTo(this.width / 2, -this.height / 2);
                    ctx.lineTo(this.width / 2, this.height / 2);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.moveTo(-this.width / 3, 0);
                    ctx.lineTo(this.width / 3, -this.height / 3);
                    ctx.lineTo(this.width / 3, this.height / 3);
                    ctx.closePath();
                    ctx.fill();

                    // Boss health bar
                    const barWidth = this.width;
                    const healthPercent = this.health / this.maxHealth;
                    ctx.fillStyle = '#400';
                    ctx.fillRect(-barWidth / 2, -this.height / 2 - 20, barWidth, 10);
                    ctx.fillStyle = '#f00';
                    ctx.fillRect(-barWidth / 2, -this.height / 2 - 20, barWidth * healthPercent, 10);

                    // Glow
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#f00';

                } else {
                    // Regular enemy ships
                    ctx.fillStyle = this.color;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = this.color;

                    // Ship body
                    ctx.beginPath();
                    ctx.moveTo(-this.width / 2, 0);
                    ctx.lineTo(this.width / 2, -this.height / 2);
                    ctx.lineTo(this.width / 3, 0);
                    ctx.lineTo(this.width / 2, this.height / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Cockpit
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width / 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        // Asteroid class
        class Asteroid {
            constructor(size = 'large') {
                this.size = size;
                this.x = canvas.width + 100;
                this.y = Math.random() * canvas.height;

                switch (size) {
                    case 'large':
                        this.radius = 40 + Math.random() * 20;
                        this.health = 30;
                        this.score = 50;
                        break;
                    case 'medium':
                        this.radius = 20 + Math.random() * 10;
                        this.health = 15;
                        this.score = 30;
                        break;
                    case 'small':
                        this.radius = 10 + Math.random() * 5;
                        this.health = 5;
                        this.score = 20;
                        break;
                }

                this.vx = -(100 + Math.random() * 150);
                this.vy = (Math.random() - 0.5) * 100;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 2;

                // Generate asteroid shape
                this.vertices = [];
                const numVertices = 8 + Math.floor(Math.random() * 5);
                for (let i = 0; i < numVertices; i++) {
                    const angle = (Math.PI * 2 * i) / numVertices;
                    const dist = this.radius * (0.7 + Math.random() * 0.3);
                    this.vertices.push({
                        x: Math.cos(angle) * dist,
                        y: Math.sin(angle) * dist
                    });
                }
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.rotation += this.rotationSpeed * dt;

                // Wrap around vertically
                if (this.y < -this.radius) this.y = canvas.height + this.radius;
                if (this.y > canvas.height + this.radius) this.y = -this.radius;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                // Shadow
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(this.vertices[0].x + 5, this.vertices[0].y + 5);
                for (let i = 1; i < this.vertices.length; i++) {
                    ctx.lineTo(this.vertices[i].x + 5, this.vertices[i].y + 5);
                }
                ctx.closePath();
                ctx.fill();

                // Main body
                const gradient = ctx.createRadialGradient(-this.radius / 3, -this.radius / 3, 0, 0, 0, this.radius);
                gradient.addColorStop(0, '#888');
                gradient.addColorStop(0.5, '#555');
                gradient.addColorStop(1, '#333');
                ctx.fillStyle = gradient;

                ctx.beginPath();
                ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
                for (let i = 1; i < this.vertices.length; i++) {
                    ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
                }
                ctx.closePath();
                ctx.fill();

                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Craters
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                for (let i = 0; i < 3; i++) {
                    const cx = (Math.random() - 0.5) * this.radius;
                    const cy = (Math.random() - 0.5) * this.radius;
                    const cr = this.radius * 0.1 + Math.random() * this.radius * 0.15;
                    ctx.beginPath();
                    ctx.arc(cx, cy, cr, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            split() {
                if (this.size === 'large') {
                    return [new Asteroid('medium'), new Asteroid('medium')];
                } else if (this.size === 'medium') {
                    return [new Asteroid('small'), new Asteroid('small')];
                }
                return [];
            }
        }

        // Powerup class
        class Powerup {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 15;
                this.type = ['health', 'shield', 'rapidFire', 'tripleShot'][Math.floor(Math.random() * 4)];
                this.vx = -100;
                this.vy = Math.sin(Date.now() / 500) * 50;
                this.angle = 0;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += Math.sin(Date.now() / 500) * 30 * dt;
                this.angle += dt * 3;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Glow
                ctx.shadowBlur = 20;

                let color, symbol;
                switch (this.type) {
                    case 'health':
                        color = '#0f0';
                        symbol = '+';
                        break;
                    case 'shield':
                        color = '#00f';
                        symbol = 'üõ°';
                        break;
                    case 'rapidFire':
                        color = '#ff0';
                        symbol = '‚ö°';
                        break;
                    case 'tripleShot':
                        color = '#f0f';
                        symbol = 'üî±';
                        break;
                }

                ctx.shadowColor = color;
                ctx.fillStyle = color;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;

                // Octagon shape
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i) / 8;
                    const x = Math.cos(angle) * this.radius;
                    const y = Math.sin(angle) * this.radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Symbol
                ctx.fillStyle = '#fff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);

                ctx.restore();
            }
        }

        // Draw player ship
        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);

            // Invincibility flash
            if (player.invincible > 0 && Math.floor(player.invincible * 10) % 2 === 0) {
                ctx.globalAlpha = 0.5;
            }

            // Shield effect
            if (player.shield > 0) {
                ctx.beginPath();
                ctx.arc(0, 0, player.width, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(0, 150, 255, ${0.3 + Math.sin(Date.now() / 100) * 0.2})`;
                ctx.lineWidth = 3;
                ctx.stroke();

                ctx.fillStyle = `rgba(0, 150, 255, 0.1)`;
                ctx.fill();
            }

            // Engine glow
            const engineGlow = ctx.createRadialGradient(-player.width / 2 - 10, 0, 0, -player.width / 2 - 10, 0, 30);
            engineGlow.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
            engineGlow.addColorStop(0.5, 'rgba(0, 150, 255, 0.4)');
            engineGlow.addColorStop(1, 'transparent');
            ctx.fillStyle = engineGlow;
            ctx.fillRect(-player.width / 2 - 40, -20, 40, 40);

            // Ship body
            ctx.fillStyle = '#0af';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#0af';

            ctx.beginPath();
            ctx.moveTo(player.width / 2, 0);
            ctx.lineTo(-player.width / 2, -player.height / 2);
            ctx.lineTo(-player.width / 3, -player.height / 4);
            ctx.lineTo(-player.width / 3, player.height / 4);
            ctx.lineTo(-player.width / 2, player.height / 2);
            ctx.closePath();
            ctx.fill();

            // Cockpit
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(player.width / 6, 0, player.width / 5, player.height / 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wing details
            ctx.fillStyle = '#08a';
            ctx.beginPath();
            ctx.moveTo(0, -player.height / 4);
            ctx.lineTo(-player.width / 3, -player.height / 2 + 5);
            ctx.lineTo(-player.width / 4, -player.height / 4);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(0, player.height / 4);
            ctx.lineTo(-player.width / 3, player.height / 2 - 5);
            ctx.lineTo(-player.width / 4, player.height / 4);
            ctx.closePath();
            ctx.fill();

            ctx.restore();

            // Thruster particles
            if (keys['KeyW'] || keys['ArrowUp'] || keys['KeyD'] || keys['ArrowRight']) {
                for (let i = 0; i < 2; i++) {
                    particles.push(new Particle(
                        player.x - player.width / 2 - 10,
                        player.y + (Math.random() - 0.5) * 10,
                        -300 - Math.random() * 200,
                        (Math.random() - 0.5) * 100,
                        Math.random() > 0.5 ? '#0ff' : '#00f',
                        3 + Math.random() * 3,
                        0.2 + Math.random() * 0.2,
                        'normal'
                    ));
                }
            }
        }

        // Draw bullet
        function drawBullet(bullet) {
            ctx.save();
            ctx.translate(bullet.x, bullet.y);

            // Glow
            ctx.shadowBlur = 15;
            ctx.shadowColor = bullet.color || '#0ff';

            // Bullet trail
            const gradient = ctx.createLinearGradient(-30, 0, 10, 0);
            gradient.addColorStop(0, 'transparent');
            gradient.addColorStop(1, bullet.color || '#0ff');
            ctx.fillStyle = gradient;
            ctx.fillRect(-30, -2, 40, 4);

            // Bullet core
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 3, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // Draw enemy bullet
        function drawEnemyBullet(bullet) {
            ctx.save();
            ctx.translate(bullet.x, bullet.y);

            ctx.shadowBlur = 15;
            ctx.shadowColor = bullet.color;

            ctx.fillStyle = bullet.color;
            ctx.beginPath();
            ctx.arc(0, 0, bullet.size, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, bullet.size / 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // Draw background
        function drawBackground(dt) {
            // Deep space gradient
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#000010');
            gradient.addColorStop(0.5, '#000020');
            gradient.addColorStop(1, '#100010');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Nebulae
            nebulae.forEach(nebula => {
                nebula.x -= nebula.speed * dt;
                if (nebula.x < -nebula.radius) {
                    nebula.x = canvas.width + nebula.radius;
                    nebula.y = Math.random() * canvas.height;
                }

                const gradient = ctx.createRadialGradient(nebula.x, nebula.y, 0, nebula.x, nebula.y, nebula.radius);
                gradient.addColorStop(0, nebula.color);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(nebula.x - nebula.radius, nebula.y - nebula.radius, nebula.radius * 2, nebula.radius * 2);
            });

            // Stars
            stars.forEach(star => {
                star.x -= star.speed * dt;
                if (star.x < 0) {
                    star.x = canvas.width;
                    star.y = Math.random() * canvas.height;
                }

                const twinkle = 0.5 + Math.sin(Date.now() / 200 + star.brightness * 10) * 0.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness * twinkle})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Spawn enemies
        function spawnEnemies() {
            const baseCount = Math.min(3 + Math.floor(wave / 2), 10);

            for (let i = 0; i < baseCount; i++) {
                setTimeout(() => {
                    if (!gameRunning) return;

                    let type = 'basic';
                    const rand = Math.random();
                    if (wave >= 3 && rand > 0.7) type = 'fast';
                    if (wave >= 5 && rand > 0.85) type = 'heavy';

                    enemies.push(new Enemy(type));
                }, i * 1000);
            }

            // Boss every 5 waves
            if (wave % 5 === 0) {
                setTimeout(() => {
                    if (!gameRunning) return;
                    enemies.push(new Enemy('boss'));
                }, baseCount * 1000);
            }
        }

        // Spawn asteroids
        function spawnAsteroids() {
            const count = 3 + Math.floor(wave / 2);
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    if (!gameRunning) return;
                    asteroids.push(new Asteroid('large'));
                }, i * 2000);
            }
        }

        // Fire bullet
        function fireBullet() {
            const now = Date.now();
            const fireRate = player.rapidFire > 0 ? player.fireRate / 3 : player.fireRate;

            if (now - player.lastFire > fireRate) {
                player.lastFire = now;

                if (player.tripleShot > 0) {
                    bullets.push(
                        { x: player.x + player.width / 2, y: player.y, vx: 800, vy: 0, color: '#0ff' },
                        { x: player.x + player.width / 2, y: player.y, vx: 780, vy: -150, color: '#0ff' },
                        { x: player.x + player.width / 2, y: player.y, vx: 780, vy: 150, color: '#0ff' }
                    );
                } else {
                    bullets.push({
                        x: player.x + player.width / 2,
                        y: player.y,
                        vx: 800,
                        vy: 0,
                        color: '#0ff'
                    });
                }
            }
        }

        // Collision detection
        function checkCollision(a, b, aRadius, bRadius) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            return Math.sqrt(dx * dx + dy * dy) < aRadius + bRadius;
        }

        // Update game
        function update(dt) {
            if (!gameRunning) return;

            // Player movement
            let dx = 0, dy = 0;
            const speed = keys['ShiftLeft'] || keys['ShiftRight'] ? player.boostSpeed : player.speed;

            if (keys['KeyW'] || keys['ArrowUp']) dy -= 1;
            if (keys['KeyS'] || keys['ArrowDown']) dy += 1;
            if (keys['KeyA'] || keys['ArrowLeft']) dx -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) dx += 1;

            if (dx !== 0 || dy !== 0) {
                const len = Math.sqrt(dx * dx + dy * dy);
                dx /= len;
                dy /= len;
            }

            player.x += dx * speed * dt;
            player.y += dy * speed * dt;

            // Boundary
            player.x = Math.max(player.width, Math.min(canvas.width - player.width, player.x));
            player.y = Math.max(player.height, Math.min(canvas.height - player.height, player.y));

            // Firing
            if (keys['Space'] || mouseDown) {
                fireBullet();
            }

            // Update invincibility
            if (player.invincible > 0) {
                player.invincible -= dt;
            }

            // Update powerup timers
            if (player.rapidFire > 0) player.rapidFire -= dt;
            if (player.tripleShot > 0) player.tripleShot -= dt;

            // Shield regeneration
            if (player.shield < player.maxShield) {
                player.shield = Math.min(player.maxShield, player.shield + 2 * dt);
            }

            // Update bullets
            bullets.forEach(bullet => {
                bullet.x += bullet.vx * dt;
                bullet.y += bullet.vy * dt;
            });
            bullets = bullets.filter(b => b.x < canvas.width + 50 && b.x > -50);

            // Update enemy bullets
            enemyBullets.forEach(bullet => {
                bullet.x += bullet.vx * dt;
                bullet.y += bullet.vy * dt;
            });
            enemyBullets = enemyBullets.filter(b =>
                b.x > -50 && b.x < canvas.width + 50 &&
                b.y > -50 && b.y < canvas.height + 50
            );

            // Update enemies
            enemies.forEach(enemy => enemy.update(dt));
            enemies = enemies.filter(e => e.x > -100);

            // Update asteroids
            asteroids.forEach(asteroid => asteroid.update(dt));
            asteroids = asteroids.filter(a => a.x > -100);

            // Update powerups
            powerups.forEach(p => p.update(dt));
            powerups = powerups.filter(p => p.x > -50);

            // Update particles
            particles.forEach(p => p.update(dt));
            particles = particles.filter(p => p.life > 0);

            // Combo timer
            if (comboTimer > 0) {
                comboTimer -= dt;
                if (comboTimer <= 0) {
                    combo = 0;
                }
            }

            // Collision: Player bullets vs Enemies
            bullets.forEach((bullet, bi) => {
                enemies.forEach((enemy, ei) => {
                    if (checkCollision(bullet, enemy, 5, enemy.width / 2)) {
                        enemy.health -= 10;
                        bullets.splice(bi, 1);

                        createExplosion(bullet.x, bullet.y, '#0ff', 10, 100, 3);

                        if (enemy.health <= 0) {
                            createExplosion(enemy.x, enemy.y, enemy.color, 50, 400, 8);

                            // Combo system
                            combo++;
                            comboTimer = 2;
                            const comboMultiplier = Math.min(combo, 10);
                            const earnedScore = enemy.score * comboMultiplier;
                            score += earnedScore;

                            if (combo >= 5) {
                                showCombo(`${combo}x COMBO! +${earnedScore}`);
                            }

                            // Chance to drop powerup
                            if (Math.random() < 0.2) {
                                powerups.push(new Powerup(enemy.x, enemy.y));
                            }

                            enemies.splice(ei, 1);
                        }
                    }
                });
            });

            // Collision: Player bullets vs Asteroids
            bullets.forEach((bullet, bi) => {
                asteroids.forEach((asteroid, ai) => {
                    if (checkCollision(bullet, asteroid, 5, asteroid.radius)) {
                        asteroid.health -= 10;
                        bullets.splice(bi, 1);

                        createExplosion(bullet.x, bullet.y, '#888', 5, 80, 2);

                        if (asteroid.health <= 0) {
                            createExplosion(asteroid.x, asteroid.y, '#666', 30, 200, 5);
                            score += asteroid.score;

                            // Split asteroid
                            const newAsteroids = asteroid.split();
                            newAsteroids.forEach(a => {
                                a.x = asteroid.x;
                                a.y = asteroid.y;
                                a.vx = asteroid.vx + (Math.random() - 0.5) * 100;
                                a.vy = (Math.random() - 0.5) * 150;
                            });
                            asteroids.push(...newAsteroids);

                            asteroids.splice(ai, 1);
                        }
                    }
                });
            });

            // Collision: Enemy bullets vs Player
            if (player.invincible <= 0) {
                enemyBullets.forEach((bullet, bi) => {
                    if (checkCollision(bullet, player, bullet.size, player.width / 2)) {
                        enemyBullets.splice(bi, 1);
                        createExplosion(bullet.x, bullet.y, '#f00', 15, 150, 4);

                        if (player.shield > 0) {
                            player.shield = Math.max(0, player.shield - bullet.damage);
                        } else {
                            player.health -= bullet.damage;
                            player.invincible = 1;
                        }

                        if (player.health <= 0) {
                            gameOver();
                        }
                    }
                });
            }

            // Collision: Asteroids vs Player
            if (player.invincible <= 0) {
                asteroids.forEach(asteroid => {
                    if (checkCollision(asteroid, player, asteroid.radius, player.width / 2)) {
                        createExplosion(player.x, player.y, '#f00', 20, 200, 5);

                        if (player.shield > 0) {
                            player.shield = Math.max(0, player.shield - 30);
                        } else {
                            player.health -= 30;
                            player.invincible = 1.5;
                        }

                        if (player.health <= 0) {
                            gameOver();
                        }
                    }
                });
            }

            // Collision: Enemies vs Player
            if (player.invincible <= 0) {
                enemies.forEach((enemy, ei) => {
                    if (checkCollision(enemy, player, enemy.width / 2, player.width / 2)) {
                        createExplosion(enemy.x, enemy.y, enemy.color, 30, 300, 6);
                        enemies.splice(ei, 1);

                        if (player.shield > 0) {
                            player.shield = Math.max(0, player.shield - 50);
                        } else {
                            player.health -= 50;
                            player.invincible = 2;
                        }

                        if (player.health <= 0) {
                            gameOver();
                        }
                    }
                });
            }

            // Collision: Powerups vs Player
            powerups.forEach((powerup, pi) => {
                if (checkCollision(powerup, player, powerup.radius, player.width / 2)) {
                    createExplosion(powerup.x, powerup.y, '#fff', 20, 150, 4);

                    switch (powerup.type) {
                        case 'health':
                            player.health = Math.min(player.maxHealth, player.health + 30);
                            break;
                        case 'shield':
                            player.shield = player.maxShield;
                            break;
                        case 'rapidFire':
                            player.rapidFire = 10;
                            break;
                        case 'tripleShot':
                            player.tripleShot = 10;
                            break;
                    }

                    powerups.splice(pi, 1);
                }
            });

            // Check wave completion
            if (enemies.length === 0 && asteroids.length === 0) {
                wave++;
                document.getElementById('waveDisplay').textContent = wave;
                showCombo(`WAVE ${wave}`);
                setTimeout(() => {
                    spawnEnemies();
                    spawnAsteroids();
                }, 2000);
            }

            // Update UI
            document.getElementById('scoreDisplay').textContent = score.toLocaleString();
            document.getElementById('healthBar').style.width = `${player.health}%`;
            document.getElementById('shieldBar').style.width = `${player.shield}%`;

            // Update powerup indicators
            document.getElementById('rapidFire').classList.toggle('active', player.rapidFire > 0);
            document.getElementById('tripleShot').classList.toggle('active', player.tripleShot > 0);
            document.getElementById('shield').classList.toggle('active', player.shield > 50);
        }

        // Draw game
        function draw(dt) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawBackground(dt);

            // Draw game objects
            asteroids.forEach(a => a.draw());
            enemies.forEach(e => e.draw());
            powerups.forEach(p => p.draw());
            bullets.forEach(b => drawBullet(b));
            enemyBullets.forEach(b => drawEnemyBullet(b));
            particles.forEach(p => p.draw());

            if (gameRunning) {
                drawPlayer();
            }
        }

        // Game loop
        function gameLoop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;

            update(dt);
            draw(dt);

            requestAnimationFrame(gameLoop);
        }

        // Show combo text
        function showCombo(text) {
            const display = document.getElementById('comboDisplay');
            display.textContent = text;
            display.classList.add('show');
            setTimeout(() => display.classList.remove('show'), 1500);
        }

        // Start game
        function startGame() {
            gameRunning = true;
            score = 0;
            wave = 1;
            combo = 0;

            player.x = 100;
            player.y = canvas.height / 2;
            player.health = player.maxHealth;
            player.shield = player.maxShield;
            player.invincible = 3;
            player.rapidFire = 0;
            player.tripleShot = 0;

            bullets = [];
            enemyBullets = [];
            enemies = [];
            asteroids = [];
            particles = [];
            powerups = [];

            initBackground();

            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('ui').classList.remove('hidden');
            document.getElementById('powerupIndicator').classList.remove('hidden');

            document.getElementById('scoreDisplay').textContent = '0';
            document.getElementById('waveDisplay').textContent = '1';

            setTimeout(() => {
                spawnEnemies();
                spawnAsteroids();
            }, 1000);
        }

        // Game over
        function gameOver() {
            gameRunning = false;

            createExplosion(player.x, player.y, '#0ff', 100, 500, 10);
            createExplosion(player.x, player.y, '#fff', 50, 300, 5);

            setTimeout(() => {
                document.getElementById('gameOverScreen').classList.remove('hidden');
                document.getElementById('finalScore').textContent = score.toLocaleString();

                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('spaceShooterHighScore', highScore);
                }
                document.getElementById('highScore').textContent = highScore.toLocaleString();
            }, 1500);
        }

        // Input handlers
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space') e.preventDefault();
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        canvas.addEventListener('mousedown', () => mouseDown = true);
        canvas.addEventListener('mouseup', () => mouseDown = false);
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            mouseDown = true;
            const touch = e.touches[0];
            mouseX = touch.clientX;
            mouseY = touch.clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            
            // Move player towards touch
            const dx = touch.clientX - player.x;
            const dy = touch.clientY - player.y;
            
            if (Math.abs(dx) > 10) keys[dx > 0 ? 'KeyD' : 'KeyA'] = true;
            else { keys['KeyD'] = false; keys['KeyA'] = false; }
            
            if (Math.abs(dy) > 10) keys[dy > 0 ? 'KeyS' : 'KeyW'] = true;
            else { keys['KeyS'] = false; keys['KeyW'] = false; }
        });

        canvas.addEventListener('touchend', () => {
            mouseDown = false;
            keys['KeyW'] = false;
            keys['KeyS'] = false;
            keys['KeyA'] = false;
            keys['KeyD'] = false;
        });

        // Initialize
        initBackground();
        document.getElementById('highScore').textContent = highScore.toLocaleString();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>