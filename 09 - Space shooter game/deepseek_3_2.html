<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Shooter: Asteroid Escape</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            background: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(28, 58, 173, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(173, 28, 58, 0.1) 0%, transparent 20%);
        }

        #game-container {
            position: relative;
            width: 1000px;
            height: 700px;
            overflow: hidden;
            border: 3px solid #1a5fb4;
            border-radius: 10px;
            box-shadow: 
                0 0 30px rgba(26, 95, 180, 0.5),
                inset 0 0 30px rgba(26, 95, 180, 0.2);
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }

        .game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .hud {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 5px #00aaff;
        }

        .score-container, .lives-container, .level-container {
            background: rgba(0, 20, 40, 0.7);
            padding: 8px 15px;
            border-radius: 10px;
            border: 1px solid #1a5fb4;
            box-shadow: 0 0 10px rgba(26, 95, 180, 0.5);
        }

        .hud-label {
            color: #4cd2ff;
            font-size: 14px;
            margin-right: 5px;
        }

        .hud-value {
            color: #fff;
        }

        #lives {
            color: #ff5555;
        }

        .controls-info {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 20, 40, 0.7);
            padding: 10px;
            border-radius: 10px;
            border: 1px solid #1a5fb4;
            font-size: 14px;
            max-width: 300px;
        }

        .controls-info p {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }

        .key {
            display: inline-block;
            background: rgba(26, 95, 180, 0.5);
            padding: 2px 8px;
            margin: 0 5px;
            border-radius: 4px;
            border: 1px solid #1a5fb4;
            min-width: 25px;
            text-align: center;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 10, 30, 0.85);
            z-index: 20;
            transition: opacity 0.5s;
        }

        .title {
            font-size: 60px;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
            background: linear-gradient(90deg, #ffaa00, #ff5555, #aa55ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255, 100, 100, 0.5);
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 22px;
            color: #4cd2ff;
            margin-bottom: 40px;
            text-align: center;
        }

        .btn {
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(135deg, #1a5fb4, #3584e4);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.2s;
            box-shadow: 0 5px 15px rgba(26, 95, 180, 0.4);
            pointer-events: auto;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(26, 95, 180, 0.6);
            background: linear-gradient(135deg, #3584e4, #1a5fb4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .game-over {
            color: #ff5555;
            font-size: 50px;
            margin-bottom: 20px;
        }

        .final-score {
            font-size: 30px;
            margin-bottom: 30px;
            color: #4cd2ff;
        }

        .instructions {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 20, 40, 0.7);
            padding: 10px;
            border-radius: 10px;
            border: 1px solid #1a5fb4;
            font-size: 14px;
            max-width: 300px;
        }

        .powerup-hud {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }

        .powerup-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #1a5fb4;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background: rgba(0, 20, 40, 0.7);
            box-shadow: 0 0 10px rgba(26, 95, 180, 0.5);
        }

        .powerup-icon.active {
            border-color: #ffaa00;
            box-shadow: 0 0 15px rgba(255, 170, 0, 0.7);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .notification {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 40, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid #1a5fb4;
            font-size: 18px;
            color: #4cd2ff;
            box-shadow: 0 0 15px rgba(26, 95, 180, 0.5);
            opacity: 0;
            transition: opacity 0.3s;
            text-align: center;
        }

        .notification.show {
            opacity: 1;
        }

        .boss-health {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background: rgba(0, 20, 40, 0.7);
            border-radius: 10px;
            border: 2px solid #ff5555;
            overflow: hidden;
            display: none;
        }

        .boss-health-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff5555, #ffaa00);
            border-radius: 8px;
            transition: width 0.3s;
        }

        .boss-name {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #ff5555;
            text-shadow: 0 0 10px rgba(255, 85, 85, 0.7);
            display: none;
        }

        @media (max-width: 1020px) {
            #game-container {
                width: 95vw;
                height: 70vh;
            }
            
            .title {
                font-size: 40px;
            }
            
            .controls-info, .instructions {
                font-size: 12px;
                max-width: 250px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <div class="game-ui">
            <div class="hud">
                <div class="score-container">
                    <span class="hud-label">SCORE:</span>
                    <span id="score" class="hud-value">0</span>
                </div>
                <div class="level-container">
                    <span class="hud-label">LEVEL:</span>
                    <span id="level" class="hud-value">1</span>
                </div>
                <div class="lives-container">
                    <span class="hud-label">LIVES:</span>
                    <span id="lives" class="hud-value">3</span>
                </div>
            </div>
            
            <div class="boss-health" id="boss-health">
                <div class="boss-health-bar" id="boss-health-bar"></div>
            </div>
            <div class="boss-name" id="boss-name">BOSS</div>
            
            <div class="powerup-hud" id="powerup-hud">
                <!-- Powerup icons will be added here -->
            </div>
            
            <div class="controls-info">
                <p><span class="key">WASD</span> or <span class="key">‚Üë‚Üì‚Üê‚Üí</span> to move</p>
                <p><span class="key">SPACE</span> to shoot</p>
                <p><span class="key">SHIFT</span> for boost</p>
                <p><span class="key">P</span> to pause</p>
            </div>
            
            <div class="instructions">
                <p>Avoid asteroids, destroy enemies, collect powerups!</p>
                <p>Defeat the boss every 5 levels!</p>
            </div>
            
            <div class="notification" id="notification"></div>
        </div>
        
        <!-- Start Screen -->
        <div id="start-screen" class="screen">
            <h1 class="title">SPACE SHOOTER</h1>
            <p class="subtitle">Asteroid Escape</p>
            <button id="start-btn" class="btn">START MISSION</button>
            <button id="instructions-btn" class="btn">HOW TO PLAY</button>
        </div>
        
        <!-- Pause Screen -->
        <div id="pause-screen" class="screen" style="display: none;">
            <h1 class="title">MISSION PAUSED</h1>
            <p class="subtitle">The universe waits for you</p>
            <button id="resume-btn" class="btn">RESUME MISSION</button>
            <button id="restart-btn" class="btn">RESTART MISSION</button>
        </div>
        
        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen" style="display: none;">
            <h1 class="game-over">MISSION FAILED</h1>
            <p class="final-score">Final Score: <span id="final-score">0</span></p>
            <p class="subtitle">Your ship was destroyed</p>
            <button id="play-again-btn" class="btn">TRY AGAIN</button>
            <button id="menu-btn" class="btn">RETURN TO BASE</button>
        </div>
        
        <!-- Instructions Screen -->
        <div id="instructions-screen" class="screen" style="display: none;">
            <h1 class="title">HOW TO PLAY</h1>
            <div style="max-width: 600px; margin: 20px; text-align: left; line-height: 1.6;">
                <p><strong>Objective:</strong> Survive as long as possible while destroying enemies and avoiding asteroids.</p>
                <p><strong>Controls:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 20px;">
                    <li>Move: WASD or Arrow Keys</li>
                    <li>Shoot: Spacebar</li>
                    <li>Boost: Shift (temporary speed boost)</li>
                    <li>Pause: P</li>
                </ul>
                <p><strong>Enemies:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 20px;">
                    <li>Scouts: Small, fast, low health</li>
                    <li>Fighters: Medium, shoot back</li>
                    <li>Bosses: Large, high health, powerful weapons (appear every 5 levels)</li>
                </ul>
                <p><strong>Powerups:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 20px;">
                    <li>Shield: Temporary invincibility</li>
                    <li>Rapid Fire: Faster shooting</li>
                    <li>Triple Shot: Shoot three lasers at once</li>
                    <li>Health: Restore one life</li>
                </ul>
            </div>
            <button id="back-btn" class="btn">BACK TO MENU</button>
        </div>
    </div>
    
    <script>
        // Game State
        const gameState = {
            screen: 'start', // start, playing, paused, gameover, instructions
            score: 0,
            level: 1,
            lives: 3,
            gameTime: 0,
            isRunning: false,
            player: null,
            enemies: [],
            asteroids: [],
            lasers: [],
            enemyLasers: [],
            particles: [],
            powerups: [],
            starfield: [],
            explosions: [],
            boss: null,
            bossActive: false,
            powerupsActive: {
                shield: { active: false, duration: 0, maxDuration: 5000 },
                rapidFire: { active: false, duration: 0, maxDuration: 8000 },
                tripleShot: { active: false, duration: 0, maxDuration: 10000 }
            },
            keys: {},
            lastShot: 0,
            shotDelay: 300, // ms between shots
            lastEnemySpawn: 0,
            enemySpawnDelay: 2000, // ms between enemy spawns
            lastAsteroidSpawn: 0,
            asteroidSpawnDelay: 1000, // ms between asteroid spawns
            lastPowerupSpawn: 0,
            powerupSpawnDelay: 15000, // ms between powerup spawns
            starCount: 200,
            notificationTimeout: null
        };

        // Canvas setup
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1000;
        canvas.height = 700;

        // Initialize game
        function initGame() {
            // Create starfield
            gameState.starfield = [];
            for (let i = 0; i < gameState.starCount; i++) {
                gameState.starfield.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 3,
                    speed: 0.5 + Math.random() * 1.5,
                    brightness: 0.5 + Math.random() * 0.5
                });
            }
            
            // Create player
            gameState.player = {
                x: canvas.width / 2,
                y: canvas.height - 100,
                width: 40,
                height: 60,
                speed: 5,
                boostSpeed: 10,
                isBoosting: false,
                rotation: 0,
                health: 100,
                maxHealth: 100,
                color: '#4cd2ff',
                engineParticles: []
            };
            
            // Reset game state
            gameState.score = 0;
            gameState.level = 1;
            gameState.lives = 3;
            gameState.gameTime = 0;
            gameState.enemies = [];
            gameState.asteroids = [];
            gameState.lasers = [];
            gameState.enemyLasers = [];
            gameState.particles = [];
            gameState.powerups = [];
            gameState.explosions = [];
            gameState.boss = null;
            gameState.bossActive = false;
            
            // Reset powerups
            for (let key in gameState.powerupsActive) {
                gameState.powerupsActive[key].active = false;
                gameState.powerupsActive[key].duration = 0;
            }
            
            updateHUD();
            updatePowerupHUD();
        }

        // Draw functions
        function drawPlayer() {
            const player = gameState.player;
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.rotation);
            
            // Draw ship body
            ctx.fillStyle = player.color;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            
            // Ship shape (triangle)
            ctx.beginPath();
            ctx.moveTo(0, -player.height/2);
            ctx.lineTo(player.width/2, player.height/2);
            ctx.lineTo(-player.width/2, player.height/2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Ship cockpit
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(0, -player.height/4, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Ship details
            ctx.fillStyle = '#ffaa00';
            ctx.fillRect(-15, player.height/3, 30, 5);
            
            ctx.restore();
            
            // Draw engine particles
            drawEngineParticles();
        }

        function drawEngineParticles() {
            const player = gameState.player;
            
            // Add new particles when moving
            if (player.isBoosting || (gameState.keys['ArrowUp'] || gameState.keys['KeyW'])) {
                for (let i = 0; i < 3; i++) {
                    gameState.player.engineParticles.push({
                        x: player.x + (Math.random() * 20 - 10),
                        y: player.y + player.height/2,
                        size: 2 + Math.random() * 4,
                        speedX: (Math.random() * 4 - 2),
                        speedY: 2 + Math.random() * 4,
                        color: player.isBoosting ? '#ffaa00' : '#4cd2ff',
                        life: 20 + Math.random() * 30
                    });
                }
            }
            
            // Update and draw particles
            for (let i = gameState.player.engineParticles.length - 1; i >= 0; i--) {
                const p = gameState.player.engineParticles[i];
                
                p.x += p.speedX;
                p.y += p.speedY;
                p.life--;
                
                if (p.life <= 0 || p.y > canvas.height) {
                    gameState.player.engineParticles.splice(i, 1);
                    continue;
                }
                
                ctx.globalAlpha = p.life / 50;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.globalAlpha = 1;
        }

        function drawEnemies() {
            gameState.enemies.forEach(enemy => {
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                
                // Enemy color based on type
                let color, wingColor;
                if (enemy.type === 'scout') {
                    color = '#ff5555';
                    wingColor = '#aa0000';
                } else if (enemy.type === 'fighter') {
                    color = '#aa55ff';
                    wingColor = '#5500aa';
                } else if (enemy.type === 'boss') {
                    color = '#ffaa00';
                    wingColor = '#aa5500';
                }
                
                // Draw enemy body
                ctx.fillStyle = color;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                
                if (enemy.type === 'boss') {
                    // Boss is larger and more detailed
                    ctx.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
                    
                    // Boss details
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(-enemy.width/4, -enemy.height/4, enemy.width/2, enemy.height/4);
                    
                    ctx.fillStyle = '#ff5555';
                    for (let i = -2; i <= 2; i++) {
                        ctx.fillRect(i * 20 - 5, enemy.height/4, 10, 10);
                    }
                } else {
                    // Regular enemy shape (different from player)
                    ctx.beginPath();
                    ctx.moveTo(0, -enemy.height/2);
                    ctx.lineTo(enemy.width/2, enemy.height/2);
                    ctx.lineTo(0, enemy.height/4);
                    ctx.lineTo(-enemy.width/2, enemy.height/2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Enemy wings
                    ctx.fillStyle = wingColor;
                    ctx.fillRect(-enemy.width/2 - 10, 0, 10, 5);
                    ctx.fillRect(enemy.width/2, 0, 10, 5);
                    
                    // Enemy cockpit
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(0, -enemy.height/4, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            });
        }

        function drawAsteroids() {
            gameState.asteroids.forEach(asteroid => {
                ctx.save();
                ctx.translate(asteroid.x, asteroid.y);
                ctx.rotate(asteroid.rotation);
                
                // Draw asteroid as irregular shape
                ctx.fillStyle = asteroid.color;
                ctx.strokeStyle = '#888888';
                ctx.lineWidth = 1;
                
                ctx.beginPath();
                for (let i = 0; i < asteroid.sides; i++) {
                    const angle = (i / asteroid.sides) * Math.PI * 2;
                    const radius = asteroid.size + asteroid.irregularity[i];
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Asteroid details
                ctx.fillStyle = '#666666';
                for (let i = 0; i < 3; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * asteroid.size * 0.7;
                    const x = Math.cos(angle) * dist;
                    const y = Math.sin(angle) * dist;
                    const size = 2 + Math.random() * 3;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            });
        }

        function drawLasers() {
            // Player lasers
            gameState.lasers.forEach(laser => {
                ctx.fillStyle = laser.color;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                
                // Draw laser beam with glow effect
                ctx.beginPath();
                ctx.moveTo(laser.x, laser.y);
                ctx.lineTo(laser.x, laser.y - laser.height);
                ctx.lineWidth = laser.width;
                ctx.stroke();
                
                // Laser tip
                ctx.beginPath();
                ctx.arc(laser.x, laser.y - laser.height/2, laser.width * 1.5, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Enemy lasers
            gameState.enemyLasers.forEach(laser => {
                ctx.fillStyle = laser.color;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                
                ctx.beginPath();
                ctx.moveTo(laser.x, laser.y);
                ctx.lineTo(laser.x, laser.y + laser.height);
                ctx.lineWidth = laser.width;
                ctx.stroke();
                
                // Laser tip
                ctx.beginPath();
                ctx.arc(laser.x, laser.y + laser.height/2, laser.width * 1.5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawPowerups() {
            gameState.powerups.forEach(powerup => {
                ctx.save();
                ctx.translate(powerup.x, powerup.y);
                
                // Powerup glow
                ctx.fillStyle = powerup.color;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(0, 0, powerup.size + 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalAlpha = 1;
                
                // Powerup icon
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(powerup.icon, 0, 0);
                
                // Pulsing animation
                const pulse = Math.sin(Date.now() / 200) * 3;
                ctx.strokeStyle = powerup.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, powerup.size + pulse, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.restore();
            });
        }

        function drawParticles() {
            gameState.particles.forEach(particle => {
                ctx.globalAlpha = particle.life / 100;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function drawExplosions() {
            gameState.explosions.forEach(explosion => {
                ctx.save();
                ctx.translate(explosion.x, explosion.y);
                
                // Explosion particles
                explosion.particles.forEach(p => {
                    ctx.globalAlpha = p.life / 100;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.restore();
                ctx.globalAlpha = 1;
            });
        }

        function drawStarfield() {
            // Draw background stars
            gameState.starfield.forEach(star => {
                // Move stars for parallax effect
                star.y += star.speed * 0.1;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
                
                ctx.globalAlpha = star.brightness;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.globalAlpha = 1;
            
            // Draw nebula effect
            const gradient = ctx.createRadialGradient(
                canvas.width * 0.3, canvas.height * 0.2, 0,
                canvas.width * 0.3, canvas.height * 0.2, 300
            );
            gradient.addColorStop(0, 'rgba(100, 50, 200, 0.1)');
            gradient.addColorStop(1, 'rgba(100, 50, 200, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const gradient2 = ctx.createRadialGradient(
                canvas.width * 0.7, canvas.height * 0.8, 0,
                canvas.width * 0.7, canvas.height * 0.8, 400
            );
            gradient2.addColorStop(0, 'rgba(200, 50, 100, 0.1)');
            gradient2.addColorStop(1, 'rgba(200, 50, 100, 0)');
            ctx.fillStyle = gradient2;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawShield() {
            if (!gameState.powerupsActive.shield.active) return;
            
            const player = gameState.player;
            const shieldSize = 1.5;
            const pulse = Math.sin(Date.now() / 200) * 5;
            
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            ctx.arc(player.x, player.y, Math.max(player.width, player.height) * shieldSize + pulse, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        // Update functions
        function updatePlayer() {
            const player = gameState.player;
            
            // Reset rotation
            player.rotation = 0;
            
            // Calculate movement speed
            let speed = player.speed;
            player.isBoosting = false;
            
            if (gameState.keys['ShiftLeft'] || gameState.keys['ShiftRight']) {
                speed = player.boostSpeed;
                player.isBoosting = true;
            }
            
            // Handle movement
            if (gameState.keys['ArrowUp'] || gameState.keys['KeyW']) {
                player.y -= speed;
                player.rotation = -0.1;
            }
            if (gameState.keys['ArrowDown'] || gameState.keys['KeyS']) {
                player.y += speed * 0.7;
                player.rotation = 0.1;
            }
            if (gameState.keys['ArrowLeft'] || gameState.keys['KeyA']) {
                player.x -= speed;
                player.rotation = -0.2;
            }
            if (gameState.keys['ArrowRight'] || gameState.keys['KeyD']) {
                player.x += speed;
                player.rotation = 0.2;
            }
            
            // Keep player in bounds
            player.x = Math.max(player.width/2, Math.min(canvas.width - player.width/2, player.x));
            player.y = Math.max(player.height/2, Math.min(canvas.height - player.height/2, player.y));
            
            // Update powerup durations
            for (let key in gameState.powerupsActive) {
                if (gameState.powerupsActive[key].active) {
                    gameState.powerupsActive[key].duration -= 16; // Assuming ~60fps
                    if (gameState.powerupsActive[key].duration <= 0) {
                        gameState.powerupsActive[key].active = false;
                        showNotification(`${key.toUpperCase()} expired!`);
                        updatePowerupHUD();
                    }
                }
            }
        }

        function updateEnemies() {
            const now = Date.now();
            
            // Spawn new enemies
            if (now - gameState.lastEnemySpawn > gameState.enemySpawnDelay) {
                spawnEnemy();
                gameState.lastEnemySpawn = now;
                
                // Increase spawn rate over time
                gameState.enemySpawnDelay = Math.max(500, 2000 - gameState.level * 100);
            }
            
            // Update existing enemies
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                
                // Move enemy
                if (enemy.type === 'boss') {
                    // Boss moves in a pattern
                    enemy.x += Math.sin(enemy.y / 100) * 2;
                    enemy.y += enemy.speed;
                    
                    // Boss shooting
                    if (now - enemy.lastShot > enemy.shootDelay) {
                        spawnEnemyLaser(enemy);
                        enemy.lastShot = now;
                    }
                    
                    // Check if boss is defeated
                    if (enemy.health <= 0) {
                        createExplosion(enemy.x, enemy.y, 100, '#ffaa00');
                        gameState.score += 1000;
                        gameState.bossActive = false;
                        gameState.enemies.splice(i, 1);
                        hideBossHealth();
                        showNotification('BOSS DEFEATED! +1000 POINTS');
                        continue;
                    }
                    
                    // Update boss health bar
                    updateBossHealth(enemy.health, enemy.maxHealth);
                } else {
                    enemy.y += enemy.speed;
                    
                    // Enemy shooting (fighters only)
                    if (enemy.type === 'fighter' && now - enemy.lastShot > enemy.shootDelay) {
                        spawnEnemyLaser(enemy);
                        enemy.lastShot = now;
                    }
                    
                    // Remove if off screen
                    if (enemy.y > canvas.height + 100) {
                        gameState.enemies.splice(i, 1);
                        continue;
                    }
                }
                
                // Check collision with player
                if (checkCollision(gameState.player, enemy)) {
                    if (!gameState.powerupsActive.shield.active) {
                        gameState.lives--;
                        updateHUD();
                        if (gameState.lives <= 0) {
                            gameOver();
                            return;
                        }
                        showNotification('HIT! Lives: ' + gameState.lives);
                    }
                    createExplosion(enemy.x, enemy.y, 30, enemy.type === 'boss' ? '#ffaa00' : '#ff5555');
                    gameState.enemies.splice(i, 1);
                    continue;
                }
                
                // Check collision with player lasers
                for (let j = gameState.lasers.length - 1; j >= 0; j--) {
                    const laser = gameState.lasers[j];
                    if (checkCollision(enemy, laser)) {
                        enemy.health -= laser.damage;
                        createParticles(enemy.x, enemy.y, 10, laser.color);
                        
                        if (enemy.health <= 0) {
                            createExplosion(enemy.x, enemy.y, enemy.type === 'boss' ? 80 : 40, '#ffaa00');
                            gameState.score += enemy.type === 'boss' ? 0 : 100;
                            gameState.score += enemy.type === 'fighter' ? 50 : 0;
                            gameState.enemies.splice(i, 1);
                            
                            if (enemy.type !== 'boss') {
                                showNotification(`+${enemy.type === 'fighter' ? 150 : 100} POINTS`);
                            }
                        }
                        
                        gameState.lasers.splice(j, 1);
                        break;
                    }
                }
            }
        }

        function updateAsteroids() {
            const now = Date.now();
            
            // Spawn new asteroids
            if (now - gameState.lastAsteroidSpawn > gameState.asteroidSpawnDelay) {
                spawnAsteroid();
                gameState.lastAsteroidSpawn = now;
            }
            
            // Update existing asteroids
            for (let i = gameState.asteroids.length - 1; i >= 0; i--) {
                const asteroid = gameState.asteroids[i];
                
                // Move asteroid
                asteroid.x += asteroid.speedX;
                asteroid.y += asteroid.speedY;
                asteroid.rotation += asteroid.rotationSpeed;
                
                // Remove if off screen
                if (asteroid.y > canvas.height + 100 || 
                    asteroid.x < -100 || 
                    asteroid.x > canvas.width + 100) {
                    gameState.asteroids.splice(i, 1);
                    continue;
                }
                
                // Check collision with player
                if (checkCollision(gameState.player, asteroid)) {
                    if (!gameState.powerupsActive.shield.active) {
                        gameState.lives--;
                        updateHUD();
                        if (gameState.lives <= 0) {
                            gameOver();
                            return;
                        }
                        showNotification('ASTEROID HIT! Lives: ' + gameState.lives);
                    }
                    createExplosion(asteroid.x, asteroid.y, asteroid.size * 2, '#888888');
                    gameState.asteroids.splice(i, 1);
                    continue;
                }
                
                // Check collision with lasers
                for (let j = gameState.lasers.length - 1; j >= 0; j--) {
                    const laser = gameState.lasers[j];
                    if (checkCollision(asteroid, laser)) {
                        // Break asteroid into smaller pieces
                        if (asteroid.size > 20) {
                            for (let k = 0; k < 3; k++) {
                                spawnAsteroid(
                                    asteroid.x,
                                    asteroid.y,
                                    asteroid.size / 2,
                                    asteroid.speedX * 1.5,
                                    asteroid.speedY * 1.5
                                );
                            }
                        }
                        
                        createExplosion(asteroid.x, asteroid.y, asteroid.size, '#ffaa00');
                        gameState.score += Math.floor(asteroid.size);
                        gameState.asteroids.splice(i, 1);
                        gameState.lasers.splice(j, 1);
                        showNotification(`+${Math.floor(asteroid.size)} POINTS`);
                        break;
                    }
                }
            }
        }

        function updateLasers() {
            // Update player lasers
            for (let i = gameState.lasers.length - 1; i >= 0; i--) {
                const laser = gameState.lasers[i];
                laser.y -= laser.speed;
                
                // Remove if off screen
                if (laser.y < -50) {
                    gameState.lasers.splice(i, 1);
                }
            }
            
            // Update enemy lasers
            for (let i = gameState.enemyLasers.length - 1; i >= 0; i--) {
                const laser = gameState.enemyLasers[i];
                laser.y += laser.speed;
                
                // Remove if off screen
                if (laser.y > canvas.height + 50) {
                    gameState.enemyLasers.splice(i, 1);
                    continue;
                }
                
                // Check collision with player
                if (checkCollision(gameState.player, laser)) {
                    if (!gameState.powerupsActive.shield.active) {
                        gameState.lives--;
                        updateHUD();
                        if (gameState.lives <= 0) {
                            gameOver();
                            return;
                        }
                        showNotification('HIT BY LASER! Lives: ' + gameState.lives);
                    }
                    gameState.enemyLasers.splice(i, 1);
                    createExplosion(laser.x, laser.y, 20, '#ff5555');
                }
            }
        }

        function updatePowerups() {
            const now = Date.now();
            
            // Spawn powerups occasionally
            if (now - gameState.lastPowerupSpawn > gameState.powerupSpawnDelay && Math.random() < 0.3) {
                spawnPowerup();
                gameState.lastPowerupSpawn = now;
            }
            
            // Update existing powerups
            for (let i = gameState.powerups.length - 1; i >= 0; i--) {
                const powerup = gameState.powerups[i];
                powerup.y += powerup.speed;
                
                // Remove if off screen
                if (powerup.y > canvas.height + 50) {
                    gameState.powerups.splice(i, 1);
                    continue;
                }
                
                // Check collision with player
                if (checkCollision(gameState.player, powerup)) {
                    activatePowerup(powerup.type);
                    gameState.powerups.splice(i, 1);
                }
            }
        }

        function updateParticles() {
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const particle = gameState.particles[i];
                particle.x += particle.speedX;
                particle.y += particle.speedY;
                particle.life--;
                
                if (particle.life <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }
        }

        function updateExplosions() {
            for (let i = gameState.explosions.length - 1; i >= 0; i--) {
                const explosion = gameState.explosions[i];
                explosion.life--;
                
                // Update particles in explosion
                for (let j = explosion.particles.length - 1; j >= 0; j--) {
                    const p = explosion.particles[j];
                    p.x += p.speedX;
                    p.y += p.speedY;
                    p.life--;
                    
                    if (p.life <= 0) {
                        explosion.particles.splice(j, 1);
                    }
                }
                
                // Remove explosion if no particles left
                if (explosion.life <= 0 || explosion.particles.length === 0) {
                    gameState.explosions.splice(i, 1);
                }
            }
        }

        function updateLevel() {
            // Check for level up
            const levelThreshold = gameState.level * 1000;
            if (gameState.score >= levelThreshold && gameState.level < 10) {
                gameState.level++;
                updateHUD();
                showNotification(`LEVEL ${gameState.level}!`);
                
                // Spawn boss every 5 levels
                if (gameState.level % 5 === 0) {
                    spawnBoss();
                }
            }
        }

        // Spawn functions
        function spawnEnemy() {
            const types = ['scout', 'fighter'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            let width, height, speed, health, color, shootDelay;
            
            if (type === 'scout') {
                width = 30;
                height = 40;
                speed = 2 + Math.random() * 1 + gameState.level * 0.2;
                health = 1;
                color = '#ff5555';
                shootDelay = 0; // Scouts don't shoot
            } else { // fighter
                width = 40;
                height = 50;
                speed = 1 + Math.random() * 1 + gameState.level * 0.1;
                health = 3;
                color = '#aa55ff';
                shootDelay = 1500 + Math.random() * 1000;
            }
            
            gameState.enemies.push({
                x: Math.random() * (canvas.width - width) + width/2,
                y: -height,
                width: width,
                height: height,
                speed: speed,
                health: health,
                maxHealth: health,
                color: color,
                type: type,
                lastShot: Date.now(),
                shootDelay: shootDelay
            });
        }

        function spawnBoss() {
            gameState.bossActive = true;
            showBossHealth();
            
            gameState.enemies.push({
                x: canvas.width / 2,
                y: -150,
                width: 120,
                height: 150,
                speed: 1,
                health: 50 + gameState.level * 10,
                maxHealth: 50 + gameState.level * 10,
                color: '#ffaa00',
                type: 'boss',
                lastShot: Date.now(),
                shootDelay: 800
            });
            
            showNotification('BOSS INCOMING!');
        }

        function spawnAsteroid(x = null, y = null, size = null, speedX = null, speedY = null) {
            const asteroidSize = size || (20 + Math.random() * 40);
            const sides = 6 + Math.floor(Math.random() * 6);
            const irregularity = [];
            
            for (let i = 0; i < sides; i++) {
                irregularity.push(Math.random() * 10 - 5);
            }
            
            gameState.asteroids.push({
                x: x || Math.random() * canvas.width,
                y: y || -asteroidSize,
                size: asteroidSize,
                sides: sides,
                irregularity: irregularity,
                speedX: speedX || (Math.random() * 4 - 2),
                speedY: speedY || (2 + Math.random() * 2 + gameState.level * 0.1),
                rotation: 0,
                rotationSpeed: (Math.random() * 0.05 - 0.025),
                color: `rgb(${100 + Math.random() * 100}, ${80 + Math.random() * 50}, ${50 + Math.random() * 50})`
            });
        }

        function spawnPowerup() {
            const powerups = [
                { type: 'shield', icon: 'üõ°Ô∏è', color: '#00ffff' },
                { type: 'rapidFire', icon: '‚ö°', color: '#ffff00' },
                { type: 'tripleShot', icon: 'üî∫', color: '#ff00ff' },
                { type: 'health', icon: '‚ù§Ô∏è', color: '#ff5555' }
            ];
            
            const powerup = powerups[Math.floor(Math.random() * powerups.length)];
            
            gameState.powerups.push({
                x: Math.random() * (canvas.width - 40) + 20,
                y: -30,
                size: 20,
                speed: 2,
                type: powerup.type,
                icon: powerup.icon,
                color: powerup.color
            });
        }

        function spawnPlayerLaser() {
            const player = gameState.player;
            const now = Date.now();
            
            // Check if player can shoot
            if (now - gameState.lastShot < gameState.shotDelay) return;
            
            // Apply rapid fire powerup
            const shotDelay = gameState.powerupsActive.rapidFire.active ? 100 : 300;
            
            if (now - gameState.lastShot >= shotDelay) {
                if (gameState.powerupsActive.tripleShot.active) {
                    // Triple shot
                    gameState.lasers.push(
                        createLaser(player.x - 15, player.y, -0.1),
                        createLaser(player.x, player.y, 0),
                        createLaser(player.x + 15, player.y, 0.1)
                    );
                } else {
                    // Single shot
                    gameState.lasers.push(createLaser(player.x, player.y, 0));
                }
                
                gameState.lastShot = now;
            }
        }

        function spawnEnemyLaser(enemy) {
            gameState.enemyLasers.push({
                x: enemy.x,
                y: enemy.y + enemy.height/2,
                width: 4,
                height: 20,
                speed: 5,
                damage: 1,
                color: enemy.type === 'boss' ? '#ffaa00' : '#ff5555'
            });
        }

        function createLaser(x, y, angle) {
            return {
                x: x,
                y: y,
                width: 6,
                height: 20,
                speed: 10,
                damage: gameState.powerupsActive.tripleShot.active ? 2 : 1,
                color: gameState.powerupsActive.tripleShot.active ? '#ff00ff' : '#00ff00',
                angle: angle
            };
        }

        // Helper functions
        function checkCollision(obj1, obj2) {
            // Simple circle collision for asteroids, rectangle for others
            if (obj2.size) {
                // obj2 is an asteroid (circular)
                const dx = obj1.x - obj2.x;
                const dy = obj1.y - obj2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const radius1 = Math.max(obj1.width, obj1.height) / 2;
                const radius2 = obj2.size;
                
                return distance < radius1 + radius2;
            } else {
                // Rectangle collision
                return obj1.x < obj2.x + obj2.width &&
                       obj1.x + obj1.width > obj2.x &&
                       obj1.y < obj2.y + obj2.height &&
                       obj1.y + obj1.height > obj2.y;
            }
        }

        function createParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    size: 2 + Math.random() * 4,
                    speedX: (Math.random() * 6 - 3),
                    speedY: (Math.random() * 6 - 3),
                    color: color,
                    life: 30 + Math.random() * 40
                });
            }
        }

        function createExplosion(x, y, size, color) {
            const particles = [];
            const particleCount = size * 2;
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                
                particles.push({
                    x: 0,
                    y: 0,
                    size: 2 + Math.random() * 4,
                    speedX: Math.cos(angle) * speed,
                    speedY: Math.sin(angle) * speed,
                    color: color,
                    life: 50 + Math.random() * 50
                });
            }
            
            gameState.explosions.push({
                x: x,
                y: y,
                size: size,
                life: 100,
                particles: particles
            });
        }

        function activatePowerup(type) {
            if (type === 'health') {
                gameState.lives = Math.min(5, gameState.lives + 1);
                updateHUD();
                showNotification('HEALTH RESTORED!');
                return;
            }
            
            gameState.powerupsActive[type].active = true;
            gameState.powerupsActive[type].duration = gameState.powerupsActive[type].maxDuration;
            
            showNotification(`${type.toUpperCase()} ACTIVATED!`);
            updatePowerupHUD();
        }

        function updateHUD() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('lives').textContent = gameState.lives;
        }

        function updatePowerupHUD() {
            const powerupHUD = document.getElementById('powerup-hud');
            powerupHUD.innerHTML = '';
            
            for (let key in gameState.powerupsActive) {
                const powerup = gameState.powerupsActive[key];
                const icon = document.createElement('div');
                icon.className = 'powerup-icon';
                
                switch(key) {
                    case 'shield': icon.textContent = 'üõ°Ô∏è'; break;
                    case 'rapidFire': icon.textContent = '‚ö°'; break;
                    case 'tripleShot': icon.textContent = 'üî∫'; break;
                }
                
                if (powerup.active) {
                    icon.classList.add('active');
                }
                
                powerupHUD.appendChild(icon);
            }
        }

        function showBossHealth() {
            document.getElementById('boss-health').style.display = 'block';
            document.getElementById('boss-name').style.display = 'block';
        }

        function hideBossHealth() {
            document.getElementById('boss-health').style.display = 'none';
            document.getElementById('boss-name').style.display = 'none';
        }

        function updateBossHealth(current, max) {
            const percent = (current / max) * 100;
            document.getElementById('boss-health-bar').style.width = `${percent}%`;
        }

        function showNotification(text) {
            const notification = document.getElementById('notification');
            notification.textContent = text;
            notification.classList.add('show');
            
            if (gameState.notificationTimeout) {
                clearTimeout(gameState.notificationTimeout);
            }
            
            gameState.notificationTimeout = setTimeout(() => {
                notification.classList.remove('show');
            }, 2000);
        }

        // Game state functions
        function startGame() {
            initGame();
            gameState.screen = 'playing';
            gameState.isRunning = true;
            
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('pause-screen').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('instructions-screen').style.display = 'none';
            
            gameLoop();
        }

        function pauseGame() {
            gameState.screen = 'paused';
            gameState.isRunning = false;
            document.getElementById('pause-screen').style.display = 'flex';
        }

        function resumeGame() {
            gameState.screen = 'playing';
            gameState.isRunning = true;
            document.getElementById('pause-screen').style.display = 'none';
            gameLoop();
        }

        function gameOver() {
            gameState.screen = 'gameover';
            gameState.isRunning = false;
            
            document.getElementById('final-score').textContent = gameState.score;
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        function showInstructions() {
            gameState.screen = 'instructions';
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('instructions-screen').style.display = 'flex';
        }

        function showMenu() {
            gameState.screen = 'start';
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('instructions-screen').style.display = 'none';
            document.getElementById('start-screen').style.display = 'flex';
        }

        // Game loop
        function gameLoop() {
            if (!gameState.isRunning) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            drawStarfield();
            
            // Update game state
            updatePlayer();
            updateEnemies();
            updateAsteroids();
            updateLasers();
            updatePowerups();
            updateParticles();
            updateExplosions();
            updateLevel();
            
            // Draw game objects
            drawAsteroids();
            drawEnemies();
            drawPowerups();
            drawLasers();
            drawParticles();
            drawExplosions();
            drawPlayer();
            drawShield();
            
            // Continue game loop
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.code] = true;
            
            // Space to shoot
            if (e.code === 'Space' && gameState.screen === 'playing') {
                spawnPlayerLaser();
                e.preventDefault();
            }
            
            // P to pause
            if (e.code === 'KeyP' && gameState.screen === 'playing') {
                pauseGame();
            }
            
            // Escape to pause
            if (e.code === 'Escape' && gameState.screen === 'playing') {
                pauseGame();
            }
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.code] = false;
        });

        // Button event listeners
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('instructions-btn').addEventListener('click', showInstructions);
        document.getElementById('resume-btn').addEventListener('click', resumeGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);
        document.getElementById('play-again-btn').addEventListener('click', startGame);
        document.getElementById('menu-btn').addEventListener('click', showMenu);
        document.getElementById('back-btn').addEventListener('click', showMenu);

        // Initialize game on load
        window.addEventListener('load', () => {
            initGame();
            drawStarfield();
            drawPlayer();
        });
    </script>
</body>
</html>