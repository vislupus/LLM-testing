<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Tetris</title>
    <style>
        :root {
            --bg-color: #202028;
            --ui-bg: #333;
            --text-color: #fff;
            --accent-color: #00d2ff;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        h1 { margin: 0 0 20px 0; font-weight: 300; letter-spacing: 2px; color: var(--accent-color); text-shadow: 0 0 10px var(--accent-color); }

        #game-container {
            position: relative;
            display: flex;
            gap: 20px;
            border: 4px solid #000;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            background: #000;
        }

        canvas {
            display: block;
            background-color: #111;
        }

        /* Sidebar UI */
        .sidebar {
            width: 120px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .stat-box {
            background: var(--ui-bg);
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }

        .stat-label {
            font-size: 10px;
            text-transform: uppercase;
            color: #888;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
        }

        #next-piece-canvas {
            background: #111;
            margin: 0 auto;
        }

        /* Overlay for Game Over / Pause */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        #overlay.hidden { display: none; }

        #overlay h2 { font-size: 40px; margin: 0 0 20px 0; color: #ff0055; }
        
        button {
            background: var(--accent-color);
            border: none;
            padding: 10px 25px;
            color: #000;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 2px;
            text-transform: uppercase;
        }
        
        button:hover { filter: brightness(1.2); }

        .controls-hint {
            margin-top: 20px;
            font-size: 12px;
            color: #666;
            text-align: center;
        }
    </style>
</head>
<body>

    <h1>TETRIS</h1>

    <div id="game-container">
        <!-- Main Game Canvas -->
        <canvas id="tetris" width="240" height="400"></canvas>

        <!-- UI Sidebar -->
        <div class="sidebar">
            <div class="stat-box">
                <div class="stat-label">Next</div>
                <canvas id="next-piece-canvas" width="80" height="80"></canvas>
            </div>
            <div class="stat-box">
                <div class="stat-label">Score</div>
                <div id="score" class="stat-value">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Level</div>
                <div id="level" class="stat-value">1</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Lines</div>
                <div id="lines" class="stat-value">0</div>
            </div>
        </div>

        <!-- Game Over / Start Overlay -->
        <div id="overlay">
            <h2 id="overlay-title">PAUSED</h2>
            <button id="btn-start">Start Game</button>
        </div>
    </div>

    <div class="controls-hint">
        Arrows to Move &bull; Up to Rotate &bull; Space to Drop &bull; P to Pause
    </div>

<script>
/**
 * Tetris Game Logic
 * Features: 7 Tetrominoes, SRS Rotation, Scoring, Ghost Piece, Collision Detection
 */

const canvas = document.getElementById('tetris');
const context = canvas.getContext('2d');
const nextCanvas = document.getElementById('next-piece-canvas');
const nextContext = nextCanvas.getContext('2d');

// Scale context for 20px blocks
context.scale(20, 20);
nextContext.scale(20, 20);

// Audio Context for simple beeps (Optional, keeping silent as per "simple graphics" request, but logic exists if needed)

// --- Game State ---
const arena = createMatrix(12, 20); // 12 width (10 visible + 2 for walls logic if needed, usually 10 is enough)

const player = {
    pos: {x: 0, y: 0},
    matrix: null,
    score: 0,
    level: 1,
    lines: 0,
};

let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;
let isPaused = true;
let isGameOver = false;

let nextPieceMatrix = null;

// --- Tetromino Definitions ---
const PIECES = 'ILJOTSZ';
const COLORS = [
    null,
    '#FF0D72', // T (Magenta)
    '#0DC2FF', // I (Cyan)
    '#0DFF72', // S (Green)
    '#F538FF', // Z (Purple)
    '#FF8E0D', // L (Orange)
    '#FFE138', // O (Yellow)
    '#3877FF', // J (Blue)
];

// --- Helper Functions ---

function createMatrix(w, h) {
    const matrix = [];
    while (h--) {
        matrix.push(new Array(w).fill(0));
    }
    return matrix;
}

function createPiece(type) {
    if (type === 'I') {
        return [
            [0, 1, 0, 0],
            [0, 1, 0, 0],
            [0, 1, 0, 0],
            [0, 1, 0, 0],
        ];
    } else if (type === 'L') {
        return [
            [0, 2, 0],
            [0, 2, 0],
            [0, 2, 2],
        ];
    } else if (type === 'J') {
        return [
            [0, 3, 0],
            [0, 3, 0],
            [3, 3, 0],
        ];
    } else if (type === 'O') {
        return [
            [4, 4],
            [4, 4],
        ];
    } else if (type === 'Z') {
        return [
            [5, 5, 0],
            [0, 5, 5],
            [0, 0, 0],
        ];
    } else if (type === 'S') {
        return [
            [0, 6, 6],
            [6, 6, 0],
            [0, 0, 0],
        ];
    } else if (type === 'T') {
        return [
            [0, 7, 0],
            [7, 7, 7],
            [0, 0, 0],
        ];
    }
}

function drawMatrix(matrix, offset, ctx = context) {
    matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                // Procedural Block Drawing with Bevel
                drawBlock(ctx, x + offset.x, y + offset.y, COLORS[value]);
            }
        });
    });
}

// Draw a single block with a pseudo-3D look
function drawBlock(ctx, x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x, y, 1, 1);
    
    // Bevel effect (Highlight top-left, Shadow bottom-right)
    ctx.lineWidth = 0.05;
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.moveTo(x, y + 1);
    ctx.lineTo(x, y);
    ctx.lineTo(x + 1, y);
    ctx.stroke();
    
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath();
    ctx.moveTo(x + 1, y);
    ctx.lineTo(x + 1, y + 1);
    ctx.lineTo(x, y + 1);
    ctx.stroke();
}

// --- Logic: Collision & Merge ---

function collide(arena, player) {
    const [m, o] = [player.matrix, player.pos];
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0 &&
               (arena[y + o.y] &&
                arena[y + o.y][x + o.x]) !== 0) {
                return true;
            }
        }
    }
    return false;
}

function draw() {
    // Clear Board
    context.fillStyle = '#000';
    context.fillRect(0, 0, canvas.width, canvas.height);

    drawMatrix(arena, {x: 0, y: 0});
    
    // Draw Ghost Piece (Visual Aid)
    const ghostPos = {...player.pos};
    while(!collide(arena, {matrix: player.matrix, pos: ghostPos})) {
        ghostPos.y++;
    }
    ghostPos.y--; // Step back one
    
    // Draw ghost (transparent)
    context.globalAlpha = 0.2;
    drawMatrix(player.matrix, ghostPos);
    context.globalAlpha = 1;

    drawMatrix(player.matrix, player.pos);
    
    // Draw Next Piece in Sidebar
    nextContext.fillStyle = '#111';
    nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
    if (nextPieceMatrix) {
        // Center the piece in the 4x4 box
        const offsetX = (4 - nextPieceMatrix[0].length) / 2;
        const offsetY = (4 - nextPieceMatrix.length) / 2;
        drawMatrix(nextPieceMatrix, {x: offsetX, y: offsetY}, nextContext);
    }
}

function merge(arena, player) {
    player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                arena[y + player.pos.y][x + player.pos.x] = value;
            }
        });
    });
}

function rotate(matrix, dir) {
    for (let y = 0; y < matrix.length; ++y) {
        for (let x = 0; x < y; ++x) {
            [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
    }
    if (dir > 0) {
        matrix.forEach(row => row.reverse());
    } else {
        matrix.reverse();
    }
}

function playerDrop() {
    player.pos.y++;
    if (collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        playerReset();
        arenaSweep();
        updateScore();
    }
    dropCounter = 0;
}

function playerMove(offset) {
    player.pos.x += offset;
    if (collide(arena, player)) {
        player.pos.x -= offset;
    }
}

function playerRotate(dir) {
    const pos = player.pos.x;
    let offset = 1;
    rotate(player.matrix, dir);
    // Wall kick (Basic: Try to move left/right if rotation hits wall)
    while (collide(arena, player)) {
        player.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > player.matrix[0].length) {
            rotate(player.matrix, -dir);
            player.pos.x = pos;
            return;
        }
    }
}

function playerReset() {
    if (nextPieceMatrix === null) nextPieceMatrix = createPiece(PIECES[PIECES.length * Math.random() | 0]);
    
    player.matrix = nextPieceMatrix;
    nextPieceMatrix = createPiece(PIECES[PIECES.length * Math.random() | 0]);
    
    player.pos.y = 0;
    player.pos.x = (arena[0].length / 2 | 0) -
                   (player.matrix[0].length / 2 | 0);
    
    if (collide(arena, player)) {
        gameOver();
    }
}

function arenaSweep() {
    let rowCount = 0;
    outer: for (let y = arena.length -1; y > 0; --y) {
        for (let x = 0; x < arena[y].length; ++x) {
            if (arena[y][x] === 0) {
                continue outer;
            }
        }
        const row = arena.splice(y, 1)[0].fill(0);
        arena.unshift(row);
        ++y;
        rowCount++;
    }
    
    if (rowCount > 0) {
        // Scoring: 1=40, 2=100, 3=300, 4=1200 * (level + 1)
        const lineScores = [0, 40, 100, 300, 1200];
        player.score += lineScores[rowCount] * (player.level + 1);
        player.lines += rowCount;
        
        // Speed up every 10 lines
        player.level = Math.floor(player.lines / 10) + 1;
        dropInterval = Math.max(100, 1000 - (player.level - 1) * 100);
    }
}

function updateScore() {
    document.getElementById('score').innerText = player.score;
    document.getElementById('level').innerText = player.level;
    document.getElementById('lines').innerText = player.lines;
}

function gameOver() {
    isGameOver = true;
    isPaused = true;
    document.getElementById('overlay-title').innerText = "GAME OVER";
    document.getElementById('btn-start').innerText = "Try Again";
    document.getElementById('overlay').classList.remove('hidden');
}

function startGame() {
    arena.forEach(row => row.fill(0));
    player.score = 0;
    player.level = 1;
    player.lines = 0;
    dropInterval = 1000;
    nextPieceMatrix = null;
    isGameOver = false;
    isPaused = false;
    
    updateScore();
    playerReset();
    document.getElementById('overlay').classList.add('hidden');
    update();
}

function togglePause() {
    if (isGameOver) return;
    isPaused = !isPaused;
    if (isPaused) {
        document.getElementById('overlay-title').innerText = "PAUSED";
        document.getElementById('btn-start').innerText = "Resume";
        document.getElementById('overlay').classList.remove('hidden');
    } else {
        document.getElementById('overlay').classList.add('hidden');
        lastTime = 0; // reset time delta so we don't jump
        update();
    }
}

// --- Game Loop ---

function update(time = 0) {
    if (isPaused) return;

    const deltaTime = time - lastTime;
    lastTime = time;

    dropCounter += deltaTime;
    if (dropCounter > dropInterval) {
        playerDrop();
    }

    draw();
    requestAnimationFrame(update);
}

// --- Event Listeners ---

document.addEventListener('keydown', event => {
    if (isPaused && event.keyCode !== 80) return; // Only allow Pause key if paused

    if (event.keyCode === 37) { // Left
        playerMove(-1);
    } else if (event.keyCode === 39) { // Right
        playerMove(1);
    } else if (event.keyCode === 40) { // Down
        playerDrop();
    } else if (event.keyCode === 81) { // Q (Rotate Left - optional)
        playerRotate(-1);
    } else if (event.keyCode === 38 || event.keyCode === 87) { // Up or W
        playerRotate(1);
    } else if (event.keyCode === 32) { // Space (Hard Drop)
        while(!collide(arena, player)) {
            player.pos.y++;
        }
        player.pos.y--;
        merge(arena, player);
        playerReset();
        arenaSweep();
        updateScore();
        dropCounter = 0;
    } else if (event.keyCode === 80) { // P
        togglePause();
    }
    
    // Prevent scrolling
    if ([32, 37, 38, 39, 40].indexOf(event.keyCode) > -1) {
        event.preventDefault();
    }
});

document.getElementById('btn-start').addEventListener('click', () => {
    if (isPaused && !isGameOver) {
        togglePause();
    } else {
        startGame();
    }
});

// Initial Draw
playerReset();
draw();

</script>
</body>
</html>