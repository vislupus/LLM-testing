<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Single-File Tetris</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:rgba(255,255,255,.07);
      --stroke:rgba(255,255,255,.14);
      --ink:#eef4ff;
      --muted:rgba(238,244,255,.72);
      --good:#35d39f;
      --warn:#ffd166;
      --bad:#ff6b87;
    }
    html,body{height:100%;margin:0;background:radial-gradient(1200px 700px at 50% 35%, rgba(103,179,255,.12), rgba(11,16,32,1));overflow:hidden;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    #wrap{position:fixed;inset:0;display:grid;place-items:center}
    canvas{display:block; width:min(92vw, 980px); height:auto; aspect-ratio: 16/9; border-radius:18px;
      background:rgba(0,0,0,.22); border:1px solid var(--stroke); box-shadow:0 18px 70px rgba(0,0,0,.55)}
    .overlay{
      position:fixed; inset:0; display:none; align-items:center; justify-content:center;
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
    }
    .card{
      width:min(720px, 92vw);
      border-radius:20px; border:1px solid rgba(255,255,255,.18);
      background:rgba(9,13,28,.78); box-shadow:0 20px 80px rgba(0,0,0,.6);
      padding:18px 18px 14px 18px;
      color:var(--ink);
    }
    h1{margin:0;font-size:28px;letter-spacing:.2px}
    p{margin:10px 0; color:var(--muted); line-height:1.35; font-weight:650}
    .row{display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap}
    .btns{display:flex; gap:10px; flex-wrap:wrap}
    button{
      border:1px solid rgba(255,255,255,.20);
      background:rgba(255,255,255,.10);
      color:var(--ink); font-weight:900;
      padding:10px 14px; border-radius:14px; cursor:pointer;
    }
    button:hover{background:rgba(255,255,255,.14)}
    .primary{background:rgba(103,179,255,.22); border-color:rgba(103,179,255,.35)}
    .primary:hover{background:rgba(103,179,255,.28)}
    .kbd{
      display:inline-block; padding:2px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.08);
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-weight:900;
      color:rgba(238,244,255,.86);
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="c" width="960" height="540"></canvas>
  </div>

  <div class="overlay" id="overlay">
    <div class="card">
      <div class="row">
        <h1 id="ovTitle">Tetris</h1>
        <div class="btns">
          <button id="btnHow">How to play</button>
          <button class="primary" id="btnStart">Start</button>
        </div>
      </div>
      <p id="ovText">
        Clean, simple Tetris in one HTML file. No external assets.
      </p>
      <p id="how" style="display:none">
        <b>Move:</b> <span class="kbd">←</span> <span class="kbd">→</span> &nbsp;
        <b>Soft drop:</b> <span class="kbd">↓</span> &nbsp;
        <b>Hard drop:</b> <span class="kbd">Space</span><br/>
        <b>Rotate:</b> <span class="kbd">↑</span> / <span class="kbd">X</span> (CW) &nbsp;
        <span class="kbd">Z</span> (CCW) &nbsp;
        <b>Hold:</b> <span class="kbd">C</span><br/>
        <b>Pause:</b> <span class="kbd">P</span> &nbsp;
        <b>Restart:</b> <span class="kbd">R</span>
      </p>
      <p style="margin:10px 0 0 0" id="ovSub" class="muted"></p>
    </div>
  </div>

<script>
(() => {
  // ============================================================
  // Single-file Tetris (procedural graphics, smooth animations)
  // Board: 10×20 (with hidden 2-row spawn buffer)
  // Rotation: SRS-ish wall kicks (simplified, good feel)
  // Scoring: classic-ish + combo + soft/hard drop
  // Speed: level increases with lines
  // Hold piece, next queue, pause, restart, game over overlay
  // ============================================================

  // ---------- Canvas / UI ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ovTitle');
  const ovText  = document.getElementById('ovText');
  const ovSub   = document.getElementById('ovSub');
  const btnStart = document.getElementById('btnStart');
  const btnHow = document.getElementById('btnHow');
  const how = document.getElementById('how');
  btnHow.addEventListener('click', () => how.style.display = (how.style.display==='none'?'block':'none'));

  // ---------- Game constants ----------
  const COLS = 10;
  const ROWS = 20;
  const HIDDEN = 2;          // spawn buffer rows (not visible)
  const GRID_ROWS = ROWS + HIDDEN;

  // Layout in 960×540
  const W = canvas.width, H = canvas.height;

  const PANEL_PAD = 18;
  const PLAY_W = 360;                 // playfield width area
  const CELL = Math.floor(PLAY_W / COLS); // cell size in px
  const FIELD_W = CELL * COLS;
  const FIELD_H = CELL * ROWS;

  const FIELD_X = 210;
  const FIELD_Y = 84;

  const SIDE_X = FIELD_X + FIELD_W + 28;
  const SIDE_Y = FIELD_Y;

  const FONT = 'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';

  const C = {
    bg0: '#0b1020',
    panel: 'rgba(255,255,255,.07)',
    stroke: 'rgba(255,255,255,.14)',
    ink: '#eef4ff',
    muted: 'rgba(238,244,255,.70)',
    accent: '#67b3ff',
    good: '#35d39f',
    warn: '#ffd166',
    bad: '#ff6b87',
    grid: 'rgba(255,255,255,.09)',
  };

  // Tetromino colors (procedural shading will add depth)
  const COLORS = {
    I: '#4ddcff',
    O: '#ffd166',
    T: '#b084ff',
    S: '#35d39f',
    Z: '#ff6b87',
    J: '#67b3ff',
    L: '#ff9f4d',
    G: 'rgba(0,0,0,0)' // ghost (drawn separately)
  };

  // 7-bag randomizer
  const BAG = ['I','O','T','S','Z','J','L'];

  // Shapes defined as 4×4 matrices per rotation (0..3)
  // We'll store base rotation 0 and rotate on the fly (or precompute).
  const SHAPES = {
    I: [
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0]
    ],
    O: [
      [0,1,1,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0]
    ],
    T: [
      [0,1,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0]
    ],
    S: [
      [0,1,1,0],
      [1,1,0,0],
      [0,0,0,0],
      [0,0,0,0]
    ],
    Z: [
      [1,1,0,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0]
    ],
    J: [
      [1,0,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0]
    ],
    L: [
      [0,0,1,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0]
    ],
  };

  function rotateMatrixCW(m){
    const n = m.length;
    const out = Array.from({length:n}, ()=>Array(n).fill(0));
    for (let y=0;y<n;y++) for (let x=0;x<n;x++) out[x][n-1-y] = m[y][x];
    return out;
  }
  function rotateMatrixCCW(m){
    const n = m.length;
    const out = Array.from({length:n}, ()=>Array(n).fill(0));
    for (let y=0;y<n;y++) for (let x=0;x<n;x++) out[n-1-x][y] = m[y][x];
    return out;
  }

  // Precompute rotations 0..3 for each piece
  const ROT = {};
  for (const k of Object.keys(SHAPES)){
    ROT[k] = [];
    ROT[k][0] = SHAPES[k].map(r=>r.slice());
    ROT[k][1] = rotateMatrixCW(ROT[k][0]);
    ROT[k][2] = rotateMatrixCW(ROT[k][1]);
    ROT[k][3] = rotateMatrixCW(ROT[k][2]);
  }

  // Simplified SRS-ish kicks
  // For most pieces: try a small list of offsets.
  // For I piece: slightly different feel; use a bigger set.
  const KICKS_NORMAL = [
    [0,0],[1,0],[-1,0],[0,-1],[2,0],[-2,0],[1,-1],[-1,-1],[0,-2]
  ];
  const KICKS_I = [
    [0,0],[2,0],[-2,0],[1,0],[-1,0],[0,-1],[0,-2],[3,0],[-3,0],[1,-1],[-1,-1]
  ];

  // ---------- Game state ----------
  let grid = [];
  let bag = [];
  let nextQueue = [];
  let cur = null; // {type, x,y, r}
  let hold = null;
  let canHold = true;

  let score = 0;
  let lines = 0;
  let level = 1;
  let combo = -1;

  let paused = false;
  let gameOver = false;

  // fall timing
  let dropTimer = 0;
  let softDropping = false;

  // animation
  let last = 0;

  // input handling (repeat)
  const keys = new Set();
  const pressed = new Set();
  window.addEventListener('keydown', (e)=>{
    const k = e.key;
    if (['ArrowLeft','ArrowRight','ArrowDown','ArrowUp',' ','p','P','r','R'].includes(k)) e.preventDefault();
    if (!keys.has(k)) pressed.add(k);
    keys.add(k);
  });
  window.addEventListener('keyup', (e)=> keys.delete(e.key));

  function consumePress(k){
    if (pressed.has(k)){ pressed.delete(k); return true; }
    return false;
  }

  // ---------- Helpers ----------
  function newGrid(){
    grid = Array.from({length:GRID_ROWS}, ()=>Array(COLS).fill(null));
  }

  function refillBag(){
    bag = BAG.slice();
    // shuffle
    for (let i=bag.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [bag[i], bag[j]] = [bag[j], bag[i]];
    }
  }

  function popFromBag(){
    if (bag.length===0) refillBag();
    return bag.pop();
  }

  function ensureQueue(n=5){
    while (nextQueue.length < n) nextQueue.push(popFromBag());
  }

  function spawnPiece(type = nextQueue.shift()){
    ensureQueue(5);
    cur = { type, r: 0, x: 3, y: 0 }; // y includes hidden area
    // Adjust spawn for I and O for nicer centering
    if (type === 'I') cur.x = 3, cur.y = 0;
    if (type === 'O') cur.x = 4, cur.y = 0;

    canHold = true;
    if (collides(cur.x, cur.y, cur.r, cur.type)){
      // immediate top-out
      setGameOver();
    }
  }

  function collides(px, py, pr, type){
    const m = ROT[type][pr];
    for (let y=0;y<4;y++){
      for (let x=0;x<4;x++){
        if (!m[y][x]) continue;
        const gx = px + x;
        const gy = py + y;
        if (gx < 0 || gx >= COLS) return true;
        if (gy >= GRID_ROWS) return true;
        if (gy >= 0 && grid[gy][gx]) return true;
      }
    }
    return false;
  }

  function lockPiece(){
    const m = ROT[cur.type][cur.r];
    for (let y=0;y<4;y++){
      for (let x=0;x<4;x++){
        if (!m[y][x]) continue;
        const gx = cur.x + x;
        const gy = cur.y + y;
        if (gy >= 0 && gy < GRID_ROWS && gx >= 0 && gx < COLS){
          grid[gy][gx] = cur.type;
        }
      }
    }
    clearLinesAndScore();
    spawnPiece();
  }

  function tryMove(dx, dy){
    if (!cur) return false;
    const nx = cur.x + dx, ny = cur.y + dy;
    if (!collides(nx, ny, cur.r, cur.type)){
      cur.x = nx; cur.y = ny;
      return true;
    }
    return false;
  }

  function tryRotate(dir){ // dir: +1 cw, -1 ccw
    if (!cur) return false;
    const nr = (cur.r + (dir===1 ? 1 : 3)) & 3;
    const kicks = (cur.type === 'I') ? KICKS_I : KICKS_NORMAL;
    for (const [kx,ky] of kicks){
      const nx = cur.x + kx;
      const ny = cur.y + ky;
      if (!collides(nx, ny, nr, cur.type)){
        cur.x = nx; cur.y = ny; cur.r = nr;
        return true;
      }
    }
    return false;
  }

  function hardDrop(){
    if (!cur) return;
    let dist = 0;
    while (tryMove(0,1)) dist++;
    // scoring for hard drop
    score += dist * 2;
    lockPiece();
  }

  function holdPiece(){
    if (!cur || !canHold) return;
    canHold = false;
    const t = cur.type;
    if (hold == null){
      hold = t;
      spawnPiece();
    } else {
      cur = { type: hold, r: 0, x: 3, y: 0 };
      if (cur.type === 'I') cur.x = 3;
      if (cur.type === 'O') cur.x = 4;
      hold = t;
      if (collides(cur.x, cur.y, cur.r, cur.type)) setGameOver();
    }
  }

  function clearLinesAndScore(){
    let cleared = 0;
    for (let y=0;y<GRID_ROWS;y++){
      let full = true;
      for (let x=0;x<COLS;x++){
        if (!grid[y][x]) { full = false; break; }
      }
      if (full){
        grid.splice(y,1);
        grid.unshift(Array(COLS).fill(null));
        cleared++;
        y--;
      }
    }

    if (cleared > 0){
      combo++;
      // classic-ish scoring: 1=100, 2=300, 3=500, 4=800 * level
      const base = [0, 100, 300, 500, 800][cleared] || 0;
      const comboBonus = Math.max(0, combo) * 50;
      score += (base * level) + (comboBonus * level);
      lines += cleared;
      level = 1 + Math.floor(lines / 10);
    } else {
      combo = -1;
    }
  }

  function fallInterval(){
    // faster with levels, but keep a reasonable floor
    // level 1 ~ 0.90s, level 10 ~ 0.22s
    const t = 0.95 * Math.pow(0.82, (level-1));
    return clamp(t, 0.06, 0.95);
  }

  function ghostY(){
    let y = cur.y;
    while (!collides(cur.x, y+1, cur.r, cur.type)) y++;
    return y;
  }

  function setGameOver(){
    gameOver = true;
    paused = false;
    ovTitle.textContent = 'Game Over';
    ovText.textContent = `Score: ${score} • Lines: ${lines} • Level: ${level}`;
    ovSub.textContent = 'Press Start to play again.';
    btnStart.textContent = 'Restart';
    overlay.style.display = 'flex';
  }

  function startGame(){
    newGrid();
    bag = [];
    nextQueue = [];
    refillBag();
    ensureQueue(5);
    hold = null;
    canHold = true;

    score = 0;
    lines = 0;
    level = 1;
    combo = -1;

    paused = false;
    gameOver = false;
    dropTimer = 0;

    spawnPiece(nextQueue.shift());
    overlay.style.display = 'none';
  }

  btnStart.addEventListener('click', startGame);

  // ---------- Drawing ----------
  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function drawPanel(x,y,w,h){
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,.06)';
    ctx.strokeStyle = 'rgba(255,255,255,.14)';
    ctx.lineWidth = 1;
    roundRect(x,y,w,h,16);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function shadeColor(hex, amt){
    // hex #rrggbb -> adjust
    const c = hex.replace('#','');
    const r = clamp(parseInt(c.slice(0,2),16)+amt, 0, 255);
    const g = clamp(parseInt(c.slice(2,4),16)+amt, 0, 255);
    const b = clamp(parseInt(c.slice(4,6),16)+amt, 0, 255);
    return `rgb(${r|0},${g|0},${b|0})`;
  }

  function drawBlock(px, py, color, alpha=1){
    // px,py are cell coords in visible field (0..COLS-1, 0..ROWS-1)
    const x = FIELD_X + px*CELL;
    const y = FIELD_Y + py*CELL;

    ctx.save();
    ctx.globalAlpha = alpha;

    // base tile
    ctx.fillStyle = color;
    roundRect(x+1, y+1, CELL-2, CELL-2, 6);
    ctx.fill();

    // highlight / bevel
    ctx.strokeStyle = 'rgba(255,255,255,.22)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x+4, y+CELL-6);
    ctx.lineTo(x+4, y+6);
    ctx.lineTo(x+CELL-6, y+6);
    ctx.stroke();

    ctx.strokeStyle = 'rgba(0,0,0,.25)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x+CELL-5, y+5);
    ctx.lineTo(x+CELL-5, y+CELL-5);
    ctx.lineTo(x+5, y+CELL-5);
    ctx.stroke();

    // inner gloss
    const g = ctx.createLinearGradient(x, y, x, y+CELL);
    g.addColorStop(0, 'rgba(255,255,255,.18)');
    g.addColorStop(0.55, 'rgba(255,255,255,.04)');
    g.addColorStop(1, 'rgba(0,0,0,.10)');
    ctx.fillStyle = g;
    roundRect(x+3, y+3, CELL-6, CELL-6, 5);
    ctx.fill();

    ctx.restore();
  }

  function drawGhostPiece(){
    if (!cur) return;
    const gy = ghostY();
    const m = ROT[cur.type][cur.r];
    ctx.save();
    ctx.globalAlpha = 0.25;
    for (let y=0;y<4;y++){
      for (let x=0;x<4;x++){
        if (!m[y][x]) continue;
        const vx = cur.x + x;
        const vy = gy + y - HIDDEN;
        if (vy >= 0 && vy < ROWS && vx >= 0 && vx < COLS){
          const base = COLORS[cur.type];
          // draw outline ghost
          const px = FIELD_X + vx*CELL;
          const py = FIELD_Y + vy*CELL;
          ctx.strokeStyle = 'rgba(255,255,255,.55)';
          ctx.lineWidth = 2;
          roundRect(px+4, py+4, CELL-8, CELL-8, 6);
          ctx.stroke();
          // subtle fill tint
          ctx.fillStyle = base;
          ctx.globalAlpha = 0.08;
          roundRect(px+4, py+4, CELL-8, CELL-8, 6);
          ctx.fill();
          ctx.globalAlpha = 0.25;
        }
      }
    }
    ctx.restore();
  }

  function drawPiece(piece, ox, oy, cellSize, alpha=1){
    // piece shown in side boxes: render from rotation 0 centered
    const m = ROT[piece][0];
    // compute bounds
    let minX=4, minY=4, maxX=-1, maxY=-1;
    for (let y=0;y<4;y++) for (let x=0;x<4;x++){
      if (!m[y][x]) continue;
      minX = Math.min(minX,x); minY = Math.min(minY,y);
      maxX = Math.max(maxX,x); maxY = Math.max(maxY,y);
    }
    const bw = (maxX-minX+1);
    const bh = (maxY-minY+1);

    const startX = ox + (4*cellSize - bw*cellSize)/2;
    const startY = oy + (4*cellSize - bh*cellSize)/2;

    for (let y=0;y<4;y++){
      for (let x=0;x<4;x++){
        if (!m[y][x]) continue;
        const px = startX + (x-minX)*cellSize;
        const py = startY + (y-minY)*cellSize;

        // mini-block
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = COLORS[piece];
        roundRect(px+1, py+1, cellSize-2, cellSize-2, 5);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,.20)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(px+3, py+cellSize-5);
        ctx.lineTo(px+3, py+5);
        ctx.lineTo(px+cellSize-5, py+5);
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  function drawBackground(){
    ctx.save();
    // base
    ctx.fillStyle = '#0b1020';
    ctx.fillRect(0,0,W,H);

    // soft glow
    const g = ctx.createRadialGradient(W*0.5,H*0.25, 10, W*0.5,H*0.25, 620);
    g.addColorStop(0, 'rgba(103,179,255,.14)');
    g.addColorStop(0.35, 'rgba(176,132,255,.10)');
    g.addColorStop(1, 'rgba(11,16,32,1)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // subtle stars
    ctx.globalAlpha = 0.55;
    for (let i=0;i<60;i++){
      const x = (i*173.7 + (performance.now()/1000)*28) % W;
      const y = (i*91.3  + (performance.now()/1000)*18) % H;
      ctx.fillStyle = 'rgba(255,255,255,.65)';
      ctx.fillRect(x, y, 1.4, 6);
    }
    ctx.restore();
  }

  function drawField(){
    // outer panel
    drawPanel(FIELD_X-18, FIELD_Y-18, FIELD_W+36, FIELD_H+36);

    // grid background
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,.18)';
    roundRect(FIELD_X, FIELD_Y, FIELD_W, FIELD_H, 14);
    ctx.fill();

    // grid lines
    ctx.strokeStyle = C.grid;
    ctx.lineWidth = 1;
    for (let x=0;x<=COLS;x++){
      const px = FIELD_X + x*CELL;
      ctx.beginPath(); ctx.moveTo(px, FIELD_Y); ctx.lineTo(px, FIELD_Y+FIELD_H); ctx.stroke();
    }
    for (let y=0;y<=ROWS;y++){
      const py = FIELD_Y + y*CELL;
      ctx.beginPath(); ctx.moveTo(FIELD_X, py); ctx.lineTo(FIELD_X+FIELD_W, py); ctx.stroke();
    }
    // thicker every 5
    ctx.strokeStyle = 'rgba(255,255,255,.10)';
    ctx.lineWidth = 2;
    for (let y=0;y<=ROWS;y+=5){
      const py = FIELD_Y + y*CELL;
      ctx.beginPath(); ctx.moveTo(FIELD_X, py); ctx.lineTo(FIELD_X+FIELD_W, py); ctx.stroke();
    }
    ctx.restore();

    // locked blocks
    for (let gy=HIDDEN; gy<GRID_ROWS; gy++){
      for (let x=0;x<COLS;x++){
        const t = grid[gy][x];
        if (!t) continue;
        const vy = gy - HIDDEN;
        drawBlock(x, vy, COLORS[t], 1);
      }
    }

    // ghost
    if (cur && !gameOver) drawGhostPiece();

    // current piece
    if (cur){
      const m = ROT[cur.type][cur.r];
      for (let y=0;y<4;y++){
        for (let x=0;x<4;x++){
          if (!m[y][x]) continue;
          const gx = cur.x + x;
          const gy = cur.y + y;
          const vy = gy - HIDDEN;
          if (vy >= 0 && vy < ROWS && gx >= 0 && gx < COLS){
            drawBlock(gx, vy, COLORS[cur.type], (cur.invuln ? 0.7 : 1));
          }
        }
      }
    }
  }

  function drawSidebar(){
    // panels
    drawPanel(SIDE_X, SIDE_Y, 240, 372);
    drawPanel(SIDE_X, SIDE_Y+390, 240, 150);

    // text
    ctx.save();
    ctx.fillStyle = C.ink;
    ctx.font = `900 18px ${FONT}`;
    ctx.fillText('NEXT', SIDE_X+18, SIDE_Y+34);

    ctx.font = `900 18px ${FONT}`;
    ctx.fillText('HOLD', SIDE_X+18, SIDE_Y+424);

    // next pieces box
    const boxX = SIDE_X+18, boxY = SIDE_Y+48;
    const boxW = 204, boxH = 306;
    ctx.fillStyle = 'rgba(0,0,0,.18)';
    roundRect(boxX, boxY, boxW, boxH, 14);
    ctx.fill();

    // hold box
    const hX = SIDE_X+18, hY = SIDE_Y+440, hW = 204, hH = 84;
    ctx.fillStyle = 'rgba(0,0,0,.18)';
    roundRect(hX, hY, hW, hH, 14);
    ctx.fill();

    // draw next queue (top 5)
    const mini = 18;
    for (let i=0;i<5;i++){
      const t = nextQueue[i];
      if (!t) continue;
      drawPiece(t, boxX+10, boxY+10+i*56, mini, 1);
    }

    // hold piece
    if (hold){
      drawPiece(hold, hX+10, hY+8, 18, canHold ? 1 : 0.65);
    } else {
      ctx.fillStyle = C.muted;
      ctx.font = `800 12px ${FONT}`;
      ctx.fillText('Press C to hold', hX+16, hY+50);
    }

    // score panel
    const infoX = 28, infoY = 84;
    drawPanel(infoX, infoY, 160, 246);
    ctx.fillStyle = C.ink;
    ctx.font = `1000 22px ${FONT}`;
    ctx.fillText('TETRIS', infoX+18, infoY+40);

    ctx.font = `900 14px ${FONT}`;
    ctx.fillStyle = C.muted;
    ctx.fillText('Score', infoX+18, infoY+78);
    ctx.fillStyle = C.ink;
    ctx.font = `1000 22px ${FONT}`;
    considered = score.toString().padStart(1,'0');
    ctx.fillText(String(score), infoX+18, infoY+104);

    ctx.font = `900 14px ${FONT}`;
    ctx.fillStyle = C.muted;
    ctx.fillText('Lines', infoX+18, infoY+138);
    ctx.fillStyle = C.ink;
    ctx.font = `1000 20px ${FONT}`;
    ctx.fillText(String(lines), infoX+18, infoY+162);

    ctx.font = `900 14px ${FONT}`;
    ctx.fillStyle = C.muted;
    ctx.fillText('Level', infoX+18, infoY+196);
    ctx.fillStyle = C.ink;
    ctx.font = `1000 20px ${FONT}`;
    ctx.fillText(String(level), infoX+18, infoY+220);

    // controls hints
    ctx.fillStyle = 'rgba(238,244,255,.55)';
    ctx.font = `800 12px ${FONT}`;
    ctx.fillText('← → move', infoX+18, infoY+264);
    ctx.fillText('↑/X rotate • Z ccw', infoX+18, infoY+282);
    ctx.fillText('↓ soft • Space hard', infoX+18, infoY+300);
    ctx.fillText('C hold • P pause • R restart', infoX+18, infoY+318);

    ctx.restore();
  }

  function drawPaused(){
    if (!paused) return;
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,.40)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = 'rgba(255,255,255,.92)';
    ctx.font = `1000 34px ${FONT}`;
    ctx.textAlign = 'center';
    ctx.fillText('Paused', W/2, H/2 - 10);
    ctx.font = `800 14px ${FONT}`;
    ctx.fillText('Press P to resume', W/2, H/2 + 20);
    ctx.restore();
  }

  // ---------- Update loop ----------
  function step(t){
    const now = t/1000;
    const dt = Math.min(0.05, (now - last) || 0.016);
    last = now;

    handleInput(dt);

    if (!paused && !gameOver){
      update(dt);
    }

    // draw
    drawBackground();
    drawSidebar();
    drawField();
    drawPaused();

    requestAnimationFrame(step);
  }

  function handleInput(dt){
    if (consumePress('p') || consumePress('P')){
      if (!gameOver && overlay.style.display !== 'flex') paused = !paused;
    }
    if (consumePress('r') || consumePress('R')){
      startGame();
    }

    if (gameOver) return;
    if (paused) return;
    if (!cur) return;

    // movement with simple DAS/ARR
    // We'll implement: initial delay then repeat for left/right/down.
    // We'll keep per-key timers.
    // (simple + smooth feel without being overly complex)
    // Stored on window for closure persistence:
    if (!handleInput.state){
      handleInput.state = {
        left: {t:0, rep:0}, right: {t:0, rep:0}, down: {t:0, rep:0}
      };
    }
    const st = handleInput.state;

    const DAS = 0.14; // delay before auto shift
    const ARR = 0.045; // repeat rate

    function keyRepeat(keyName, keySet, action){
      const k = st[keyName];
      if (keys.has(keySet[0]) || (keySet[1] && keys.has(keySet[1]))){
        k.t += dt;
        if (k.t === dt){ // just pressed
          action();
          k.rep = 0;
        } else if (k.t > DAS){
          k.rep += dt;
          while (k.rep > ARR){
            k.rep -= ARR;
            action();
          }
        }
      } else {
        k.t = 0; k.rep = 0;
      }
    }

    keyRepeat('left', ['ArrowLeft','a'], ()=>tryMove(-1,0));
    keyRepeat('right',['ArrowRight','d'], ()=>tryMove(1,0));

    softDropping = keys.has('ArrowDown') || keys.has('s');

    // single press actions
    if (consumePress('ArrowUp') || consumePress('x') || consumePress('X')) tryRotate(+1);
    if (consumePress('z') || consumePress('Z')) tryRotate(-1);
    if (consumePress('c') || consumePress('C')) holdPiece();
    if (consumePress(' ')) hardDrop();
  }

  function update(dt){
    // gravity
    dropTimer += dt;
    const interval = softDropping ? Math.max(0.03, fallInterval()*0.12) : fallInterval();

    // soft drop scoring (per cell)
    // We'll apply score when it actually moves down due to soft drop.
    while (dropTimer >= interval){
      dropTimer -= interval;
      if (tryMove(0,1)){
        if (softDropping) score += 1;
      } else {
        // lock delay (tiny) - keep it simple: lock immediately after failing to drop
        lockPiece();
        break;
      }
    }

    // UI overlay shouldn’t appear unless game over
  }

  // ---------- Initial overlay ----------
  function showStartOverlay(){
    ovTitle.textContent = 'Tetris';
    ovText.textContent = 'A complete Tetris game in one standalone HTML file. No external assets.';
    ovSub.textContent = 'Press Start (or R anytime) to play.';
    btnStart.textContent = 'Start';
    overlay.style.display = 'flex';
  }

  // ---------- Boot ----------
  showStartOverlay();
  requestAnimationFrame(step);

})();
</script>
</body>
</html>
