<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Babylon.js 3D Space Battle</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            background: #000;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            display: block;
        }
    </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

<script>
(function () {
    var canvas = document.getElementById("renderCanvas");
    var engine = new BABYLON.Engine(canvas, true, { stencil: true });

    var createScene = function () {
        var scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);

        // Camera
        var camera = new BABYLON.ArcRotateCamera(
            "camera",
            -Math.PI / 2,
            Math.PI / 3,
            180,
            BABYLON.Vector3.Zero(),
            scene
        );
        camera.attachControl(canvas, true);
        camera.lowerRadiusLimit = 60;
        camera.upperRadiusLimit = 260;
        camera.wheelPrecision = 50;
        camera.useAutoRotationBehavior = true;
        camera.autoRotationBehavior.idleRotationSpeed = 0.02;
        camera.autoRotationBehavior.idleRotationWaitTime = 2000;
        camera.autoRotationBehavior.idleRotationSpinUpTime = 2000;

        // Lights
        var hemiLight = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
        hemiLight.intensity = 0.6;

        var dirLight = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-0.5, -1, 0.5), scene);
        dirLight.position = new BABYLON.Vector3(100, 100, -100);
        dirLight.intensity = 0.7;

        // Glow for emissive parts/projectiles
        var glow = new BABYLON.GlowLayer("glow", scene);
        glow.intensity = 0.8;

        // Procedural starfield background
        var starMat = new BABYLON.StandardMaterial("starMat", scene);
        starMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
        starMat.disableLighting = true;

        var starCount = 350;
        for (var i = 0; i < starCount; i++) {
            var star = BABYLON.MeshBuilder.CreatePlane("star" + i, { size: 0.7 }, scene);
            star.material = starMat;
            star.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
            var r = 400 + Math.random() * 250;
            var theta = Math.random() * Math.PI * 2;
            var phi = Math.acos(2 * Math.random() - 1);
            var x = r * Math.sin(phi) * Math.cos(theta);
            var y = r * Math.cos(phi);
            var z = r * Math.sin(phi) * Math.sin(theta);
            star.position = new BABYLON.Vector3(x, y, z);
        }

        // GUI for health bars
        var guiTex = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

        var teamColors = [
            new BABYLON.Color3(0.4, 0.8, 1.0), // blue team
            new BABYLON.Color3(1.0, 0.4, 0.4)  // red team
        ];

        // Shared projectile materials and particle texture
        var projectileMatBlue = new BABYLON.StandardMaterial("projBlue", scene);
        projectileMatBlue.emissiveColor = new BABYLON.Color3(0.5, 0.9, 1.5);
        projectileMatBlue.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.2);
        projectileMatBlue.specularColor = new BABYLON.Color3(0, 0, 0);

        var projectileMatRed = new BABYLON.StandardMaterial("projRed", scene);
        projectileMatRed.emissiveColor = new BABYLON.Color3(1.5, 0.4, 0.4);
        projectileMatRed.diffuseColor = new BABYLON.Color3(0.2, 0.1, 0.1);
        projectileMatRed.specularColor = new BABYLON.Color3(0, 0, 0);

        var flareTex = new BABYLON.Texture("https://playground.babylonjs.com/textures/flare.png", scene);

        var ships = [];
        var fleets = [[], []];
        var shipIdCounter = 0;

        // Ship creation
        function createShip(isFlagship, team) {
            var hullLength = isFlagship ? 18 : 11;
            var hullWidth  = isFlagship ? 7  : 4.5;
            var hullHeight = isFlagship ? 3.2 : 2.2;

            var hull = BABYLON.MeshBuilder.CreateBox("shipHull" + shipIdCounter, {
                width: hullWidth,
                height: hullHeight,
                depth: hullLength
            }, scene);

            var hullMat = new BABYLON.StandardMaterial("shipMat" + shipIdCounter, scene);
            hullMat.diffuseColor = new BABYLON.Color3(0.35, 0.35, 0.38);
            hullMat.specularColor = new BABYLON.Color3(0.7, 0.7, 0.7);
            hullMat.emissiveColor = teamColors[team].scale(0.15);
            hull.material = hullMat;

            // Nose
            var nose = BABYLON.MeshBuilder.CreateCylinder("nose" + shipIdCounter, {
                diameterTop: 0,
                diameterBottom: isFlagship ? 3.2 : 2.2,
                height: isFlagship ? 6 : 4,
                tessellation: 6
            }, scene);
            nose.material = hullMat;
            nose.parent = hull;
            nose.rotation.x = Math.PI / 2;
            nose.position.z = hullLength / 2 + (isFlagship ? 3 : 2);

            // Wings
            var wingMat = new BABYLON.StandardMaterial("wingMat" + shipIdCounter, scene);
            wingMat.diffuseColor = new BABYLON.Color3(0.18, 0.18, 0.2);
            wingMat.emissiveColor = teamColors[team].scale(0.2);
            var wingSpan = hullWidth * 1.8;
            for (var s = -1; s <= 1; s += 2) {
                var wing = BABYLON.MeshBuilder.CreateBox("wing" + shipIdCounter + "_" + s, {
                    width: wingSpan,
                    height: 0.4,
                    depth: isFlagship ? hullLength * 0.7 : hullLength * 0.6
                }, scene);
                wing.material = wingMat;
                wing.parent = hull;
                wing.position = new BABYLON.Vector3(0, -hullHeight * 0.4, 0);
                wing.rotation.z = s * 0.25;
            }

            // Top fin / bridge
            var fin = BABYLON.MeshBuilder.CreateBox("fin" + shipIdCounter, {
                width: hullWidth * 0.4,
                height: isFlagship ? hullHeight * 1.2 : hullHeight * 0.9,
                depth: hullLength * 0.35
            }, scene);
            fin.material = hullMat;
            fin.parent = hull;
            fin.position = new BABYLON.Vector3(0, hullHeight * 0.7, -hullLength * 0.05);

            // Side pods for flagship
            if (isFlagship) {
                for (var p = -1; p <= 1; p += 2) {
                    var pod = BABYLON.MeshBuilder.CreateBox("pod" + shipIdCounter + "_" + p, {
                        width: hullWidth * 0.5,
                        height: hullHeight * 0.8,
                        depth: hullLength * 0.5
                    }, scene);
                    pod.material = hullMat;
                    pod.parent = hull;
                    pod.position = new BABYLON.Vector3(p * (hullWidth * 0.9), 0, -hullLength * 0.1);
                }
            }

            // Engine block
            var engineBlock = BABYLON.MeshBuilder.CreateBox("engine" + shipIdCounter, {
                width: hullWidth * 0.9,
                height: hullHeight * 0.6,
                depth: hullLength * 0.35
            }, scene);
            var engineMat = new BABYLON.StandardMaterial("engineMat" + shipIdCounter, scene);
            engineMat.diffuseColor = new BABYLON.Color3(0.15, 0.15, 0.18);
            engineMat.emissiveColor = teamColors[team].scale(0.35);
            engineBlock.material = engineMat;
            engineBlock.parent = hull;
            engineBlock.position = new BABYLON.Vector3(0, 0, -hullLength * 0.45);

            // Glowing thruster cones
            var thrusterMat = new BABYLON.StandardMaterial("thrMat" + shipIdCounter, scene);
            thrusterMat.emissiveColor = teamColors[team].scale(1.5);
            thrusterMat.specularColor = new BABYLON.Color3(0, 0, 0);
            thrusterMat.alpha = 0.9;

            var thrusterCount = isFlagship ? 3 : 2;
            for (var t = 0; t < thrusterCount; t++) {
                var thr = BABYLON.MeshBuilder.CreateCylinder("thr" + shipIdCounter + "_" + t, {
                    diameterTop: 0,
                    diameterBottom: isFlagship ? 1.8 : 1.2,
                    height: isFlagship ? 5 : 4,
                    tessellation: 6
                }, scene);
                thr.material = thrusterMat;
                thr.parent = hull;
                thr.rotation.x = -Math.PI / 2;
                var offsetX = (t - (thrusterCount - 1) / 2) * (isFlagship ? 2.4 : 1.8);
                thr.position = new BABYLON.Vector3(offsetX, -hullHeight * 0.1, -hullLength * 0.7);
            }

            // Engine spotlight (directional light from thrusters)
            var engineLight = new BABYLON.SpotLight(
                "engLight" + shipIdCounter,
                new BABYLON.Vector3(0, 0, -hullLength * 0.7),
                new BABYLON.Vector3(0, 0, -1),
                Math.PI / 2.5,
                2,
                scene
            );
            engineLight.diffuse = teamColors[team].scale(1.4);
            engineLight.specular = teamColors[team];
            engineLight.intensity = isFlagship ? 2.0 : 1.2;
            engineLight.range = isFlagship ? 55 : 35;
            engineLight.parent = hull;

            // Health bar GUI
            var hbContainer = new BABYLON.GUI.Rectangle("hbCon" + shipIdCounter);
            hbContainer.width = "60px";
            hbContainer.height = "10px";
            hbContainer.cornerRadius = 4;
            hbContainer.color = "white";
            hbContainer.thickness = 1;
            hbContainer.background = "rgba(0,0,0,0.6)";
            guiTex.addControl(hbContainer);
            hbContainer.linkWithMesh(hull);
            hbContainer.linkOffsetY = -40;

            var hbFill = new BABYLON.GUI.Rectangle("hbFill" + shipIdCounter);
            hbFill.height = 1;
            hbFill.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            hbFill.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            hbFill.left = "0px";
            hbFill.thickness = 0;
            hbFill.background = team === 0 ? "#4ad4ff" : "#ff5555";
            hbContainer.addControl(hbFill);
            hbFill.width = 1; // full at start

            var maxHealth = isFlagship ? 300 : 100;
            var boundingRadius = Math.max(hullLength, hullWidth) * 0.7;

            var ship = {
                id: shipIdCounter++,
                mesh: hull,
                isFlagship: isFlagship,
                team: team,
                maxHealth: maxHealth,
                health: maxHealth,
                destroyed: false,
                velocity: new BABYLON.Vector3(0, 0, 0),
                cooldown: Math.random() * 3,
                boundingRadius: boundingRadius,
                hbContainer: hbContainer,
                hbFill: hbFill,
                engineLight: engineLight
            };

            engineLight.includedOnlyMeshes = [hull];

            ships.push(ship);
            fleets[team].push(ship);

            return ship;
        }

        // Fleets
        function createFleet(team) {
            var baseX = team === 0 ? -80 : 80;
            var side = team === 0 ? 1 : -1;

            // Flagship
            var flagship = createShip(true, team);
            flagship.mesh.position = new BABYLON.Vector3(baseX, 0, 0);
            flagship.mesh.rotation.y = side > 0 ? Math.PI / 2 : -Math.PI / 2;

            // Escorts around it
            var radius = 25;
            for (var i = 0; i < 9; i++) {
                var angle = (i / 9) * Math.PI * 2;
                var offsetY = (Math.random() - 0.5) * 12;
                var offsetZ = Math.sin(angle) * radius;
                var offsetX = Math.cos(angle) * radius * 0.15;
                var escort = createShip(false, team);
                escort.mesh.position = new BABYLON.Vector3(
                    baseX + offsetX,
                    offsetY,
                    offsetZ
                );
                escort.mesh.rotation.y = side > 0 ? Math.PI / 2 : -Math.PI / 2;
            }
        }

        createFleet(0);
        createFleet(1);

        // Explosion effects
        function createExplosion(position, color) {
            // Fireball
            var fire = new BABYLON.ParticleSystem("fireExplosion", 800, scene);
            fire.particleTexture = flareTex;
            fire.emitter = position.clone();
            fire.minEmitBox = new BABYLON.Vector3(-2, -2, -2);
            fire.maxEmitBox = new BABYLON.Vector3(2, 2, 2);
            fire.color1 = new BABYLON.Color4(1, 0.8, 0.4, 1);
            fire.color2 = new BABYLON.Color4(1, 0.3, 0.1, 1);
            fire.colorDead = new BABYLON.Color4(0.2, 0, 0, 0);
            fire.minSize = 1.5;
            fire.maxSize = 4.0;
            fire.minLifeTime = 0.2;
            fire.maxLifeTime = 0.6;
            fire.emitRate = 4000;
            fire.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            fire.gravity = new BABYLON.Vector3(0, 0, 0);
            fire.direction1 = new BABYLON.Vector3(-1, -1, -1);
            fire.direction2 = new BABYLON.Vector3(1, 1, 1);
            fire.minAngularSpeed = 0;
            fire.maxAngularSpeed = Math.PI;
            fire.minEmitPower = 20;
            fire.maxEmitPower = 40;
            fire.updateSpeed = 0.01;

            // Sparks/debris
            var sparks = new BABYLON.ParticleSystem("sparksExplosion", 600, scene);
            sparks.particleTexture = flareTex;
            sparks.emitter = position.clone();
            sparks.minEmitBox = BABYLON.Vector3.Zero();
            sparks.maxEmitBox = BABYLON.Vector3.Zero();
            sparks.color1 = new BABYLON.Color4(color.r * 1.5, color.g * 1.5, color.b * 1.5, 1);
            sparks.color2 = new BABYLON.Color4(1, 1, 1, 1);
            sparks.colorDead = new BABYLON.Color4(0.5, 0.5, 0.5, 0);
            sparks.minSize = 0.3;
            sparks.maxSize = 0.7;
            sparks.minLifeTime = 0.4;
            sparks.maxLifeTime = 0.9;
            sparks.emitRate = 2500;
            sparks.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            sparks.gravity = new BABYLON.Vector3(0, -9.81, 0);
            sparks.direction1 = new BABYLON.Vector3(-1, -1, -1).scale(2);
            sparks.direction2 = new BABYLON.Vector3(1, 1, 1).scale(2);
            sparks.minEmitPower = 25;
            sparks.maxEmitPower = 60;
            sparks.updateSpeed = 0.015;

            // Shockwave disc
            var shockwave = BABYLON.MeshBuilder.CreateDisc("shockwave", { radius: 1, tessellation: 64 }, scene);
            shockwave.position = position.clone();
            shockwave.rotation.x = Math.PI / 2;
            var shockMat = new BABYLON.StandardMaterial("shockMat", scene);
            shockMat.emissiveColor = color.scale(1.8);
            shockMat.alpha = 0.6;
            shockMat.backFaceCulling = false;
            shockwave.material = shockMat;

            var shockStart = performance.now();
            var shockDuration = 700;
            scene.registerBeforeRender(function shockAnim() {
                var t = performance.now() - shockStart;
                var ratio = t / shockDuration;
                if (ratio > 1) {
                    scene.unregisterBeforeRender(shockAnim);
                    shockwave.dispose();
                    return;
                }
                shockwave.scaling.x = shockwave.scaling.z = 1 + ratio * 25;
                shockMat.alpha = 0.6 * (1 - ratio);
            });

            fire.start();
            sparks.start();

            setTimeout(function () {
                fire.stop();
                sparks.stop();
            }, 200);

            setTimeout(function () {
                fire.dispose();
                sparks.dispose();
            }, 1200);
        }

        // Health/damage logic
        function updateHealthBar(ship) {
            var ratio = ship.health / ship.maxHealth;
            if (ratio < 0) ratio = 0;
            ship.hbFill.width = ratio;
            if (ratio <= 0) {
                ship.hbContainer.isVisible = false;
            }
        }

        function destroyShip(ship) {
            if (ship.destroyed) return;
            ship.destroyed = true;

            var pos = ship.mesh.position.clone();
            createExplosion(pos, teamColors[ship.team]);

            ship.mesh.setEnabled(false);
            if (ship.engineLight) {
                ship.engineLight.dispose();
            }
            ship.hbContainer.isVisible = false;

            // Chain reaction: nearby ships also explode
            var chainRadius = ship.boundingRadius * 2.3;
            for (var i = 0; i < ships.length; i++) {
                var other = ships[i];
                if (other === ship || other.destroyed) continue;
                var dist = BABYLON.Vector3.Distance(pos, other.mesh.position);
                if (dist < chainRadius) {
                    other.health = 0;
                    updateHealthBar(other);
                    destroyShip(other);
                }
            }
        }

        function applyDamage(ship, dmg) {
            if (ship.destroyed) return;
            ship.health -= dmg;
            if (ship.health <= 0) {
                ship.health = 0;
                updateHealthBar(ship);
                destroyShip(ship);
            } else {
                updateHealthBar(ship);
            }
        }

        // Projectiles
        var projectiles = [];

        function spawnProjectile(shooter, target, dualOffsetVec) {
            if (!target || target.destroyed) return;

            var origin = shooter.mesh.position.clone();
            var targetPos = target.mesh.position.clone();
            var dir = targetPos.subtract(origin).normalize();

            if (dualOffsetVec) {
                origin = origin.add(dualOffsetVec);
            }

            var speed = 90;
            var proj = BABYLON.MeshBuilder.CreateSphere("proj", { diameter: 1 }, scene);
            proj.material = shooter.team === 0 ? projectileMatBlue : projectileMatRed;
            proj.position = origin.add(dir.scale(shooter.boundingRadius * 0.8));

            var vel = dir.scale(speed);
            var life = 6;

            // Trail
            var trail = new BABYLON.ParticleSystem("projTrail", 200, scene);
            trail.particleTexture = flareTex;
            trail.emitter = proj;
            trail.color1 = shooter.team === 0
                ? new BABYLON.Color4(0.4, 0.9, 1.0, 1)
                : new BABYLON.Color4(1.0, 0.4, 0.4, 1);
            trail.color2 = new BABYLON.Color4(1, 1, 1, 0.8);
            trail.colorDead = new BABYLON.Color4(0, 0, 0, 0);
            trail.minSize = 0.3;
            trail.maxSize = 0.8;
            trail.minLifeTime = 0.1;
            trail.maxLifeTime = 0.3;
            trail.emitRate = 600;
            trail.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
            trail.gravity = new BABYLON.Vector3(0, 0, 0);
            trail.direction1 = new BABYLON.Vector3(0, 0, 0);
            trail.direction2 = new BABYLON.Vector3(0, 0, 0);
            trail.minEmitPower = 0.5;
            trail.maxEmitPower = 1;
            trail.updateSpeed = 0.01;
            trail.start();

            projectiles.push({
                mesh: proj,
                velocity: vel,
                life: life,
                team: shooter.team,
                trail: trail
            });
        }

        function acquireTarget(ship) {
            var enemies = ship.team === 0 ? fleets[1] : fleets[0];
            var best = null;
            var bestDist = Infinity;

            // Prefer enemy flagship if alive
            for (var i = 0; i < enemies.length; i++) {
                var e = enemies[i];
                if (!e.isFlagship || e.destroyed) continue;
                return e;
            }

            // Otherwise closest alive enemy
            for (var j = 0; j < enemies.length; j++) {
                var en = enemies[j];
                if (en.destroyed) continue;
                var d = BABYLON.Vector3.Distance(ship.mesh.position, en.mesh.position);
                if (d < bestDist) {
                    bestDist = d;
                    best = en;
                }
            }
            return best;
        }

        // Main update loop
        var lastTime = performance.now();
        var battleCenter = new BABYLON.Vector3(0, 0, 0);

        scene.onBeforeRenderObservable.add(function () {
            var now = performance.now();
            var dt = (now - lastTime) / 1000;
            lastTime = now;

            // Ships: movement and firing
            for (var i = 0; i < ships.length; i++) {
                var s = ships[i];
                if (s.destroyed) continue;

                var target = acquireTarget(s);
                var targetPos = target && !target.destroyed ? target.mesh.position : battleCenter;

                var desiredDir = targetPos.subtract(s.mesh.position);
                desiredDir = desiredDir.length() > 0.001 ? desiredDir.normalize() : new BABYLON.Vector3(0, 0, 1);

                // Add some 3D swaying motion for cinematic feel
                var timeFactor = now * 0.001 + s.id;
                var sway = new BABYLON.Vector3(
                    Math.sin(timeFactor * 0.8) * 0.2,
                    Math.sin(timeFactor * 1.3 + i) * 0.5,
                    Math.cos(timeFactor * 0.9 + i * 0.5) * 0.5
                );
                desiredDir = desiredDir.add(sway).normalize();

                var maxSpeed = s.isFlagship ? 22 : 28;
                var accelMag = s.isFlagship ? 14 : 18;
                var accel = desiredDir.scale(accelMag);

                s.velocity = s.velocity.add(accel.scale(dt));

                var speed = s.velocity.length();
                if (speed > maxSpeed) {
                    s.velocity.scaleInPlace(maxSpeed / speed);
                }

                // Slight drag
                s.velocity.scaleInPlace(0.995);

                s.mesh.position = s.mesh.position.add(s.velocity.scale(dt));

                // Orient ship along its velocity
                if (s.velocity.lengthSquared() > 0.1) {
                    var futurePos = s.mesh.position.add(s.velocity);
                    s.mesh.lookAt(futurePos);
                }

                // Firing logic
                s.cooldown -= dt;
                if (s.cooldown <= 0) {
                    var currentTarget = acquireTarget(s);
                    if (currentTarget) {
                        if (s.isFlagship) {
                            // Dual salvos for flagships
                            var toTarget = currentTarget.mesh.position.subtract(s.mesh.position).normalize();
                            var up = new BABYLON.Vector3(0, 1, 0);
                            var side = BABYLON.Vector3.Cross(toTarget, up);
                            if (side.lengthSquared() < 0.01) {
                                side = new BABYLON.Vector3(1, 0, 0);
                            } else {
                                side = side.normalize();
                            }
                            var dualOffset = side.scale(3.2);
                            spawnProjectile(s, currentTarget, dualOffset);
                            spawnProjectile(s, currentTarget, dualOffset.scale(-1));
                        } else {
                            spawnProjectile(s, currentTarget, null);
                        }
                    }
                    // Normal ships & flagships both fire every ~3s
                    s.cooldown = 3 + Math.random() * 0.5;
                }
            }

            // Projectiles: movement and collision
            for (var p = projectiles.length - 1; p >= 0; p--) {
                var pr = projectiles[p];
                pr.life -= dt;
                if (pr.life <= 0) {
                    pr.trail.stop();
                    pr.trail.dispose();
                    pr.mesh.dispose();
                    projectiles.splice(p, 1);
                    continue;
                }

                pr.mesh.position = pr.mesh.position.add(pr.velocity.scale(dt));

                var enemies = pr.team === 0 ? fleets[1] : fleets[0];
                for (var e = 0; e < enemies.length; e++) {
                    var sh = enemies[e];
                    if (sh.destroyed) continue;
                    var dist = BABYLON.Vector3.Distance(pr.mesh.position, sh.mesh.position);
                    if (dist < sh.boundingRadius * 0.6) {
                        // Impact
                        applyDamage(sh, sh.isFlagship ? 40 : 50);
                        pr.trail.stop();
                        pr.trail.dispose();
                        pr.mesh.dispose();
                        projectiles.splice(p, 1);
                        break;
                    }
                }
            }
        });

        return scene;
    };

    var scene = createScene();

    engine.runRenderLoop(function () {
        scene.render();
    });

    window.addEventListener("resize", function () {
        engine.resize();
    });
})();
</script>
</body>
</html>