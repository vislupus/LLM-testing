<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Space Battle Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
        }

        #renderCanvas {
            width: 100%;
            height: 100vh;
            display: block;
            touch-action: none;
        }

        /* UI Overlay */
        .ui-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            pointer-events: none;
        }

        .fleet-info {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 12px;
            color: #fff;
            margin-bottom: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .fleet-blue {
            border-left: 4px solid #4ecdc4;
        }

        .fleet-red {
            border-left: 4px solid #e94560;
        }

        .fleet-title {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 8px;
        }

        .fleet-stats {
            font-size: 0.85rem;
            color: #aaa;
        }

        .fleet-stats span {
            color: #fff;
            font-weight: bold;
        }

        /* Controls Hint */
        .controls-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            padding: 12px 25px;
            border-radius: 25px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 100;
        }

        /* Battle Status */
        .battle-status {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 30px;
            color: #fff;
            font-size: 1.2rem;
            font-weight: bold;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .battle-status.victory-blue {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.8), rgba(32, 191, 107, 0.8));
            box-shadow: 0 0 30px rgba(78, 205, 196, 0.5);
        }

        .battle-status.victory-red {
            background: linear-gradient(135deg, rgba(233, 69, 96, 0.8), rgba(214, 52, 71, 0.8));
            box-shadow: 0 0 30px rgba(233, 69, 96, 0.5);
        }

        /* Speed Control */
        .speed-control {
            position: fixed;
            bottom: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 12px;
            color: #fff;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .speed-label {
            font-size: 0.85rem;
            margin-bottom: 8px;
            text-align: center;
        }

        .speed-slider {
            width: 150px;
        }
    </style>
</head>
<body>
    <!-- Main Canvas -->
    <canvas id="renderCanvas"></canvas>

    <!-- UI Overlay -->
    <div class="ui-overlay">
        <div class="fleet-info fleet-blue">
            <div class="fleet-title" style="color: #4ecdc4;">üü¶ Azure Fleet</div>
            <div class="fleet-stats">
                Ships: <span id="blue-ships">10</span> | Active: <span id="blue-active">10</span>
            </div>
        </div>
        <div class="fleet-info fleet-red">
            <div class="fleet-title" style="color: #e94560;">üü• Crimson Fleet</div>
            <div class="fleet-stats">
                Ships: <span id="red-ships">10</span> | Active: <span id="red-active">10</span>
            </div>
        </div>
    </div>

    <!-- Battle Status -->
    <div class="battle-status" id="battle-status">
        ‚öîÔ∏è Space Battle in Progress
    </div>

    <!-- Speed Control -->
    <div class="speed-control">
        <div class="speed-label">‚è±Ô∏è Battle Speed</div>
        <input type="range" class="speed-slider" id="speedSlider" min="25" max="200" value="100">
    </div>

    <!-- Controls Hint -->
    <div class="controls-hint">
        üñ±Ô∏è Drag to Rotate &nbsp;|&nbsp; Scroll to Zoom &nbsp;|&nbsp; Right-click Drag to Pan
    </div>

    <!-- Babylon.js -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <script>
        // ==================== BATTLE CONFIGURATION ====================
        const CONFIG = {
            fleet: {
                blue: {
                    color: new BABYLON.Color3(0.3, 0.8, 0.77),
                    accentColor: new BABYLON.Color3(0.2, 0.9, 0.85),
                    projectileColor: new BABYLON.Color3(0.3, 0.9, 0.85),
                    projectileEmissive: new BABYLON.Color3(0.15, 0.6, 0.55),
                    position: new BABYLON.Vector3(-50, 0, 0)
                },
                red: {
                    color: new BABYLON.Color3(0.9, 0.27, 0.37),
                    accentColor: new BABYLON.Color3(0.95, 0.35, 0.45),
                    projectileColor: new BABYLON.Color3(0.95, 0.3, 0.35),
                    projectileEmissive: new BABYLON.Color3(0.7, 0.15, 0.2),
                    position: new BABYLON.Vector3(50, 0, 0)
                }
            },
            ship: {
                flagship: {
                    health: 500,
                    size: 8,
                    speed: 0.08,
                    fireRate: 3000,
                    projectileSpeed: 2.5,
                    projectileCount: 2,
                    damage: 45
                },
                escort: {
                    health: 150,
                    size: 3,
                    speed: 0.12,
                    fireRate: 3000,
                    projectileSpeed: 2,
                    projectileCount: 1,
                    damage: 20
                }
            },
            explosion: {
                chainReactionDistance: 12,
                debrisCount: 30,
                sparkCount: 50,
                shockwaveRadius: 15
            },
            battle: {
                speedMultiplier: 1
            }
        };

        // ==================== GAME STATE ====================
        let gameState = {
            blueFleet: [],
            redFleet: [],
            projectiles: [],
            explosions: [],
            debris: [],
            sparks: [],
            isGameOver: false,
            winner: null
        };

        // ==================== BABYLON SETUP ====================
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
        let scene, camera;

        // ==================== CREATE SCENE ====================
        const createScene = () => {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.02, 0.02, 0.05, 1);

            // Camera
            camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2.5, 150, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 30;
            camera.upperRadiusLimit = 300;
            camera.lowerBetaLimit = 0.1;
            camera.upperBetaLimit = Math.PI - 0.1;
            camera.wheelPrecision = 10;
            camera.panningSensibility = 50;

            // Lighting
            setupLighting();

            // Create starfield
            createStarfield();

            // Create nebula
            createNebula();

            // Create fleets
            createBlueFleet();
            createRedFleet();

            // Start battle
            startBattle();

            return scene;
        };

        // ==================== LIGHTING SETUP ====================
        function setupLighting() {
            // Ambient light
            const ambientLight = new BABYLON.HemisphericLight("ambient", new BABYLON.Vector3(0, 1, 0), scene);
            ambientLight.intensity = 0.3;
            ambientLight.diffuse = new BABYLON.Color3(0.6, 0.6, 0.8);

            // Directional light (simulating distant star)
            const sunLight = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-1, -0.5, -0.5), scene);
            sunLight.intensity = 0.5;
            sunLight.diffuse = new BABYLON.Color3(1, 0.95, 0.9);

            // Glow layer for projectiles and engines
            const glowLayer = new BABYLON.GlowLayer("glow", scene);
            glowLayer.intensity = 1.5;
        }

        // ==================== STARFIELD ====================
        function createStarfield() {
            const starCount = 2000;
            const positions = [];
            const colors = [];

            for (let i = 0; i < starCount; i++) {
                // Random position on sphere
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 400 + Math.random() * 200;

                positions.push(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta),
                    radius * Math.cos(phi)
                );

                // Star color (white to blue-white)
                const brightness = 0.7 + Math.random() * 0.3;
                colors.push(brightness, brightness * (0.9 + Math.random() * 0.1), brightness, 1);
            }

            const starPoints = new BABYLON.PointsCloudSystem("stars", 1, scene);
            starPoints.addPoints(starCount, (particle, i) => {
                particle.position = new BABYLON.Vector3(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
                particle.color = new BABYLON.Color4(colors[i * 4], colors[i * 4 + 1], colors[i * 4 + 2], colors[i * 4 + 3]);
            });
            starPoints.buildMeshAsync();
        }

        // ==================== NEBULA ====================
        function createNebula() {
            // Create nebula clouds
            for (let i = 0; i < 5; i++) {
                const nebulaCloud = BABYLON.MeshBuilder.CreateSphere("nebula" + i, {
                    diameter: 150 + Math.random() * 100,
                    segments: 8
                }, scene);

                const nebulaMat = new BABYLON.StandardMaterial("nebulaMat" + i, scene);
                nebulaMat.diffuseColor = new BABYLON.Color3(
                    Math.random() * 0.3,
                    Math.random() * 0.2,
                    Math.random() * 0.4 + 0.2
                );
                nebulaMat.emissiveColor = nebulaMat.diffuseColor.scale(0.3);
                nebulaMat.specularColor = new BABYLON.Color3(0, 0, 0);
                nebulaMat.alpha = 0.15;

                nebulaCloud.material = nebulaMat;
                nebulaCloud.position = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 300,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 200
                );
                nebulaCloud.scaling = new BABYLON.Vector3(1, 0.5 + Math.random() * 0.3, 1);
            }
        }

        // ==================== SHIP CREATION ====================
        function createShip(fleet, isFlagship, position, index) {
            const shipConfig = isFlagship ? CONFIG.ship.flagship : CONFIG.ship.escort;
            const fleetConfig = CONFIG.fleet[fleet];

            const ship = new BABYLON.TransformNode("ship_" + fleet + "_" + index, scene);
            ship.position = position.clone();

            // Ship group for health bar
            const shipGroup = new BABYLON.TransformNode("shipGroup_" + fleet + "_" + index, scene);
            shipGroup.position = position.clone();
            shipGroup.metadata = {
                fleet,
                isFlagship,
                health: shipConfig.health,
                maxHealth: shipConfig.health,
                lastFire: 0,
                target: null,
                velocity: new BABYLON.Vector3(0, 0, 0),
                rotationVelocity: new BABYLON.Vector3(0, 0, 0)
            };

            // Create ship mesh
            const shipMesh = createShipMesh(shipGroup, fleetConfig, isFlagship);
            shipGroup.addChild(shipMesh);

            // Engine glow
            createEngineGlow(shipGroup, fleetConfig);

            // Health bar
            createHealthBar(shipGroup);

            // Add to fleet
            gameState[fleet + "Fleet"].push(shipGroup);

            return shipGroup;
        }

        function createShipMesh(parent, fleetConfig, isFlagship) {
            const shipGroup = new BABYLON.TransformNode("shipMesh", scene);
            const scale = isFlagship ? 1 : 0.5;

            // Main hull
            const hull = BABYLON.MeshBuilder.CreateCylinder("hull", {
                height: isFlagship ? 12 : 6,
                diameterTop: isFlagship ? 3 : 1.5,
                diameterBottom: isFlagship ? 5 : 2.5,
                tessellation: 8
            }, scene);
            hull.rotation.x = Math.PI / 2;
            hull.position.z = isFlagship ? 2 : 1;

            const hullMat = new BABYLON.StandardMaterial("hullMat", scene);
            hullMat.diffuseColor = fleetConfig.color;
            hullMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
            hullMat.specularPower = 32;
            hull.material = hullMat;
            hull.parent = shipGroup;
            hull.scaling = new BABYLON.Vector3(scale, scale, scale);

            // Wings
            for (let i = 0; i < 4; i++) {
                const wing = BABYLON.MeshBuilder.CreateBox("wing" + i, {
                    width: isFlagship ? 8 : 4,
                    height: 0.3,
                    depth: isFlagship ? 4 : 2
                }, scene);
                wing.position = new BABYLON.Vector3(
                    (i % 2 === 0 ? 1 : -1) * (isFlagship ? 5 : 2.5),
                    0,
                    i < 2 ? -1 : 2
                );
                wing.rotation.y = (i % 2 === 0 ? 1 : -1) * Math.PI / 4;

                const wingMat = new BABYLON.StandardMaterial("wingMat", scene);
                wingMat.diffuseColor = fleetConfig.accentColor;
                wingMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                wing.material = wingMat;
                wing.parent = shipGroup;
                wing.scaling = new BABYLON.Vector3(scale, scale, scale);
            }

            // Bridge/cockpit
            const bridge = BABYLON.MeshBuilder.CreateSphere("bridge", {
                diameter: isFlagship ? 4 : 2,
                segments: 8
            }, scene);
            bridge.position.z = isFlagship ? -2 : -1;
            bridge.scaling = new BABYLON.Vector3(1, 0.5, 1.5);

            const bridgeMat = new BABYLON.StandardMaterial("bridgeMat", scene);
            bridgeMat.diffuseColor = fleetConfig.accentColor;
            bridgeMat.emissiveColor = fleetConfig.accentColor.scale(0.2);
            bridge.material = bridgeMat;
            bridge.parent = shipGroup;
            bridge.scaling = new BABYLON.Vector3(scale, scale, scale);

            // Weapon pods
            const podCount = isFlagship ? 4 : 2;
            for (let i = 0; i < podCount; i++) {
                const pod = BABYLON.MeshBuilder.CreateCylinder("pod" + i, {
                    height: 1,
                    diameter: 0.8,
                    tessellation: 8
                }, scene);
                pod.rotation.x = Math.PI / 2;

                const angle = (i / podCount) * Math.PI * 2;
                pod.position = new BABYLON.Vector3(
                    Math.cos(angle) * (isFlagship ? 2 : 1),
                    0,
                    isFlagship ? 4 : 2
                );

                const podMat = new BABYLON.StandardMaterial("podMat", scene);
                podMat.diffuseColor = fleetConfig.accentColor;
                podMat.emissiveColor = fleetConfig.projectileEmissive;
                pod.material = podMat;
                pod.parent = shipGroup;
                pod.scaling = new BABYLON.Vector3(scale, scale, scale);
            }

            // Details for flagship
            if (isFlagship) {
                // Extra sensors
                for (let i = 0; i < 3; i++) {
                    const sensor = BABYLON.MeshBuilder.CreateSphere("sensor" + i, {
                        diameter: 0.8,
                        segments: 8
                    }, scene);
                    sensor.position = new BABYLON.Vector3(
                        (i - 1) * 2,
                        1.5,
                        -3
                    );

                    const sensorMat = new BABYLON.StandardMaterial("sensorMat", scene);
                    sensorMat.diffuseColor = new BABYLON.Color3(0.8, 0.8, 1);
                    sensorMat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.5);
                    sensor.material = sensorMat;
                    sensor.parent = shipGroup;
                }

                // Rear engine glow
                const rearGlow = BABYLON.MeshBuilder.CreateCylinder("rearGlow", {
                    height: 0.5,
                    diameter: 4,
                    tessellation: 16
                }, scene);
                rearGlow.position.z = -4;
                rearGlow.rotation.x = Math.PI / 2;

                const rearGlowMat = new BABYLON.StandardMaterial("rearGlowMat", scene);
                rearGlowMat.diffuseColor = fleetConfig.projectileColor;
                rearGlowMat.emissiveColor = fleetConfig.projectileColor.scale(0.5);
                rearGlow.material = rearGlowMat;
                rearGlow.parent = shipGroup;
            }

            return shipGroup;
        }

        function createEngineGlow(parent, fleetConfig) {
            // Engine thrusters
            const engineCount = 4;
            for (let i = 0; i < engineCount; i++) {
                const engine = BABYLON.MeshBuilder.CreateCylinder("engine" + i, {
                    height: 1.5,
                    diameter: 0.8,
                    tessellation: 8
                }, scene);
                engine.rotation.x = Math.PI / 2;

                const angle = (i / engineCount) * Math.PI * 2 + Math.PI / 4;
                engine.position = new BABYLON.Vector3(
                    Math.cos(angle) * 1.5,
                    Math.sin(angle) * 1.5,
                    5
                );

                const engineMat = new BABYLON.StandardMaterial("engineMat", scene);
                engineMat.diffuseColor = fleetConfig.projectileColor;
                engineMat.emissiveColor = fleetConfig.projectileColor.scale(0.8);
                engine.material = engineMat;
                engine.parent = parent;

                // Point light for engine
                const light = new BABYLON.PointLight("engineLight" + i, engine.position.clone(), scene);
                light.diffuse = fleetConfig.projectileColor;
                light.intensity = 0.5;
                light.range = 10;
                light.parent = parent;
            }
        }

        function createHealthBar(parent) {
            const healthBarGroup = new BABYLON.TransformNode("healthBar", scene);
            healthBarGroup.position.y = 8;

            // Background
            const bgWidth = 4;
            const bg = BABYLON.MeshBuilder.CreatePlane("healthBg", {
                width: bgWidth,
                height: 0.4
            }, scene);
            bg.position.z = 0;

            const bgMat = new BABYLON.StandardMaterial("bgMat", scene);
            bgMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            bgMat.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            bgMat.backFaceCulling = false;
            bg.material = bgMat;
            bg.parent = healthBarGroup;

            // Health fill
            const fill = BABYLON.MeshBuilder.CreatePlane("healthFill", {
                width: bgWidth - 0.2,
                height: 0.3
            }, scene);
            fill.position.z = 0.01;

            const fillMat = new BABYLON.StandardMaterial("fillMat", scene);
            fillMat.diffuseColor = new BABYLON.Color3(0.2, 0.9, 0.3);
            fillMat.emissiveColor = new BABYLON.Color3(0.1, 0.4, 0.15);
            fillMat.backFaceCulling = false;
            fill.material = fillMat;
            fill.parent = healthBarGroup;

            healthBarGroup.parent = parent;
            parent.metadata.healthBar = {
                fill,
                fillMat,
                bg,
                bgMat
            };
        }

        function updateHealthBar(ship) {
            if (!ship.metadata.healthBar) return;

            const healthPercent = ship.metadata.health / ship.metadata.maxHealth;
            const width = (4 - 0.2) * healthPercent;

            ship.metadata.healthBar.fill.scaling.x = healthPercent;
            ship.metadata.healthBar.fill.position.x = -(4 - 0.2) * (1 - healthPercent) / 2;

            // Color based on health
            if (healthPercent > 0.6) {
                ship.metadata.healthBar.fillMat.diffuseColor = new BABYLON.Color3(0.2, 0.9, 0.3);
                ship.metadata.healthBar.fillMat.emissiveColor = new BABYLON.Color3(0.1, 0.4, 0.15);
            } else if (healthPercent > 0.3) {
                ship.metadata.healthBar.fillMat.diffuseColor = new BABYLON.Color3(0.9, 0.7, 0.2);
                ship.metadata.healthBar.fillMat.emissiveColor = new BABYLON.Color3(0.4, 0.3, 0.1);
            } else {
                ship.metadata.healthBar.fillMat.diffuseColor = new BABYLON.Color3(0.9, 0.2, 0.2);
                ship.metadata.healthBar.fillMat.emissiveColor = new BABYLON.Color3(0.4, 0.1, 0.1);
            }
        }

        // ==================== FLEET CREATION ====================
        function createBlueFleet() {
            const flagshipPos = CONFIG.fleet.blue.position.clone();

            // Create flagship at center
            createShip('blue', true, flagshipPos, 'flagship');

            // Create escorts in formation
            const escortPositions = [
                new BABYLON.Vector3(-60, 5, 20),
                new BABYLON.Vector3(-60, -5, 20),
                new BABYLON.Vector3(-60, 10, -10),
                new BABYLON.Vector3(-60, -10, -10),
                new BABYLON.Vector3(-55, 0, 30),
                new BABYLON.Vector3(-55, 8, 0),
                new BABYLON.Vector3(-55, -8, 0),
                new BABYLON.Vector3(-65, 5, 10),
                new BABYLON.Vector3(-65, -5, 10)
            ];

            escortPositions.forEach((pos, i) => {
                createShip('blue', false, pos, i);
            });

            updateFleetUI();
        }

        function createRedFleet() {
            const flagshipPos = CONFIG.fleet.red.position.clone();

            // Create flagship at center
            createShip('red', true, flagshipPos, 'flagship');

            // Create escorts in formation
            const escortPositions = [
                new BABYLON.Vector3(60, 5, 20),
                new BABYLON.Vector3(60, -5, 20),
                new BABYLON.Vector3(60, 10, -10),
                new BABYLON.Vector3(60, -10, -10),
                new BABYLON.Vector3(55, 0, 30),
                new BABYLON.Vector3(55, 8, 0),
                new BABYLON.Vector3(55, -8, 0),
                new BABYLON.Vector3(65, 5, 10),
                new BABYLON.Vector3(65, -5, 10)
            ];

            escortPositions.forEach((pos, i) => {
                createShip('red', false, pos, i);
            });

            updateFleetUI();
        }

        // ==================== PROJECTILE SYSTEM ====================
        function fireProjectile(ship) {
            const now = Date.now();
            const config = ship.metadata.isFlagship ? CONFIG.ship.flagship : CONFIG.ship.escort;

            if (now - ship.metadata.lastFire < config.fireRate / CONFIG.battle.speedMultiplier) return;
            ship.metadata.lastFire = now;

            const fleetConfig = CONFIG.fleet[ship.metadata.fleet];
            const projectileCount = ship.metadata.isFlagship ? 2 : 1;

            for (let i = 0; i < projectileCount; i++) {
                const projectile = BABYLON.MeshBuilder.CreateSphere("projectile", {
                    diameter: ship.metadata.isFlagship ? 0.8 : 0.5,
                    segments: 8
                }, scene);

                projectile.position = ship.position.clone();

                // Offset for dual fire
                const offset = (i === 0 ? 1 : -1) * 0.8;
                projectile.position.x += offset;

                const projectileMat = new BABYLON.StandardMaterial("projectileMat", scene);
                projectileMat.diffuseColor = fleetConfig.projectileColor;
                projectileMat.emissiveColor = fleetConfig.projectileEmissive;
                projectileMat.specularColor = new BABYLON.Color3(1, 1, 1);
                projectile.material = projectileMat;

                // Find target
                const target = findTarget(ship);
                let direction;

                if (target) {
                    direction = target.position.subtract(projectile.position).normalize();
                    ship.metadata.target = target;
                } else {
                    // Calculate forward direction from ship rotation
                    direction = new BABYLON.Vector3(
                        Math.sin(ship.rotation.y),
                        -Math.sin(ship.rotation.x),
                        Math.cos(ship.rotation.y)
                    ).normalize();
                }

                // Add some spread
                direction.x += (Math.random() - 0.5) * 0.1;
                direction.y += (Math.random() - 0.5) * 0.1;
                direction.z += (Math.random() - 0.5) * 0.1;
                direction.normalize();

                projectile.metadata = {
                    fleet: ship.metadata.fleet,
                    damage: config.damage,
                    speed: config.projectileSpeed,
                    direction,
                    lifetime: 0,
                    maxLifetime: 5,
                    trail: []
                };

                // Create trail
                createProjectileTrail(projectile, fleetConfig.projectileColor);

                gameState.projectiles.push(projectile);
            }

            // Muzzle flash
            createMuzzleFlash(ship.position, fleetConfig.projectileColor);
        }

        function createProjectileTrail(projectile, color) {
            // Create initial path with two slightly different points
            const startPos = projectile.position.clone();
            const endPos = projectile.position.clone();
            endPos.addInPlace(projectile.metadata.direction.scale(0.1));
            
            const trailMesh = BABYLON.MeshBuilder.CreateTube("trail", {
                path: [startPos, endPos],
                radius: projectile.metadata.fleet === 'blue' ? 0.15 : 0.2,
                tessellation: 6,
                updatable: true
            }, scene);

            const trailMat = new BABYLON.StandardMaterial("trailMat", scene);
            trailMat.diffuseColor = color;
            trailMat.emissiveColor = color.scale(0.5);
            trailMat.alpha = 0.6;
            trailMat.backFaceCulling = false;
            trailMesh.material = trailMat;

            projectile.metadata.trailMesh = trailMesh;
            projectile.metadata.trailMat = trailMat;
            // Initialize trail with starting points
            projectile.metadata.trail = [startPos, endPos];
        }

        function createMuzzleFlash(position, color) {
            const flash = BABYLON.MeshBuilder.CreateSphere("flash", {
                diameter: 2,
                segments: 8
            }, scene);
            flash.position = position.clone();

            const flashMat = new BABYLON.StandardMaterial("flashMat", scene);
            flashMat.diffuseColor = color;
            flashMat.emissiveColor = color.scale(1);
            flashMat.alpha = 0.8;
            flash.material = flashMat;

            // Animate flash
            let flashLife = 0;
            const flashObserver = scene.onBeforeRenderObservable.add(() => {
                flashLife += 0.016 * CONFIG.battle.speedMultiplier;
                flash.scaling.scaleInPlace(0.85);
                flashMat.alpha = 0.8 * (1 - flashLife / 0.2);

                if (flashLife > 0.2) {
                    flash.dispose();
                    scene.onBeforeRenderObservable.remove(flashObserver);
                }
            });
        }

        function updateProjectiles() {
            if (gameState.isGameOver) return;

            gameState.projectiles.forEach((projectile, index) => {
                if (!projectile.metadata) {
                    gameState.projectiles.splice(index, 1);
                    return;
                }

                const metadata = projectile.metadata;
                metadata.lifetime += 0.016 * CONFIG.battle.speedMultiplier;

                // Store trail point first
                metadata.trail.push(projectile.position.clone());
                if (metadata.trail.length > 15) metadata.trail.shift();

                // Update trail mesh (need at least 2 points)
                if (metadata.trailMesh && metadata.trail.length >= 2) {
                    try {
                        BABYLON.MeshBuilder.CreateTube("trail", {
                            path: metadata.trail,
                            radius: metadata.fleet === 'blue' ? 0.1 : 0.15,
                            tessellation: 6,
                            instance: metadata.trailMesh
                        });
                    } catch (e) {
                        // Ignore trail update errors
                    }
                }

                // Move projectile
                projectile.position.addInPlace(metadata.direction.scale(metadata.speed * CONFIG.battle.speedMultiplier));

                // Check collision with ships
                const targetFleet = metadata.fleet === 'blue' ? gameState.redFleet : gameState.blueFleet;

                targetFleet.forEach(ship => {
                    if (!ship.metadata || ship.metadata.health <= 0) return;

                    const distance = BABYLON.Vector3.Distance(projectile.position, ship.position);
                    const hitDistance = ship.metadata.isFlagship ? 6 : 3;

                    if (distance < hitDistance) {
                        // Hit!
                        ship.metadata.health -= metadata.damage;
                        updateHealthBar(ship);

                        // Create hit effect
                        createHitEffect(projectile.position, metadata.fleet === 'blue' ? CONFIG.fleet.blue.projectileColor : CONFIG.fleet.red.projectileColor);

                        // Remove projectile
                        if (metadata.trailMesh) metadata.trailMesh.dispose();
                        projectile.dispose();
                        gameState.projectiles.splice(index, 1);

                        // Check if destroyed
                        if (ship.metadata.health <= 0) {
                            createExplosion(ship);
                        }
                    }
                });

                // Remove if lifetime expired
                if (metadata.lifetime > metadata.maxLifetime) {
                    if (metadata.trailMesh) metadata.trailMesh.dispose();
                    projectile.dispose();
                    gameState.projectiles.splice(index, 1);
                }
            });
        }

        function createHitEffect(position, color) {
            // Small spark burst
            for (let i = 0; i < 5; i++) {
                const spark = BABYLON.MeshBuilder.CreateSphere("spark", {
                    diameter: 0.2,
                    segments: 4
                }, scene);
                spark.position = position.clone();

                const sparkMat = new BABYLON.StandardMaterial("sparkMat", scene);
                sparkMat.diffuseColor = new BABYLON.Color3(1, 1, 0.5);
                sparkMat.emissiveColor = new BABYLON.Color3(1, 0.8, 0.3);
                spark.material = sparkMat;

                const velocity = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );

                spark.metadata = { velocity, lifetime: 0 };
                gameState.sparks.push(spark);
            }
        }

        // ==================== EXPLOSION SYSTEM ====================
        function createExplosion(ship) {
            const position = ship.position.clone();

            // Main explosion sphere
            const explosion = BABYLON.MeshBuilder.CreateSphere("explosion", {
                diameter: 5,
                segments: 16
            }, scene);
            explosion.position = position;

            const explosionMat = new BABYLON.StandardMaterial("explosionMat", scene);
            explosionMat.diffuseColor = new BABYLON.Color3(1, 0.5, 0.2);
            explosionMat.emissiveColor = new BABYLON.Color3(1, 0.3, 0.1);
            explosionMat.alpha = 0.9;
            explosion.material = explosionMat;

            // Explosion light
            const explosionLight = new BABYLON.PointLight("explosionLight", position, scene);
            explosionLight.diffuse = new BABYLON.Color3(1, 0.5, 0.2);
            explosionLight.intensity = 3;
            explosionLight.range = 50;

            // Animate explosion
            let explosionLife = 0;
            const explosionObserver = scene.onBeforeRenderObservable.add(() => {
                explosionLife += 0.016 * CONFIG.battle.speedMultiplier;

                const scale = 1 + explosionLife * 8;
                explosion.scaling = new BABYLON.Vector3(scale, scale, scale);
                explosionMat.alpha = 0.9 * (1 - explosionLife / 1.5);
                explosionLight.intensity = 3 * (1 - explosionLife / 1.5);

                if (explosionLife > 1.5) {
                    explosion.dispose();
                    explosionLight.dispose();
                    scene.onBeforeRenderObservable.remove(explosionObserver);
                }
            });

            gameState.explosions.push({
                position,
                light: explosionLight,
                lifetime: 0
            });

            // Create debris
            createDebris(position, ship.metadata.fleet);

            // Create shockwave
            createShockwave(position);

            // Check chain reaction
            checkChainReaction(position);

            // Remove ship
            ship.dispose();

            // Update fleet count
            updateFleetUI();
            checkVictory();
        }

        function createDebris(position, fleet) {
            const fleetConfig = CONFIG.fleet[fleet];
            const debrisCount = CONFIG.explosion.debrisCount;

            for (let i = 0; i < debrisCount; i++) {
                const debris = BABYLON.MeshBuilder.CreateBox("debris" + i, {
                    width: 0.3 + Math.random() * 0.5,
                    height: 0.3 + Math.random() * 0.5,
                    depth: 0.3 + Math.random() * 0.5
                }, scene);
                debris.position = position.clone();

                const debrisMat = new BABYLON.StandardMaterial("debrisMat", scene);
                debrisMat.diffuseColor = fleetConfig.color;
                debrisMat.emissiveColor = new BABYLON.Color3(0.3, 0.2, 0.1);
                debris.material = debrisMat;

                const velocity = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 3,
                    (Math.random() - 0.5) * 3,
                    (Math.random() - 0.5) * 3
                );

                debris.metadata = {
                    velocity,
                    rotationVelocity: new BABYLON.Vector3(
                        Math.random() * 0.1,
                        Math.random() * 0.1,
                        Math.random() * 0.1
                    ),
                    lifetime: 0
                };

                gameState.debris.push(debris);
            }
        }

        function createShockwave(position) {
            const shockwave = BABYLON.MeshBuilder.CreateDisc("shockwave", {
                radius: 1,
                tessellation: 32
            }, scene);
            shockwave.position = position.clone();
            shockwave.rotation.x = Math.PI / 2;

            const shockwaveMat = new BABYLON.StandardMaterial("shockwaveMat", scene);
            shockwaveMat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            shockwaveMat.emissiveColor = new BABYLON.Color3(0.8, 0.8, 1);
            shockwaveMat.alpha = 0.8;
            shockwaveMat.backFaceCulling = false;
            shockwave.material = shockwaveMat;

            let shockwaveLife = 0;
            const shockwaveObserver = scene.onBeforeRenderObservable.add(() => {
                shockwaveLife += 0.016 * CONFIG.battle.speedMultiplier;

                const scale = 1 + shockwaveLife * 10;
                shockwave.scaling = new BABYLON.Vector3(scale, scale, 1);
                shockwaveMat.alpha = 0.8 * (1 - shockwaveLife / 1);

                if (shockwaveLife > 1) {
                    shockwave.dispose();
                    scene.onBeforeRenderObservable.remove(shockwaveObserver);
                }
            });
        }

        function checkChainReaction(explosionPos) {
            const chainDistance = CONFIG.explosion.chainReactionDistance;

            ['blue', 'red'].forEach(fleet => {
                const fleetShips = gameState[fleet + 'Fleet'];
                fleetShips.forEach((ship, index) => {
                    if (!ship.metadata || ship.metadata.health <= 0) return;

                    const distance = BABYLON.Vector3.Distance(explosionPos, ship.position);
                    if (distance < chainDistance) {
                        // Chain reaction!
                        ship.metadata.health = 0;
                        updateHealthBar(ship);

                        // Delayed explosion
                        setTimeout(() => {
                            if (ship.metadata && ship.metadata.health <= 0) {
                                createExplosion(ship);
                            }
                        }, 100 + Math.random() * 200);
                    }
                });
            });
        }

        function updateDebrisAndSparks() {
            // Update debris
            gameState.debris.forEach((debris, index) => {
                if (!debris.metadata) {
                    gameState.debris.splice(index, 1);
                    return;
                }

                debris.metadata.lifetime += 0.016 * CONFIG.battle.speedMultiplier;

                debris.position.addInPlace(debris.metadata.velocity.scale(0.016 * CONFIG.battle.speedMultiplier));
                debris.rotation.x += debris.metadata.rotationVelocity.x;
                debris.rotation.y += debris.metadata.rotationVelocity.y;
                debris.rotation.z += debris.metadata.rotationVelocity.z;

                // Fade out
                if (debris.metadata.lifetime > 3) {
                    debris.dispose();
                    gameState.debris.splice(index, 1);
                }
            });

            // Update sparks
            gameState.sparks.forEach((spark, index) => {
                if (!spark.metadata) {
                    gameState.sparks.splice(index, 1);
                    return;
                }

                spark.metadata.lifetime += 0.016 * CONFIG.battle.speedMultiplier;

                spark.position.addInPlace(spark.metadata.velocity.scale(0.016 * CONFIG.battle.speedMultiplier));

                if (spark.metadata.lifetime > 0.5) {
                    spark.dispose();
                    gameState.sparks.splice(index, 1);
                }
            });
        }

        // ==================== SHIP AI ====================
        function findTarget(ship) {
            const targetFleet = ship.metadata.fleet === 'blue' ? gameState.redFleet : gameState.blueFleet;
            let nearestTarget = null;
            let nearestDist = Infinity;

            targetFleet.forEach(target => {
                if (!target.metadata || target.metadata.health <= 0) return;

                const dist = BABYLON.Vector3.Distance(ship.position, target.position);
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestTarget = target;
                }
            });

            return nearestTarget;
        }

        function updateShipAI() {
            if (gameState.isGameOver) return;

            ['blue', 'red'].forEach(fleet => {
                const fleetShips = gameState[fleet + 'Fleet'];

                fleetShips.forEach(ship => {
                    if (!ship.metadata || ship.metadata.health <= 0) return;

                    const config = ship.metadata.isFlagship ? CONFIG.ship.flagship : CONFIG.ship.escort;

                    // Find target
                    const target = findTarget(ship);

                    if (target) {
                        // Turn towards target
                        const direction = target.position.subtract(ship.position).normalize();
                        const targetRotation = Math.atan2(direction.x, direction.z);
                        const targetPitch = Math.atan2(direction.y, Math.sqrt(direction.x * direction.x + direction.z * direction.z));

                        // Smooth rotation
                        ship.rotation.y = BABYLON.Scalar.Lerp(ship.rotation.y, targetRotation, 0.02 * CONFIG.battle.speedMultiplier);
                        ship.rotation.x = BABYLON.Scalar.Lerp(ship.rotation.x, targetPitch, 0.02 * CONFIG.battle.speedMultiplier);

                        // Move towards target at distance
                        const distance = BABYLON.Vector3.Distance(ship.position, target.position);
                        const optimalDistance = ship.metadata.isFlagship ? 40 : 25;

                        if (distance > optimalDistance + 5) {
                            ship.position.addInPlace(direction.scale(config.speed * CONFIG.battle.speedMultiplier));
                        } else if (distance < optimalDistance - 5) {
                            ship.position.subtractInPlace(direction.scale(config.speed * 0.5 * CONFIG.battle.speedMultiplier));
                        }

                        // Strafe
                        const strafe = new BABYLON.Vector3(direction.z, 0, -direction.x);
                        if (Math.random() < 0.02) {
                            ship.position.addInPlace(strafe.scale(Math.random() * 5));
                        }

                        // Fire at target
                        fireProjectile(ship);
                    } else {
                        // No target, move towards enemy flagship
                        const enemyFlagPos = fleet === 'blue' ? CONFIG.fleet.red.position : CONFIG.fleet.blue.position;
                        const direction = enemyFlagPos.subtract(ship.position).normalize();

                        ship.rotation.y = Math.atan2(direction.x, direction.z);
                        ship.rotation.x = Math.atan2(direction.y, Math.sqrt(direction.x * direction.x + direction.z * direction.z));

                        ship.position.addInPlace(direction.scale(config.speed * 0.5 * CONFIG.battle.speedMultiplier));
                    }

                    // Keep in bounds
                    const bounds = 80;
                    if (Math.abs(ship.position.x) > bounds) ship.position.x = Math.sign(ship.position.x) * bounds;
                    if (Math.abs(ship.position.y) > bounds) ship.position.y = Math.sign(ship.position.y) * bounds;
                    if (Math.abs(ship.position.z) > bounds) ship.position.z = Math.sign(ship.position.z) * bounds;

                    // Make health bar face camera
                    if (ship.metadata.healthBar) {
                        ship.metadata.healthBar.fill.lookAt(camera.position);
                        ship.metadata.healthBar.fill.position.z = 0.01;
                        ship.metadata.healthBar.bg.lookAt(camera.position);
                        ship.metadata.healthBar.bg.position.z = 0;
                    }
                });
            });
        }

        // ==================== UI UPDATES ====================
        function updateFleetUI() {
            const blueActive = gameState.blueFleet.filter(s => s.metadata && s.metadata.health > 0).length;
            const redActive = gameState.redFleet.filter(s => s.metadata && s.metadata.health > 0).length;

            document.getElementById('blue-ships').textContent = gameState.blueFleet.length;
            document.getElementById('blue-active').textContent = blueActive;
            document.getElementById('red-ships').textContent = gameState.redFleet.length;
            document.getElementById('red-active').textContent = redActive;
        }

        function checkVictory() {
            const blueActive = gameState.blueFleet.filter(s => s.metadata && s.metadata.health > 0).length;
            const redActive = gameState.redFleet.filter(s => s.metadata && s.metadata.health > 0).length;

            const statusEl = document.getElementById('battle-status');

            if (blueActive === 0) {
                gameState.isGameOver = true;
                gameState.winner = 'red';
                statusEl.textContent = 'üéâ Crimson Fleet Victorious!';
                statusEl.className = 'battle-status victory-red';
            } else if (redActive === 0) {
                gameState.isGameOver = true;
                gameState.winner = 'blue';
                statusEl.textContent = 'üéâ Azure Fleet Victorious!';
                statusEl.className = 'battle-status victory-blue';
            }
        }

        // ==================== BATTLE LOOP ====================
        function startBattle() {
            scene.registerBeforeRender(() => {
                updateShipAI();
                updateProjectiles();
                updateDebrisAndSparks();
            });
        }

        // ==================== SPEED CONTROL ====================
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            CONFIG.battle.speedMultiplier = e.target.value / 100;
        });

        // ==================== INITIALIZATION ====================
        scene = createScene();

        engine.runRenderLoop(() => {
            scene.render();
        });

        window.addEventListener('resize', () => {
            engine.resize();
        });

        console.log('Space Battle Simulation loaded successfully!');
    </script>
</body>
</html>