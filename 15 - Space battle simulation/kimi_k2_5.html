<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Space Battle - Babylon.js</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="instructions">Drag to rotate • Scroll to zoom • Watch the battle unfold</div>
    <canvas id="renderCanvas"></canvas>
    
    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
        
        const createScene = function () {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.02, 0.02, 0.05);
            
            // Camera - ArcRotate for cinematic orbit
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 150, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 30;
            camera.upperRadiusLimit = 300;
            camera.wheelPrecision = 50;
            
            // Post-processing glow for neon effects
            const gl = new BABYLON.GlowLayer("glow", scene);
            gl.intensity = 0.6;
            
            // Lighting
            const hemiLight = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
            hemiLight.intensity = 0.4;
            hemiLight.diffuse = new BABYLON.Color3(0.2, 0.2, 0.3);
            
            // Starfield background
            const starSystem = new BABYLON.ParticleSystem("stars", 2000, scene);
            starSystem.particleTexture = new BABYLON.Texture("https://cdn.babylonjs.com/textures/flare.png", scene);
            starSystem.emitter = new BABYLON.Vector3(0, 0, 0);
            starSystem.minEmitBox = new BABYLON.Vector3(-200, -200, -200);
            starSystem.maxEmitBox = new BABYLON.Vector3(200, 200, 200);
            starSystem.color1 = new BABYLON.Color4(1, 1, 1, 0.8);
            starSystem.color2 = new BABYLON.Color4(0.5, 0.8, 1, 0.5);
            starSystem.minSize = 0.1;
            starSystem.maxSize = 0.8;
            starSystem.minLifeTime = 9999;
            starSystem.maxLifeTime = 9999;
            starSystem.emitRate = 2000;
            starSystem.start();
            
            // GUI for health bars
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            
            // Materials
            const blueMat = new BABYLON.StandardMaterial("blueMat", scene);
            blueMat.diffuseColor = new BABYLON.Color3(0.2, 0.4, 1);
            blueMat.emissiveColor = new BABYLON.Color3(0.1, 0.2, 0.5);
            blueMat.specularColor = new BABYLON.Color3(0.5, 0.7, 1);
            
            const redMat = new BABYLON.StandardMaterial("redMat", scene);
            redMat.diffuseColor = new BABYLON.Color3(1, 0.2, 0.2);
            redMat.emissiveColor = new BABYLON.Color3(0.5, 0.1, 0.1);
            redMat.specularColor = new BABYLON.Color3(1, 0.5, 0.5);
            
            const engineBlue = new BABYLON.StandardMaterial("engBlue", scene);
            engineBlue.emissiveColor = new BABYLON.Color3(0, 0.8, 1);
            
            const engineRed = new BABYLON.StandardMaterial("engRed", scene);
            engineRed.emissiveColor = new BABYLON.Color3(1, 0.4, 0);
            
            // Ship Class
            class Ship {
                constructor(type, faction, position) {
                    this.type = type; // 'flagship' or 'escort'
                    this.faction = faction; // 'blue' or 'red'
                    this.maxHealth = type === 'flagship' ? 200 : 100;
                    this.health = this.maxHealth;
                    this.lastShot = 0;
                    this.isDead = false;
                    
                    const size = type === 'flagship' ? 3 : 1.5;
                    const mat = faction === 'blue' ? blueMat : redMat;
                    
                    // Create mesh group
                    this.mesh = new BABYLON.TransformNode("ship", scene);
                    this.mesh.position = position;
                    
                    // Main hull
                    const hull = BABYLON.MeshBuilder.CreateBox("hull", {
                        width: size * 2,
                        height: size * 0.8,
                        depth: size * 3
                    }, scene);
                    hull.material = mat;
                    hull.parent = this.mesh;
                    
                    // Flagship extra details
                    if (type === 'flagship') {
                        const bridge = BABYLON.MeshBuilder.CreateBox("bridge", {
                            width: size, height: size * 0.5, depth: size
                        }, scene);
                        bridge.position.y = size * 0.6;
                        bridge.material = mat;
                        bridge.parent = this.mesh;
                        
                        // Side engines
                        [-1, 1].forEach(side => {
                            const engine = BABYLON.MeshBuilder.CreateCylinder("eng", {
                                diameter: size * 0.4, height: size
                            }, scene);
                            engine.rotation.x = Math.PI / 2;
                            engine.position = new BABYLON.Vector3(side * size * 1.2, 0, -size * 1.5);
                            engine.material = mat;
                            engine.parent = this.mesh;
                        });
                    }
                    
                    // Engine glow at back
                    const glow = BABYLON.MeshBuilder.CreatePlane("glow", {size: size}, scene);
                    glow.position = new BABYLON.Vector3(0, 0, -size * 1.6);
                    glow.material = faction === 'blue' ? engineBlue : engineRed;
                    glow.parent = this.mesh;
                    glow.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
                    
                    // Engine light
                    const light = new BABYLON.PointLight("shipLight", new BABYLON.Vector3(0, 0, -size * 2), scene);
                    light.diffuse = faction === 'blue' ? new BABYLON.Color3(0, 0.8, 1) : new BABYLON.Color3(1, 0.4, 0);
                    light.intensity = 2;
                    light.range = 10;
                    light.parent = this.mesh;
                    
                    // Thruster particles
                    const thruster = new BABYLON.ParticleSystem("thrust", 100, scene);
                    thruster.particleTexture = new BABYLON.Texture("https://cdn.babylonjs.com/textures/flare.png", scene);
                    thruster.emitter = this.mesh;
                    thruster.minEmitBox = new BABYLON.Vector3(-size/2, -size/4, -size*2);
                    thruster.maxEmitBox = new BABYLON.Vector3(size/2, size/4, -size*2);
                    thruster.color1 = faction === 'blue' ? new BABYLON.Color4(0, 0.8, 1, 1) : new BABYLON.Color4(1, 0.4, 0, 1);
                    thruster.color2 = faction === 'blue' ? new BABYLON.Color4(0, 0.4, 1, 0) : new BABYLON.Color4(1, 0.2, 0, 0);
                    thruster.minSize = size * 0.2;
                    thruster.maxSize = size * 0.5;
                    thruster.minLifeTime = 0.2;
                    thruster.maxLifeTime = 0.5;
                    thruster.emitRate = 50;
                    thruster.start();
                    this.thruster = thruster;
                    
                    // Health bar GUI
                    this.healthBar = new BABYLON.GUI.Rectangle();
                    this.healthBar.width = "60px";
                    this.healthBar.height = "8px";
                    this.healthBar.cornerRadius = 4;
                    this.healthBar.color = faction === 'blue' ? "#4488ff" : "#ff4444";
                    this.healthBar.thickness = 1;
                    this.healthBar.background = "rgba(0,0,0,0.5)";
                    advancedTexture.addControl(this.healthBar);
                    this.healthBar.linkWithMesh(this.mesh);
                    this.healthBar.linkOffsetY = -40;
                    
                    this.healthFill = new BABYLON.GUI.Rectangle();
                    this.healthFill.width = "100%";
                    this.healthFill.height = "100%";
                    this.healthFill.background = faction === 'blue' ? "#4488ff" : "#ff4444";
                    this.healthFill.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                    this.healthBar.addControl(this.healthFill);
                }
                
                takeDamage(amount) {
                    if (this.isDead) return;
                    this.health -= amount;
                    if (this.health <= 0) {
                        this.explode();
                    } else {
                        this.healthFill.width = (this.health / this.maxHealth * 100) + "%";
                    }
                }
                
                explode() {
                    if (this.isDead) return;
                    this.isDead = true;
                    this.healthBar.isVisible = false;
                    this.thruster.stop();
                    
                    const pos = this.mesh.position.clone();
                    const size = this.type === 'flagship' ? 3 : 1.5;
                    
                    // Create explosion
                    createExplosion(pos, size * 2, this.faction);
                    
                    // Chain reaction check
                    const allShips = [...blueFleet, ...redFleet];
                    allShips.forEach(ship => {
                        if (!ship.isDead && ship !== this) {
                            const dist = BABYLON.Vector3.Distance(pos, ship.mesh.position);
                            if (dist < size * 3) { // Within explosion radius
                                setTimeout(() => ship.takeDamage(ship.maxHealth), 100);
                            }
                        }
                    });
                    
                    // Hide mesh
                    this.mesh.dispose();
                }
            }
            
            // Explosion System
            function createExplosion(position, scale, faction) {
                // Fire burst
                const fire = new BABYLON.ParticleSystem("fire", 200, scene);
                fire.particleTexture = new BABYLON.Texture("https://cdn.babylonjs.com/textures/flare.png", scene);
                fire.emitter = position;
                fire.minEmitBox = new BABYLON.Vector3(-1, -1, -1);
                fire.maxEmitBox = new BABYLON.Vector3(1, 1, 1);
                fire.color1 = new BABYLON.Color4(1, 0.8, 0.2, 1);
                fire.color2 = new BABYLON.Color4(1, 0.2, 0, 1);
                fire.colorDead = new BABYLON.Color4(0.1, 0, 0, 0);
                fire.minSize = scale * 0.5;
                fire.maxSize = scale * 2;
                fire.minLifeTime = 0.5;
                fire.maxLifeTime = 1.5;
                fire.emitRate = 1000;
                fire.targetStopDuration = 0.1;
                fire.createSphereEmitter(scale);
                fire.start();
                
                // Sparks
                const sparks = new BABYLON.ParticleSystem("sparks", 100, scene);
                sparks.particleTexture = new BABYLON.Texture("https://cdn.babylonjs.com/textures/flare.png", scene);
                sparks.emitter = position;
                sparks.color1 = new BABYLON.Color4(1, 1, 0.8, 1);
                sparks.color2 = new BABYLON.Color4(1, 0.8, 0.2, 1);
                sparks.minSize = 0.2;
                sparks.maxSize = 0.8;
                sparks.minLifeTime = 0.3;
                sparks.maxLifeTime = 1;
                sparks.emitRate = 500;
                sparks.targetStopDuration = 0.2;
                sparks.start();
                
                // Shockwave ring
                const shockwave = BABYLON.MeshBuilder.CreateTorus("shock", {
                    diameter: scale * 2,
                    thickness: 0.5,
                    tessellation: 32
                }, scene);
                shockwave.position = position;
                shockwave.material = new BABYLON.StandardMaterial("sw", scene);
                shockwave.material.emissiveColor = new BABYLON.Color3(1, 0.9, 0.7);
                shockwave.material.alpha = 0.8;
                
                // Animate shockwave expansion
                const animScale = new BABYLON.Animation("scale", "scaling", 60, 
                    BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                animScale.setKeys([
                    { frame: 0, value: new BABYLON.Vector3(1, 1, 1) },
                    { frame: 30, value: new BABYLON.Vector3(5, 5, 5) }
                ]);
                shockwave.animations.push(animScale);
                
                const animAlpha = new BABYLON.Animation("alpha", "material.alpha", 60,
                    BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                animAlpha.setKeys([
                    { frame: 0, value: 0.8 },
                    { frame: 30, value: 0 }
                ]);
                shockwave.animations.push(animAlpha);
                
                scene.beginAnimation(shockwave, 0, 30, false, 1, () => shockwave.dispose());
                
                // Debris chunks
                for (let i = 0; i < 8; i++) {
                    const debris = BABYLON.MeshBuilder.CreateBox("deb", {size: scale * 0.3}, scene);
                    debris.position = position.clone();
                    const dir = new BABYLON.Vector3(
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5
                    ).normalize();
                    debris.position.addInPlace(dir.scale(Math.random() * scale));
                    debris.material = new BABYLON.StandardMaterial("deb", scene);
                    debris.material.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                    
                    // Fly outward
                    const speed = 0.5 + Math.random();
                    const rotSpeed = (Math.random() - 0.5) * 0.2;
                    let life = 60;
                    
                    scene.registerBeforeRender(() => {
                        if (life > 0) {
                            debris.position.addInPlace(dir.scale(speed));
                            debris.rotation.x += rotSpeed;
                            debris.rotation.y += rotSpeed;
                            life--;
                            if (life < 20) debris.scaling.scaleInPlace(0.9);
                        } else if (debris.isVisible) {
                            debris.dispose();
                        }
                    });
                }
            }
            
            // Projectile Management
            const projectiles = [];
            
            function createProjectile(origin, target, faction) {
                const color = faction === 'blue' ? new BABYLON.Color3(0, 1, 1) : new BABYLON.Color3(1, 0, 0);
                const mat = new BABYLON.StandardMaterial("proj", scene);
                mat.emissiveColor = color;
                mat.disableLighting = true;
                
                const proj = BABYLON.MeshBuilder.CreateSphere("proj", {diameter: 0.4}, scene);
                proj.position = origin.clone();
                proj.material = mat;
                
                // Trail
                const trail = new BABYLON.ParticleSystem("trail", 50, scene);
                trail.particleTexture = new BABYLON.Texture("https://cdn.babylonjs.com/textures/flare.png", scene);
                trail.emitter = proj;
                trail.minEmitBox = new BABYLON.Vector3(0, 0, 0);
                trail.maxEmitBox = new BABYLON.Vector3(0, 0, 0);
                trail.color1 = new BABYLON.Color4(color.r, color.g, color.b, 0.8);
                trail.color2 = new BABYLON.Color4(color.r, color.g, color.b, 0);
                trail.minSize = 0.2;
                trail.maxSize = 0.5;
                trail.minLifeTime = 0.2;
                trail.maxLifeTime = 0.4;
                trail.emitRate = 100;
                trail.start();
                
                const dir = target.subtract(origin).normalize();
                
                projectiles.push({
                    mesh: proj,
                    trail: trail,
                    direction: dir,
                    speed: 1.5,
                    faction: faction,
                    life: 200
                });
            }
            
            // Create Fleets
            const blueFleet = [];
            const redFleet = [];
            
            function createFleet(faction, offsetX) {
                const fleet = [];
                // Flagship center
                const flagship = new Ship('flagship', faction, new BABYLON.Vector3(offsetX, 0, 0));
                fleet.push(flagship);
                
                // 9 escorts in formation
                for (let i = 0; i < 9; i++) {
                    const angle = (i / 9) * Math.PI * 2;
                    const radius = 15;
                    const pos = new BABYLON.Vector3(
                        offsetX + Math.cos(angle) * radius,
                        (Math.random() - 0.5) * 10,
                        Math.sin(angle) * radius
                    );
                    fleet.push(new Ship('escort', faction, pos));
                }
                return fleet;
            }
            
            const blueFleet = createFleet('blue', -40);
            const redFleet = createFleet('red', 40);
            
            // Movement and Combat Logic
            scene.registerBeforeRender(() => {
                const now = Date.now();
                
                // Update Blue Fleet
                blueFleet.forEach((ship, idx) => {
                    if (ship.isDead) return;
                    
                    // Movement - drift toward enemies with variation
                    const target = redFleet[0].isDead ? 
                        new BABYLON.Vector3(40, 0, 0) : 
                        redFleet[Math.floor(Math.random() * redFleet.length)].mesh.position;
                    
                    const dir = target.subtract(ship.mesh.position).normalize();
                    const speed = ship.type === 'flagship' ? 0.1 : 0.15;
                    ship.mesh.position.addInScale(dir, speed);
                    ship.mesh.lookAt(target);
                    
                    // Bobbing motion
                    ship.mesh.position.y = Math.sin(now * 0.001 + idx) * 2;
                    
                    // Shooting
                    if (now - ship.lastShot > 3000) {
                        // Find nearest enemy
                        let nearest = null;
                        let minDist = Infinity;
                        redFleet.forEach(enemy => {
                            if (!enemy.isDead) {
                                const d = BABYLON.Vector3.Distance(ship.mesh.position, enemy.mesh.position);
                                if (d < minDist) {
                                    minDist = d;
                                    nearest = enemy;
                                }
                            }
                        });
                        
                        if (nearest) {
                            if (ship.type === 'flagship') {
                                createProjectile(ship.mesh.position, nearest.mesh.position, 'blue');
                                setTimeout(() => {
                                    createProjectile(ship.mesh.position, nearest.mesh.position, 'blue');
                                }, 100);
                            } else {
                                createProjectile(ship.mesh.position, nearest.mesh.position, 'blue');
                            }
                            ship.lastShot = now;
                        }
                    }
                });
                
                // Update Red Fleet (mirror behavior)
                redFleet.forEach((ship, idx) => {
                    if (ship.isDead) return;
                    
                    const target = blueFleet[0].isDead ? 
                        new BABYLON.Vector3(-40, 0, 0) : 
                        blueFleet[Math.floor(Math.random() * blueFleet.length)].mesh.position;
                    
                    const dir = target.subtract(ship.mesh.position).normalize();
                    const speed = ship.type === 'flagship' ? 0.1 : 0.15;
                    ship.mesh.position.addInScale(dir, speed);
                    ship.mesh.lookAt(target);
                    
                    ship.mesh.position.y = Math.sin(now * 0.001 + idx + 100) * 2;
                    
                    if (now - ship.lastShot > 3000) {
                        let nearest = null;
                        let minDist = Infinity;
                        blueFleet.forEach(enemy => {
                            if (!enemy.isDead) {
                                const d = BABYLON.Vector3.Distance(ship.mesh.position, enemy.mesh.position);
                                if (d < minDist) {
                                    minDist = d;
                                    nearest = enemy;
                                }
                            }
                        });
                        
                        if (nearest) {
                            if (ship.type === 'flagship') {
                                createProjectile(ship.mesh.position, nearest.mesh.position, 'red');
                                setTimeout(() => {
                                    createProjectile(ship.mesh.position, nearest.mesh.position, 'red');
                                }, 100);
                            } else {
                                createProjectile(ship.mesh.position, nearest.mesh.position, 'red');
                            }
                            ship.lastShot = now;
                        }
                    }
                });
                
                // Update Projectiles
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    if (p.life <= 0) {
                        p.trail.stop();
                        p.mesh.dispose();
                        projectiles.splice(i, 1);
                        continue;
                    }
                    
                    p.mesh.position.addInPlace(p.direction.scale(p.speed));
                    p.life--;
                    
                    // Collision detection
                    const targets = p.faction === 'blue' ? redFleet : blueFleet;
                    for (let target of targets) {
                        if (!target.isDead) {
                            const dist = BABYLON.Vector3.Distance(p.mesh.position, target.mesh.position);
                            if (dist < 3) {
                                target.takeDamage(p.faction === 'blue' ? 25 : 25);
                                p.life = 0; // Destroy projectile
                                break;
                            }
                        }
                    }
                }
            });
            
            return scene;
        };
        
        const scene = createScene();
        
        engine.runRenderLoop(() => {
            scene.render();
        });
        
        window.addEventListener("resize", () => {
            engine.resize();
        });
    </script>
</body>
</html>