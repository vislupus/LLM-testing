<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Diffusion-Limited Aggregation (DLA) Simulation – Animated 2D Growth</title>
    <style>
        body { margin:0; background:#000; display:flex; justify-content:center; align-items:center; height:100vh; }
        canvas { box-shadow:0 0 60px rgba(0,255,255,0.6); image-rendering:pixelated; }
        #controls {
            position:absolute; top:20px; left:20px; color:#0ff; font-family:Arial, sans-serif; background:rgba(0,0,0,0.5); padding:15px; border-radius:8px; }
        input[type=range] { width:200px; }
        button { padding:8px 16px; margin-top:10px; background:#0ff; color:#000; border:none; cursor:pointer; }
    </style>
</head>
<body>

<canvas id="c" width="800" height="800"></canvas>

<div id="controls">
    <div>Particles: <input type="range" id="particles" min="20" max="500" step="20" value="150"><span id="pval">150</span></div>
    <div>Bias: <input type="range" id="bias" min="0" max="100" value="25"><span id="bval">0.25</span></div>
    <div>Speed: <input type="range" id="speed" min="1" max="30" value="12"><span id="sval">12</span></div>
    <div>Stuck: <span id="stuckCount">1</span></div>
    <button id="resetBtn">Reset</button>
    <button id="pauseBtn">Pause / Resume</button>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const SIZE = 800;
const CENTER = 400;
let grid = new Uint8Array(SIZE * SIZE); // 0 = empty, 1 stuck
let stuck = []; // {x, y, color}
let moving = [];
let maxR = 0;
let running = true;
let isPaused = false;
let targetParticles = 150;
let biasStrength = 0.25;
let stepsPerFrame = 12;
let hueStart = 200; // start with cyan/blue
const GOLDEN_ANGLE = 137.508; // degrees - perfect for natural rainbow distribution

const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // left, right, up, down

function reset() {
    grid.fill(0);
    stuck = [];
    moving = [];
    maxR = 0;
    running = true;
    isPaused = false;
    hueStart = 200;
    const cx = CENTER, cy = CENTER;
    grid[cx * SIZE + cy] = 1;
    stuck.push({x: cx, y: cy, hue: hueStart});
    for (let i = 0; i < targetParticles; i++) spawn();
    document.getElementById('stuckCount').innerText = '1';
}

function spawn() {
    if (!running || isPaused) return;
    let launchR = Math.max(maxR + 30, 60);
    let angle = Math.random() * Math.PI * 2;
    let x = Math.round(CENTER + launchR * Math.cos(angle));
    let y = Math.round(CENTER + launchR * Math.sin(angle));
    if (x < 0 || x >= SIZE || y < 0 || y >= SIZE) return spawn();
    if (grid[x * SIZE + y] === 1) return spawn(); // extremely rare
    moving.push({x, y});
}

function update() {
    if (!running || isPaused) return;

    while (moving.length < targetParticles) spawn();

    for (let step = 0; step < stepsPerFrame; step++) {
        for (let i = moving.length - 1; i >= 0; i--) {
            const p = moving[i];

            // inward direction signs
            const dx = CENTER - p.x;
            const dy = CENTER - p.y;
            const dirX = dx > 0 ? 1 : (dx < 0 ? -1 : 0);
            const dirY = dy > 0 ? 1 : (dy < 0 ? -1 : 0);

            // weights for directions: left(-x), right(+x), up(-y), down(+y)
            let weights = [1, 1, 1, 1];
            if (dirX > 0) weights[1] += biasStrength; // prefer right
            if (dirX < 0) weights[0] += biasStrength; // prefer left
            if (dirY > 0) weights[3] += biasStrength; // prefer down
            if (dirY < 0) weights[2] += biasStrength; // prefer up

            const totalWeight = weights[0] + weights[1] + weights[2] + weights[3];
            let r = Math.random() * totalWeight;
            let choice = 0;
            let cum = weights[0];
            if (r < cum) choice = 0;
            else { cum += weights[1]; if (r < cum) choice = 1;
            else { cum += weights[2]; if (r < cum) choice = 2;
            else choice = 3; }}

            const [mx, my] = dirs[choice];
            const nx = p.x + mx;
            const ny = p.y + my;

            if (nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE) {
                moving.splice(i, 1);
                spawn();
                continue;
            }

            if (grid[nx * SIZE + ny] === 1) {
                // stick at current position
                grid[p.x * SIZE + p.y] = 1;
                hueStart += GOLDEN_ANGLE;
                const hue = hueStart % 360;
                stuck.push({x: p.x, y: p.y, hue});
                const d = Math.hypot(p.x - CENTER, p.y - CENTER);
                if (d > maxR) maxR = d;
                moving.splice(i, 1);
                spawn();
                document.getElementById('stuckCount').innerText = stuck.length;
                if (maxR >= CENTER - 50) running = false;
                continue;
            }

            // move
            p.x = nx;
            p.y = ny;

            // kill if too far
            if (Math.hypot(nx - CENTER, ny - CENTER) > maxR + 120) {
                moving.splice(i, 1);
                spawn();
            }
        }
    }
}

function draw() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, SIZE, SIZE);

    // draw stuck - rainbow
    for (let p of stuck) {
        ctx.fillStyle = `hsl(${p.hue}, 100%, 50%)`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 1.8, 0, Math.PI * 2);
        ctx.fill();
    }

    // draw moving - white
    ctx.fillStyle = '#ffffff';
    for (let p of moving) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 1.2, 0, Math.PI * 2);
        ctx.fill();
    }

    if (!running) {
        ctx.font = '48px Arial';
        ctx.fillStyle = '#0ff';
        ctx.textAlign = 'center';
        ctx.fillText('Complete – ' + stuck.length + ' particles', CENTER, CENTER + 20);
    }
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

document.getElementById('particles').oninput = e => {
    targetParticles = +e.target.value;
    document.getElementById('pval').innerText = e.target.value;
};
document.getElementById('bias').oninput = e => {
    biasStrength = e.target.value / 100;
    document.getElementById('bval').innerText = e.target.value / 100;
};
document.getElementById('speed').oninput = e => {
    stepsPerFrame = +e.target.value;
    document.getElementById('sval').innerText = e.target.value;
};
document.getElementById('resetBtn').onclick = reset;
document.getElementById('pauseBtn').onclick = () => {
    isPaused = !isPaused;
    if (!isPaused) loop();
};

reset();
loop();
</script>
</body>
</html>