<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diffusion-Limited Aggregation Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #e0e0e0;
        }

        h1 {
            margin-bottom: 20px;
            font-size: 2rem;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
        }

        .container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1200px;
        }

        .canvas-wrapper {
            background: #0f0f23;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        canvas {
            display: block;
            border-radius: 8px;
            background: #000;
        }

        .controls {
            background: #0f0f23;
            border-radius: 12px;
            padding: 20px;
            min-width: 280px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #00d4ff;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #2a2a4a;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
            transition: transform 0.2s;
        }

        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .value-display {
            text-align: right;
            font-size: 0.85rem;
            color: #888;
            margin-top: 5px;
        }

        .stats {
            background: #1a1a3e;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .stats h3 {
            color: #00d4ff;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .stat-item span:first-child {
            color: #888;
        }

        .stat-item span:last-child {
            color: #00ff88;
            font-weight: 600;
        }

        .buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #00d4ff;
            color: #0f0f23;
        }

        .btn-primary:hover {
            background: #00a8cc;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #2a2a4a;
            color: #e0e0e0;
        }

        .btn-secondary:hover {
            background: #3a3a5a;
            transform: translateY(-2px);
        }

        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-size: 0.85rem;
        }

        .status.running {
            background: rgba(0, 255, 136, 0.1);
            color: #00ff88;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .status.stopped {
            background: rgba(255, 100, 100, 0.1);
            color: #ff6464;
            border: 1px solid rgba(255, 100, 100, 0.3);
        }

        .legend {
            margin-top: 15px;
            padding: 10px;
            background: #1a1a3e;
            border-radius: 8px;
            font-size: 0.8rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .instructions {
            margin-top: 15px;
            padding: 10px;
            background: #1a1a3e;
            border-radius: 8px;
            font-size: 0.8rem;
            line-height: 1.6;
        }

        .instructions h4 {
            color: #00d4ff;
            margin-bottom: 8px;
        }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
                align-items: center;
            }

            canvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <h1>Diffusion-Limited Aggregation Simulation</h1>

    <div class="container">
        <div class="canvas-wrapper">
            <canvas id="canvas" width="600" height="600"></canvas>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Initial Particles</label>
                <input type="range" id="initialParticles" min="1" max="500" value="100">
                <div class="value-display" id="initialParticlesValue">100</div>
            </div>

            <div class="control-group">
                <label>Movement Speed</label>
                <input type="range" id="speed" min="1" max="10" value="3">
                <div class="value-display" id="speedValue">3</div>
            </div>

            <div class="control-group">
                <label>Inward Bias Strength</label>
                <input type="range" id="bias" min="0" max="100" value="20">
                <div class="value-display" id="biasValue">20%</div>
            </div>

            <div class="control-group">
                <label>Particle Size</label>
                <input type="range" id="particleSize" min="2" max="8" value="4">
                <div class="value-display" id="particleSizeValue">4px</div>
            </div>

            <div class="control-group">
                <label>Max Active Particles</label>
                <input type="range" id="maxActive" min="10" max="200" value="50">
                <div class="value-display" id="maxActiveValue">50</div>
            </div>

            <div class="buttons">
                <button class="btn-primary" id="startBtn">Start</button>
                <button class="btn-secondary" id="resetBtn">Reset</button>
            </div>

            <div class="status running" id="status">Ready to start</div>

            <div class="stats">
                <h3>Statistics</h3>
                <div class="stat-item">
                    <span>Total Particles:</span>
                    <span id="totalParticles">0</span>
                </div>
                <div class="stat-item">
                    <span>Fixed Particles:</span>
                    <span id="fixedParticles">0</span>
                </div>
                <div class="stat-item">
                    <span>Active Particles:</span>
                    <span id="activeParticles">0</span>
                </div>
                <div class="stat-item">
                    <span>FPS:</span>
                    <span id="fps">0</span>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #00d4ff;"></div>
                    <span>Fixed cluster</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b6b;"></div>
                    <span>Active moving particles</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffd93d;"></div>
                    <span>Newly fixed</span>
                </div>
            </div>

            <div class="instructions">
                <h4>How it works:</h4>
                <p>Diffusion-Limited Aggregation (DLA) is a process where particles diffuse and aggregate into clusters. New particles spawn around the cluster, move randomly with a slight inward bias, and stick when they touch the existing structure.</p>
            </div>
        </div>
    </div>

    <script>
        // DLA Simulation Class
        class DLASimulation {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = canvas.width;
                this.height = canvas.height;

                // Particle storage - using arrays for efficiency
                this.fixedParticles = [];
                this.activeParticles = [];
                this.newlyFixed = [];

                // Settings
                this.settings = {
                    initialParticles: 100,
                    speed: 3,
                    bias: 0.2,
                    particleSize: 4,
                    maxActive: 50,
                    edgeMargin: 50
                };

                // State
                this.isRunning = false;
                this.animationId = null;
                this.lastFrameTime = 0;
                this.frameCount = 0;
                this.fps = 0;
                this.lastFpsUpdate = 0;
                this.growthStopped = false;

                // Performance optimization: spatial hash for collision detection
                this.spatialHash = new Map();
                this.cellSize = this.settings.particleSize * 2;

                this.setupEventListeners();
                this.reset();
            }

            setupEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => this.toggleSimulation());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());

                // Settings changes
                document.getElementById('initialParticles').addEventListener('input', (e) => {
                    this.settings.initialParticles = parseInt(e.target.value);
                    document.getElementById('initialParticlesValue').textContent = e.target.value;
                });

                document.getElementById('speed').addEventListener('input', (e) => {
                    this.settings.speed = parseInt(e.target.value);
                    document.getElementById('speedValue').textContent = e.target.value;
                });

                document.getElementById('bias').addEventListener('input', (e) => {
                    this.settings.bias = parseInt(e.target.value) / 100;
                    document.getElementById('biasValue').textContent = e.target.value + '%';
                });

                document.getElementById('particleSize').addEventListener('input', (e) => {
                    this.settings.particleSize = parseInt(e.target.value);
                    document.getElementById('particleSizeValue').textContent = e.target.value + 'px';
                    this.cellSize = this.settings.particleSize * 2;
                });

                document.getElementById('maxActive').addEventListener('input', (e) => {
                    this.settings.maxActive = parseInt(e.target.value);
                    document.getElementById('maxActiveValue').textContent = e.target.value;
                });
            }

            reset() {
                this.stop();
                this.fixedParticles = [];
                this.activeParticles = [];
                this.newlyFixed = [];
                this.growthStopped = false;
                this.spatialHash.clear();

                // Initialize with center particle(s)
                const centerX = this.width / 2;
                const centerY = this.height / 2;

                // Create initial cluster of particles
                const initialCount = this.settings.initialParticles;
                const radius = Math.sqrt(initialCount) * this.settings.particleSize * 1.5;

                for (let i = 0; i < initialCount; i++) {
                    const angle = (i / initialCount) * Math.PI * 2;
                    const r = radius * Math.sqrt(Math.random()) * 0.5;
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;
                    this.addFixedParticle(x, y);
                }

                // Start with some active particles
                this.spawnInitialActiveParticles();

                this.render();
                this.updateStats();
                this.updateStatus('Ready to start');
            }

            addFixedParticle(x, y) {
                const particle = {
                    x: x,
                    y: y,
                    size: this.settings.particleSize,
                    time: Date.now()
                };
                this.fixedParticles.push(particle);
                this.newlyFixed.push(particle);

                // Update spatial hash
                const key = this.getSpatialKey(x, y);
                if (!this.spatialHash.has(key)) {
                    this.spatialHash.set(key, []);
                }
                this.spatialHash.get(key).push(particle);

                // Clear newly fixed after a short delay
                setTimeout(() => {
                    const index = this.newlyFixed.indexOf(particle);
                    if (index > -1) {
                        this.newlyFixed.splice(index, 1);
                    }
                }, 100);
            }

            getSpatialKey(x, y) {
                const cx = Math.floor(x / this.cellSize);
                const cy = Math.floor(y / this.cellSize);
                return `${cx},${cy}`;
            }

            spawnInitialActiveParticles() {
                const count = Math.min(20, this.settings.maxActive);
                for (let i = 0; i < count; i++) {
                    this.spawnActiveParticle();
                }
            }

            spawnActiveParticle() {
                // Spawn around the cluster edge
                const centerX = this.width / 2;
                const centerY = this.height / 2;

                // Calculate spawn radius based on cluster extent
                let maxDist = 0;
                for (const p of this.fixedParticles) {
                    const dist = Math.sqrt((p.x - centerX) ** 2 + (p.y - centerY) ** 2);
                    maxDist = Math.max(maxDist, dist);
                }

                const spawnRadius = maxDist + 50 + Math.random() * 100;
                const angle = Math.random() * Math.PI * 2;

                const x = centerX + Math.cos(angle) * spawnRadius;
                const y = centerY + Math.sin(angle) * spawnRadius;

                this.activeParticles.push({
                    x: x,
                    y: y,
                    vx: 0,
                    vy: 0,
                    size: this.settings.particleSize
                });
            }

            toggleSimulation() {
                if (this.isRunning) {
                    this.stop();
                } else {
                    this.start();
                }
            }

            start() {
                this.isRunning = true;
                document.getElementById('startBtn').textContent = 'Pause';
                this.updateStatus('Running');
                this.animate();
            }

            stop() {
                this.isRunning = false;
                document.getElementById('startBtn').textContent = 'Start';
                this.updateStatus('Paused');
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }

            animate(currentTime = 0) {
                if (!this.isRunning) return;

                // Calculate FPS
                this.frameCount++;
                if (currentTime - this.lastFpsUpdate >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsUpdate = currentTime;
                }

                // Update simulation
                this.update();
                this.render();
                this.updateStats();

                this.animationId = requestAnimationFrame((t) => this.animate(t));
            }

            update() {
                if (this.growthStopped) return;

                // Check if cluster has reached the edge
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                let maxDist = 0;

                for (const p of this.fixedParticles) {
                    const dist = Math.sqrt((p.x - centerX) ** 2 + (p.y - centerY) ** 2);
                    maxDist = Math.max(maxDist, dist);
                }

                const edgeDistance = this.width / 2 - this.settings.edgeMargin;
                if (maxDist >= edgeDistance) {
                    this.growthStopped = true;
                    this.updateStatus('Growth stopped - cluster reached edge');
                    this.stop();
                    return;
                }

                // Update active particles
                const toRemove = [];

                for (let i = 0; i < this.activeParticles.length; i++) {
                    const particle = this.activeParticles[i];

                    // Random walk with inward bias
                    const speed = this.settings.speed * 0.5;

                    // Random movement
                    let dx = (Math.random() - 0.5) * 2 * speed;
                    let dy = (Math.random() - 0.5) * 2 * speed;

                    // Inward bias
                    const toCenterX = centerX - particle.x;
                    const toCenterY = centerY - particle.y;
                    const toCenterDist = Math.sqrt(toCenterX ** 2 + toCenterY ** 2);

                    if (toCenterDist > 0) {
                        dx += (toCenterX / toCenterDist) * speed * this.settings.bias;
                        dy += (toCenterY / toCenterDist) * speed * this.settings.bias;
                    }

                    particle.x += dx;
                    particle.y += dy;

                    // Keep within bounds
                    particle.x = Math.max(particle.size, Math.min(this.width - particle.size, particle.x));
                    particle.y = Math.max(particle.size, Math.min(this.height - particle.size, particle.y));

                    // Check collision with fixed particles
                    if (this.checkCollision(particle)) {
                        this.addFixedParticle(particle.x, particle.y);
                        toRemove.push(i);

                        // Spawn new active particle
                        if (this.activeParticles.length < this.settings.maxActive) {
                            this.spawnActiveParticle();
                        }
                    }

                    // Respawn if too far outside
                    const distFromCenter = Math.sqrt((particle.x - centerX) ** 2 + (particle.y - centerY) ** 2);
                    if (distFromCenter > maxDist + 200) {
                        this.spawnActiveParticle();
                        toRemove.push(i);
                    }
                }

                // Remove collided particles (in reverse order to maintain indices)
                for (let i = toRemove.length - 1; i >= 0; i--) {
                    this.activeParticles.splice(toRemove[i], 1);
                }

                // Maintain minimum active particles
                while (this.activeParticles.length < Math.min(10, this.settings.maxActive)) {
                    this.spawnActiveParticle();
                }
            }

            checkCollision(particle) {
                const searchRadius = particle.size + this.settings.particleSize;
                const cx = Math.floor(particle.x / this.cellSize);
                const cy = Math.floor(particle.y / this.cellSize);

                // Check neighboring cells
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const key = `${cx + dx},${cy + dy}`;
                        const neighbors = this.spatialHash.get(key);

                        if (neighbors) {
                            for (const fixed of neighbors) {
                                const dist = Math.sqrt(
                                    (particle.x - fixed.x) ** 2 +
                                    (particle.y - fixed.y) ** 2
                                );

                                if (dist < searchRadius) {
                                    return true;
                                }
                            }
                        }
                    }
                }

                return false;
            }

            render() {
                const ctx = this.ctx;

                // Clear canvas with fade effect for trails
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, this.width, this.height);

                // Draw fixed particles
                for (const particle of this.fixedParticles) {
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);

                    // Check if newly fixed
                    if (this.newlyFixed.includes(particle)) {
                        ctx.fillStyle = '#ffd93d';
                        ctx.shadowColor = '#ffd93d';
                        ctx.shadowBlur = 10;
                    } else {
                        ctx.fillStyle = '#00d4ff';
                        ctx.shadowColor = '#00d4ff';
                        ctx.shadowBlur = 5;
                    }

                    ctx.fill();
                }

                // Draw active particles
                ctx.shadowBlur = 0;
                for (const particle of this.activeParticles) {
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fillStyle = '#ff6b6b';
                    ctx.fill();
                }

                // Draw edge boundary
                ctx.strokeStyle = 'rgba(255, 100, 100, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(this.width / 2, this.height / 2,
                       this.width / 2 - this.settings.edgeMargin, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            updateStats() {
                document.getElementById('totalParticles').textContent = this.fixedParticles.length;
                document.getElementById('fixedParticles').textContent = this.fixedParticles.length - this.newlyFixed.length;
                document.getElementById('activeParticles').textContent = this.activeParticles.length;
                document.getElementById('fps').textContent = this.fps;
            }

            updateStatus(message) {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = this.isRunning ? 'status running' : 'status stopped';
            }
        }

        // Initialize simulation when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('canvas');
            window.simulation = new DLASimulation(canvas);
        });
    </script>

<script>
/**
 * Iframe 元素高亮注入脚本
 * 需要在目标网站中引入此脚本来支持跨域 iframe 高亮功能
 *
 * 使用方法：
 * 1. 将此脚本添加到目标网站的 HTML 中
 * 2. 或通过浏览器扩展、用户脚本等方式注入
 */

(function () {
  "use strict";

  // 检查是否在 iframe 中
  if (window.self === window.top) {
    return; // 不在 iframe 中，不执行
  }

  // 检查是否已经初始化过
  if (window.__iframeHighlightInitialized) {
    return;
  }
  window.__iframeHighlightInitialized = true;
  console.log("Iframe 高亮脚本已加载");

  // 创建高亮覆盖层
  var overlay = document.createElement("div");
  overlay.id = "iframe-highlight-overlay";
  overlay.style.cssText = "\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n    pointer-events: none;\n    z-index: 999999;\n    overflow: hidden;\n  ";

  // 创建悬停高亮框（虚线边框）
  var highlightBox = document.createElement("div");
  highlightBox.id = "iframe-highlight-box";
  highlightBox.style.cssText = "\n    position: absolute;\n    border: 2px dashed #007AFF;\n    background: rgba(0, 122, 255, 0.08);\n    pointer-events: none;\n    display: none;\n    transition: all 0.1s ease;\n    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.8);\n    border-radius: 2px;\n  ";

  // 创建选中节点的常驻高亮框（实线边框）
  var selectedBox = document.createElement("div");
  selectedBox.id = "iframe-selected-box";
  selectedBox.style.cssText = "\n    position: absolute;\n    border: 2px solid #007AFF;\n    pointer-events: none;\n    display: none;\n    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.9), 0 0 8px rgba(255, 107, 53, 0.4);\n    border-radius: 2px;\n    z-index: 1000000;\n  ";

  // 创建悬停标签显示
  var tagLabel = document.createElement("div");
  tagLabel.id = "iframe-tag-label";
  tagLabel.style.cssText = "\n    position: absolute;\n    background: #007AFF;\n    color: white;\n    padding: 2px 6px;\n    font-size: 11px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    border-radius: 2px;\n    pointer-events: none;\n    display: none;\n    white-space: nowrap;\n    z-index: 1000001;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    font-weight: 500;\n  ";

  // 创建选中节点标签
  var selectedLabel = document.createElement("div");
  selectedLabel.id = "iframe-selected-label";
  selectedLabel.style.cssText = "\n    position: absolute;\n    background: #007AFF;\n    color: white;\n    padding: 3px 8px;\n    font-size: 11px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    border-radius: 3px;\n    pointer-events: none;\n    display: none;\n    white-space: nowrap;\n    z-index: 1000002;\n    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);\n    font-weight: 600;\n  ";
  overlay.appendChild(highlightBox);
  overlay.appendChild(selectedBox);
  overlay.appendChild(tagLabel);
  overlay.appendChild(selectedLabel);
  document.body.appendChild(overlay);

  // 存储当前选中的元素
  var selectedElement = null;
  var highlightEnabled = false;

  // 更新选中元素的高亮显示
  function updateSelectedHighlight(element) {
    console.log("updateSelectedHighlight called with:", element);
    if (!element) {
      selectedBox.style.display = "none";
      selectedLabel.style.display = "none";
      selectedElement = null;
      console.log("Cleared selected highlight");
      return;
    }
    selectedElement = element;
    var rect = element.getBoundingClientRect();
    console.log("Selected element rect:", rect);

    // 更新选中高亮框位置
    selectedBox.style.display = "block";
    selectedBox.style.left = "".concat(rect.left - 2, "px");
    selectedBox.style.top = "".concat(rect.top - 2, "px");
    selectedBox.style.width = "".concat(rect.width + 4, "px");
    selectedBox.style.height = "".concat(rect.height + 4, "px");

    // 更新选中标签位置和内容
    selectedLabel.style.display = "block";
    selectedLabel.textContent = "\u2713 <".concat(element.tagName.toLowerCase(), ">");

    // 计算标签位置，确保不超出视窗
    var labelTop = rect.top - 28;
    var labelLeft = rect.left;

    // 如果标签会超出顶部，显示在元素下方
    if (labelTop < 5) {
      labelTop = rect.bottom + 5;
    }

    // 如果标签会超出右侧，向左调整
    var labelWidth = selectedLabel.offsetWidth || 100; // 预估宽度
    if (labelLeft + labelWidth > window.innerWidth - 10) {
      labelLeft = window.innerWidth - labelWidth - 10;
    }
    selectedLabel.style.left = "".concat(Math.max(5, labelLeft), "px");
    selectedLabel.style.top = "".concat(labelTop, "px");
    console.log("Selected highlight positioned at:", {
      left: selectedBox.style.left,
      top: selectedBox.style.top,
      width: selectedBox.style.width,
      height: selectedBox.style.height
    });
  }
  function getElementSelector(element) {
    if (!(element instanceof Element)) throw new Error('Argument must be a DOM element');
    var segments = [];
    var current = element;
    while (current !== document.documentElement) {
      var selector = '';
      // 优先检查唯一ID
      if (current.id && document.querySelectorAll("#".concat(current.id)).length === 1) {
        segments.unshift("#".concat(current.id));
        break; // ID唯一，无需继续向上
      }

      // 生成类名选择器（取第一个有效类名）
      var classes = Array.from(current.classList).filter(function (c) {
        return !c.startsWith('js-');
      });
      var className = classes.length > 0 ? ".".concat(classes[0]) : '';

      // 生成位置索引（nth-child）
      var tag = current.tagName.toLowerCase();
      if (!className) {
        var siblings = Array.from(current.parentNode.children);
        var index = siblings.findIndex(function (el) {
          return el === current;
        }) + 1;
        selector = "".concat(tag, ":nth-child(").concat(index, ")");
      } else {
        selector = className;
      }
      segments.unshift(selector);
      current = current.parentElement;
    }

    // 处理根元素
    if (current === document.documentElement) {
      segments.unshift('html');
    }
    return segments.join(' > ');
  }

  // 获取元素文本内容
  function getElementText(element) {
    var _element$textContent;
    if (element.tagName === "INPUT") {
      return element.value || element.placeholder || "";
    }
    if (element.tagName === "TEXTAREA") {
      return element.value || element.placeholder || "";
    }
    var text = ((_element$textContent = element.textContent) === null || _element$textContent === void 0 ? void 0 : _element$textContent.trim()) || "";
    return text.length > 50 ? text.substring(0, 50) + "..." : text;
  }

  // 获取元素属性信息
  function getElementAttributes(element) {
    var attrs = {};
    for (var i = 0; i < element.attributes.length; i++) {
      var attr = element.attributes[i];
      attrs[attr.name] = attr.value;
    }
    return attrs;
  }

  // 鼠标悬停事件处理
  function handleMouseOver(e) {
    if (!highlightEnabled) return;
    var target = e.target;
    if (!target || target === overlay || target === highlightBox || target === tagLabel || target === selectedBox || target === selectedLabel) {
      return;
    }

    // 避免高亮 html 和 body 元素
    if (target === document.documentElement || target === document.body) {
      return;
    }

    // 如果是已选中的元素，不显示悬停高亮
    if (target === selectedElement) {
      highlightBox.style.display = "none";
      tagLabel.style.display = "none";
      return;
    }
    var rect = target.getBoundingClientRect();
    var selector = getElementSelector(target);
    var text = getElementText(target);
    var attributes = getElementAttributes(target);

    // 更新悬停高亮框位置
    highlightBox.style.display = "block";
    highlightBox.style.left = "".concat(rect.left - 2, "px");
    highlightBox.style.top = "".concat(rect.top - 2, "px");
    highlightBox.style.width = "".concat(rect.width + 4, "px");
    highlightBox.style.height = "".concat(rect.height + 4, "px");

    // 更新标签位置和内容
    tagLabel.style.display = "block";
    tagLabel.textContent = "<".concat(target.tagName.toLowerCase(), ">");

    // 计算标签位置，确保不超出视窗
    var labelTop = rect.top - 22;
    var labelLeft = rect.left;

    // 如果标签会超出顶部，显示在元素下方
    if (labelTop < 0) {
      labelTop = rect.bottom + 5;
    }

    // 如果标签会超出右侧，向左调整
    if (labelLeft + tagLabel.offsetWidth > window.innerWidth) {
      labelLeft = window.innerWidth - tagLabel.offsetWidth - 5;
    }
    tagLabel.style.left = "".concat(Math.max(0, labelLeft), "px");
    tagLabel.style.top = "".concat(labelTop, "px");

    // 发送消息到父窗口
    var elementInfo = {
      tagName: target.tagName.toLowerCase(),
      rect: {
        left: rect.left,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.width,
        height: rect.height,
        x: rect.x,
        y: rect.y
      },
      selector: selector,
      text: text,
      attributes: attributes,
      url: window.location.href,
      path: window.location.pathname,
      timestamp: Date.now()
    };
    try {
      window.parent.postMessage({
        type: "iframe-element-hover",
        data: elementInfo,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("无法发送消息到父窗口:", error);
    }
  }

  // 鼠标离开事件处理
  function handleMouseOut(e) {
    if (!highlightEnabled) return;
    var relatedTarget = e.relatedTarget;

    // 如果鼠标移动到高亮相关元素上，不隐藏高亮
    if (relatedTarget && (relatedTarget === highlightBox || relatedTarget === tagLabel || relatedTarget === overlay || relatedTarget === selectedBox || relatedTarget === selectedLabel)) {
      return;
    }
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    try {
      window.parent.postMessage({
        type: "iframe-element-hover",
        data: null,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("无法发送消息到父窗口:", error);
    }
  }

  // 点击事件处理
  function handleClick(e) {
    var target = e.target;
    if (!target || target === overlay || target === highlightBox || target === tagLabel || target === selectedBox || target === selectedLabel) {
      return;
    }

    // 避免处理 html 和 body 元素
    if (target === document.documentElement || target === document.body) {
      return;
    }

    // 检查是否是交互元素，这些元素需要保留默认行为
    var isInteractiveElement = ['input', 'textarea', 'select', 'button', 'a'].includes(target.tagName.toLowerCase());

    // 如果高亮功能启用，对于非交互元素阻止默认行为和事件传播
    if (highlightEnabled) {
      e.preventDefault();
      e.stopPropagation();
    }
    var rect = target.getBoundingClientRect();
    var selector = getElementSelector(target);
    var text = getElementText(target);
    var attributes = getElementAttributes(target);
    console.log("Element clicked:", {
      tagName: target.tagName,
      selector: selector,
      rect: rect
    });

    // 立即更新选中高亮
    updateSelectedHighlight(target);

    // 隐藏悬停高亮，因为现在是选中状态
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    var elementInfo = {
      tagName: target.tagName.toLowerCase(),
      rect: {
        left: rect.left,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.width,
        height: rect.height,
        x: rect.x,
        y: rect.y
      },
      selector: selector,
      text: text,
      attributes: attributes,
      url: window.location.href,
      path: window.location.pathname,
      timestamp: Date.now()
    };
    try {
      window.parent.postMessage({
        type: "iframe-element-click",
        data: elementInfo,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("无法发送消息到父窗口:", error);
    }
  }

  // 监听来自父窗口的消息
  function handleParentMessage(event) {
    console.log("Received message from parent:", event.data);
    if (event.data.type === "iframe-highlight-toggle") {
      var enabled = event.data.enabled;
      console.log("Highlight toggle:", enabled);
      if (enabled) {
        enableHighlight();
      } else {
        disableHighlight();
      }
    } else if (event.data.type === "enable-iframe-highlight") {
      console.log("Enable iframe highlight");
      enableHighlight();
    } else if (event.data.type === "disable-iframe-highlight") {
      console.log("Disable iframe highlight");
      disableHighlight();
    } else if (event.data.type === "toggle-iframe-highlight") {
      var _enabled = event.data.enabled !== undefined ? event.data.enabled : !highlightEnabled;
      console.log("Toggle iframe highlight to:", _enabled);
      if (_enabled) {
        enableHighlight();
      } else {
        disableHighlight();
      }
    } else if (event.data.type === "update-selected-element") {
      var selector = event.data.selector;
      console.log("Update selected element with selector:", selector);
      if (selector) {
        try {
          var element = document.querySelector(selector);
          console.log("Found element by selector:", element);
          updateSelectedHighlight(element);
        } catch (error) {
          console.warn("Failed to select element:", error);
          updateSelectedHighlight(null);
        }
      } else {
        updateSelectedHighlight(null);
      }
    } else if (event.data.type === "clear-selected-element") {
      console.log("Clear selected element");
      updateSelectedHighlight(null);
    }
  }

  // 启用高亮功能
  function enableHighlight() {
    console.log("Enabling highlight");
    document.addEventListener("mouseover", handleMouseOver, true);
    document.addEventListener("mouseout", handleMouseOut, true);
    document.addEventListener("click", handleClick, true);
    highlightEnabled = true;
    overlay.style.display = "block";
  }

  // 禁用高亮功能
  function disableHighlight() {
    console.log("Disabling highlight");
    highlightEnabled = false;
    // 保持事件监听器，但通过 highlightEnabled 变量控制行为
    // 这样可以保留选中状态的显示
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    // 不隐藏 selectedBox 和 selectedLabel，保留选中状态
  }

  // 完全禁用高亮功能（移除所有监听器）
  function fullyDisableHighlight() {
    console.log("Fully disabling highlight");
    highlightEnabled = false;
    document.removeEventListener("mouseover", handleMouseOver, true);
    document.removeEventListener("mouseout", handleMouseOut, true);
    document.removeEventListener("click", handleClick, true);
    overlay.style.display = "none";
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    selectedBox.style.display = "none";
    selectedLabel.style.display = "none";
  }

  // 添加事件监听
  enableHighlight();
  window.addEventListener("message", handleParentMessage);

  // 暴露全局函数供外部调用
  window.__iframeHighlightControl = {
    enable: enableHighlight,
    disable: disableHighlight,
    fullyDisable: fullyDisableHighlight,
    isEnabled: function isEnabled() {
      return highlightEnabled;
    },
    getSelectedElement: function getSelectedElement() {
      return selectedElement;
    },
    updateSelected: updateSelectedHighlight,
    // 通过消息发送开关控制
    sendToggleMessage: function sendToggleMessage(enabled) {
      window.parent.postMessage({
        type: 'iframe-highlight-status',
        enabled: enabled || highlightEnabled,
        source: 'iframe-highlight-injector'
      }, '*');
    }
  };

  // 通知父窗口脚本已加载
  try {
    window.parent.postMessage({
      type: "iframe-highlight-ready",
      data: {
        url: window.location.href,
        userAgent: navigator.userAgent,
        timestamp: Date.now()
      },
      source: "iframe-highlight-injector"
    }, "*");
  } catch (error) {
    console.warn("无法发送就绪消息到父窗口:", error);
  }

  // 清理函数
  window.__iframeHighlightCleanup = function () {
    fullyDisableHighlight();
    window.removeEventListener("message", handleParentMessage);
    if (overlay.parentElement) {
      overlay.parentElement.removeChild(overlay);
    }
    delete window.__iframeHighlightInitialized;
    delete window.__iframeHighlightCleanup;
  };
})();

</script>
</body>
</html>
