<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Diffusion-Limited Aggregation (DLA) Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0c0c2e 0%, #1a1a3e 100%);
            color: #e0e0ff;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        header {
            text-align: center;
            margin-bottom: 25px;
            padding: 20px;
            width: 100%;
            background: rgba(20, 20, 60, 0.8);
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid #3a3a8a;
        }
        
        h1 {
            color: #7eb6ff;
            margin-bottom: 8px;
            font-size: 2.5rem;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        
        .subtitle {
            color: #b0b0ff;
            font-size: 1.1rem;
            margin-bottom: 15px;
        }
        
        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            width: 100%;
            justify-content: center;
        }
        
        .simulation-area {
            flex: 1;
            min-width: 600px;
            background: rgba(15, 15, 45, 0.9);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            border: 1px solid #3a3a8a;
            display: flex;
            flex-direction: column;
        }
        
        .canvas-container {
            position: relative;
            flex: 1;
            border-radius: 8px;
            overflow: hidden;
            background: #0a0a20;
            border: 2px solid #4a4aaa;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .status-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(10, 10, 30, 0.85);
            padding: 12px 18px;
            border-radius: 8px;
            border: 1px solid #5a5acc;
            font-size: 0.95rem;
            color: #d0d0ff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .status-item {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
            min-width: 180px;
        }
        
        .status-value {
            color: #7eb6ff;
            font-weight: bold;
        }
        
        .controls-panel {
            flex: 0 0 300px;
            background: rgba(15, 15, 45, 0.9);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            border: 1px solid #3a3a8a;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        .control-title {
            color: #7eb6ff;
            margin-bottom: 15px;
            font-size: 1.3rem;
            padding-bottom: 8px;
            border-bottom: 1px solid #3a3a8a;
        }
        
        .slider-container {
            margin-bottom: 20px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            color: #d0d0ff;
        }
        
        .slider-value {
            color: #7eb6ff;
            font-weight: bold;
        }
        
        .slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, #3a3a8a, #7eb6ff);
            border-radius: 4px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #7eb6ff;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(126, 182, 255, 0.8);
        }
        
        .buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        button {
            flex: 1;
            min-width: 120px;
            padding: 14px 20px;
            background: linear-gradient(to bottom, #3a3a8a, #2a2a6a);
            color: #e0e0ff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            border: 1px solid #5a5acc;
        }
        
        button:hover {
            background: linear-gradient(to bottom, #4a4aaa, #3a3a8a);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.primary {
            background: linear-gradient(to bottom, #2a8a5a, #1a6a3a);
            border-color: #3acc7a;
        }
        
        button.primary:hover {
            background: linear-gradient(to bottom, #3aaa6a, #2a8a5a);
        }
        
        button.reset {
            background: linear-gradient(to bottom, #8a2a2a, #6a1a1a);
            border-color: #cc3a3a;
        }
        
        button.reset:hover {
            background: linear-gradient(to bottom, #aa3a3a, #8a2a2a);
        }
        
        .info-panel {
            margin-top: 25px;
            width: 100%;
            background: rgba(15, 15, 45, 0.9);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            border: 1px solid #3a3a8a;
        }
        
        .info-title {
            color: #7eb6ff;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }
        
        .info-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        
        .info-item {
            background: rgba(25, 25, 65, 0.7);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #7eb6ff;
        }
        
        .info-item h4 {
            color: #b0b0ff;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }
        
        .info-item p {
            color: #d0d0ff;
            font-size: 0.95rem;
            line-height: 1.5;
        }
        
        .growth-boundary {
            position: absolute;
            top: 50px;
            left: 50px;
            right: 50px;
            bottom: 50px;
            border: 1px dashed rgba(126, 182, 255, 0.5);
            pointer-events: none;
        }
        
        .footer {
            margin-top: 25px;
            text-align: center;
            color: #a0a0cc;
            font-size: 0.9rem;
            padding: 15px;
        }
        
        @media (max-width: 1000px) {
            .content {
                flex-direction: column;
            }
            
            .simulation-area, .controls-panel {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>2D Diffusion-Limited Aggregation (DLA) Simulation</h1>
            <p class="subtitle">Watch particles randomly walk and stick to form fractal structures in real-time</p>
        </header>
        
        <div class="content">
            <div class="simulation-area">
                <div class="canvas-container">
                    <canvas id="dlaCanvas"></canvas>
                    <div class="growth-boundary" id="boundary"></div>
                    <div class="status-overlay">
                        <div class="status-item">
                            <span>Active Particles:</span>
                            <span id="activeCount" class="status-value">100</span>
                        </div>
                        <div class="status-item">
                            <span>Fixed Particles:</span>
                            <span id="fixedCount" class="status-value">1</span>
                        </div>
                        <div class="status-item">
                            <span>Cluster Radius:</span>
                            <span id="clusterRadius" class="status-value">0 px</span>
                        </div>
                        <div class="status-item">
                            <span>Growth Status:</span>
                            <span id="growthStatus" class="status-value">Growing</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="controls-panel">
                <h2 class="control-title">Simulation Controls</h2>
                
                <div class="control-group">
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Particle Count:</span>
                            <span id="particleCountValue" class="slider-value">100</span>
                        </div>
                        <input type="range" min="10" max="500" value="100" class="slider" id="particleCountSlider">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Movement Speed:</span>
                            <span id="speedValue" class="slider-value">2.0</span>
                        </div>
                        <input type="range" min="0.5" max="5" step="0.1" value="2.0" class="slider" id="speedSlider">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Inward Bias Strength:</span>
                            <span id="biasValue" class="slider-value">0.3</span>
                        </div>
                        <input type="range" min="0" max="1" step="0.05" value="0.3" class="slider" id="biasSlider">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Particle Size:</span>
                            <span id="sizeValue" class="slider-value">3 px</span>
                        </div>
                        <input type="range" min="1" max="8" step="0.5" value="3" class="slider" id="sizeSlider">
                    </div>
                </div>
                
                <div class="buttons">
                    <button id="startBtn" class="primary">Start / Resume</button>
                    <button id="pauseBtn">Pause</button>
                    <button id="resetBtn" class="reset">Reset Simulation</button>
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <h2 class="info-title">About Diffusion-Limited Aggregation</h2>
            <div class="info-content">
                <div class="info-item">
                    <h4>What is DLA?</h4>
                    <p>DLA is a process where particles undergoing random walks cluster together to form fractal, branching structures. It's used to model phenomena like electrodeposition, coral growth, and snowflake formation.</p>
                </div>
                <div class="info-item">
                    <h4>How it Works</h4>
                    <p>Particles start at the canvas edge and move randomly with a slight bias toward the center. When a particle touches the existing cluster, it sticks in place. A new particle then spawns to maintain the active particle count.</p>
                </div>
                <div class="info-item">
                    <h4>Parameters Explained</h4>
                    <p><strong>Inward Bias:</strong> Controls how strongly particles are drawn toward the center. <strong>Movement Speed:</strong> How fast particles move each frame. <strong>Particle Count:</strong> Number of active particles simultaneously moving.</p>
                </div>
                <div class="info-item">
                    <h4>Stopping Condition</h4>
                    <p>Growth stops automatically when the cluster reaches within 50 pixels of any canvas edge. This boundary is shown as a dashed rectangle in the simulation.</p>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p>2D DLA Simulation | Particles move randomly with inward bias and stick upon contact | Built with HTML5 Canvas & JavaScript</p>
        </div>
    </div>

    <script>
        // Canvas and context setup
        const canvas = document.getElementById('dlaCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas dimensions
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        
        // Initialize canvas size
        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);
        
        // Simulation parameters
        let params = {
            particleCount: 100,
            movementSpeed: 2.0,
            inwardBias: 0.3,
            particleSize: 3,
            isRunning: true,
            growthStopped: false
        };
        
        // Simulation state
        let activeParticles = [];
        let fixedParticles = [];
        let animationId = null;
        let clusterRadius = 0;
        let centerX, centerY;
        
        // Boundary for growth (50px from edges)
        let boundary = {
            top: 50,
            right: 50,
            bottom: 50,
            left: 50
        };
        
        // Particle class
        class Particle {
            constructor(isFixed = false, x = null, y = null) {
                this.isFixed = isFixed;
                this.size = params.particleSize;
                
                if (isFixed) {
                    // Fixed particle at center for initial seed
                    this.x = centerX;
                    this.y = centerY;
                    this.color = '#7eb6ff';
                } else {
                    // Create a new moving particle at a random edge
                    this.x = x !== null ? x : this.getRandomEdgePosition().x;
                    this.y = y !== null ? y : this.getRandomEdgePosition().y;
                    this.color = this.getRandomParticleColor();
                }
            }
            
            getRandomEdgePosition() {
                const edge = Math.floor(Math.random() * 4);
                const padding = 10;
                
                switch(edge) {
                    case 0: // Top edge
                        return { x: Math.random() * canvas.width, y: padding };
                    case 1: // Right edge
                        return { x: canvas.width - padding, y: Math.random() * canvas.height };
                    case 2: // Bottom edge
                        return { x: Math.random() * canvas.width, y: canvas.height - padding };
                    case 3: // Left edge
                        return { x: padding, y: Math.random() * canvas.height };
                }
            }
            
            getRandomParticleColor() {
                const colors = ['#ff7eb6', '#7effb6', '#ffb67e', '#b67eff', '#7eb6ff'];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            move() {
                if (this.isFixed) return;
                
                // Random movement with bias toward center
                const randomAngle = Math.random() * Math.PI * 2;
                const biasAngle = Math.atan2(centerY - this.y, centerX - this.x);
                
                // Combine random movement with bias
                const combinedAngle = randomAngle * (1 - params.inwardBias) + biasAngle * params.inwardBias;
                
                // Update position
                this.x += Math.cos(combinedAngle) * params.movementSpeed;
                this.y += Math.sin(combinedAngle) * params.movementSpeed;
                
                // Keep particle within canvas bounds
                this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));
            }
            
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // Add a subtle glow for fixed particles
                if (this.isFixed) {
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 5;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
            
            // Check if particle touches any fixed particle
            checkStick() {
                if (this.isFixed) return false;
                
                for (const fixedParticle of fixedParticles) {
                    const dx = this.x - fixedParticle.x;
                    const dy = this.y - fixedParticle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.size + fixedParticle.size + 1) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // Check if particle is near the boundary
            isNearBoundary() {
                return (
                    this.x < boundary.left + 20 || 
                    this.x > canvas.width - boundary.right - 20 ||
                    this.y < boundary.top + 20 || 
                    this.y > canvas.height - boundary.bottom - 20
                );
            }
        }
        
        // Initialize simulation
        function initSimulation() {
            // Clear existing particles
            activeParticles = [];
            fixedParticles = [];
            
            // Calculate center
            centerX = canvas.width / 2;
            centerY = canvas.height / 2;
            
            // Create initial fixed particle at center
            fixedParticles.push(new Particle(true));
            
            // Create initial active particles
            for (let i = 0; i < params.particleCount; i++) {
                activeParticles.push(new Particle(false));
            }
            
            // Update status display
            updateStatus();
            
            // Start animation if not already running
            if (!animationId) {
                animate();
            }
        }
        
        // Main animation loop
        function animate() {
            if (!params.isRunning) {
                animationId = null;
                return;
            }
            
            // Clear canvas with a subtle fade effect for trailing motion
            ctx.fillStyle = 'rgba(10, 10, 32, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw boundary
            drawBoundary();
            
            // Move and draw active particles
            for (let i = activeParticles.length - 1; i >= 0; i--) {
                const particle = activeParticles[i];
                
                // Move particle
                particle.move();
                
                // Check if particle should stick to cluster
                if (particle.checkStick()) {
                    // Convert to fixed particle
                    particle.isFixed = true;
                    particle.color = '#7eb6ff';
                    particle.size = params.particleSize;
                    
                    // Move to fixed particles array
                    fixedParticles.push(particle);
                    activeParticles.splice(i, 1);
                    
                    // Spawn a new particle if growth hasn't stopped
                    if (!params.growthStopped) {
                        activeParticles.push(new Particle(false));
                    }
                    
                    // Update cluster radius
                    updateClusterRadius();
                    
                    // Check if growth should stop (cluster reached boundary)
                    if (clusterRadius > Math.min(
                        canvas.width/2 - boundary.right, 
                        canvas.height/2 - boundary.bottom
                    ) - 20) {
                        params.growthStopped = true;
                        document.getElementById('growthStatus').textContent = 'Stopped (Boundary Reached)';
                        document.getElementById('growthStatus').style.color = '#ff7e7e';
                    }
                }
                
                // Draw particle
                particle.draw();
            }
            
            // Draw fixed particles
            for (const particle of fixedParticles) {
                particle.draw();
            }
            
            // Update status display
            updateStatus();
            
            // Continue animation
            animationId = requestAnimationFrame(animate);
        }
        
        // Draw growth boundary
        function drawBoundary() {
            ctx.strokeStyle = 'rgba(126, 182, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(
                boundary.left, 
                boundary.top, 
                canvas.width - boundary.left - boundary.right, 
                canvas.height - boundary.top - boundary.bottom
            );
            ctx.setLineDash([]);
            
            // Update boundary element position
            const boundaryEl = document.getElementById('boundary');
            boundaryEl.style.left = `${boundary.left}px`;
            boundaryEl.style.top = `${boundary.top}px`;
            boundaryEl.style.right = `${boundary.right}px`;
            boundaryEl.style.bottom = `${boundary.bottom}px`;
        }
        
        // Update cluster radius (distance from center to farthest fixed particle)
        function updateClusterRadius() {
            clusterRadius = 0;
            
            for (const particle of fixedParticles) {
                const dx = particle.x - centerX;
                const dy = particle.y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > clusterRadius) {
                    clusterRadius = distance;
                }
            }
        }
        
        // Update status display
        function updateStatus() {
            document.getElementById('activeCount').textContent = activeParticles.length;
            document.getElementById('fixedCount').textContent = fixedParticles.length;
            document.getElementById('clusterRadius').textContent = `${Math.round(clusterRadius)} px`;
            
            if (!params.growthStopped) {
                document.getElementById('growthStatus').textContent = 'Growing';
                document.getElementById('growthStatus').style.color = '#7eb6ff';
            }
        }
        
        // Event listeners for controls
        document.getElementById('particleCountSlider').addEventListener('input', function() {
            const value = parseInt(this.value);
            document.getElementById('particleCountValue').textContent = value;
            params.particleCount = value;
            
            // Adjust active particles count
            const diff = value - activeParticles.length;
            if (diff > 0) {
                // Add more particles
                for (let i = 0; i < diff; i++) {
                    activeParticles.push(new Particle(false));
                }
            } else if (diff < 0) {
                // Remove particles (remove from end)
                activeParticles.splice(diff, -diff);
            }
        });
        
        document.getElementById('speedSlider').addEventListener('input', function() {
            const value = parseFloat(this.value);
            document.getElementById('speedValue').textContent = value.toFixed(1);
            params.movementSpeed = value;
        });
        
        document.getElementById('biasSlider').addEventListener('input', function() {
            const value = parseFloat(this.value);
            document.getElementById('biasValue').textContent = value.toFixed(2);
            params.inwardBias = value;
        });
        
        document.getElementById('sizeSlider').addEventListener('input', function() {
            const value = parseFloat(this.value);
            document.getElementById('sizeValue').textContent = `${value} px`;
            params.particleSize = value;
            
            // Update size of all particles
            for (const particle of activeParticles) {
                particle.size = value;
            }
            for (const particle of fixedParticles) {
                particle.size = value;
            }
        });
        
        document.getElementById('startBtn').addEventListener('click', function() {
            params.isRunning = true;
            if (!animationId) {
                animate();
            }
        });
        
        document.getElementById('pauseBtn').addEventListener('click', function() {
            params.isRunning = false;
        });
        
        document.getElementById('resetBtn').addEventListener('click', function() {
            params.growthStopped = false;
            initSimulation();
        });
        
        // Initialize simulation when page loads
        window.addEventListener('load', function() {
            resizeCanvas();
            initSimulation();
        });
        
        // Handle visibility change to pause animation when tab is not visible
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                params.isRunning = false;
            }
        });
    </script>
</body>
</html>