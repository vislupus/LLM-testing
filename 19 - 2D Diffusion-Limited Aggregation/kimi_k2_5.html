<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diffusion-Limited Aggregation (DLA)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0a0a0a; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; box-shadow: 0 0 30px rgba(0,0,0,0.8); }
        .glass-panel {
            background: rgba(20, 20, 25, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .slider {
            -webkit-appearance: none; width: 100%; background: transparent;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: #a855f7; cursor: pointer; margin-top: -5px;
        }
        .slider::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #374151; border-radius: 2px;
        }
    </style>
</head>
<body>

    <!-- UI Overlay -->
    <div class="absolute top-4 left-4 w-72 glass-panel rounded-xl p-5 text-gray-200 z-10 select-none">
        <h1 class="text-xl font-bold text-purple-400 mb-1">DLA Simulation</h1>
        <p class="text-xs text-gray-500 mb-4">Diffusion-Limited Aggregation</p>

        <!-- Stats -->
        <div class="grid grid-cols-2 gap-2 mb-4 text-xs">
            <div class="bg-gray-800 p-2 rounded border border-gray-700">
                <div class="text-gray-500">Cluster Size</div>
                <div id="stat-size" class="font-mono text-purple-300 text-lg">1</div>
            </div>
            <div class="bg-gray-800 p-2 rounded border border-gray-700">
                <div class="text-gray-500">Active</div>
                <div id="stat-active" class="font-mono text-cyan-300 text-lg">100</div>
            </div>
        </div>

        <!-- Controls -->
        <div class="space-y-3">
            <div>
                <div class="flex justify-between text-xs mb-1">
                    <span>Particle Speed</span>
                    <span id="val-speed" class="text-purple-400">2.0</span>
                </div>
                <input type="range" id="slider-speed" min="0.5" max="5.0" step="0.1" value="2.0" class="slider">
            </div>

            <div>
                <div class="flex justify-between text-xs mb-1">
                    <span>Inward Bias</span>
                    <span id="val-bias" class="text-purple-400">0.05</span>
                </div>
                <input type="range" id="slider-bias" min="0" max="0.2" step="0.01" value="0.05" class="slider">
            </div>

            <div>
                <div class="flex justify-between text-xs mb-1">
                    <span>Spawn Radius</span>
                    <span id="val-spawn" class="text-purple-400">Auto</span>
                </div>
                <input type="range" id="slider-spawn" min="50" max="400" step="10" value="0" class="slider">
                <div class="text-[10px] text-gray-600 mt-1">Set to 0 for auto-scaling</div>
            </div>

            <div class="flex gap-2 mt-4">
                <button id="btn-reset" class="flex-1 bg-purple-700 hover:bg-purple-600 text-white py-2 rounded text-xs font-bold transition">Reset</button>
                <button id="btn-pause" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white py-2 rounded text-xs font-bold transition">Pause</button>
            </div>
        </div>
        
        <div class="mt-4 text-[10px] text-gray-500 text-center">
            Growth stops 50px from edge
        </div>
    </div>

    <script>
        // --- Configuration ---
        const config = {
            particleCount: 100,
            baseSpeed: 2.0,
            inwardBias: 0.05,
            spawnRadius: 0, // 0 = auto
            maxRadius: 0, // Calculated from canvas
            stickDistance: 3,
            edgePadding: 50
        };

        // --- State ---
        let particles = [];
        let cluster = [];
        let centerX, centerY;
        let maxClusterRadius = 0;
        let isRunning = true;
        let isComplete = false;
        let animationId;

        // --- Classes ---

        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                // Spawn on a circle around the cluster
                let spawnR = config.spawnRadius > 0 ? config.spawnRadius : maxClusterRadius + 20;
                // Ensure we don't spawn too close to edge
                spawnR = Math.min(spawnR, config.maxRadius - 10);
                
                const angle = Math.random() * Math.PI * 2;
                this.x = centerX + Math.cos(angle) * spawnR;
                this.y = centerY + Math.sin(angle) * spawnR;
                
                // Random initial velocity
                const velAngle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(velAngle) * config.baseSpeed;
                this.vy = Math.sin(velAngle) * config.baseSpeed;
            }

            update() {
                // Brownian motion (random walk)
                this.vx += (Math.random() - 0.5) * 2;
                this.vy += (Math.random() - 0.5) * 2;
                
                // Normalize to maintain speed
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                this.vx = (this.vx / speed) * config.baseSpeed;
                this.vy = (this.vy / speed) * config.baseSpeed;

                // Inward bias (drift toward center)
                const dx = centerX - this.x;
                const dy = centerY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) {
                    this.vx += (dx / dist) * config.inwardBias;
                    this.vy += (dy / dist) * config.inwardBias;
                }

                this.x += this.vx;
                this.y += this.vy;

                // Check if too far from cluster (lost particle), respawn
                const distFromCenter = Math.sqrt((this.x - centerX)**2 + (this.y - centerY)**2);
                if (distFromCenter > config.maxRadius + 50) {
                    this.reset();
                    return false; // Not stuck
                }

                // Check collision with cluster
                for (let p of cluster) {
                    const dx = this.x - p.x;
                    const dy = this.y - p.y;
                    if (dx * dx + dy * dy < config.stickDistance * config.stickDistance) {
                        return true; // Stuck
                    }
                }

                // Check bounds
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.reset();
                }

                return false;
            }

            draw(ctx) {
                ctx.fillStyle = 'rgba(168, 85, 247, 0.6)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- Main ---

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        document.body.appendChild(canvas);

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            centerX = canvas.width / 2;
            centerY = canvas.height / 2;
            config.maxRadius = Math.min(canvas.width, canvas.height) / 2 - config.edgePadding;
        }

        function init() {
            resize();
            cluster = [];
            particles = [];
            maxClusterRadius = 0;
            isComplete = false;
            
            // Seed crystal at center
            cluster.push({ x: centerX, y: centerY, generation: 0 });
            
            // Initialize particles
            for (let i = 0; i < config.particleCount; i++) {
                particles.push(new Particle());
            }
            
            updateStats();
        }

        function getClusterColor(generation) {
            // Gradient from purple to cyan to yellow
            const ratio = Math.min(generation / 500, 1);
            const r = Math.floor(168 * (1 - ratio) + 250 * ratio);
            const g = Math.floor(85 * (1 - ratio) + 204 * ratio);
            const b = Math.floor(247);
            return `rgb(${r}, ${g}, ${b})`;
        }

        function draw() {
            // Clear with fade effect for trails
            ctx.fillStyle = 'rgba(10, 10, 10, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw cluster
            for (let i = 0; i < cluster.length; i++) {
                const p = cluster[i];
                const color = getClusterColor(i);
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Glow effect for newer particles
                if (i > cluster.length - 20) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = color;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }

            // Draw active particles
            if (!isComplete) {
                for (let p of particles) {
                    p.draw(ctx);
                }
            }

            // Draw boundary circle
            ctx.strokeStyle = 'rgba(168, 85, 247, 0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(centerX, centerY, maxClusterRadius + 20, 0, Math.PI * 2);
            ctx.stroke();
        }

        function update() {
            if (!isRunning || isComplete) return;

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const stuck = particles[i].update();
                
                if (stuck) {
                    // Add to cluster
                    const newParticle = {
                        x: particles[i].x,
                        y: particles[i].y,
                        generation: cluster.length
                    };
                    cluster.push(newParticle);
                    
                    // Update max radius
                    const dist = Math.sqrt((newParticle.x - centerX)**2 + (newParticle.y - centerY)**2);
                    if (dist > maxClusterRadius) {
                        maxClusterRadius = dist;
                    }
                    
                    // Check completion
                    if (maxClusterRadius >= config.maxRadius) {
                        isComplete = true;
                        particles = [];
                    } else {
                        // Respawn particle
                        particles[i] = new Particle();
                    }
                }
            }

            updateStats();
        }

        function updateStats() {
            document.getElementById('stat-size').textContent = cluster.length;
            document.getElementById('stat-active').textContent = particles.length;
        }

        function loop() {
            update();
            draw();
            animationId = requestAnimationFrame(loop);
        }

        // --- UI Setup ---

        function setupUI() {
            document.getElementById('slider-speed').addEventListener('input', (e) => {
                config.baseSpeed = parseFloat(e.target.value);
                document.getElementById('val-speed').textContent = config.baseSpeed.toFixed(1);
            });

            document.getElementById('slider-bias').addEventListener('input', (e) => {
                config.inwardBias = parseFloat(e.target.value);
                document.getElementById('val-bias').textContent = config.inwardBias.toFixed(2);
            });

            document.getElementById('slider-spawn').addEventListener('input', (e) => {
                config.spawnRadius = parseInt(e.target.value);
                document.getElementById('val-spawn').textContent = config.spawnRadius > 0 ? config.spawnRadius : 'Auto';
            });

            document.getElementById('btn-reset').addEventListener('click', () => {
                init();
            });

            document.getElementById('btn-pause').addEventListener('click', (e) => {
                isRunning = !isRunning;
                e.target.textContent = isRunning ? 'Pause' : 'Resume';
            });
        }

        // --- Start ---
        window.addEventListener('resize', () => {
            resize();
            // Don't reinit, just update center
            const dx = canvas.width / 2 - centerX;
            const dy = canvas.height / 2 - centerY;
            centerX = canvas.width / 2;
            centerY = canvas.height / 2;
            
            // Shift cluster
            for (let p of cluster) {
                p.x += dx;
                p.y += dy;
            }
            for (let p of particles) {
                p.x += dx;
                p.y += dy;
            }
        });

        setupUI();
        init();
        loop();

    </script>
</body>
</html>