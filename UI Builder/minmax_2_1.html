<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI Builder - Drag & Drop Interface Designer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #1e1e1e;
            --bg-darker: #121212;
            --bg-panel: #252526;
            --bg-hover: #3a3a3a;
            --bg-active: #094771;
            --border-color: #3c3c3c;
            --text-primary: #cccccc;
            --text-secondary: #858585;
            --accent: #0e639c;
            --accent-hover: #1177bb;
            --success: #4caf50;
            --warning: #ff9800;
            --danger: #f44336;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        /* Main Layout */
        .app-container {
            display: grid;
            grid-template-columns: 250px 1fr 280px;
            grid-template-rows: 40px 1fr;
            height: 100vh;
        }

        /* Top Toolbar */
        .toolbar {
            grid-column: 1 / -1;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 16px;
        }

        .toolbar-brand {
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: var(--border-color);
        }

        .toolbar-btn {
            background: transparent;
            border: none;
            color: var(--text-primary);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: background 0.15s;
        }

        .toolbar-btn:hover {
            background: var(--bg-hover);
        }

        .toolbar-btn.primary {
            background: var(--accent);
        }

        .toolbar-btn.primary:hover {
            background: var(--accent-hover);
        }

        /* Left Panel - Components Library */
        .components-panel {
            background: var(--bg-panel);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            padding: 12px 16px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-color);
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .component-category {
            margin-bottom: 16px;
        }

        .category-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
            padding-left: 4px;
        }

        .component-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .component-item {
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px 8px;
            cursor: grab;
            text-align: center;
            transition: all 0.15s;
            user-select: none;
        }

        .component-item:hover {
            border-color: var(--accent);
            background: rgba(14, 99, 156, 0.1);
        }

        .component-item:active {
            cursor: grabbing;
        }

        .component-icon {
            width: 32px;
            height: 32px;
            margin: 0 auto 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-hover);
            border-radius: 4px;
            font-size: 16px;
        }

        .component-name {
            font-size: 11px;
            color: var(--text-primary);
        }

        /* Canvas Area */
        .canvas-container {
            background: var(--bg-darker);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .canvas-tabs {
            display: flex;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            padding: 0 12px;
        }

        .canvas-tab {
            padding: 10px 16px;
            font-size: 13px;
            color: var(--text-secondary);
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: all 0.15s;
        }

        .canvas-tab:hover {
            color: var(--text-primary);
        }

        .canvas-tab.active {
            color: var(--text-primary);
            border-bottom-color: var(--accent);
        }

        .canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: auto;
        }

        .canvas {
            position: absolute;
            min-width: 100%;
            min-height: 100%;
            background-image:
                linear-gradient(var(--border-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--border-color) 1px, transparent 1px);
            background-size: 20px 20px;
            background-position: -1px -1px;
        }

        /* Canvas Element */
        .canvas-element {
            position: absolute;
            cursor: move;
            user-select: none;
            min-width: 20px;
            min-height: 20px;
        }

        .canvas-element.selected {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }

        .canvas-element.dragging {
            opacity: 0.8;
            z-index: 1000;
        }

        /* Resize Handles */
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: white;
            border: 1px solid var(--accent);
            border-radius: 2px;
            display: none;
        }

        .canvas-element.selected .resize-handle {
            display: block;
        }

        .resize-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
        .resize-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
        .resize-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
        .resize-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }
        .resize-handle.n { top: -5px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .resize-handle.s { bottom: -5px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        .resize-handle.w { left: -5px; top: 50%; transform: translateY(-50%); cursor: w-resize; }
        .resize-handle.e { right: -5px; top: 50%; transform: translateY(-50%); cursor: e-resize; }

        /* Connection Points */
        .connection-point {
            position: absolute;
            width: 12px;
            height: 12px;
            background: white;
            border: 2px solid var(--accent);
            border-radius: 50%;
            cursor: crosshair;
            display: none;
            z-index: 10;
        }

        .canvas-element.selected .connection-point,
        .canvas-element.connecting .connection-point {
            display: block;
        }

        .connection-point.top { top: -6px; left: 50%; transform: translateX(-50%); }
        .connection-point.bottom { bottom: -6px; left: 50%; transform: translateX(-50%); }
        .connection-point.left { left: -6px; top: 50%; transform: translateY(-50%); }
        .connection-point.right { right: -6px; top: 50%; transform: translateY(-50%); }

        /* Connection Lines */
        .connection-line {
            stroke: var(--accent);
            stroke-width: 2;
            fill: none;
        }

        /* Alignment Guides */
        .alignment-guide {
            position: absolute;
            background: var(--accent);
            pointer-events: none;
            z-index: 9999;
        }

        .alignment-guide.horizontal {
            height: 1px;
            left: 0;
            right: 0;
        }

        .alignment-guide.vertical {
            width: 1px;
            top: 0;
            bottom: 0;
        }

        /* Right Panel - Properties */
        .properties-panel {
            background: var(--bg-panel);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .properties-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .property-section {
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
            margin-bottom: 12px;
            padding-left: 4px;
        }

        .property-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 8px;
        }

        .property-label {
            font-size: 12px;
            color: var(--text-primary);
            min-width: 80px;
        }

        .property-input {
            flex: 1;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 6px 10px;
            color: var(--text-primary);
            font-size: 12px;
        }

        .property-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .property-input-small {
            width: 60px;
        }

        .property-input-color {
            width: 40px;
            height: 28px;
            padding: 2px;
            cursor: pointer;
        }

        .property-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .property-checkbox input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .property-checkbox label {
            font-size: 12px;
            color: var(--text-primary);
            cursor: pointer;
        }

        .no-selection {
            text-align: center;
            color: var(--text-secondary);
            padding: 40px 20px;
            font-size: 13px;
        }

        /* Layer Panel */
        .layers-panel {
            border-top: 1px solid var(--border-color);
            padding: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .layer-item {
            display: flex;
            align-items: center;
            padding: 8px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            font-size: 12px;
            gap: 8px;
        }

        .layer-item:hover {
            border-color: var(--accent);
        }

        .layer-item.selected {
            border-color: var(--accent);
            background: rgba(14, 99, 156, 0.1);
        }

        .layer-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-hover);
            border-radius: 3px;
            font-size: 12px;
        }

        .layer-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .layer-delete {
            width: 20px;
            height: 20px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .layer-delete:hover {
            background: var(--danger);
            color: white;
        }

        /* Canvas Context Menu */
        .context-menu {
            position: fixed;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 4px 0;
            min-width: 160px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            z-index: 10000;
            display: none;
        }

        .context-menu.visible {
            display: block;
        }

        .context-menu-item {
            padding: 8px 16px;
            font-size: 13px;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.1s;
        }

        .context-menu-item:hover {
            background: var(--bg-hover);
        }

        .context-menu-item.danger {
            color: var(--danger);
        }

        .context-menu-divider {
            height: 1px;
            background: var(--border-color);
            margin: 4px 0;
        }

        /* SVG Icon Styles */
        .svg-icon {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-darker);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 20000;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 30000;
        }

        .toast {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px 20px;
            margin-top: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 16px;
            left: 16px;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 4px;
            display: flex;
            gap: 4px;
            z-index: 100;
        }

        .zoom-btn {
            width: 28px;
            height: 28px;
            background: transparent;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .zoom-btn:hover {
            background: var(--bg-hover);
        }

        .zoom-value {
            padding: 0 8px;
            display: flex;
            align-items: center;
            font-size: 12px;
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Toolbar -->
        <div class="toolbar">
            <span class="toolbar-brand">UI Builder</span>
            <div class="toolbar-divider"></div>
            <button class="toolbar-btn" onclick="newProject()">
                <svg class="svg-icon" viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zm-1 9h-2v6h2v-6zm0-4h-2v2h2V7z"/></svg>
                New
            </button>
            <button class="toolbar-btn" onclick="openProject()">
                <svg class="svg-icon" viewBox="0 0 24 24"><path d="M20 6h-8l-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 12H4V8h16v10z"/></svg>
                Open
            </button>
            <button class="toolbar-btn primary" onclick="exportProject()">
                <svg class="svg-icon" viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                Export HTML
            </button>
            <div style="flex: 1;"></div>
            <button class="toolbar-btn" onclick="toggleGrid()">
                <svg class="svg-icon" viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 20H4v-4h4v4zm0-6H4v-4h4v4zm0-6H4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4z"/></svg>
                Grid
            </button>
            <button class="toolbar-btn" onclick="toggleSnap()">
                <svg class="svg-icon" viewBox="0 0 24 24"><path d="M3 5v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2H5c-1.11 0-2 .9-2 2zm4 2h10v2H7V7zm0 4h10v2H7v-2zm0 4h7v2H7v-2z"/></svg>
                Snap
            </button>
            <button class="toolbar-btn" onclick="deleteSelected()">
                <svg class="svg-icon" viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                Delete
            </button>
        </div>

        <!-- Components Panel -->
        <div class="components-panel">
            <div class="panel-header">Components</div>
            <div class="panel-content">
                <div class="component-category">
                    <div class="category-title">Basic Inputs</div>
                    <div class="component-grid">
                        <div class="component-item" draggable="true" data-type="button">
                            <div class="component-icon">▢</div>
                            <div class="component-name">Button</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="input">
                            <div class="component-icon">▭</div>
                            <div class="component-name">Input</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="textarea">
                            <div class="component-icon">▤</div>
                            <div class="component-name">Text Area</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="checkbox">
                            <div class="component-icon">☑</div>
                            <div class="component-name">Checkbox</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="radio">
                            <div class="component-icon">◉</div>
                            <div class="component-name">Radio</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="select">
                            <div class="component-icon">▼</div>
                            <div class="component-name">Dropdown</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="slider">
                            <div class="component-icon">◀▶</div>
                            <div class="component-name">Slider</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="range">
                            <div class="component-icon">≡</div>
                            <div class="component-name">Range</div>
                        </div>
                    </div>
                </div>
                <div class="component-category">
                    <div class="category-title">Display</div>
                    <div class="component-grid">
                        <div class="component-item" draggable="true" data-type="progress">
                            <div class="component-icon">▬</div>
                            <div class="component-name">Progress</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="text">
                            <div class="component-icon">T</div>
                            <div class="component-name">Text</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="heading">
                            <div class="component-icon">H</div>
                            <div class="component-name">Heading</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="badge">
                            <div class="component-icon">●</div>
                            <div class="component-name">Badge</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="avatar">
                            <div class="component-icon">◉</div>
                            <div class="component-name">Avatar</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="card">
                            <div class="component-icon">▣</div>
                            <div class="component-name">Card</div>
                        </div>
                    </div>
                </div>
                <div class="component-category">
                    <div class="category-title">Shapes</div>
                    <div class="component-grid">
                        <div class="component-item" draggable="true" data-type="rectangle">
                            <div class="component-icon">▢</div>
                            <div class="component-name">Rectangle</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="circle">
                            <div class="component-icon">◯</div>
                            <div class="component-name">Circle</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="triangle">
                            <div class="component-icon">△</div>
                            <div class="component-name">Triangle</div>
                        </div>
                        <div class="component-item" draggable="true" data-type="line">
                            <div class="component-icon">—</div>
                            <div class="component-name">Line</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="canvas-container">
            <div class="canvas-tabs">
                <div class="canvas-tab active">Design</div>
                <div class="canvas-tab" onclick="switchToCode()">Code</div>
            </div>
            <div class="canvas-wrapper" id="canvasWrapper">
                <div class="canvas" id="canvas"></div>
            </div>
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomOut()">−</button>
                <div class="zoom-value" id="zoomValue">100%</div>
                <button class="zoom-btn" onclick="zoomIn()">+</button>
                <button class="zoom-btn" onclick="resetZoom()">⟲</button>
            </div>
        </div>

        <!-- Properties Panel -->
        <div class="properties-panel">
            <div class="panel-header">Properties</div>
            <div class="properties-content" id="propertiesContent">
                <div class="no-selection">
                    Select an element to edit its properties
                </div>
            </div>
            <div class="layers-panel">
                <div class="section-title">Layers</div>
                <div id="layersList"></div>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" onclick="duplicateElement()">
            <svg class="svg-icon" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
            Duplicate
        </div>
        <div class="context-menu-item" onclick="copyElement()">
            <svg class="svg-icon" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
            Copy
        </div>
        <div class="context-menu-item" onclick="pasteElement()">
            <svg class="svg-icon" viewBox="0 0 24 24"><path d="M19 2h-4.18C14.4.84 13.3 0 12 0c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z"/></svg>
            Paste
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" onclick="bringToFront()">
            <svg class="svg-icon" viewBox="0 0 24 24"><path d="M13 3h-2v10h2V3zm4.83 2.17l-1.42 1.42C17.99 7.86 19 9.81 19 12c0 3.87-3.13 7-7 7s-7-3.13-7-7c0-2.19 1.01-4.14 2.58-5.42L6.17 5.17C4.23 6.82 3 9.26 3 12c0 4.97 4.03 9 9 9s9-4.03 9-9c0-2.74-1.23-5.18-3.17-6.83z"/></svg>
            Bring to Front
        </div>
        <div class="context-menu-item" onclick="sendToBack()">
            <svg class="svg-icon" viewBox="0 0 24 24"><path d="M13 3h-2v10h2V3zm4.83 2.17l-1.42 1.42C17.99 7.86 19 9.81 19 12c0 3.87-3.13 7-7 7s-7-3.13-7-7c0-2.19 1.01-4.14 2.58-5.42L6.17 5.17C4.23 6.82 3 9.26 3 12c0 4.97 4.03 9 9 9s9-4.03 9-9c0-2.74-1.23-5.18-3.17-6.83z"/></svg>
            Send to Back
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item danger" onclick="deleteSelected()">
            <svg class="svg-icon" viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
            Delete
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal-overlay" id="exportModal">
        <div class="modal">
            <div class="modal-title">Export as HTML</div>
            <div class="modal-body">
                <p style="margin-bottom: 16px; font-size: 13px; color: var(--text-secondary);">
                    Your design will be exported as a standalone HTML file with all styles and components.
                </p>
                <div class="property-row">
                    <label class="property-label">Filename:</label>
                    <input type="text" class="property-input" id="exportFilename" value="my-design.html">
                </div>
                <div class="property-checkbox">
                    <input type="checkbox" id="exportInline" checked>
                    <label for="exportInline">Inline CSS styles</label>
                </div>
                <div class="property-checkbox">
                    <input type="checkbox" id="exportResponsive" checked>
                    <label for="exportResponsive">Make responsive</label>
                </div>
            </div>
            <div class="modal-actions">
                <button class="toolbar-btn" onclick="closeExportModal()">Cancel</button>
                <button class="toolbar-btn primary" onclick="downloadExport()">Download</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <script>
        // ==================== STATE MANAGEMENT ====================
        const state = {
            elements: [],
            connections: [],
            selectedElement: null,
            selectedConnection: null,
            isDragging: false,
            isResizing: false,
            isConnecting: false,
            isPanning: false,
            connectingFrom: null,
            dragOffset: { x: 0, y: 0 },
            resizeHandle: null,
            startPos: { x: 0, y: 0 },
            zoom: 1,
            gridSize: 20,
            snapEnabled: true,
            showGrid: true,
            clipboard: null,
            panOffset: { x: 0, y: 0 },
            panStart: { x: 0, y: 0 }
        };

        // ==================== CANVAS SETUP ====================
        const canvas = document.getElementById('canvas');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const contextMenu = document.getElementById('contextMenu');

        // Initialize canvas size
        function initCanvas() {
            const rect = canvasWrapper.getBoundingClientRect();
            canvas.style.width = '2000px';
            canvas.style.height = '1500px';
        }

        // ==================== ELEMENT FACTORY ====================
        function createElement(type, x, y) {
            const id = 'el_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const defaults = {
                button: { width: 120, height: 40, text: 'Button', bgColor: '#0e639c', borderRadius: 6 },
                input: { width: 200, height: 36, placeholder: 'Enter text...', borderColor: '#3c3c3c', borderRadius: 4 },
                textarea: { width: 300, height: 100, placeholder: 'Enter text...', borderColor: '#3c3c3c', borderRadius: 4 },
                checkbox: { width: 20, height: 20, checked: false, borderColor: '#3c3c3c' },
                radio: { width: 20, height: 20, checked: false, borderColor: '#3c3c3c' },
                select: { width: 180, height: 36, options: ['Option 1', 'Option 2', 'Option 3'], borderRadius: 4 },
                slider: { width: 200, height: 36, min: 0, max: 100, value: 50, borderRadius: 4 },
                range: { width: 200, height: 36, min: 0, max: 100, value: 50, borderRadius: 4 },
                progress: { width: 200, height: 20, value: 50, max: 100, bgColor: '#3c3c3c', progressColor: '#0e639c' },
                text: { width: 200, height: 24, text: 'Sample text', fontSize: 14, color: '#cccccc' },
                heading: { width: 200, height: 36, text: 'Heading', fontSize: 24, fontWeight: 'bold', color: '#cccccc' },
                badge: { width: 60, height: 24, text: 'Badge', fontSize: 12, bgColor: '#4caf50', borderRadius: 12 },
                avatar: { width: 48, height: 48, bgColor: '#0e639c', borderRadius: '50%' },
                card: { width: 300, height: 200, bgColor: '#252526', borderRadius: 8, borderColor: '#3c3c3c' },
                rectangle: { width: 150, height: 100, bgColor: '#0e639c', borderRadius: 0, borderColor: 'transparent' },
                circle: { width: 100, height: 100, bgColor: '#0e639c', borderRadius: '50%', borderColor: 'transparent' },
                triangle: { width: 100, height: 100, bgColor: '#0e639c', borderColor: 'transparent' },
                line: { width: 200, height: 4, bgColor: '#0e639c', borderColor: 'transparent' }
            };

            const element = {
                id,
                type,
                x: snapToGrid(x),
                y: snapToGrid(y),
                width: defaults[type]?.width || 100,
                height: defaults[type]?.height || 100,
                rotation: 0,
                opacity: 1,
                visible: true,
                locked: false,
                name: type.charAt(0).toUpperCase() + type.slice(1) + ' ' + (state.elements.length + 1),
                style: { ...defaults[type] },
                connections: []
            };

            return element;
        }

        function renderElement(element) {
            const div = document.createElement('div');
            div.className = 'canvas-element';
            div.id = element.id;
            div.style.left = element.x + 'px';
            div.style.top = element.y + 'px';
            div.style.width = element.width + 'px';
            div.style.height = element.height + 'px';
            div.style.opacity = element.opacity;
            div.style.transform = `rotate(${element.rotation}deg)`;

            // Add resize handles
            div.innerHTML = `
                <div class="resize-handle nw"></div>
                <div class="resize-handle ne"></div>
                <div class="resize-handle sw"></div>
                <div class="resize-handle se"></div>
                <div class="resize-handle n"></div>
                <div class="resize-handle s"></div>
                <div class="resize-handle w"></div>
                <div class="resize-handle e"></div>
                <div class="connection-point top"></div>
                <div class="connection-point bottom"></div>
                <div class="connection-point left"></div>
                <div class="connection-point right"></div>
            `;

            // Render element content based on type
            div.appendChild(createElementContent(element));

            return div;
        }

        function createElementContent(element) {
            const content = document.createElement('div');
            content.style.cssText = `
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                overflow: hidden;
            `;

            const style = element.style;

            switch(element.type) {
                case 'button':
                    content.style.background = style.bgColor || '#0e639c';
                    content.style.color = 'white';
                    content.style.borderRadius = (style.borderRadius || 6) + 'px';
                    content.style.fontSize = '14px';
                    content.style.fontWeight = '500';
                    content.style.cursor = 'pointer';
                    content.textContent = style.text || 'Button';
                    break;

                case 'input':
                    content.innerHTML = `<input type="text" placeholder="${style.placeholder || 'Enter text...'}" style="
                        width: 100%;
                        height: 100%;
                        border: 1px solid ${style.borderColor || '#3c3c3c'};
                        border-radius: ${style.borderRadius || 4}px;
                        background: #1e1e1e;
                        color: #cccccc;
                        padding: 0 12px;
                        font-size: 14px;
                        outline: none;
                    ">`;
                    break;

                case 'textarea':
                    content.innerHTML = `<textarea placeholder="${style.placeholder || 'Enter text...'}" style="
                        width: 100%;
                        height: 100%;
                        border: 1px solid ${style.borderColor || '#3c3c3c'};
                        border-radius: ${style.borderRadius || 4}px;
                        background: #1e1e1e;
                        color: #cccccc;
                        padding: 8px 12px;
                        font-size: 14px;
                        resize: none;
                        outline: none;
                    "></textarea>`;
                    break;

                case 'checkbox':
                    content.innerHTML = `<input type="checkbox" ${style.checked ? 'checked' : ''} style="
                        width: ${element.width}px;
                        height: ${element.height}px;
                        cursor: pointer;
                        accent-color: #0e639c;
                    ">`;
                    break;

                case 'radio':
                    content.innerHTML = `<input type="radio" ${style.checked ? 'checked' : ''} style="
                        width: ${element.width}px;
                        height: ${element.height}px;
                        cursor: pointer;
                        accent-color: #0e639c;
                    ">`;
                    break;

                case 'select':
                    content.innerHTML = `<select style="
                        width: 100%;
                        height: 100%;
                        border: 1px solid ${style.borderColor || '#3c3c3c'};
                        border-radius: ${style.borderRadius || 4}px;
                        background: #1e1e1e;
                        color: #cccccc;
                        padding: 0 12px;
                        font-size: 14px;
                        outline: none;
                        cursor: pointer;
                    ">
                        ${(style.options || ['Option 1', 'Option 2', 'Option 3']).map(opt => `<option>${opt}</option>`).join('')}
                    </select>`;
                    break;

                case 'slider':
                    content.style.flexDirection = 'column';
                    content.innerHTML = `<input type="range" min="${style.min || 0}" max="${style.max || 100}" value="${style.value || 50}" style="width: 90%; accent-color: #0e639c;">
                        <span style="font-size: 12px; color: #858585;">${style.value || 50}</span>`;
                    break;

                case 'range':
                    content.style.flexDirection = 'row';
                    content.style.gap = '8px';
                    content.innerHTML = `<span style="font-size: 12px; color: #858585;">${style.min || 0}</span>
                        <input type="range" min="${style.min || 0}" max="${style.max || 100}" value="${style.value || 50}" style="flex: 1; accent-color: #0e639c;">
                        <span style="font-size: 12px; color: #858585;">${style.max || 100}</span>`;
                    break;

                case 'progress':
                    content.style.background = style.bgColor || '#3c3c3c';
                    content.style.borderRadius = '4px';
                    content.style.overflow = 'hidden';
                    content.innerHTML = `<div style="
                        width: ${((style.value || 50) / (style.max || 100)) * 100}%;
                        height: 100%;
                        background: ${style.progressColor || '#0e639c'};
                    "></div>`;
                    break;

                case 'text':
                    content.style.color = style.color || '#cccccc';
                    content.style.fontSize = (style.fontSize || 14) + 'px';
                    content.style.justifyContent = 'flex-start';
                    content.style.paddingLeft = '8px';
                    content.textContent = style.text || 'Sample text';
                    break;

                case 'heading':
                    content.style.color = style.color || '#cccccc';
                    content.style.fontSize = (style.fontSize || 24) + 'px';
                    content.style.fontWeight = style.fontWeight || 'bold';
                    content.style.justifyContent = 'flex-start';
                    content.style.paddingLeft = '8px';
                    content.textContent = style.heading || 'Heading';
                    break;

                case 'badge':
                    content.style.background = style.bgColor || '#4caf50';
                    content.style.color = 'white';
                    content.style.borderRadius = (style.borderRadius || 12) + 'px';
                    content.style.fontSize = (style.fontSize || 12) + 'px';
                    content.textContent = style.text || 'Badge';
                    break;

                case 'avatar':
                    content.style.background = style.bgColor || '#0e639c';
                    content.style.borderRadius = style.borderRadius || '50%';
                    content.innerHTML = `<span style="color: white; font-size: 20px;">◉</span>`;
                    break;

                case 'card':
                    content.style.background = style.bgColor || '#252526';
                    content.style.border = `1px solid ${style.borderColor || '#3c3c3c'}`;
                    content.style.borderRadius = (style.borderRadius || 8) + 'px';
                    break;

                case 'rectangle':
                    content.style.background = style.bgColor || '#0e639c';
                    content.style.borderRadius = (style.borderRadius || 0) + 'px';
                    break;

                case 'circle':
                    content.style.background = style.bgColor || '#0e639c';
                    content.style.borderRadius = '50%';
                    break;

                case 'triangle':
                    content.innerHTML = `<div style="
                        width: 0;
                        height: 0;
                        border-left: ${element.width / 2}px solid transparent;
                        border-right: ${element.width / 2}px solid transparent;
                        border-bottom: ${element.height}px solid ${style.bgColor || '#0e639c'};
                    "></div>`;
                    break;

                case 'line':
                    content.style.background = style.bgColor || '#0e639c';
                    content.style.borderRadius = '2px';
                    content.style.height = Math.max(4, element.height) + 'px';
                    content.style.marginTop = (element.height > 4 ? (element.height - 4) / 2 : 0) + 'px';
                    break;

                default:
                    content.style.background = '#0e639c';
            }

            return content;
        }

        function updateElement(element) {
            const div = document.getElementById(element.id);
            if (!div) return;

            div.style.left = element.x + 'px';
            div.style.top = element.y + 'px';
            div.style.width = element.width + 'px';
            div.style.height = element.height + 'px';
            div.style.opacity = element.opacity;
            div.style.transform = `rotate(${element.rotation}deg)`;

            // Update content
            const content = div.querySelector(':scope > div:last-child');
            if (content) {
                content.remove();
                div.appendChild(createElementContent(element));
            }

            // Update connected lines
            updateConnections(element.id);
        }

        // ==================== DRAG AND DROP FROM PANEL ====================
        document.querySelectorAll('.component-item').forEach(item => {
            item.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('componentType', item.dataset.type);
                e.dataTransfer.effectAllowed = 'copy';
            });
        });

        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        });

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            const type = e.dataTransfer.getData('componentType');
            if (type) {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left + canvas.scrollLeft) / state.zoom;
                const y = (e.clientY - rect.top + canvas.scrollTop) / state.zoom;
                addElement(type, x, y);
            }
        });

        // ==================== ELEMENT MANAGEMENT ====================
        function addElement(type, x, y) {
            const element = createElement(type, x, y);
            state.elements.push(element);

            const div = renderElement(element);
            canvas.appendChild(div);

            addElementEventListeners(div, element);
            updateLayers();
            selectElement(element);
            showToast(`Added ${element.name}`);
        }

        function addElementEventListeners(div, element) {
            // Mouse down for selection and drag start
            div.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('resize-handle')) {
                    startResize(e, element);
                    return;
                }

                if (e.target.classList.contains('connection-point')) {
                    startConnection(e, element);
                    return;
                }

                selectElement(element);
                startDrag(e, element);
            });

            // Context menu
            div.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                selectElement(element);
                showContextMenu(e.clientX, e.clientY);
            });
        }

        function selectElement(element) {
            // Deselect previous
            if (state.selectedElement) {
                const prevDiv = document.getElementById(state.selectedElement.id);
                if (prevDiv) prevDiv.classList.remove('selected');
            }

            state.selectedElement = element;

            if (element) {
                const div = document.getElementById(element.id);
                if (div) div.classList.add('selected');
                updatePropertiesPanel(element);
            } else {
                updatePropertiesPanel(null);
            }

            updateLayers();
        }

        function deleteSelected() {
            if (state.selectedElement) {
                // Remove connections
                state.connections = state.connections.filter(conn => {
                    if (conn.from.elementId === state.selectedElement.id ||
                        conn.to.elementId === state.selectedElement.id) {
                        const line = document.getElementById(conn.id);
                        if (line) line.remove();
                        return false;
                    }
                    return true;
                });

                // Remove element
                const div = document.getElementById(state.selectedElement.id);
                if (div) div.remove();

                state.elements = state.elements.filter(e => e.id !== state.selectedElement.id);

                showToast('Element deleted');
                selectElement(null);
                updateLayers();
            }
        }

        // ==================== DRAG HANDLING ====================
        function startDrag(e, element) {
            e.preventDefault();
            state.isDragging = true;
            state.selectedElement = element;

            const div = document.getElementById(element.id);
            div.classList.add('dragging');

            const rect = div.getBoundingClientRect();
            state.dragOffset = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };

            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', stopDrag);
        }

        function onDrag(e) {
            if (!state.isDragging || !state.selectedElement) return;

            const canvasRect = canvas.getBoundingClientRect();
            let x = (e.clientX - canvasRect.left - state.dragOffset.x) / state.zoom;
            let y = (e.clientY - canvasRect.top - state.dragOffset.y) / state.zoom;

            // Snap to grid
            if (state.snapEnabled) {
                x = snapToGrid(x);
                y = snapToGrid(y);
            }

            // Constrain to canvas
            x = Math.max(0, Math.min(x, canvas.offsetWidth - state.selectedElement.width));
            y = Math.max(0, Math.min(y, canvas.offsetHeight - state.selectedElement.height));

            state.selectedElement.x = x;
            state.selectedElement.y = y;

            const div = document.getElementById(state.selectedElement.id);
            div.style.left = x + 'px';
            div.style.top = y + 'px';

            // Update connections
            updateConnections(state.selectedElement.id);

            // Show alignment guides
            showAlignmentGuides(state.selectedElement);
        }

        function stopDrag() {
            if (state.isDragging && state.selectedElement) {
                const div = document.getElementById(state.selectedElement.id);
                div.classList.remove('dragging');
                hideAlignmentGuides();
            }

            state.isDragging = false;
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', stopDrag);
        }

        // ==================== RESIZE HANDLING ====================
        function startResize(e, element) {
            e.preventDefault();
            e.stopPropagation();

            state.isResizing = true;
            state.selectedElement = element;
            state.resizeHandle = e.target.className.split(' ')[1];

            const div = document.getElementById(element.id);
            const rect = div.getBoundingClientRect();
            state.startPos = { x: e.clientX, y: e.clientY };

            document.addEventListener('mousemove', onResize);
            document.addEventListener('mouseup', stopResize);
        }

        function onResize(e) {
            if (!state.isResizing || !state.selectedElement) return;

            const dx = (e.clientX - state.startPos.x) / state.zoom;
            const dy = (e.clientY - state.startPos.y) / state.zoom;

            const element = state.selectedElement;
            const minSize = { width: 20, height: 20 };

            switch (state.resizeHandle) {
                case 'se':
                    element.width = Math.max(minSize.width, element.width + dx);
                    element.height = Math.max(minSize.height, element.height + dy);
                    break;
                case 'sw':
                    if (element.width - dx > minSize.width) {
                        element.x += dx;
                        element.width -= dx;
                    }
                    element.height = Math.max(minSize.height, element.height + dy);
                    break;
                case 'ne':
                    if (element.height - dy > minSize.height) {
                        element.y += dy;
                        element.height -= dy;
                    }
                    element.width = Math.max(minSize.width, element.width + dx);
                    break;
                case 'nw':
                    if (element.width - dx > minSize.width) {
                        element.x += dx;
                        element.width -= dx;
                    }
                    if (element.height - dy > minSize.height) {
                        element.y += dy;
                        element.height -= dy;
                    }
                    break;
                case 'n':
                    if (element.height - dy > minSize.height) {
                        element.y += dy;
                        element.height -= dy;
                    }
                    break;
                case 's':
                    element.height = Math.max(minSize.height, element.height + dy);
                    break;
                case 'w':
                    if (element.width - dx > minSize.width) {
                        element.x += dx;
                        element.width -= dx;
                    }
                    break;
                case 'e':
                    element.width = Math.max(minSize.width, element.width + dx);
                    break;
            }

            if (state.snapEnabled) {
                element.x = snapToGrid(element.x);
                element.y = snapToGrid(element.y);
                element.width = snapToGrid(element.width);
                element.height = snapToGrid(element.height);
            }

            state.startPos = { x: e.clientX, y: e.clientY };
            updateElement(element);
            updateConnections(element.id);
        }

        function stopResize() {
            state.isResizing = false;
            state.resizeHandle = null;
            document.removeEventListener('mousemove', onResize);
            document.removeEventListener('mouseup', stopResize);
        }

        // ==================== CONNECTION LINES ====================
        function startConnection(e, element) {
            e.preventDefault();
            e.stopPropagation();

            state.isConnecting = true;
            state.connectingFrom = {
                elementId: element.id,
                point: e.target.className.split(' ')[1]
            };

            // Create temporary connection line
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('class', 'connection-line');
            line.setAttribute('id', 'temp-connection');
            line.style.pointerEvents = 'none';

            const svg = getConnectionsSVG();
            svg.appendChild(line);

            const rect = e.target.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            updateLinePosition(line, {
                x: (rect.left + rect.width / 2 - canvasRect.left) / state.zoom,
                y: (rect.top + rect.height / 2 - canvasRect.top) / state.zoom
            }, {
                x: (e.clientX - canvasRect.left) / state.zoom,
                y: (e.clientY - canvasRect.top) / state.zoom
            });

            document.addEventListener('mousemove', onConnection);
            document.addEventListener('mouseup', endConnection);
        }

        function onConnection(e) {
            if (!state.isConnecting) return;

            const line = document.getElementById('temp-connection');
            if (!line) return;

            const canvasRect = canvas.getBoundingClientRect();

            // Find element under cursor
            const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
            const connectionPoint = elementUnderCursor?.closest('.connection-point');

            let toPos = {
                x: (e.clientX - canvasRect.left) / state.zoom,
                y: (e.clientY - canvasRect.top) / state.zoom
            };

            if (connectionPoint) {
                const rect = connectionPoint.getBoundingClientRect();
                toPos = {
                    x: (rect.left + rect.width / 2 - canvasRect.left) / state.zoom,
                    y: (rect.top + rect.height / 2 - canvasRect.top) / state.zoom
                };

                // Highlight potential target
                const targetElement = connectionPoint.closest('.canvas-element');
                if (targetElement) {
                    targetElement.classList.add('connecting');
                }
            }

            // Get from position
            const fromElement = state.elements.find(el => el.id === state.connectingFrom.elementId);
            if (fromElement) {
                const fromPos = getConnectionPoint(fromElement, state.connectingFrom.point);
                updateLinePosition(line, fromPos, toPos);
            }
        }

        function endConnection(e) {
            document.removeEventListener('mousemove', onConnection);
            document.removeEventListener('mouseup', endConnection);

            const tempLine = document.getElementById('temp-connection');
            if (tempLine) tempLine.remove();

            // Find target
            const elementUnderCursor = document.elementFromPoint(e.clientX, e.clientY);
            const connectionPoint = elementUnderCursor?.closest('.connection-point');

            if (connectionPoint && state.connectingFrom) {
                const targetElement = connectionPoint.closest('.canvas-element');
                const targetId = targetElement?.id;

                if (targetId && targetId !== state.connectingFrom.elementId) {
                    // Create connection
                    const connection = {
                        id: 'conn_' + Date.now(),
                        from: {
                            elementId: state.connectingFrom.elementId,
                            point: state.connectingFrom.point
                        },
                        to: {
                            elementId: targetId,
                            point: connectionPoint.className.split(' ')[1]
                        }
                    };

                    state.connections.push(connection);
                    renderConnection(connection);
                    showToast('Connection created');
                }
            }

            // Remove connecting highlights
            document.querySelectorAll('.connecting').forEach(el => el.classList.remove('connecting'));

            state.isConnecting = false;
            state.connectingFrom = null;
        }

        function getConnectionsSVG() {
            let svg = document.getElementById('connections-svg');
            if (!svg) {
                svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('id', 'connections-svg');
                svg.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: visible;';
                canvas.appendChild(svg);
            }
            return svg;
        }

        function renderConnection(connection) {
            const svg = getConnectionsSVG();

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            line.setAttribute('class', 'connection-line');
            line.setAttribute('id', connection.id);
            line.style.cursor = 'pointer';

            line.addEventListener('click', () => selectConnection(connection));
            line.addEventListener('dblclick', () => deleteConnection(connection));

            svg.appendChild(line);
            updateConnection(connection);
        }

        function updateConnection(connection) {
            const line = document.getElementById(connection.id);
            if (!line) return;

            const fromElement = state.elements.find(el => el.id === connection.from.elementId);
            const toElement = state.elements.find(el => el.id === connection.to.elementId);

            if (!fromElement || !toElement) {
                // Remove connection if elements don't exist
                line.remove();
                state.connections = state.connections.filter(c => c.id !== connection.id);
                return;
            }

            const fromPos = getConnectionPoint(fromElement, connection.from.point);
            const toPos = getConnectionPoint(toElement, connection.to.point);

            // Create curved path
            const path = createCurvePath(fromPos, toPos);
            line.setAttribute('d', path);
        }

        function getConnectionPoint(element, point) {
            const x = element.x + element.width / 2;
            const y = element.y + element.height / 2;

            switch (point) {
                case 'top': return { x, y: element.y };
                case 'bottom': return { x, y: element.y + element.height };
                case 'left': return { x: element.x, y };
                case 'right': return { x: element.x + element.width, y };
                default: return { x, y };
            }
        }

        function createCurvePath(from, to) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const cx1 = { x: from.x + dx * 0.5, y: from.y };
            const cx2 = { x: to.x - dx * 0.5, y: to.y };

            return `M ${from.x} ${from.y} C ${cx1.x} ${cx1.y}, ${cx2.x} ${cx2.y}, ${to.x} ${to.y}`;
        }

        function updateLinePosition(line, from, to) {
            const path = createCurvePath(from, to);
            line.setAttribute('d', path);
        }

        function updateConnections(elementId) {
            state.connections.forEach(conn => {
                if (conn.from.elementId === elementId || conn.to.elementId === elementId) {
                    updateConnection(conn);
                }
            });
        }

        function deleteConnection(connection) {
            const line = document.getElementById(connection.id);
            if (line) line.remove();
            state.connections = state.connections.filter(c => c.id !== connection.id);
            showToast('Connection deleted');
        }

        function selectConnection(connection) {
            state.selectedConnection = connection;
            showToast('Connection selected');
        }

        // ==================== ALIGNMENT GUIDES ====================
        function showAlignmentGuides(element) {
            hideAlignmentGuides();

            const guides = [];
            const tolerance = 5;

            state.elements.forEach(other => {
                if (other.id === element.id) return;

                // Vertical center alignment
                if (Math.abs((element.x + element.width / 2) - (other.x + other.width / 2)) < tolerance) {
                    guides.push({
                        type: 'vertical',
                        x: element.x + element.width / 2
                    });
                }

                // Horizontal center alignment
                if (Math.abs((element.y + element.height / 2) - (other.y + other.height / 2)) < tolerance) {
                    guides.push({
                        type: 'horizontal',
                        y: element.y + element.height / 2
                    });
                }

                // Left edge alignment
                if (Math.abs(element.x - other.x) < tolerance) {
                    guides.push({
                        type: 'vertical',
                        x: element.x
                    });
                }

                // Right edge alignment
                if (Math.abs((element.x + element.width) - (other.x + other.width)) < tolerance) {
                    guides.push({
                        type: 'vertical',
                        x: element.x + element.width
                    });
                }

                // Top edge alignment
                if (Math.abs(element.y - other.y) < tolerance) {
                    guides.push({
                        type: 'horizontal',
                        y: element.y
                    });
                }

                // Bottom edge alignment
                if (Math.abs((element.y + element.height) - (other.y + other.height)) < tolerance) {
                    guides.push({
                        type: 'horizontal',
                        y: element.y + element.height
                    });
                }
            });

            guides.forEach(guide => {
                const div = document.createElement('div');
                div.className = `alignment-guide ${guide.type}`;
                div.style.left = guide.x + 'px';
                div.style.top = guide.y + 'px';
                div.style.zIndex = '9999';
                canvas.appendChild(div);
            });
        }

        function hideAlignmentGuides() {
            document.querySelectorAll('.alignment-guide').forEach(el => el.remove());
        }

        // ==================== PROPERTIES PANEL ====================
        function updatePropertiesPanel(element) {
            const content = document.getElementById('propertiesContent');

            if (!element) {
                content.innerHTML = '<div class="no-selection">Select an element to edit its properties</div>';
                return;
            }

            const style = element.style;

            let html = `
                <div class="property-section">
                    <div class="section-title">Transform</div>
                    <div class="property-row">
                        <label class="property-label">X</label>
                        <input type="number" class="property-input property-input-small" value="${Math.round(element.x)}" onchange="updateElementProperty('x', parseFloat(this.value))">
                        <label class="property-label">Y</label>
                        <input type="number" class="property-input property-input-small" value="${Math.round(element.y)}" onchange="updateElementProperty('y', parseFloat(this.value))">
                    </div>
                    <div class="property-row">
                        <label class="property-label">W</label>
                        <input type="number" class="property-input property-input-small" value="${Math.round(element.width)}" onchange="updateElementProperty('width', parseFloat(this.value))">
                        <label class="property-label">H</label>
                        <input type="number" class="property-input property-input-small" value="${Math.round(element.height)}" onchange="updateElementProperty('height', parseFloat(this.value))">
                    </div>
                    <div class="property-row">
                        <label class="property-label">Rotation</label>
                        <input type="number" class="property-input" value="${element.rotation}" min="0" max="360" onchange="updateElementProperty('rotation', parseFloat(this.value))">
                    </div>
                    <div class="property-row">
                        <label class="property-label">Opacity</label>
                        <input type="range" class="property-input" min="0" max="1" step="0.1" value="${element.opacity}" onchange="updateElementProperty('opacity', parseFloat(this.value))">
                    </div>
                </div>
                <div class="property-section">
                    <div class="section-title">Appearance</div>
                    <div class="property-row">
                        <label class="property-label">Background</label>
                        <input type="color" class="property-input property-input-color" value="${style.bgColor || '#0e639c'}" onchange="updateElementProperty('bgColor', this.value)">
                    </div>
                    <div class="property-row">
                        <label class="property-label">Border Color</label>
                        <input type="color" class="property-input property-input-color" value="${style.borderColor || '#3c3c3c'}" onchange="updateElementProperty('borderColor', this.value)">
                    </div>
                    <div class="property-row">
                        <label class="property-label">Border Radius</label>
                        <input type="number" class="property-input property-input-small" value="${style.borderRadius || 0}" onchange="updateElementProperty('borderRadius', parseFloat(this.value))">
                    </div>
                    <div class="property-row">
                        <label class="property-label">Box Shadow</label>
                        <input type="text" class="property-input" value="${style.boxShadow || ''}" placeholder="0 2px 4px rgba(0,0,0,0.3)" onchange="updateElementProperty('boxShadow', this.value)">
                    </div>
                </div>
            `;

            // Add text-specific properties
            if (['text', 'heading', 'button', 'badge'].includes(element.type)) {
                html += `
                    <div class="property-section">
                        <div class="section-title">Typography</div>
                        <div class="property-row">
                            <label class="property-label">Text</label>
                            <input type="text" class="property-input" value="${style.text || style.heading || ''}" onchange="updateElementProperty('text', this.value)">
                        </div>
                        <div class="property-row">
                            <label class="property-label">Color</label>
                            <input type="color" class="property-input property-input-color" value="${style.color || '#cccccc'}" onchange="updateElementProperty('color', this.value)">
                        </div>
                        <div class="property-row">
                            <label class="property-label">Font Size</label>
                            <input type="number" class="property-input property-input-small" value="${style.fontSize || 14}" onchange="updateElementProperty('fontSize', parseFloat(this.value))">
                        </div>
                    </div>
                `;
            }

            // Add progress-specific properties
            if (element.type === 'progress') {
                html += `
                    <div class="property-section">
                        <div class="section-title">Progress</div>
                        <div class="property-row">
                            <label class="property-label">Value</label>
                            <input type="range" class="property-input" min="0" max="${style.max || 100}" value="${style.value || 50}" onchange="updateElementProperty('value', parseFloat(this.value))">
                        </div>
                        <div class="property-row">
                            <label class="property-label">Progress</label>
                            <input type="color" class="property-input property-input-color" value="${style.progressColor || '#0e639c'}" onchange="updateElementProperty('progressColor', this.value)">
                        </div>
                    </div>
                `;
            }

            html += `
                <div class="property-section">
                    <div class="section-title">Info</div>
                    <div class="property-row">
                        <label class="property-label">Name</label>
                        <input type="text" class="property-input" value="${element.name}" onchange="updateElementProperty('name', this.value)">
                    </div>
                </div>
            `;

            content.innerHTML = html;
        }

        function updateElementProperty(prop, value) {
            if (!state.selectedElement) return;

            // Handle nested properties
            if (prop.includes('.')) {
                const [parent, child] = prop.split('.');
                state.selectedElement[parent][child] = value;
            } else {
                state.selectedElement[prop] = value;
            }

            updateElement(state.selectedElement);
            updateLayers();
        }

        // ==================== LAYERS PANEL ====================
        function updateLayers() {
            const list = document.getElementById('layersList');
            list.innerHTML = state.elements.map(el => `
                <div class="layer-item ${state.selectedElement?.id === el.id ? 'selected' : ''}" onclick="selectElementById('${el.id}')">
                    <div class="layer-icon">${getTypeIcon(el.type)}</div>
                    <div class="layer-name">${el.name}</div>
                    <button class="layer-delete" onclick="event.stopPropagation(); deleteLayer('${el.id}')">×</button>
                </div>
            `).join('');
        }

        function getTypeIcon(type) {
            const icons = {
                button: '▢', input: '▭', textarea: '▤', checkbox: '☑', radio: '◉',
                select: '▼', slider: '◀▶', range: '≡', progress: '▬',
                text: 'T', heading: 'H', badge: '●', avatar: '◉', card: '▣',
                rectangle: '▢', circle: '◯', triangle: '△', line: '—'
            };
            return icons[type] || '▢';
        }

        function selectElementById(id) {
            const element = state.elements.find(el => el.id === id);
            if (element) selectElement(element);
        }

        function deleteLayer(id) {
            const element = state.elements.find(el => el.id === id);
            if (element) {
                selectElement(element);
                deleteSelected();
            }
        }

        // ==================== CONTEXT MENU ====================
        function showContextMenu(x, y) {
            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';
            contextMenu.classList.add('visible');
        }

        function hideContextMenu() {
            contextMenu.classList.remove('visible');
        }

        document.addEventListener('click', hideContextMenu);

        function duplicateElement() {
            if (!state.selectedElement) return;

            const newElement = { ...state.selectedElement };
            newElement.id = 'el_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            newElement.x += 20;
            newElement.y += 20;
            newElement.name = state.selectedElement.name + ' copy';

            state.elements.push(newElement);

            const div = renderElement(newElement);
            canvas.appendChild(div);
            addElementEventListeners(div, newElement);
            updateLayers();
            selectElement(newElement);
        }

        function copyElement() {
            if (state.selectedElement) {
                state.clipboard = JSON.parse(JSON.stringify(state.selectedElement));
                showToast('Element copied');
            }
        }

        function pasteElement() {
            if (state.clipboard) {
                const newElement = JSON.parse(JSON.stringify(state.clipboard));
                newElement.id = 'el_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                newElement.x += 20;
                newElement.y += 20;
                newElement.name = newElement.name.replace(' copy', '') + ' copy';

                state.elements.push(newElement);

                const div = renderElement(newElement);
                canvas.appendChild(div);
                addElementEventListeners(div, newElement);
                updateLayers();
                selectElement(newElement);
                showToast('Element pasted');
            }
        }

        function bringToFront() {
            if (!state.selectedElement) return;
            const index = state.elements.findIndex(el => el.id === state.selectedElement.id);
            if (index > -1 && index < state.elements.length - 1) {
                const element = state.elements.splice(index, 1)[0];
                state.elements.push(element);
                const div = document.getElementById(element.id);
                canvas.appendChild(div);
                updateLayers();
            }
        }

        function sendToBack() {
            if (!state.selectedElement) return;
            const index = state.elements.findIndex(el => el.id === state.selectedElement.id);
            if (index > 0) {
                const element = state.elements.splice(index, 1)[0];
                state.elements.unshift(element);
                const div = document.getElementById(element.id);
                canvas.insertBefore(div, canvas.firstChild);
                updateLayers();
            }
        }

        // ==================== GRID AND SNAP ====================
        function snapToGrid(value) {
            if (!state.snapEnabled) return value;
            return Math.round(value / state.gridSize) * state.gridSize;
        }

        function toggleGrid() {
            state.showGrid = !state.showGrid;
            canvas.style.backgroundImage = state.showGrid ?
                `linear-gradient(var(--border-color) 1px, transparent 1px), linear-gradient(90deg, var(--border-color) 1px, transparent 1px)` : 'none';
            showToast(state.showGrid ? 'Grid visible' : 'Grid hidden');
        }

        function toggleSnap() {
            state.snapEnabled = !state.snapEnabled;
            showToast(state.snapEnabled ? 'Snap enabled' : 'Snap disabled');
        }

        // ==================== ZOOM ====================
        function zoomIn() {
            state.zoom = Math.min(3, state.zoom + 0.1);
            applyZoom();
        }

        function zoomOut() {
            state.zoom = Math.max(0.1, state.zoom - 0.1);
            applyZoom();
        }

        function resetZoom() {
            state.zoom = 1;
            applyZoom();
        }

        function applyZoom() {
            canvas.style.transform = `scale(${state.zoom})`;
            canvas.style.transformOrigin = 'top left';
            document.getElementById('zoomValue').textContent = Math.round(state.zoom * 100) + '%';
        }

        // ==================== EXPORT ====================
        function exportProject() {
            document.getElementById('exportModal').classList.add('visible');
        }

        function closeExportModal() {
            document.getElementById('exportModal').classList.remove('visible');
        }

        function downloadExport() {
            const filename = document.getElementById('exportFilename').value || 'my-design.html';
            const inlineCSS = document.getElementById('exportInline').checked;
            const responsive = document.getElementById('exportResponsive').checked;

            const html = generateExportHTML(inlineCSS, responsive);

            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            closeExportModal();
            showToast(`Exported as ${filename}`);
        }

        function generateExportHTML(inlineCSS, responsive) {
            let elementsHTML = '';

            state.elements.forEach(el => {
                const style = el.style;
                let content = '';

                switch(el.type) {
                    case 'button':
                        content = `<button style="
                            width: 100%;
                            height: 100%;
                            background: ${style.bgColor || '#0e639c'};
                            color: white;
                            border: none;
                            border-radius: ${style.borderRadius || 6}px;
                            font-size: 14px;
                            font-weight: 500;
                            cursor: pointer;
                        ">${style.text || 'Button'}</button>`;
                        break;
                    case 'input':
                        content = `<input type="text" placeholder="${style.placeholder || 'Enter text...'}" style="
                            width: 100%;
                            height: 100%;
                            border: 1px solid ${style.borderColor || '#3c3c3c'};
                            border-radius: ${style.borderRadius || 4}px;
                            background: #1e1e1e;
                            color: #cccccc;
                            padding: 0 12px;
                            font-size: 14px;
                        ">`;
                        break;
                    case 'textarea':
                        content = `<textarea placeholder="${style.placeholder || 'Enter text...'}" style="
                            width: 100%;
                            height: 100%;
                            border: 1px solid ${style.borderColor || '#3c3c3c'};
                            border-radius: ${style.borderRadius || 4}px;
                            background: #1e1e1e;
                            color: #cccccc;
                            padding: 8px 12px;
                            font-size: 14px;
                            resize: none;
                        "></textarea>`;
                        break;
                    case 'checkbox':
                        content = `<input type="checkbox" ${style.checked ? 'checked' : ''} style="width: ${el.width}px; height: ${el.height}px; accent-color: #0e639c;">`;
                        break;
                    case 'radio':
                        content = `<input type="radio" ${style.checked ? 'checked' : ''} style="width: ${el.width}px; height: ${el.height}px; accent-color: #0e639c;">`;
                        break;
                    case 'select':
                        content = `<select style="
                            width: 100%;
                            height: 100%;
                            border: 1px solid ${style.borderColor || '#3c3c3c'};
                            border-radius: ${style.borderRadius || 4}px;
                            background: #1e1e1e;
                            color: #cccccc;
                            padding: 0 12px;
                            font-size: 14px;
                        ">${(style.options || ['Option 1', 'Option 2', 'Option 3']).map(opt => `<option>${opt}</option>`).join('')}</select>`;
                        break;
                    case 'slider':
                        content = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%;">
                            <input type="range" min="${style.min || 0}" max="${style.max || 100}" value="${style.value || 50}" style="width: 90%; accent-color: #0e639c;">
                            <span style="font-size: 12px; color: #858585;">${style.value || 50}</span>
                        </div>`;
                        break;
                    case 'progress':
                        content = `<div style="
                            width: 100%;
                            height: 100%;
                            background: ${style.bgColor || '#3c3c3c'};
                            border-radius: 4px;
                            overflow: hidden;
                        "><div style="
                            width: ${((style.value || 50) / (style.max || 100)) * 100}%;
                            height: 100%;
                            background: ${style.progressColor || '#0e639c'};
                        "></div></div>`;
                        break;
                    case 'text':
                        content = `<span style="
                            color: ${style.color || '#cccccc'};
                            font-size: ${style.fontSize || 14}px;
                        ">${style.text || 'Sample text'}</span>`;
                        break;
                    case 'heading':
                        content = `<h2 style="
                            color: ${style.color || '#cccccc'};
                            font-size: ${style.fontSize || 24}px;
                            font-weight: bold;
                            margin: 0;
                        ">${style.heading || 'Heading'}</h2>`;
                        break;
                    case 'badge':
                        content = `<span style="
                            display: inline-flex;
                            align-items: center;
                            justify-content: center;
                            background: ${style.bgColor || '#4caf50'};
                            color: white;
                            font-size: ${style.fontSize || 12}px;
                            border-radius: ${style.borderRadius || 12}px;
                            padding: 0 12px;
                        ">${style.text || 'Badge'}</span>`;
                        break;
                    case 'card':
                        content = `<div style="
                            width: 100%;
                            height: 100%;
                            background: ${style.bgColor || '#252526'};
                            border: 1px solid ${style.borderColor || '#3c3c3c'};
                            border-radius: ${style.borderRadius || 8}px;
                        "></div>`;
                        break;
                    case 'rectangle':
                        content = `<div style="
                            width: 100%;
                            height: 100%;
                            background: ${style.bgColor || '#0e639c'};
                            border-radius: ${style.borderRadius || 0}px;
                        "></div>`;
                        break;
                    case 'circle':
                        content = `<div style="
                            width: 100%;
                            height: 100%;
                            background: ${style.bgColor || '#0e639c'};
                            border-radius: 50%;
                        "></div>`;
                        break;
                    case 'triangle':
                        content = `<div style="
                            width: 0;
                            height: 0;
                            border-left: ${el.width / 2}px solid transparent;
                            border-right: ${el.width / 2}px solid transparent;
                            border-bottom: ${el.height}px solid ${style.bgColor || '#0e639c'};
                        "></div>`;
                        break;
                    case 'line':
                        content = `<div style="
                            width: 100%;
                            height: ${Math.max(4, el.height)}px;
                            background: ${style.bgColor || '#0e639c'};
                            border-radius: 2px;
                        "></div>`;
                        break;
                }

                elementsHTML += `<div style="
                    position: absolute;
                    left: ${el.x}px;
                    top: ${el.y}px;
                    width: ${el.width}px;
                    height: ${el.height}px;
                    opacity: ${el.opacity};
                    transform: rotate(${el.rotation}deg);
                    ${style.boxShadow ? `box-shadow: ${style.boxShadow};` : ''}
                ">${content}</div>`;
            });

            // Generate connection lines
            let connectionsHTML = '';
            if (state.connections.length > 0) {
                connectionsHTML = `<svg style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">`;
                state.connections.forEach(conn => {
                    const fromEl = state.elements.find(e => e.id === conn.from.elementId);
                    const toEl = state.elements.find(e => e.id === conn.to.elementId);
                    if (fromEl && toEl) {
                        const from = getConnectionPoint(fromEl, conn.from.point);
                        const to = getConnectionPoint(toEl, conn.to.point);
                        const dx = to.x - from.x;
                        const path = `M ${from.x} ${from.y} C ${from.x + dx * 0.5} ${from.y}, ${to.x - dx * 0.5} ${to.y}, ${to.x} ${to.y}`;
                        connectionsHTML += `<path d="${path}" stroke="#0e639c" stroke-width="2" fill="none"/>`;
                    }
                });
                connectionsHTML += `</svg>`;
            }

            const css = inlineCSS ? '' : `
                <style>
                    * { margin: 0; padding: 0; box-sizing: border-box; }
                    body {
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                        background: #121212;
                        min-height: 100vh;
                        overflow: auto;
                    }
                    .canvas {
                        position: relative;
                        width: ${canvas.offsetWidth}px;
                        height: ${canvas.offsetHeight}px;
                        background: #121212;
                        ${state.showGrid ? `background-image: linear-gradient(#3c3c3c 1px, transparent 1px), linear-gradient(90deg, #3c3c3c 1px, transparent 1px); background-size: 20px 20px;` : ''}
                    }
                </style>
            `;

            return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI Design Export</title>
    ${css}
</head>
<body>
    <div class="canvas">
        ${connectionsHTML}
        ${elementsHTML}
    </div>
</body>
</html>`;
        }

        // ==================== NEW/OPEN PROJECT ====================
        function newProject() {
            if (state.elements.length > 0) {
                if (!confirm('Create new project? All unsaved changes will be lost.')) return;
            }

            state.elements = [];
            state.connections = [];
            state.selectedElement = null;

            canvas.innerHTML = '';
            updateLayers();
            updatePropertiesPanel(null);
            showToast('New project created');
        }

        function openProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,.uib';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        loadProject(data);
                        showToast('Project loaded');
                    } catch (err) {
                        showToast('Error loading project');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function loadProject(data) {
            state.elements = data.elements || [];
            state.connections = data.connections || [];

            canvas.innerHTML = '';

            state.elements.forEach(el => {
                const div = renderElement(el);
                canvas.appendChild(div);
                addElementEventListeners(div, el);
            });

            // Re-render connections
            const svg = getConnectionsSVG();
            svg.innerHTML = '';
            state.connections.forEach(conn => renderConnection(conn));

            updateLayers();
            selectElement(null);
        }

        function saveProject() {
            const data = {
                elements: state.elements,
                connections: state.connections,
                gridSize: state.gridSize,
                snapEnabled: state.snapEnabled,
                showGrid: state.showGrid
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'project.uib';
            a.click();
            URL.revokeObjectURL(url);

            showToast('Project saved');
        }

        // ==================== TOAST NOTIFICATIONS ====================
        function showToast(message) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            container.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        }

        // ==================== KEYBOARD SHORTCUTS ====================
        document.addEventListener('keydown', (e) => {
            // Delete
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (state.selectedElement && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                    deleteSelected();
                }
            }

            // Copy
            if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                if (state.selectedElement) {
                    e.preventDefault();
                    copyElement();
                }
            }

            // Paste
            if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                e.preventDefault();
                pasteElement();
            }

            // Duplicate
            if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
                e.preventDefault();
                duplicateElement();
            }

            // Save
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveProject();
            }

            // Escape
            if (e.key === 'Escape') {
                selectElement(null);
                hideContextMenu();
            }
        });

        // ==================== CANVAS CONTEXT MENU ====================
        canvas.addEventListener('contextmenu', (e) => {
            if (e.target === canvas || e.target.classList.contains('canvas-element') === false) {
                e.preventDefault();
                showContextMenu(e.clientX, e.clientY);
            }
        });

        // ==================== INITIALIZATION ====================
        function init() {
            initCanvas();
            updateLayers();

            // Add some sample elements
            setTimeout(() => {
                addElement('card', 100, 100);
                addElement('button', 120, 130);
                addElement('input', 120, 190);
                addElement('progress', 120, 250);
            }, 100);

            // Window resize handler
            window.addEventListener('resize', initCanvas);
        }

        // Start the application
        init();
    </script>
</body>
</html>
