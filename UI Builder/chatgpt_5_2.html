<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Single-File UI Builder (Figma-ish) + Flowchart Connectors</title>
  <style>
    :root{
      --bg:#0b0f16;
      --panel:#121a26;
      --panel2:#0f1622;
      --line:#23314a;
      --text:#e9eefc;
      --muted:#aebad6;
      --accent:#67b3ff;
      --good:#35d39f;
      --bad:#ff6b87;
      --warn:#ffd166;
      --shadow: rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      --grid: rgba(255,255,255,.05);
      --guide: rgba(103,179,255,.75);
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; background:var(--bg); color:var(--text); font-family:var(--sans); overflow:hidden; }
    button, input, select, textarea { font: inherit; color: inherit; }
    a{ color:var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }
    .app{
      height:100%;
      display:grid;
      grid-template-rows: 54px 1fr;
    }
    header{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(18,26,38,.98), rgba(10,15,22,.92));
      box-shadow: 0 8px 26px var(--shadow);
      user-select:none;
    }
    .brand{ font-weight:900; letter-spacing:.2px; }
    .brand small{ margin-left:8px; font-weight:650; color:var(--muted); }
    .pill{
      font-size:12px; color:var(--muted);
      padding:6px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      background: rgba(255,255,255,.03);
      white-space: nowrap;
    }
    .spacer{ flex:1; }
    .btn{
      display:inline-flex; align-items:center; gap:8px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      padding:8px 10px;
      border-radius:12px;
      cursor:pointer;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
      font-weight:800;
    }
    .btn:hover{ background: rgba(255,255,255,.06); border-color:#2f4061; }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ border-color: rgba(103,179,255,.55); box-shadow: 0 0 0 3px rgba(103,179,255,.12); }
    .btn.toggle.on{ background: rgba(103,179,255,.12); border-color: rgba(103,179,255,.55); }
    .btn.danger{ border-color: rgba(255,107,135,.45); }
    .k{
      font-family:var(--mono);
      font-size:11px;
      padding:2px 7px;
      border-radius:999px;
      border:1px solid var(--line);
      color:var(--muted);
      font-weight:700;
    }

    .main{
      height:100%;
      display:grid;
      grid-template-columns: 280px 1fr 360px;
      min-height:0;
    }
    @media (max-width: 1060px){
      .main{ grid-template-columns: 260px 1fr 340px; }
    }
    @media (max-width: 920px){
      .main{ grid-template-columns: 1fr; grid-template-rows: 230px 1fr 310px; }
      .left{ border-right:none !important; border-bottom:1px solid var(--line); }
      .right{ border-left:none !important; border-top:1px solid var(--line); }
    }

    .left, .right{
      min-height:0;
      background: rgba(18,26,38,.92);
    }
    .left{ border-right:1px solid var(--line); }
    .right{ border-left:1px solid var(--line); }

    .panel{
      height:100%;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .panel h2{
      margin:0;
      padding:10px 12px;
      font-size:12px;
      letter-spacing:.9px;
      text-transform:uppercase;
      color:var(--muted);
      border-bottom:1px solid var(--line);
      background: rgba(0,0,0,.10);
    }
    .panel .body{
      padding:10px 12px;
      min-height:0;
      overflow:auto;
    }
    .group{
      border:1px solid var(--line);
      border-radius:16px;
      background: rgba(255,255,255,.03);
      padding:10px;
      margin-bottom:10px;
    }
    .groupTitle{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
      color:var(--muted);
      font-weight:900;
      font-size:12px;
      letter-spacing:.4px;
    }
    .libGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px;
    }
    .libItem{
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(255,255,255,.03);
      padding:10px 10px;
      cursor:grab;
      user-select:none;
      transition: background .12s ease, border-color .12s ease, transform .05s ease;
      display:flex;
      flex-direction:column;
      gap:6px;
      min-height:58px;
    }
    .libItem:hover{ background: rgba(255,255,255,.06); border-color:#2f4061; }
    .libItem:active{ transform: translateY(1px); cursor:grabbing; }
    .libItem .t{ font-weight:900; }
    .libItem .s{ font-size:11px; color:var(--muted); line-height:1.25; }

    /* Canvas area */
    .center{
      position:relative;
      min-height:0;
      background:
        radial-gradient(1200px 600px at 50% 0%, rgba(103,179,255,.08), transparent 60%),
        radial-gradient(900px 500px at 0% 100%, rgba(53,211,159,.06), transparent 55%),
        radial-gradient(900px 500px at 100% 100%, rgba(255,209,102,.05), transparent 55%),
        linear-gradient(180deg, rgba(10,14,20,.92), rgba(8,10,16,.96));
      overflow:hidden;
    }
    .canvasShell{
      position:absolute; inset: 12px;
      overflow:auto;
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;
      background: rgba(0,0,0,.18);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
    }
    .canvasWrap{
      position:relative;
      margin: 14px;
      display:inline-block;
      background:
        repeating-linear-gradient(0deg, transparent 0px, transparent calc(var(--gridSize) - 1px), var(--grid) calc(var(--gridSize) - 1px), var(--grid) var(--gridSize)),
        repeating-linear-gradient(90deg, transparent 0px, transparent calc(var(--gridSize) - 1px), var(--grid) calc(var(--gridSize) - 1px), var(--grid) var(--gridSize));
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      box-shadow: 0 20px 50px rgba(0,0,0,.30);
    }
    .canvasWrap.hideGrid{
      background: rgba(255,255,255,.02);
    }
    .canvas{
      position:relative;
      width: 1200px;
      height: 720px;
      border-radius:14px;
      overflow:hidden;
      background: rgba(255,255,255,.02);
    }

    /* SVG connections overlay */
    .connSvg{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:auto;
    }
    .connPath{
      fill:none;
      stroke: rgba(200,220,255,.85);
      stroke-width: 2;
      vector-effect: non-scaling-stroke;
      cursor:pointer;
    }
    .connPath.selected{
      stroke: var(--accent);
      stroke-width: 3;
    }
    .connHandle{
      fill: rgba(103,179,255,.95);
      stroke: rgba(10,15,22,.95);
      stroke-width: 2;
      cursor: move;
      pointer-events: all;
    }
    .arrowMarker{
      fill: rgba(200,220,255,.95);
    }

    /* Elements on canvas */
    .node{
      position:absolute;
      user-select:none;
      touch-action:none;
      outline:none;
    }
    .node .inner{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:flex; align-items:center; justify-content:center;
      overflow:hidden;
    }
    .node[data-type="text"] .inner{
      display:block;
      padding: 10px;
      justify-content:flex-start;
      align-items:flex-start;
      white-space: pre-wrap;
    }

    /* Default component look */
    .ui-button{
      width:100%; height:100%;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(103,179,255,.18);
      border-radius: 12px;
      font-weight: 900;
      cursor: default;
    }
    .ui-input, .ui-textfield, .ui-dropdown{
      width:100%; height:100%;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.18);
      border-radius: 12px;
      padding: 10px 10px;
      color: var(--text);
      outline:none;
    }
    .ui-checkboxWrap{
      width:100%; height:100%;
      display:flex; align-items:center; gap:10px;
      padding: 8px 10px;
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 12px;
      background: rgba(0,0,0,.18);
      justify-content:flex-start;
      font-weight: 800;
    }
    .ui-slider{
      width: 100%;
    }
    .ui-stepper{
      width:100%; height:100%;
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 12px;
      background: rgba(0,0,0,.18);
      display:flex; align-items:center; justify-content:space-between;
      padding: 6px 8px;
      gap:8px;
      font-weight: 900;
    }
    .ui-stepper button{
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.04);
      border-radius: 10px;
      width: 34px; height: 34px;
      cursor: default;
      font-weight: 900;
    }
    .ui-progress{
      width:100%; height:100%;
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 999px;
      background: rgba(0,0,0,.18);
      overflow:hidden;
      padding: 4px;
    }
    .ui-progress > div{
      height:100%;
      border-radius: 999px;
      background: rgba(53,211,159,.55);
      width: 55%;
    }

    /* Shapes */
    .shape-rect{
      width:100%; height:100%;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 12px;
    }
    .shape-circle{
      width:100%; height:100%;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 9999px;
    }
    .shape-triangle{
      width:100%; height:100%;
      position:relative;
      background: transparent;
    }
    .shape-triangle:before{
      content:"";
      position:absolute; left:50%; top:50%;
      transform: translate(-50%,-50%);
      width:0; height:0;
      border-left: 60px solid transparent;
      border-right: 60px solid transparent;
      border-bottom: 110px solid rgba(255,255,255,.10);
      filter: drop-shadow(0 0 0 rgba(0,0,0,0));
    }
    .shape-line{
      width:100%; height:100%;
      position:relative;
      background: transparent;
    }
    .shape-line:before{
      content:"";
      position:absolute;
      left:0; top:50%;
      width:100%; height:2px;
      background: rgba(255,255,255,.72);
      transform: translateY(-50%);
    }

    /* Selection box overlay */
    .selection{
      position:absolute;
      border: 2px solid rgba(103,179,255,.85);
      border-radius: 10px;
      box-shadow: 0 0 0 2px rgba(103,179,255,.12);
      pointer-events:none;
      display:none;
      z-index: 9999;
    }
    .handle{
      position:absolute;
      width: 10px; height: 10px;
      background: rgba(103,179,255,.95);
      border:2px solid rgba(10,15,22,.95);
      border-radius: 3px;
      pointer-events:auto;
    }
    .handle.nw{ left:-6px; top:-6px; cursor:nwse-resize; }
    .handle.ne{ right:-6px; top:-6px; cursor:nesw-resize; }
    .handle.sw{ left:-6px; bottom:-6px; cursor:nesw-resize; }
    .handle.se{ right:-6px; bottom:-6px; cursor:nwse-resize; }
    .handle.n{ left:50%; top:-6px; transform:translateX(-50%); cursor:ns-resize; }
    .handle.s{ left:50%; bottom:-6px; transform:translateX(-50%); cursor:ns-resize; }
    .handle.w{ left:-6px; top:50%; transform:translateY(-50%); cursor:ew-resize; }
    .handle.e{ right:-6px; top:50%; transform:translateY(-50%); cursor:ew-resize; }

    /* Guides */
    .guide{
      position:absolute;
      display:none;
      z-index: 9000;
      pointer-events:none;
    }
    .guide.v{ top:0; bottom:0; width:1px; background: var(--guide); }
    .guide.h{ left:0; right:0; height:1px; background: var(--guide); }

    /* Canvas resizer */
    .canvasResizer{
      position:absolute;
      width: 14px; height: 14px;
      right: 6px; bottom: 6px;
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 4px;
      background: rgba(255,255,255,.08);
      cursor: nwse-resize;
      z-index: 9500;
    }

    /* Properties panel controls */
    .row{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 8px;
    }
    .row3{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
      margin-bottom: 8px;
    }
    .label{
      font-size: 12px; color: var(--muted);
      margin: 8px 0 6px;
      font-weight: 900;
      letter-spacing: .2px;
    }
    .ctrl{
      width:100%;
      border:1px solid var(--line);
      border-radius: 12px;
      padding: 9px 10px;
      background: rgba(255,255,255,.03);
      outline:none;
    }
    .ctrl:focus{ border-color: rgba(103,179,255,.55); box-shadow: 0 0 0 3px rgba(103,179,255,.12); }
    .miniHelp{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
      margin-top: 10px;
    }
    .tiny{
      font-size: 11px; color: var(--muted); font-family: var(--mono);
      padding: 6px 8px; border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.03);
      line-height: 1.35;
      margin-top: 8px;
    }
    .sep{
      height:1px;
      background: rgba(255,255,255,.08);
      margin: 10px 0;
    }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="brand">UI Builder <small>single-file ¬∑ drag/drop ¬∑ grid ¬∑ guides ¬∑ connectors ¬∑ export</small></div>
    <div class="pill" id="pillDoc">Canvas: ‚Äî</div>
    <div class="pill" id="pillSel">Selection: ‚Äî</div>
    <div class="spacer"></div>

    <button class="btn toggle" id="btnConnect" title="Connect tool: click two elements to connect"><span>üîó</span>Connect <span class="k">C</span></button>
    <button class="btn toggle on" id="btnSnap" title="Snap to grid & guides"><span>üß≤</span>Snap <span class="k">G</span></button>
    <button class="btn toggle on" id="btnGrid" title="Show/hide grid"><span>‚ñ¶</span>Grid</button>

    <button class="btn" id="btnDuplicate" title="Duplicate selected"><span>üìÑ</span>Duplicate <span class="k">Ctrl D</span></button>
    <button class="btn danger" id="btnDelete" title="Delete selected (element or connection)"><span>üóëÔ∏è</span>Delete <span class="k">Del</span></button>
    <button class="btn primary" id="btnExport" title="Export to runnable HTML"><span>üßæ</span>Export HTML</button>
  </header>

  <div class="main">
    <!-- LEFT: Library -->
    <aside class="left panel">
      <h2>Library</h2>
      <div class="body">
        <div class="group">
          <div class="groupTitle"><span>UI Components</span><span class="k">Drag ‚Üí</span></div>
          <div class="libGrid" id="libUI"></div>
        </div>
        <div class="group">
          <div class="groupTitle"><span>Shapes</span><span class="k">Drag ‚Üí</span></div>
          <div class="libGrid" id="libShapes"></div>
        </div>
        <div class="tiny">
          Tips:
          <br>‚Ä¢ Drag components onto the canvas
          <br>‚Ä¢ Drag handles to resize
          <br>‚Ä¢ Connect mode: click two elements
          <br>‚Ä¢ Click a connection to edit its bend
        </div>
      </div>
    </aside>

    <!-- CENTER: Canvas -->
    <section class="center">
      <div class="canvasShell" id="canvasShell">
        <div class="canvasWrap" id="canvasWrap" style="--gridSize: 16px;">
          <div class="canvas" id="canvas">
            <!-- Connections SVG (behind nodes) -->
            <svg class="connSvg" id="connSvg">
              <defs>
                <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                  <path class="arrowMarker" d="M0,0 L10,3 L0,6 Z"></path>
                </marker>
              </defs>
              <g id="connGroup"></g>
              <g id="connHandles"></g>
            </svg>

            <!-- Guides -->
            <div class="guide v" id="guideV"></div>
            <div class="guide h" id="guideH"></div>

            <!-- Selection overlay -->
            <div class="selection" id="selection">
              <div class="handle nw" data-h="nw"></div>
              <div class="handle n" data-h="n"></div>
              <div class="handle ne" data-h="ne"></div>
              <div class="handle e" data-h="e"></div>
              <div class="handle se" data-h="se"></div>
              <div class="handle s" data-h="s"></div>
              <div class="handle sw" data-h="sw"></div>
              <div class="handle w" data-h="w"></div>
            </div>

            <!-- Canvas resize handle -->
            <div class="canvasResizer" id="canvasResizer" title="Resize canvas"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- RIGHT: Properties -->
    <aside class="right panel">
      <h2>Properties</h2>
      <div class="body">
        <div class="group">
          <div class="groupTitle"><span>Canvas</span><span class="k">W√óH</span></div>
          <div class="row">
            <div>
              <div class="label">Width (px)</div>
              <input class="ctrl" id="canvasW" type="number" min="200" max="8000" step="10" />
            </div>
            <div>
              <div class="label">Height (px)</div>
              <input class="ctrl" id="canvasH" type="number" min="200" max="8000" step="10" />
            </div>
          </div>
          <div class="row">
            <div>
              <div class="label">Grid size (px)</div>
              <input class="ctrl" id="gridSize" type="number" min="4" max="128" step="1" />
            </div>
            <div>
              <div class="label">Guide snap (px)</div>
              <input class="ctrl" id="guideSnap" type="number" min="1" max="30" step="1" />
            </div>
          </div>
        </div>

        <div class="group">
          <div class="groupTitle"><span>Selection</span><span class="k" id="selType">‚Äî</span></div>

          <div id="noSel" class="miniHelp">
            Click an element to edit its properties.<br>
            Use <b>Connect</b> to draw flowchart lines between elements.
          </div>

          <div id="props" style="display:none;">
            <div class="row">
              <div>
                <div class="label">X</div>
                <input class="ctrl" id="pX" type="number" step="1" />
              </div>
              <div>
                <div class="label">Y</div>
                <input class="ctrl" id="pY" type="number" step="1" />
              </div>
            </div>
            <div class="row">
              <div>
                <div class="label">Width</div>
                <input class="ctrl" id="pW" type="number" min="10" step="1" />
              </div>
              <div>
                <div class="label">Height</div>
                <input class="ctrl" id="pH" type="number" min="10" step="1" />
              </div>
            </div>

            <div class="sep"></div>

            <div class="row">
              <div>
                <div class="label">Fill</div>
                <input class="ctrl" id="pFill" type="color" />
              </div>
              <div>
                <div class="label">Text color</div>
                <input class="ctrl" id="pTextColor" type="color" />
              </div>
            </div>

            <div class="row">
              <div>
                <div class="label">Border width</div>
                <input class="ctrl" id="pBorderW" type="number" min="0" max="40" step="1" />
              </div>
              <div>
                <div class="label">Border color</div>
                <input class="ctrl" id="pBorderC" type="color" />
              </div>
            </div>

            <div class="row">
              <div>
                <div class="label">Border radius</div>
                <input class="ctrl" id="pRadius" type="number" min="0" max="400" step="1" />
              </div>
              <div>
                <div class="label">Opacity</div>
                <input class="ctrl" id="pOpacity" type="number" min="0" max="1" step="0.05" />
              </div>
            </div>

            <div class="row">
              <div>
                <div class="label">Font size (px)</div>
                <input class="ctrl" id="pFontSize" type="number" min="6" max="120" step="1" />
              </div>
              <div>
                <div class="label">Z-index</div>
                <input class="ctrl" id="pZ" type="number" step="1" />
              </div>
            </div>

            <div class="label">Text / Content</div>
            <textarea class="ctrl" id="pText" rows="3" placeholder="Label / text content"></textarea>

            <div class="sep"></div>

            <div class="groupTitle"><span>Box Shadow</span><span class="k">CSS</span></div>
            <div class="row">
              <div>
                <div class="label">Shadow X</div>
                <input class="ctrl" id="pShX" type="number" step="1" />
              </div>
              <div>
                <div class="label">Shadow Y</div>
                <input class="ctrl" id="pShY" type="number" step="1" />
              </div>
            </div>
            <div class="row">
              <div>
                <div class="label">Blur</div>
                <input class="ctrl" id="pShBlur" type="number" min="0" step="1" />
              </div>
              <div>
                <div class="label">Spread</div>
                <input class="ctrl" id="pShSpread" type="number" step="1" />
              </div>
            </div>
            <div class="row">
              <div>
                <div class="label">Shadow color</div>
                <input class="ctrl" id="pShColor" type="color" />
              </div>
              <div>
                <div class="label">Enabled</div>
                <select class="ctrl" id="pShOn">
                  <option value="1">On</option>
                  <option value="0">Off</option>
                </select>
              </div>
            </div>

            <div class="sep"></div>

            <div class="groupTitle"><span>Component-specific</span><span class="k">Optional</span></div>
            <div class="row">
              <div>
                <div class="label">Value (slider/progress)</div>
                <input class="ctrl" id="pValue" type="number" step="1" />
              </div>
              <div>
                <div class="label">Checked (checkbox)</div>
                <select class="ctrl" id="pChecked">
                  <option value="0">No</option>
                  <option value="1">Yes</option>
                </select>
              </div>
            </div>
            <div class="row">
              <div>
                <div class="label">Min</div>
                <input class="ctrl" id="pMin" type="number" step="1" />
              </div>
              <div>
                <div class="label">Max</div>
                <input class="ctrl" id="pMax" type="number" step="1" />
              </div>
            </div>
            <div class="label">Dropdown options (comma-separated)</div>
            <input class="ctrl" id="pOptions" type="text" placeholder="Option A, Option B, Option C" />
          </div>
        </div>

        <div class="tiny">
          Shortcuts:
          <br><b>C</b> Connect tool
          <br><b>G</b> Snap toggle
          <br><b>Del</b> Delete
          <br><b>Ctrl/‚åò + D</b> Duplicate
          <br>Click connection ‚Üí drag blue handle to adjust bend
        </div>
      </div>
    </aside>
  </div>
</div>

<script>
(() => {
  // ========= STATE =========
  const State = {
    canvasW: 1200,
    canvasH: 720,
    gridSize: 16,
    guideSnapPx: 6,
    showGrid: true,
    snap: true,

    nodes: new Map(),        // id -> node
    connections: new Map(),  // id -> conn

    selectedNodeId: null,
    selectedConnId: null,

    connectMode: false,
    connectFromId: null,

    drag: null,   // {type:'move'|'resize'|'canvas', ...}
    nextZ: 10,
  };

  const $ = (id) => document.getElementById(id);
  const canvas = $("canvas");
  const canvasWrap = $("canvasWrap");
  const pillDoc = $("pillDoc");
  const pillSel = $("pillSel");

  const selection = $("selection");
  const guideV = $("guideV");
  const guideH = $("guideH");

  const connSvg = $("connSvg");
  const connGroup = $("connGroup");
  const connHandles = $("connHandles");

  const btnConnect = $("btnConnect");
  const btnSnap = $("btnSnap");
  const btnGrid = $("btnGrid");
  const btnExport = $("btnExport");
  const btnDelete = $("btnDelete");
  const btnDuplicate = $("btnDuplicate");

  const canvasWInput = $("canvasW");
  const canvasHInput = $("canvasH");
  const gridSizeInput = $("gridSize");
  const guideSnapInput = $("guideSnap");
  const canvasResizer = $("canvasResizer");

  // Properties panel
  const selType = $("selType");
  const noSel = $("noSel");
  const props = $("props");

  const pX = $("pX"), pY = $("pY"), pW = $("pW"), pH = $("pH");
  const pFill = $("pFill"), pTextColor = $("pTextColor");
  const pBorderW = $("pBorderW"), pBorderC = $("pBorderC");
  const pRadius = $("pRadius"), pOpacity = $("pOpacity");
  const pFontSize = $("pFontSize"), pZ = $("pZ");
  const pText = $("pText");
  const pShX = $("pShX"), pShY = $("pShY"), pShBlur = $("pShBlur"), pShSpread = $("pShSpread"), pShColor = $("pShColor"), pShOn = $("pShOn");
  const pValue = $("pValue"), pChecked = $("pChecked"), pMin = $("pMin"), pMax = $("pMax"), pOptions = $("pOptions");

  // ========= HELPERS =========
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const snapTo = (v, step)=> Math.round(v/step)*step;
  const uid = () => (crypto.randomUUID ? crypto.randomUUID() : String(Math.random()).slice(2));

  function canvasRect() {
    return canvas.getBoundingClientRect();
  }
  function toCanvasXY(clientX, clientY){
    const r = canvasRect();
    return { x: clientX - r.left, y: clientY - r.top };
  }
  function within(v, target, eps){ return Math.abs(v-target) <= eps; }

  function setPills(){
    pillDoc.textContent = `Canvas: ${State.canvasW}√ó${State.canvasH}`;
    if (State.selectedNodeId){
      const n = State.nodes.get(State.selectedNodeId);
      pillSel.textContent = `Selection: ${n.type} (${n.id.slice(0,8)})`;
    } else if (State.selectedConnId){
      pillSel.textContent = `Selection: connection (${State.selectedConnId.slice(0,8)})`;
    } else {
      pillSel.textContent = `Selection: ‚Äî`;
    }
  }

  function setCanvasSize(w,h){
    State.canvasW = clamp(Math.round(w), 200, 8000);
    State.canvasH = clamp(Math.round(h), 200, 8000);
    canvas.style.width = State.canvasW + "px";
    canvas.style.height = State.canvasH + "px";
    canvasWInput.value = State.canvasW;
    canvasHInput.value = State.canvasH;
    requestConnectionsUpdate();
    setPills();
  }
  function setGridSize(sz){
    State.gridSize = clamp(Math.round(sz), 4, 128);
    canvasWrap.style.setProperty("--gridSize", State.gridSize + "px");
    gridSizeInput.value = State.gridSize;
  }
  function setGuideSnapPx(px){
    State.guideSnapPx = clamp(Math.round(px), 1, 30);
    guideSnapInput.value = State.guideSnapPx;
  }
  function setShowGrid(on){
    State.showGrid = !!on;
    canvasWrap.classList.toggle("hideGrid", !State.showGrid);
    btnGrid.classList.toggle("on", State.showGrid);
  }
  function setSnap(on){
    State.snap = !!on;
    btnSnap.classList.toggle("on", State.snap);
  }
  function setConnectMode(on){
    State.connectMode = !!on;
    btnConnect.classList.toggle("on", State.connectMode);
    State.connectFromId = null;
    canvas.style.cursor = State.connectMode ? "crosshair" : "default";
  }

  function hideGuides(){
    guideV.style.display = "none";
    guideH.style.display = "none";
  }
  function showGuideV(x){
    guideV.style.display = "block";
    guideV.style.left = x + "px";
  }
  function showGuideH(y){
    guideH.style.display = "block";
    guideH.style.top = y + "px";
  }

  function deselectAll(){
    State.selectedNodeId = null;
    State.selectedConnId = null;
    State.connectFromId = null;
    selection.style.display = "none";
    // unselect connection visuals
    for (const path of connGroup.querySelectorAll(".connPath")){
      path.classList.remove("selected");
    }
    // remove handles
    connHandles.innerHTML = "";
    updatePropsPanel();
    setPills();
  }

  // ========= NODE CREATION =========
  function defaultStyleFor(type){
    return {
      fill: "#1a2437",
      textColor: "#e9eefc",
      borderW: 1,
      borderC: "#3a4b72",
      radius: 12,
      opacity: 1,
      fontSize: 14,
      shadowOn: 1,
      shX: 0,
      shY: 10,
      shBlur: 24,
      shSpread: 0,
      shColor: "#000000",
    };
  }

  function makeNode(type, x, y){
    const id = uid();
    const base = defaultStyleFor(type);
    const node = {
      id, type,
      x: Math.round(x), y: Math.round(y),
      w: 160, h: 52,
      z: State.nextZ++,
      text: "",
      value: 50,
      checked: 0,
      min: 0,
      max: 100,
      options: ["Option A", "Option B", "Option C"],
      style: {...base},
    };

    // sensible defaults
    if (type === "button"){ node.text = "Button"; node.w=160; node.h=48; node.style.fill="#2b3f66"; }
    if (type === "input"){ node.text = ""; node.w=220; node.h=48; }
    if (type === "textfield"){ node.text = "Label"; node.w=240; node.h=56; node.style.fill="#121a26"; }
    if (type === "checkbox"){ node.text = "Checkbox"; node.w=180; node.h=44; }
    if (type === "dropdown"){ node.w=220; node.h=48; }
    if (type === "slider"){ node.w=260; node.h=44; node.value=40; }
    if (type === "stepper"){ node.w=200; node.h=48; node.value=1; node.min=0; node.max=10; }
    if (type === "progress"){ node.w=240; node.h=26; node.value=55; node.style.radius=999; node.style.fill="#0f1622"; }
    if (type === "text"){ node.w=240; node.h=110; node.text="Text block‚Ä¶"; node.style.fill="#0f1622"; node.style.borderW=1; node.style.radius=14; node.style.fontSize=16; }
    if (type === "rect"){ node.w=200; node.h=130; node.style.fill="#141f33"; }
    if (type === "circle"){ node.w=140; node.h=140; node.style.radius=9999; node.style.fill="#141f33"; }
    if (type === "triangle"){ node.w=160; node.h=140; node.style.fill="#141f33"; node.style.borderW=0; node.style.radius=0; }
    if (type === "line"){ node.w=220; node.h=30; node.style.fill="#ffffff"; node.style.borderW=0; node.style.radius=0; node.style.opacity=1; }

    State.nodes.set(id, node);
    mountNode(node);
    selectNode(id);
    requestConnectionsUpdate();
  }

  function mountNode(node){
    const el = document.createElement("div");
    el.className = "node";
    el.tabIndex = 0;
    el.dataset.id = node.id;
    el.dataset.type = node.type;

    const inner = document.createElement("div");
    inner.className = "inner";
    el.appendChild(inner);

    // Build inner content
    buildInner(node, inner);

    // pointer events
    el.addEventListener("pointerdown", (e) => onNodePointerDown(e, node.id));
    el.addEventListener("click", (e) => onNodeClick(e, node.id));

    canvas.appendChild(el);
    renderNode(node);
  }

  function buildInner(node, inner){
    inner.innerHTML = "";
    const t = node.type;

    if (t === "button"){
      const b = document.createElement("button");
      b.className = "ui-button";
      b.type = "button";
      b.textContent = node.text || "Button";
      b.tabIndex = -1;
      inner.appendChild(b);
      return;
    }
    if (t === "input"){
      const inp = document.createElement("input");
      inp.className = "ui-input";
      inp.type = "text";
      inp.placeholder = "Input‚Ä¶";
      inp.value = "";
      inp.tabIndex = -1;
      inner.appendChild(inp);
      return;
    }
    if (t === "textfield"){
      const wrap = document.createElement("div");
      wrap.style.width="100%"; wrap.style.height="100%";
      wrap.style.display="grid";
      wrap.style.gridTemplateRows="auto 1fr";
      wrap.style.gap="6px";
      const label = document.createElement("div");
      label.textContent = node.text || "Label";
      label.style.fontWeight="900";
      label.style.color="var(--muted)";
      label.style.fontSize="12px";
      const tf = document.createElement("input");
      tf.className = "ui-textfield";
      tf.type="text";
      tf.placeholder="Type‚Ä¶";
      tf.tabIndex = -1;
      wrap.appendChild(label);
      wrap.appendChild(tf);
      inner.appendChild(wrap);
      return;
    }
    if (t === "checkbox"){
      const wrap = document.createElement("div");
      wrap.className = "ui-checkboxWrap";
      const cb = document.createElement("input");
      cb.type="checkbox";
      cb.checked = !!node.checked;
      cb.tabIndex = -1;
      const lab = document.createElement("div");
      lab.textContent = node.text || "Checkbox";
      wrap.appendChild(cb);
      wrap.appendChild(lab);
      inner.appendChild(wrap);
      return;
    }
    if (t === "dropdown"){
      const sel = document.createElement("select");
      sel.className = "ui-dropdown";
      sel.tabIndex = -1;
      for (const o of (node.options?.length ? node.options : ["Option A","Option B"])){
        const opt = document.createElement("option");
        opt.textContent = o;
        sel.appendChild(opt);
      }
      inner.appendChild(sel);
      return;
    }
    if (t === "slider"){
      const wrap = document.createElement("div");
      wrap.style.width="100%"; wrap.style.height="100%";
      wrap.style.display="flex"; wrap.style.alignItems="center"; wrap.style.justifyContent="center";
      const r = document.createElement("input");
      r.type="range";
      r.className="ui-slider";
      r.min = node.min ?? 0;
      r.max = node.max ?? 100;
      r.value = node.value ?? 50;
      r.tabIndex=-1;
      wrap.appendChild(r);
      inner.appendChild(wrap);
      return;
    }
    if (t === "stepper"){
      const st = document.createElement("div");
      st.className = "ui-stepper";
      const minus = document.createElement("button"); minus.textContent="‚àí"; minus.tabIndex=-1;
      const val = document.createElement("div"); val.textContent = String(node.value ?? 0); val.style.fontFamily="var(--mono)";
      const plus = document.createElement("button"); plus.textContent="+"; plus.tabIndex=-1;
      st.appendChild(minus); st.appendChild(val); st.appendChild(plus);
      inner.appendChild(st);
      return;
    }
    if (t === "progress"){
      const pr = document.createElement("div");
      pr.className = "ui-progress";
      const bar = document.createElement("div");
      pr.appendChild(bar);
      inner.appendChild(pr);
      return;
    }
    if (t === "text"){
      const div = document.createElement("div");
      div.textContent = node.text || "Text‚Ä¶";
      div.style.width="100%";
      div.style.height="100%";
      div.style.whiteSpace="pre-wrap";
      inner.appendChild(div);
      return;
    }

    // Shapes
    if (t === "rect"){
      const r = document.createElement("div");
      r.className="shape-rect";
      inner.appendChild(r);
      return;
    }
    if (t === "circle"){
      const c = document.createElement("div");
      c.className="shape-circle";
      inner.appendChild(c);
      return;
    }
    if (t === "triangle"){
      const tri = document.createElement("div");
      tri.className="shape-triangle";
      inner.appendChild(tri);
      return;
    }
    if (t === "line"){
      const line = document.createElement("div");
      line.className="shape-line";
      inner.appendChild(line);
      return;
    }

    inner.textContent = t;
  }

  function nodeEl(id){
    return canvas.querySelector(`.node[data-id="${CSS.escape(id)}"]`);
  }

  function renderNode(node){
    const el = nodeEl(node.id);
    if (!el) return;

    // optional snapping
    let x=node.x, y=node.y, w=node.w, h=node.h;

    el.style.left = x + "px";
    el.style.top = y + "px";
    el.style.width = w + "px";
    el.style.height = h + "px";
    el.style.zIndex = node.z;

    // Apply style (to wrapper + inner content)
    const style = node.style || {};
    const fill = style.fill ?? "#1a2437";
    const textColor = style.textColor ?? "#e9eefc";
    const borderW = style.borderW ?? 1;
    const borderC = style.borderC ?? "#3a4b72";
    const radius = style.radius ?? 12;
    const opacity = style.opacity ?? 1;
    const fontSize = style.fontSize ?? 14;

    const shadowOn = +style.shadowOn ? 1 : 0;
    const sh = shadowOn
      ? `${style.shX ?? 0}px ${style.shY ?? 10}px ${style.shBlur ?? 24}px ${style.shSpread ?? 0}px ${style.shColor ?? "#000000"}`
      : "none";

    el.style.opacity = opacity;
    el.style.boxShadow = sh;

    // Most things: style the .inner (background + border + radius)
    const inner = el.querySelector(".inner");
    if (inner){
      inner.style.background = fill;
      inner.style.border = `${borderW}px solid ${borderC}`;
      inner.style.borderRadius = radius + "px";
      inner.style.color = textColor;
      inner.style.fontSize = fontSize + "px";
      inner.style.fontFamily = "var(--sans)";
    }

    // Special cases: shapes need fill applied differently
    if (node.type === "triangle"){
      // triangle uses :before border-bottom color. We can approximate by setting CSS variable via inline style.
      // We'll re-style by injecting a unique style tag? Keep simple: set inner background, and set pseudo via inline "filter" is hard.
      // Instead: make triangle an SVG polygon? For builder simplicity, we keep CSS triangle and update using a CSS custom property.
      // We'll rebuild triangle as SVG for export anyway; for builder, update via inline style with a CSS variable.
      inner.style.background = "transparent";
      inner.style.border = "none";
      inner.style.borderRadius = "0px";
      // Set CSS variable for pseudo fill by applying a style element on the node.
      el.style.setProperty("--triFill", fill);
      const tri = inner.querySelector(".shape-triangle");
      if (tri){
        tri.style.setProperty("--triFill", fill);
        // rewrite pseudo triangle size based on node size
        const bw = Math.max(10, Math.round(node.w * 0.42));
        const bh = Math.max(10, Math.round(node.h * 0.78));
        tri.style.setProperty("--triBW", bw + "px");
        tri.style.setProperty("--triBH", bh + "px");
        // patch via inline stylesheet on this node
        let tag = el.querySelector("style[data-tri='1']");
        if (!tag){
          tag = document.createElement("style");
          tag.dataset.tri = "1";
          el.appendChild(tag);
        }
        tag.textContent = `
          .node[data-id="${CSS.escape(node.id)}"] .shape-triangle:before{
            border-left: var(--triBW) solid transparent;
            border-right: var(--triBW) solid transparent;
            border-bottom: var(--triBH) solid var(--triFill);
          }
        `;
      }
    }

    if (node.type === "line"){
      inner.style.background="transparent";
      inner.style.border="none";
      inner.style.borderRadius="0px";
      const ln = inner.querySelector(".shape-line");
      if (ln){
        ln.style.background="transparent";
        // Use fill as stroke color; use fontSize as stroke width (hack) or borderW
        const strokeW = Math.max(1, borderW || 2);
        let tag = el.querySelector("style[data-line='1']");
        if (!tag){
          tag = document.createElement("style");
          tag.dataset.line = "1";
          el.appendChild(tag);
        }
        tag.textContent = `
          .node[data-id="${CSS.escape(node.id)}"] .shape-line:before{
            height:${strokeW}px;
            background:${fill};
          }
        `;
      }
    }

    // Update component-specific internals
    syncComponentInternals(node);

    // update selection box if selected
    if (State.selectedNodeId === node.id){
      updateSelectionBox();
    }
  }

  function syncComponentInternals(node){
    const el = nodeEl(node.id);
    if (!el) return;
    const inner = el.querySelector(".inner");
    const t = node.type;

    if (t === "button"){
      const b = inner.querySelector("button");
      if (b) b.textContent = node.text || "Button";
      return;
    }
    if (t === "textfield"){
      const label = inner.querySelector("div > div");
      if (label) label.textContent = node.text || "Label";
      return;
    }
    if (t === "checkbox"){
      const cb = inner.querySelector('input[type="checkbox"]');
      const lab = inner.querySelector(".ui-checkboxWrap div");
      if (cb) cb.checked = !!node.checked;
      if (lab) lab.textContent = node.text || "Checkbox";
      return;
    }
    if (t === "dropdown"){
      const sel = inner.querySelector("select");
      if (sel){
        sel.innerHTML = "";
        const opts = (node.options && node.options.length) ? node.options : ["Option A","Option B"];
        for (const o of opts){
          const opt = document.createElement("option");
          opt.textContent = o;
          sel.appendChild(opt);
        }
      }
      return;
    }
    if (t === "slider"){
      const r = inner.querySelector('input[type="range"]');
      if (r){
        r.min = node.min ?? 0;
        r.max = node.max ?? 100;
        r.value = node.value ?? 50;
      }
      return;
    }
    if (t === "stepper"){
      const val = inner.querySelector(".ui-stepper div");
      if (val) val.textContent = String(node.value ?? 0);
      return;
    }
    if (t === "progress"){
      const bar = inner.querySelector(".ui-progress > div");
      if (bar){
        const v = clamp(Number(node.value ?? 50), 0, 100);
        bar.style.width = v + "%";
      }
      return;
    }
    if (t === "text"){
      const div = inner.querySelector("div");
      if (div) div.textContent = node.text ?? "";
      return;
    }
  }

  // ========= SELECTION + OVERLAY =========
  function selectNode(id){
    State.selectedConnId = null;
    State.selectedNodeId = id;
    State.connectFromId = State.connectMode ? (State.connectFromId ?? null) : null;
    // unselect connections
    for (const path of connGroup.querySelectorAll(".connPath")){
      path.classList.remove("selected");
    }
    connHandles.innerHTML = "";
    updateSelectionBox();
    updatePropsPanel();
    setPills();
  }

  function selectConnection(connId){
    State.selectedNodeId = null;
    State.selectedConnId = connId;
    State.connectFromId = null;
    selection.style.display = "none";
    // highlight
    for (const path of connGroup.querySelectorAll(".connPath")){
      path.classList.toggle("selected", path.dataset.id === connId);
    }
    // show bend handle
    renderConnectionHandles();
    updatePropsPanel();
    setPills();
  }

  function updateSelectionBox(){
    const id = State.selectedNodeId;
    if (!id){
      selection.style.display = "none";
      return;
    }
    const n = State.nodes.get(id);
    if (!n) return;
    selection.style.display = "block";
    selection.style.left = n.x + "px";
    selection.style.top = n.y + "px";
    selection.style.width = n.w + "px";
    selection.style.height = n.h + "px";
  }

  // ========= DRAG / RESIZE =========
  function onNodeClick(e, id){
    e.stopPropagation();
    if (State.connectMode){
      // connect mode: click two nodes
      if (!State.connectFromId){
        State.connectFromId = id;
        selectNode(id);
        // subtle feedback by changing selection border temporarily
        selection.style.boxShadow = "0 0 0 2px rgba(255,209,102,.25), 0 0 0 2px rgba(103,179,255,.12)";
        setTimeout(()=> selection.style.boxShadow = "0 0 0 2px rgba(103,179,255,.12)", 180);
      } else if (State.connectFromId && State.connectFromId !== id){
        const from = State.connectFromId;
        const to = id;
        createConnection(from, to);
        State.connectFromId = null;
      }
      return;
    }
    selectNode(id);
  }

  function onNodePointerDown(e, id){
    // ignore if clicking while connect mode -> still allow selection but not drag (feels more like connector tool)
    if (State.connectMode) return;

    // ignore clicks on embedded inputs/buttons (we still want selection/drag)
    e.preventDefault();
    e.stopPropagation();

    const node = State.nodes.get(id);
    if (!node) return;

    selectNode(id);

    State.drag = {
      type: "move",
      id,
      startClientX: e.clientX,
      startClientY: e.clientY,
      startX: node.x,
      startY: node.y,
    };

    hideGuides();
    canvas.setPointerCapture?.(e.pointerId);
  }

  function onHandlePointerDown(e){
    if (!State.selectedNodeId) return;
    e.preventDefault(); e.stopPropagation();

    const h = e.target.dataset.h;
    const node = State.nodes.get(State.selectedNodeId);
    if (!node) return;

    State.drag = {
      type: "resize",
      id: node.id,
      handle: h,
      startClientX: e.clientX,
      startClientY: e.clientY,
      startX: node.x,
      startY: node.y,
      startW: node.w,
      startH: node.h,
    };
    hideGuides();
    selection.setPointerCapture?.(e.pointerId);
  }

  function applySnapAndGuides(candidate, movingId){
    // candidate: {x,y,w,h}
    // snap to grid first
    if (State.snap){
      const gs = State.gridSize;
      candidate.x = snapTo(candidate.x, gs);
      candidate.y = snapTo(candidate.y, gs);
      candidate.w = Math.max(10, snapTo(candidate.w, gs));
      candidate.h = Math.max(10, snapTo(candidate.h, gs));
    }

    // alignment guides (edges + centers)
    let gx = null, gy = null;
    const eps = State.snap ? State.guideSnapPx : 0;

    if (eps > 0){
      const cLeft = candidate.x;
      const cRight = candidate.x + candidate.w;
      const cCX = candidate.x + candidate.w/2;

      const cTop = candidate.y;
      const cBot = candidate.y + candidate.h;
      const cCY = candidate.y + candidate.h/2;

      // collect other node lines
      for (const [id,n] of State.nodes){
        if (id === movingId) continue;
        const linesX = [n.x, n.x + n.w/2, n.x + n.w];
        const linesY = [n.y, n.y + n.h/2, n.y + n.h];

        // X align
        for (const lx of linesX){
          if (within(cLeft, lx, eps)) { candidate.x = lx; gx = lx; }
          if (within(cRight, lx, eps)) { candidate.x = lx - candidate.w; gx = lx; }
          if (within(cCX, lx, eps)) { candidate.x = lx - candidate.w/2; gx = lx; }
        }
        // Y align
        for (const ly of linesY){
          if (within(cTop, ly, eps)) { candidate.y = ly; gy = ly; }
          if (within(cBot, ly, eps)) { candidate.y = ly - candidate.h; gy = ly; }
          if (within(cCY, ly, eps)) { candidate.y = ly - candidate.h/2; gy = ly; }
        }
      }
    }

    if (gx !== null) showGuideV(gx); else guideV.style.display="none";
    if (gy !== null) showGuideH(gy); else guideH.style.display="none";
    return candidate;
  }

  function onPointerMove(e){
    if (!State.drag) return;

    if (State.drag.type === "move"){
      const node = State.nodes.get(State.drag.id);
      if (!node) return;
      const dx = e.clientX - State.drag.startClientX;
      const dy = e.clientY - State.drag.startClientY;

      let cand = {
        x: State.drag.startX + dx,
        y: State.drag.startY + dy,
        w: node.w, h: node.h
      };
      cand = applySnapAndGuides(cand, node.id);

      node.x = clamp(Math.round(cand.x), 0, State.canvasW - 10);
      node.y = clamp(Math.round(cand.y), 0, State.canvasH - 10);

      renderNode(node);
      requestConnectionsUpdate();
      return;
    }

    if (State.drag.type === "resize"){
      const node = State.nodes.get(State.drag.id);
      if (!node) return;
      const dx = e.clientX - State.drag.startClientX;
      const dy = e.clientY - State.drag.startClientY;

      let x = State.drag.startX, y = State.drag.startY;
      let w = State.drag.startW, h = State.drag.startH;

      const handle = State.drag.handle;

      if (handle.includes("e")) w = State.drag.startW + dx;
      if (handle.includes("s")) h = State.drag.startH + dy;
      if (handle.includes("w")) { w = State.drag.startW - dx; x = State.drag.startX + dx; }
      if (handle.includes("n")) { h = State.drag.startH - dy; y = State.drag.startY + dy; }

      // keep minimum
      w = Math.max(10, w);
      h = Math.max(10, h);

      let cand = { x, y, w, h };
      cand = applySnapAndGuides(cand, node.id);

      // clamp to canvas
      cand.x = clamp(cand.x, 0, State.canvasW - 10);
      cand.y = clamp(cand.y, 0, State.canvasH - 10);
      cand.w = clamp(cand.w, 10, State.canvasW - cand.x);
      cand.h = clamp(cand.h, 10, State.canvasH - cand.y);

      node.x = Math.round(cand.x);
      node.y = Math.round(cand.y);
      node.w = Math.round(cand.w);
      node.h = Math.round(cand.h);

      renderNode(node);
      requestConnectionsUpdate();
      updatePropsPanelFieldsFromSelection(); // keep inputs in sync while dragging
      return;
    }

    if (State.drag.type === "canvas"){
      const dx = e.clientX - State.drag.startClientX;
      const dy = e.clientY - State.drag.startClientY;
      const w = State.drag.startW + dx;
      const h = State.drag.startH + dy;
      setCanvasSize(w,h);
      return;
    }

    if (State.drag.type === "connHandle"){
      const conn = State.connections.get(State.drag.id);
      if (!conn) return;
      const pt = toCanvasXY(e.clientX, e.clientY);
      conn.controlAbs = { x: pt.x, y: pt.y };
      // store offset relative to mid
      const anchors = getAnchors(conn.from, conn.to);
      const mid = { x: (anchors.s.x + anchors.t.x)/2, y:(anchors.s.y + anchors.t.y)/2 };
      conn.ctrlOffset = { x: pt.x - mid.x, y: pt.y - mid.y };
      updateConnectionPath(conn);
      renderConnectionHandles();
    }
  }

  function onPointerUp(){
    if (!State.drag) return;
    State.drag = null;
    hideGuides();
    // refresh props for clean snapped values
    updatePropsPanelFieldsFromSelection();
  }

  window.addEventListener("pointermove", onPointerMove);
  window.addEventListener("pointerup", onPointerUp);

  // Attach resize handles listeners
  selection.querySelectorAll(".handle").forEach(h => h.addEventListener("pointerdown", onHandlePointerDown));

  // ========= CANVAS RESIZE HANDLE =========
  canvasResizer.addEventListener("pointerdown", (e) => {
    e.preventDefault(); e.stopPropagation();
    State.drag = {
      type: "canvas",
      startClientX: e.clientX,
      startClientY: e.clientY,
      startW: State.canvasW,
      startH: State.canvasH,
    };
    canvasResizer.setPointerCapture?.(e.pointerId);
  });

  // ========= DRAG/DROP LIBRARY =========
  const LIB_UI = [
    {type:"button", title:"Button", desc:"Clickable button"},
    {type:"input", title:"Input", desc:"Single-line input"},
    {type:"textfield", title:"Text Field", desc:"Label + input"},
    {type:"checkbox", title:"Checkbox", desc:"Checked/unchecked"},
    {type:"dropdown", title:"Dropdown", desc:"Select options"},
    {type:"slider", title:"Slider", desc:"Range input"},
    {type:"stepper", title:"Stepper", desc:"+ / ‚àí numeric"},
    {type:"progress", title:"Progress Bar", desc:"0‚Äì100%"},
    {type:"text", title:"Text", desc:"Multiline text"},
  ];
  const LIB_SHAPES = [
    {type:"rect", title:"Rectangle", desc:"Basic shape"},
    {type:"circle", title:"Circle", desc:"Basic shape"},
    {type:"triangle", title:"Triangle", desc:"Basic shape"},
    {type:"line", title:"Line", desc:"Stroke shape"},
  ];

  function makeLibItem(item){
    const div = document.createElement("div");
    div.className = "libItem";
    div.draggable = true;
    div.dataset.type = item.type;
    div.innerHTML = `<div class="t">${item.title}</div><div class="s">${item.desc}</div>`;
    div.addEventListener("dragstart", (e) => {
      e.dataTransfer.setData("text/plain", item.type);
      e.dataTransfer.effectAllowed = "copy";
    });
    // click-to-add convenience
    div.addEventListener("click", () => {
      const x = (State.canvasW/2) - 80;
      const y = (State.canvasH/2) - 30;
      makeNode(item.type, x, y);
    });
    return div;
  }

  function mountLibrary(){
    const libUI = $("libUI");
    const libShapes = $("libShapes");
    for (const it of LIB_UI) libUI.appendChild(makeLibItem(it));
    for (const it of LIB_SHAPES) libShapes.appendChild(makeLibItem(it));
  }

  canvas.addEventListener("dragover", (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = "copy";
  });
  canvas.addEventListener("drop", (e) => {
    e.preventDefault();
    const type = e.dataTransfer.getData("text/plain");
    if (!type) return;
    const pt = toCanvasXY(e.clientX, e.clientY);
    makeNode(type, pt.x - 80, pt.y - 26);
  });

  // deselect on canvas click
  canvas.addEventListener("pointerdown", (e) => {
    // if clicking on SVG connection area, allow selection there; otherwise deselect
    if (e.target.closest(".node")) return;
    if (e.target.closest(".connPath") || e.target.closest(".connHandle")) return;
    if (e.target.closest(".selection")) return;
    deselectAll();
  });

  // ========= CONNECTIONS =========
  function getNodeBox(id){
    const n = State.nodes.get(id);
    if (!n) return null;
    return { x:n.x, y:n.y, w:n.w, h:n.h, cx:n.x+n.w/2, cy:n.y+n.h/2 };
  }

  function getAnchors(fromId, toId){
    const A = getNodeBox(fromId);
    const B = getNodeBox(toId);
    if (!A || !B) return { s:{x:0,y:0}, t:{x:0,y:0} };

    // pick attachment side based on direction
    const dx = B.cx - A.cx;
    const dy = B.cy - A.cy;

    const s = {x:A.cx, y:A.cy};
    const t = {x:B.cx, y:B.cy};

    if (Math.abs(dx) >= Math.abs(dy)){
      // horizontal
      s.x = dx >= 0 ? (A.x + A.w) : A.x;
      s.y = A.cy;
      t.x = dx >= 0 ? B.x : (B.x + B.w);
      t.y = B.cy;
    } else {
      // vertical
      s.y = dy >= 0 ? (A.y + A.h) : A.y;
      s.x = A.cx;
      t.y = dy >= 0 ? B.y : (B.y + B.h);
      t.x = B.cx;
    }
    return { s, t };
  }

  function createConnection(fromId, toId){
    const id = uid();
    const anchors = getAnchors(fromId, toId);
    const mid = { x:(anchors.s.x+anchors.t.x)/2, y:(anchors.s.y+anchors.t.y)/2 };
    const conn = {
      id,
      from: fromId,
      to: toId,
      // control point offset relative to mid
      ctrlOffset: { x: 0, y: -60 },
      controlAbs: { x: mid.x, y: mid.y - 60 }, // convenience cache
    };
    State.connections.set(id, conn);
    mountConnection(conn);
    selectConnection(id);
    requestConnectionsUpdate();
  }

  function mountConnection(conn){
    const path = document.createElementNS("http://www.w3.org/2000/svg","path");
    path.classList.add("connPath");
    path.dataset.id = conn.id;
    path.setAttribute("marker-end","url(#arrow)");
    path.addEventListener("pointerdown", (e) => {
      e.stopPropagation();
      e.preventDefault();
      selectConnection(conn.id);
    });
    connGroup.appendChild(path);
    updateConnectionPath(conn);
  }

  function connectionPathEl(id){
    return connGroup.querySelector(`.connPath[data-id="${CSS.escape(id)}"]`);
  }

  function updateConnectionPath(conn){
    const path = connectionPathEl(conn.id);
    if (!path) return;

    const a = getAnchors(conn.from, conn.to);
    const mid = { x:(a.s.x+a.t.x)/2, y:(a.s.y+a.t.y)/2 };
    const ctrl = {
      x: mid.x + (conn.ctrlOffset?.x ?? 0),
      y: mid.y + (conn.ctrlOffset?.y ?? -60)
    };
    conn.controlAbs = ctrl;

    // Quadratic curve: M s Q ctrl t
    const d = `M ${a.s.x} ${a.s.y} Q ${ctrl.x} ${ctrl.y} ${a.t.x} ${a.t.y}`;
    path.setAttribute("d", d);
  }

  function requestConnectionsUpdate(){
    // Update all connection paths + handles if selected
    for (const conn of State.connections.values()){
      updateConnectionPath(conn);
    }
    if (State.selectedConnId){
      renderConnectionHandles();
    }
  }

  function renderConnectionHandles(){
    connHandles.innerHTML = "";
    const id = State.selectedConnId;
    if (!id) return;
    const conn = State.connections.get(id);
    if (!conn) return;

    const a = getAnchors(conn.from, conn.to);
    const mid = { x:(a.s.x+a.t.x)/2, y:(a.s.y+a.t.y)/2 };
    const ctrl = { x: mid.x + conn.ctrlOffset.x, y: mid.y + conn.ctrlOffset.y };

    const h = document.createElementNS("http://www.w3.org/2000/svg","circle");
    h.classList.add("connHandle");
    h.setAttribute("cx", ctrl.x);
    h.setAttribute("cy", ctrl.y);
    h.setAttribute("r", 7);
    h.dataset.id = conn.id;

    h.addEventListener("pointerdown", (e) => {
      e.preventDefault(); e.stopPropagation();
      State.drag = {
        type: "connHandle",
        id: conn.id,
        startClientX: e.clientX,
        startClientY: e.clientY,
      };
      connSvg.setPointerCapture?.(e.pointerId);
    });

    connHandles.appendChild(h);
  }

  // ========= PROPERTIES PANEL =========
  function updatePropsPanel(){
    const node = State.selectedNodeId ? State.nodes.get(State.selectedNodeId) : null;
    const conn = State.selectedConnId ? State.connections.get(State.selectedConnId) : null;

    if (!node && !conn){
      noSel.style.display = "block";
      props.style.display = "none";
      selType.textContent = "‚Äî";
      return;
    }

    if (conn && !node){
      noSel.style.display = "block";
      props.style.display = "none";
      selType.textContent = "connection";
      // small hint in "noSel"
      noSel.innerHTML = `
        <b>Connection selected</b><br>
        Drag the blue handle on the curve to adjust its bend.<br>
        Press <b>Delete</b> to remove the connection.
      `;
      return;
    }

    // node selected
    noSel.style.display = "none";
    props.style.display = "block";
    selType.textContent = node.type;

    // fill fields
    updatePropsPanelFieldsFromSelection();
  }

  function updatePropsPanelFieldsFromSelection(){
    const node = State.selectedNodeId ? State.nodes.get(State.selectedNodeId) : null;
    if (!node) return;

    pX.value = node.x;
    pY.value = node.y;
    pW.value = node.w;
    pH.value = node.h;

    pZ.value = node.z;

    const s = node.style || {};
    pFill.value = toHexColor(s.fill ?? "#1a2437");
    pTextColor.value = toHexColor(s.textColor ?? "#e9eefc");
    pBorderW.value = s.borderW ?? 1;
    pBorderC.value = toHexColor(s.borderC ?? "#3a4b72");
    pRadius.value = s.radius ?? 12;
    pOpacity.value = s.opacity ?? 1;
    pFontSize.value = s.fontSize ?? 14;

    pText.value = node.text ?? "";

    pShX.value = s.shX ?? 0;
    pShY.value = s.shY ?? 10;
    pShBlur.value = s.shBlur ?? 24;
    pShSpread.value = s.shSpread ?? 0;
    pShColor.value = toHexColor(s.shColor ?? "#000000");
    pShOn.value = String(+s.shadowOn ? 1 : 0);

    pValue.value = node.value ?? 50;
    pChecked.value = String(node.checked ? 1 : 0);
    pMin.value = node.min ?? 0;
    pMax.value = node.max ?? 100;
    pOptions.value = (node.options && node.options.length) ? node.options.join(", ") : "";
  }

  function toHexColor(c){
    // Accepts hex already; if rgba or named, fall back to #ffffff.
    if (!c) return "#ffffff";
    c = String(c).trim();
    if (c.startsWith("#")) {
      if (c.length === 4){
        return "#" + c[1]+c[1]+c[2]+c[2]+c[3]+c[3];
      }
      if (c.length === 7) return c;
    }
    return "#ffffff";
  }

  function applyPropsToSelection(){
    const node = State.selectedNodeId ? State.nodes.get(State.selectedNodeId) : null;
    if (!node) return;

    const nx = Number(pX.value), ny = Number(pY.value), nw = Number(pW.value), nh = Number(pH.value);
    node.x = clamp(Math.round(nx), 0, State.canvasW - 10);
    node.y = clamp(Math.round(ny), 0, State.canvasH - 10);
    node.w = clamp(Math.round(nw), 10, State.canvasW - node.x);
    node.h = clamp(Math.round(nh), 10, State.canvasH - node.y);

    node.z = Math.round(Number(pZ.value) || node.z);

    node.text = pText.value ?? "";

    node.value = Number(pValue.value);
    node.checked = (pChecked.value === "1") ? 1 : 0;
    node.min = Number(pMin.value);
    node.max = Number(pMax.value);

    const opts = (pOptions.value || "")
      .split(",")
      .map(s => s.trim())
      .filter(Boolean);
    node.options = opts.length ? opts : node.options;

    node.style = node.style || {};
    node.style.fill = pFill.value;
    node.style.textColor = pTextColor.value;
    node.style.borderW = clamp(Number(pBorderW.value)||0, 0, 40);
    node.style.borderC = pBorderC.value;
    node.style.radius = clamp(Number(pRadius.value)||0, 0, 400);
    node.style.opacity = clamp(Number(pOpacity.value)||1, 0, 1);
    node.style.fontSize = clamp(Number(pFontSize.value)||14, 6, 120);

    node.style.shadowOn = (pShOn.value === "1") ? 1 : 0;
    node.style.shX = Number(pShX.value)||0;
    node.style.shY = Number(pShY.value)||0;
    node.style.shBlur = clamp(Number(pShBlur.value)||0, 0, 200);
    node.style.shSpread = clamp(Number(pShSpread.value)||0, -100, 200);
    node.style.shColor = pShColor.value;

    renderNode(node);
    requestConnectionsUpdate();
    setPills();
  }

  // Hook property inputs
  const propInputs = [pX,pY,pW,pH,pFill,pTextColor,pBorderW,pBorderC,pRadius,pOpacity,pFontSize,pZ,pText,pShX,pShY,pShBlur,pShSpread,pShColor,pShOn,pValue,pChecked,pMin,pMax,pOptions];
  for (const inp of propInputs){
    inp.addEventListener("input", applyPropsToSelection);
  }

  // Canvas props
  canvasWInput.addEventListener("input", () => setCanvasSize(canvasWInput.value, State.canvasH));
  canvasHInput.addEventListener("input", () => setCanvasSize(State.canvasW, canvasHInput.value));
  gridSizeInput.addEventListener("input", () => setGridSize(gridSizeInput.value));
  guideSnapInput.addEventListener("input", () => setGuideSnapPx(guideSnapInput.value));

  // ========= DELETE / DUPLICATE =========
  function deleteSelection(){
    if (State.selectedConnId){
      const id = State.selectedConnId;
      State.connections.delete(id);
      const p = connectionPathEl(id);
      if (p) p.remove();
      connHandles.innerHTML = "";
      State.selectedConnId = null;
      setPills();
      updatePropsPanel();
      return;
    }
    if (State.selectedNodeId){
      const id = State.selectedNodeId;
      // Remove node
      State.nodes.delete(id);
      const el = nodeEl(id);
      if (el) el.remove();

      // Remove any connections attached
      for (const [cid,c] of [...State.connections]){
        if (c.from === id || c.to === id){
          State.connections.delete(cid);
          const p = connectionPathEl(cid);
          if (p) p.remove();
        }
      }
      State.selectedNodeId = null;
      selection.style.display = "none";
      connHandles.innerHTML = "";
      requestConnectionsUpdate();
      setPills();
      updatePropsPanel();
    }
  }

  function duplicateSelection(){
    if (!State.selectedNodeId) return;
    const src = State.nodes.get(State.selectedNodeId);
    if (!src) return;

    const id = uid();
    const copy = JSON.parse(JSON.stringify(src));
    copy.id = id;
    copy.x += State.gridSize;
    copy.y += State.gridSize;
    copy.z = State.nextZ++;
    State.nodes.set(id, copy);
    mountNode(copy);
    selectNode(id);
    requestConnectionsUpdate();
  }

  // ========= TOPBAR BUTTONS =========
  btnConnect.addEventListener("click", () => setConnectMode(!State.connectMode));
  btnSnap.addEventListener("click", () => setSnap(!State.snap));
  btnGrid.addEventListener("click", () => setShowGrid(!State.showGrid));
  btnDelete.addEventListener("click", deleteSelection);
  btnDuplicate.addEventListener("click", duplicateSelection);
  btnExport.addEventListener("click", () => {
    const html = exportToHTML();
    downloadText(html, "exported_ui.html");
  });

  // ========= KEYBOARD =========
  window.addEventListener("keydown", (e) => {
    const mod = e.ctrlKey || e.metaKey;
    if (e.key === "Delete" || e.key === "Backspace"){
      deleteSelection();
      return;
    }
    if (mod && e.key.toLowerCase() === "d"){
      e.preventDefault();
      duplicateSelection();
      return;
    }
    if (e.key.toLowerCase() === "c"){
      setConnectMode(!State.connectMode);
      return;
    }
    if (e.key.toLowerCase() === "g"){
      setSnap(!State.snap);
      return;
    }
    if (e.key === "Escape"){
      deselectAll();
      return;
    }
  });

  // ========= CONNECTION CLICK HANDLING (SVG background) =========
  connSvg.addEventListener("pointerdown", (e) => {
    // click empty SVG to deselect connection
    if (e.target === connSvg || e.target === connGroup || e.target === connHandles){
      // don't deselect if in connect mode and user is choosing
      if (!State.connectMode) deselectAll();
    }
  });

  // ========= EXPORT =========
  function downloadText(text, filename){
    const blob = new Blob([text], {type:"text/html;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
  }

  function escapeHtml(s){
    return String(s ?? "").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function exportToHTML(){
    // Create a runnable HTML containing the canvas with absolutely positioned elements + SVG connectors.
    // Note: exported file is "viewer" (no editor), but is fully runnable and matches the design.

    const nodes = [...State.nodes.values()].sort((a,b)=>a.z-b.z);
    const conns = [...State.connections.values()];

    // Build element HTML
    const nodeHtml = nodes.map(n => renderExportNode(n)).join("\n");

    // Build SVG paths
    const connPaths = conns.map(c => {
      const a = getAnchors(c.from, c.to);
      const mid = { x:(a.s.x+a.t.x)/2, y:(a.s.y+a.t.y)/2 };
      const ctrl = { x: mid.x + (c.ctrlOffset?.x ?? 0), y: mid.y + (c.ctrlOffset?.y ?? -60) };
      const d = `M ${a.s.x} ${a.s.y} Q ${ctrl.x} ${ctrl.y} ${a.t.x} ${a.t.y}`;
      return `<path d="${d}" fill="none" stroke="rgba(200,220,255,.90)" stroke-width="2" marker-end="url(#arrow)"></path>`;
    }).join("\n");

    const css = `
      html,body{height:100%;margin:0;background:#0b0f16;color:#e9eefc;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
      .canvas{position:relative;width:${State.canvasW}px;height:${State.canvasH}px;margin:24px auto;background:rgba(255,255,255,.02);border:1px solid rgba(255,255,255,.12);border-radius:14px;overflow:hidden;box-shadow:0 20px 60px rgba(0,0,0,.35);}
      .node{position:absolute;user-select:none;}
      .node .inner{position:absolute;inset:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;overflow:hidden;}
      .ui-button{width:100%;height:100%;border:1px solid rgba(255,255,255,.18);background:rgba(103,179,255,.18);border-radius:12px;font-weight:900;}
      .ui-input,.ui-textfield,.ui-dropdown{width:100%;height:100%;border:1px solid rgba(255,255,255,.18);background:rgba(0,0,0,.18);border-radius:12px;padding:10px 10px;color:#e9eefc;outline:none;}
      .ui-checkboxWrap{width:100%;height:100%;display:flex;align-items:center;gap:10px;padding:8px 10px;border:1px solid rgba(255,255,255,.18);border-radius:12px;background:rgba(0,0,0,.18);justify-content:flex-start;font-weight:800;}
      .ui-slider{width:100%;}
      .ui-stepper{width:100%;height:100%;border:1px solid rgba(255,255,255,.18);border-radius:12px;background:rgba(0,0,0,.18);display:flex;align-items:center;justify-content:space-between;padding:6px 8px;gap:8px;font-weight:900;}
      .ui-stepper button{border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.04);border-radius:10px;width:34px;height:34px;font-weight:900;}
      .ui-progress{width:100%;height:100%;border:1px solid rgba(255,255,255,.18);border-radius:999px;background:rgba(0,0,0,.18);overflow:hidden;padding:4px;}
      .ui-progress>div{height:100%;border-radius:999px;background:rgba(53,211,159,.55);}
      .shape-rect{width:100%;height:100%;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.18);border-radius:12px;}
      .shape-circle{width:100%;height:100%;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.18);border-radius:9999px;}
      .shape-line{width:100%;height:100%;position:relative;background:transparent;}
      .shape-line:before{content:"";position:absolute;left:0;top:50%;width:100%;transform:translateY(-50%);}
    `;

    // For triangles, export as SVG polygons so fill is exact.
    const html = `<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Exported UI</title>
<style>${css}</style>
</head>
<body>
  <div class="canvas">
    <svg style="position:absolute;inset:0;width:100%;height:100%;pointer-events:none;" viewBox="0 0 ${State.canvasW} ${State.canvasH}" preserveAspectRatio="none">
      <defs>
        <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
          <path d="M0,0 L10,3 L0,6 Z" fill="rgba(200,220,255,.95)"></path>
        </marker>
      </defs>
      ${connPaths}
    </svg>

    ${nodeHtml}
  </div>
</body>
</html>`;
    return html;
  }

  function renderExportNode(n){
    const s = n.style || {};
    const shadowOn = +s.shadowOn ? 1 : 0;
    const sh = shadowOn ? `${s.shX ?? 0}px ${s.shY ?? 10}px ${s.shBlur ?? 24}px ${s.shSpread ?? 0}px ${s.shColor ?? "#000000"}` : "none";
    const baseInnerStyle = [
      `background:${s.fill ?? "#1a2437"}`,
      `border:${(s.borderW ?? 1)}px solid ${(s.borderC ?? "#3a4b72")}`,
      `border-radius:${(s.radius ?? 12)}px`,
      `color:${s.textColor ?? "#e9eefc"}`,
      `font-size:${(s.fontSize ?? 14)}px`,
      `opacity:${(s.opacity ?? 1)}`,
      `box-shadow:${sh}`,
      `width:100%`, `height:100%`,
    ].join(";");

    const outerStyle = [
      `left:${n.x}px`,
      `top:${n.y}px`,
      `width:${n.w}px`,
      `height:${n.h}px`,
      `z-index:${n.z}`,
      `position:absolute`,
    ].join(";");

    const t = n.type;

    // UI components
    if (t === "button"){
      return `<div class="node" style="${outerStyle}">
        <div class="inner" style="${baseInnerStyle};border:0;background:transparent;box-shadow:none;">
          <button class="ui-button" style="${baseInnerStyle}">${escapeHtml(n.text || "Button")}</button>
        </div>
      </div>`;
    }
    if (t === "input"){
      return `<div class="node" style="${outerStyle}">
        <div class="inner" style="${baseInnerStyle};border:0;background:transparent;box-shadow:none;">
          <input class="ui-input" style="${baseInnerStyle}" placeholder="Input‚Ä¶" />
        </div>
      </div>`;
    }
    if (t === "textfield"){
      return `<div class="node" style="${outerStyle}">
        <div class="inner" style="${baseInnerStyle};border:0;background:transparent;box-shadow:none;">
          <div style="width:100%;height:100%;display:grid;grid-template-rows:auto 1fr;gap:6px;">
            <div style="font-weight:900;color:rgba(174,186,214,1);font-size:12px;">${escapeHtml(n.text || "Label")}</div>
            <input class="ui-textfield" style="${baseInnerStyle}" placeholder="Type‚Ä¶" />
          </div>
        </div>
      </div>`;
    }
    if (t === "checkbox"){
      const checked = n.checked ? "checked" : "";
      return `<div class="node" style="${outerStyle}">
        <div class="inner" style="${baseInnerStyle};border:0;background:transparent;box-shadow:none;">
          <div class="ui-checkboxWrap" style="${baseInnerStyle}">
            <input type="checkbox" ${checked} />
            <div>${escapeHtml(n.text || "Checkbox")}</div>
          </div>
        </div>
      </div>`;
    }
    if (t === "dropdown"){
      const opts = (n.options?.length ? n.options : ["Option A","Option B"]).map(o => `<option>${escapeHtml(o)}</option>`).join("");
      return `<div class="node" style="${outerStyle}">
        <div class="inner" style="${baseInnerStyle};border:0;background:transparent;box-shadow:none;">
          <select class="ui-dropdown" style="${baseInnerStyle}">${opts}</select>
        </div>
      </div>`;
    }
    if (t === "slider"){
      const min = Number.isFinite(n.min) ? n.min : 0;
      const max = Number.isFinite(n.max) ? n.max : 100;
      const val = Number.isFinite(n.value) ? n.value : 50;
      return `<div class="node" style="${outerStyle}">
        <div class="inner" style="${baseInnerStyle};border:0;background:transparent;box-shadow:none;">
          <div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;">
            <input class="ui-slider" type="range" min="${min}" max="${max}" value="${val}" />
          </div>
        </div>
      </div>`;
    }
    if (t === "stepper"){
      const val = Number.isFinite(n.value) ? n.value : 0;
      return `<div class="node" style="${outerStyle}">
        <div class="inner" style="${baseInnerStyle};border:0;background:transparent;box-shadow:none;">
          <div class="ui-stepper" style="${baseInnerStyle}">
            <button type="button">‚àí</button>
            <div style="font-family:${getComputedStyle(document.documentElement).getPropertyValue("--mono") || "ui-monospace"}">${escapeHtml(String(val))}</div>
            <button type="button">+</button>
          </div>
        </div>
      </div>`;
    }
    if (t === "progress"){
      const v = clamp(Number(n.value ?? 50), 0, 100);
      return `<div class="node" style="${outerStyle}">
        <div class="inner" style="${baseInnerStyle};border:0;background:transparent;box-shadow:none;">
          <div class="ui-progress" style="${baseInnerStyle}">
            <div style="width:${v}%;"></div>
          </div>
        </div>
      </div>`;
    }
    if (t === "text"){
      // text block uses inner style directly
      const innerStyle = `${baseInnerStyle};padding:10px;align-items:flex-start;justify-content:flex-start;white-space:pre-wrap;display:block;`;
      return `<div class="node" style="${outerStyle}">
        <div class="inner" style="${innerStyle}">${escapeHtml(n.text || "")}</div>
      </div>`;
    }

    // Shapes
    if (t === "triangle"){
      // SVG polygon within the node
      const fill = s.fill ?? "rgba(255,255,255,.10)";
      const strokeW = s.borderW ?? 0;
      const strokeC = s.borderC ?? "transparent";
      return `<div class="node" style="${outerStyle}">
        <div class="inner" style="background:transparent;border:0;box-shadow:${sh};opacity:${s.opacity ?? 1};">
          <svg width="100%" height="100%" viewBox="0 0 ${n.w} ${n.h}" preserveAspectRatio="none" style="display:block;">
            <polygon points="${n.w/2},0 ${n.w},${n.h} 0,${n.h}" fill="${fill}" stroke="${strokeC}" stroke-width="${strokeW}"></polygon>
          </svg>
        </div>
      </div>`;
    }
    if (t === "line"){
      const stroke = s.fill ?? "rgba(255,255,255,.72)";
      const strokeW = Math.max(1, s.borderW ?? 2);
      const innerStyle = `background:transparent;border:0;box-shadow:${sh};opacity:${s.opacity ?? 1};`;
      return `<div class="node" style="${outerStyle}">
        <div class="inner" style="${innerStyle}">
          <div class="shape-line" style="width:100%;height:100%;">
            <style>
              .node[data-line="${n.id}"] .shape-line:before{ height:${strokeW}px; background:${stroke}; }
            </style>
          </div>
        </div>
      </div>`;
    }
    // rect/circle fallback
    const klass = (t === "circle") ? "shape-circle" : "shape-rect";
    return `<div class="node" style="${outerStyle}">
      <div class="inner" style="${baseInnerStyle}">
        <div class="${klass}" style="background:${s.fill ?? "#141f33"};border:${(s.borderW ?? 1)}px solid ${(s.borderC ?? "#3a4b72")};border-radius:${(t==="circle" ? "9999px" : (s.radius ?? 12)+"px")};width:100%;height:100%;"></div>
      </div>
    </div>`;
  }

  // ========= INITIALIZE =========
  function init(){
    mountLibrary();

    // defaults
    canvasWInput.value = State.canvasW;
    canvasHInput.value = State.canvasH;
    gridSizeInput.value = State.gridSize;
    guideSnapInput.value = State.guideSnapPx;

    setCanvasSize(State.canvasW, State.canvasH);
    setGridSize(State.gridSize);
    setGuideSnapPx(State.guideSnapPx);
    setShowGrid(true);
    setSnap(true);
    setConnectMode(false);
    setPills();

    // seed a couple nodes so it's not empty
    makeNode("button", 120, 120);
    makeNode("textfield", 120, 200);
    makeNode("rect", 520, 140);
    makeNode("circle", 820, 140);
    // quick connection
    const ids = [...State.nodes.keys()];
    if (ids.length >= 2){
      createConnection(ids[0], ids[2]);
      createConnection(ids[1], ids[3]);
    }

    updatePropsPanel();
  }

  init();

  // ========= EXTRA: CLEAN UX =========
  // Keep SVG viewBox synced with canvas size (for marker scaling & pointer coords)
  const resizeObserver = new ResizeObserver(() => {
    const w = State.canvasW, h = State.canvasH;
    connSvg.setAttribute("viewBox", `0 0 ${w} ${h}`);
  });
  resizeObserver.observe(canvas);

})();
</script>
</body>
</html>
