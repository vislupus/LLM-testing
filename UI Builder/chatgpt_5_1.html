<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Standalone UI / Flowchart Builder</title>
<style>
  html, body {
    margin:0;
    padding:0;
    height:100%;
    overflow:hidden;
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
  }
  body {
    display:flex;
    background:#f3f4f6;
  }

  /* Sidebar (palette) */
  #sidebar {
    width:260px;
    background:#111827;
    color:#e5e7eb;
    display:flex;
    flex-direction:column;
    border-right:1px solid #374151;
    box-sizing:border-box;
  }
  #sidebar h2 {
    margin:8px 12px;
    font-size:16px;
  }
  #sidebar .section-title {
    padding:4px 12px;
    font-size:12px;
    text-transform:uppercase;
    letter-spacing:0.06em;
    color:#9ca3af;
    margin-top:6px;
  }
  #sidebar .palette {
    flex:1;
    overflow:auto;
    padding:4px 8px 12px;
  }
  .palette-group {
    margin-bottom:8px;
    border:1px solid #374151;
    border-radius:6px;
    padding:6px;
  }
  .palette-group-title {
    font-size:12px;
    margin-bottom:4px;
    color:#d1d5db;
  }
  .palette-item {
    user-select:none;
    border:1px solid #4b5563;
    border-radius:4px;
    padding:4px 6px;
    font-size:12px;
    margin:2px 0;
    background:#1f2937;
    cursor:grab;
  }
  .palette-item:active {
    cursor:grabbing;
  }

  /* Top bar */
  #topbar {
    position:fixed;
    left:260px;
    right:260px;
    top:0;
    height:40px;
    background:#111827;
    color:#e5e7eb;
    display:flex;
    align-items:center;
    padding:0 8px;
    box-sizing:border-box;
    border-bottom:1px solid #374151;
    z-index:10;
  }
  #topbar button {
    margin-right:6px;
    padding:4px 10px;
    font-size:12px;
    border-radius:4px;
    border:1px solid #4b5563;
    background:#1f2937;
    color:#e5e7eb;
    cursor:pointer;
  }
  #topbar button:hover {
    background:#374151;
  }
  #connectionModeIndicator {
    font-size:11px;
    margin-left:8px;
    color:#facc15;
  }
  #statusText {
    font-size:11px;
    color:#9ca3af;
    margin-left:auto;
  }

  /* Right panel (properties) */
  #rightPanel {
    width:260px;
    background:#111827;
    color:#e5e7eb;
    display:flex;
    flex-direction:column;
    border-left:1px solid #374151;
    box-sizing:border-box;
  }
  #propertiesPanel {
    flex:1;
    overflow:auto;
    padding:8px;
  }
  #propertiesPanel h3 {
    margin:4px 0;
    font-size:13px;
  }
  .prop-group-title {
    font-size:11px;
    margin-top:6px;
    margin-bottom:2px;
    color:#9ca3af;
    text-transform:uppercase;
  }
  .prop-row {
    display:flex;
    align-items:center;
    margin:2px 0;
    font-size:11px;
  }
  .prop-row label {
    flex:0 0 72px;
  }
  .prop-row input,
  .prop-row select {
    flex:1;
    font-size:11px;
    padding:1px 2px;
    border-radius:3px;
    border:1px solid #4b5563;
    background:#1f2937;
    color:#e5e7eb;
  }
  .prop-row input[type="color"] {
    padding:0;
    border:none;
    background:none;
  }
  .prop-row input[type="checkbox"] {
    flex:0 0 auto;
  }
  #downloadArea {
    padding:6px 8px;
    border-top:1px solid #374151;
    font-size:11px;
  }

  /* Canvas area */
  #canvasWrapper {
    flex:1;
    position:relative;
    margin-left:260px;
    margin-right:260px;
    margin-top:40px;
    background:#111827;
    overflow:auto;
  }
  #canvasContainer {
    position:relative;
    margin:20px;
    background:#ffffff;
    box-shadow:0 0 0 1px #d1d5db;
    overflow:visible;
  }
  #canvas {
    position:relative;
    background-size:20px 20px;
    background-image:
      linear-gradient(to right,#e5e7eb 1px,transparent 1px),
      linear-gradient(to bottom,#e5e7eb 1px,transparent 1px);
  }
  #canvasSizeHandle {
    position:absolute;
    width:14px;
    height:14px;
    right:-7px;
    bottom:-7px;
    background:#111827;
    border-radius:50%;
    border:2px solid #4b5563;
    cursor:nwse-resize;
    z-index:5;
  }

  .canvas-element {
    position:absolute;
    box-sizing:border-box;
    cursor:move;
  }
  .canvas-element.selected {
    outline:1px solid #3b82f6;
  }

  /* Resize handles */
  .resize-handle {
    position:absolute;
    width:8px;
    height:8px;
    background:#3b82f6;
    border-radius:50%;
    border:1px solid #ffffff;
    box-sizing:border-box;
    z-index:3;
  }
  .handle-tl { top:-4px; left:-4px; cursor:nwse-resize; }
  .handle-tr { top:-4px; right:-4px; cursor:nesw-resize; }
  .handle-bl { bottom:-4px; left:-4px; cursor:nesw-resize; }
  .handle-br { bottom:-4px; right:-4px; cursor:nwse-resize; }
  .handle-tm { top:-4px; left:50%; transform:translateX(-50%); cursor:ns-resize; }
  .handle-bm { bottom:-4px; left:50%; transform:translateX(-50%); cursor:ns-resize; }
  .handle-ml { left:-4px; top:50%; transform:translateY(-50%); cursor:ew-resize; }
  .handle-mr { right:-4px; top:50%; transform:translateY(-50%); cursor:ew-resize; }

  /* Alignment guides */
  .alignment-guide {
    position:absolute;
    background:#f97316;
    pointer-events:none;
    z-index:2;
  }
  .alignment-guide.h { height:1px; }
  .alignment-guide.v { width:1px; }

  /* Connections */
  svg.connection-layer {
    position:absolute;
    left:0;
    top:0;
    overflow:visible;
    pointer-events:none;
    z-index:1;
  }
  .connection-line {
    stroke:#4b5563;
    stroke-width:2;
    fill:none;
    marker-end:url(#arrowhead);
    cursor:pointer;
  }
  .connection-line.selected {
    stroke:#10b981;
    marker-end:url(#arrowhead-selected);
  }

  .connector-handle {
    position:absolute;
    width:10px;
    height:10px;
    border-radius:50%;
    border:2px solid #10b981;
    background:#ffffff;
    box-sizing:border-box;
    pointer-events:auto;
    cursor:crosshair;
    z-index:4;
  }

  /* Default component styles (visual only) */
  .ui-button {
    padding:4px 10px;
    border-radius:4px;
    border:1px solid #4b5563;
    background:#3b82f6;
    color:white;
    font-size:12px;
    text-align:center;
  }
  .ui-input, .ui-textfield {
    padding:4px 6px;
    border-radius:4px;
    border:1px solid #9ca3af;
    background:#ffffff;
    color:#111827;
    font-size:12px;
  }
  .ui-checkbox-container {
    display:flex;
    align-items:center;
    font-size:12px;
    color:#111827;
  }
  .ui-checkbox-container input {
    margin-right:4px;
  }
  .ui-dropdown {
    padding:4px 6px;
    border-radius:4px;
    border:1px solid #9ca3af;
    background:#ffffff;
    color:#111827;
    font-size:12px;
  }
  .ui-slider {
    width:100%;
  }
  .ui-stepper {
    display:flex;
    font-size:12px;
  }
  .ui-stepper button {
    width:20px;
  }
  .ui-stepper input {
    width:40px;
    text-align:center;
  }
  .ui-progress {
    width:100%;
  }

  .shape-rect {
    background:#e5e7eb;
    border:1px solid #9ca3af;
  }
  .shape-circle {
    background:#e5e7eb;
    border-radius:50%;
    border:1px solid #9ca3af;
  }
  .shape-triangle {
    width:0;
    height:0;
    background:transparent !important;
  }
  .shape-line {
    background:#111827;
  }
</style>
</head>
<body>
<div id="sidebar">
  <h2>UI Builder</h2>
  <div class="section-title">Components</div>
  <div class="palette">
    <div class="palette-group">
      <div class="palette-group-title">UI Controls</div>
      <div class="palette-item" draggable="true" data-type="button">Button</div>
      <div class="palette-item" draggable="true" data-type="input">Input</div>
      <div class="palette-item" draggable="true" data-type="textfield">Text Field</div>
      <div class="palette-item" draggable="true" data-type="checkbox">Checkbox</div>
      <div class="palette-item" draggable="true" data-type="dropdown">Dropdown</div>
      <div class="palette-item" draggable="true" data-type="slider">Slider</div>
      <div class="palette-item" draggable="true" data-type="stepper">Stepper</div>
      <div class="palette-item" draggable="true" data-type="progress">Progress Bar</div>
    </div>
    <div class="palette-group">
      <div class="palette-group-title">Shapes</div>
      <div class="palette-item" draggable="true" data-type="rect">Rectangle</div>
      <div class="palette-item" draggable="true" data-type="circle">Circle</div>
      <div class="palette-item" draggable="true" data-type="triangle">Triangle</div>
      <div class="palette-item" draggable="true" data-type="line">Line</div>
    </div>
  </div>
</div>

<div id="topbar">
  <button id="toggleConnectionMode">Connection Mode: Off</button>
  <button id="deleteSelected">Delete Selected</button>
  <button id="exportBtn">Export HTML</button>
  <span id="connectionModeIndicator"></span>
  <span id="statusText"></span>
</div>

<div id="canvasWrapper">
  <div id="canvasContainer">
    <div id="canvas"></div>
    <div id="canvasSizeHandle" title="Resize canvas"></div>
    <svg id="connectionLayer" class="connection-layer"></svg>
  </div>
</div>

<div id="rightPanel">
  <div id="propertiesPanel">
    <h3>Properties</h3>
    <div id="noSelection">Select an element to edit its properties.</div>
    <div id="elementProps" style="display:none;">
      <div class="prop-group-title">Position &amp; Size</div>
      <div class="prop-row"><label>X</label><input type="number" id="prop-x"></div>
      <div class="prop-row"><label>Y</label><input type="number" id="prop-y"></div>
      <div class="prop-row"><label>Width</label><input type="number" id="prop-width"></div>
      <div class="prop-row"><label>Height</label><input type="number" id="prop-height"></div>

      <div class="prop-group-title">Appearance</div>
      <div class="prop-row"><label>BG Color</label><input type="color" id="prop-bgcolor"></div>
      <div class="prop-row"><label>Text</label><input type="text" id="prop-text"></div>
      <div class="prop-row"><label>Font Size</label><input type="number" id="prop-fontsize" min="6" max="48"></div>
      <div class="prop-row"><label>Radius</label><input type="number" id="prop-radius" min="0" max="200"></div>
      <div class="prop-row"><label>Border</label><input type="text" id="prop-border" placeholder="1px solid #000"></div>

      <div class="prop-group-title">Shadow</div>
      <div class="prop-row"><label>Enable</label><input type="checkbox" id="prop-shadow-enable"></div>
      <div class="prop-row"><label>X</label><input type="number" id="prop-shadow-x" value="0"></div>
      <div class="prop-row"><label>Y</label><input type="number" id="prop-shadow-y" value="4"></div>
      <div class="prop-row"><label>Blur</label><input type="number" id="prop-shadow-blur" value="10"></div>
      <div class="prop-row"><label>Spread</label><input type="number" id="prop-shadow-spread" value="0"></div>
      <div class="prop-row"><label>Color</label><input type="color" id="prop-shadow-color" value="#000000"></div>

      <div class="prop-group-title">Specific</div>
      <div id="specificProps"></div>
    </div>

    <div class="prop-group-title">Canvas</div>
    <div class="prop-row"><label>Width</label><input type="number" id="canvas-width"></div>
    <div class="prop-row"><label>Height</label><input type="number" id="canvas-height"></div>
  </div>
  <div id="downloadArea">
    Export creates a single runnable HTML file containing this design.  
    Open it directly in any browser to view the UI and flowchart.
  </div>
</div>

<script>
(function(){
  // ----- State -----
  let elements = [];          // {id,type,x,y,w,h,styles,specific}
  let connections = [];       // {id,fromId,fromSide,toId,toSide}
  let elementIdCounter = 1;
  let connectionIdCounter = 1;

  const gridSize = 20;
  const snapThreshold = 5;

  const canvas = document.getElementById('canvas');
  const canvasContainer = document.getElementById('canvasContainer');
  const canvasSizeHandle = document.getElementById('canvasSizeHandle');
  const connectionLayer = document.getElementById('connectionLayer');
  const statusText = document.getElementById('statusText');

  const elementPropsPanel = document.getElementById('elementProps');
  const noSelectionPanel = document.getElementById('noSelection');
  const specificProps = document.getElementById('specificProps');

  const propX = document.getElementById('prop-x');
  const propY = document.getElementById('prop-y');
  const propW = document.getElementById('prop-width');
  const propH = document.getElementById('prop-height');
  const propBg = document.getElementById('prop-bgcolor');
  const propText = document.getElementById('prop-text');
  const propFont = document.getElementById('prop-fontsize');
  const propRadius = document.getElementById('prop-radius');
  const propBorder = document.getElementById('prop-border');

  const shadowEnable = document.getElementById('prop-shadow-enable');
  const shadowX = document.getElementById('prop-shadow-x');
  const shadowY = document.getElementById('prop-shadow-y');
  const shadowBlur = document.getElementById('prop-shadow-blur');
  const shadowSpread = document.getElementById('prop-shadow-spread');
  const shadowColor = document.getElementById('prop-shadow-color');

  const canvasWInput = document.getElementById('canvas-width');
  const canvasHInput = document.getElementById('canvas-height');

  let selectedElementId = null;
  let selectedConnectionId = null;

  let isDraggingElement = false;
  let dragOffset = {x:0,y:0};
  let resizing = false;
  let resizeDir = null;
  let startRect = null;
  let startMouse = null;

  let isResizingCanvas = false;
  let canvasStart = null;

  let connectionMode = false;
  let pendingConnectionFrom = null; // {id, side}

  function setStatus(msg, duration=1500){
    statusText.textContent = msg;
    if(duration){
      setTimeout(()=>{ if(statusText.textContent===msg) statusText.textContent=''; }, duration);
    }
  }

  // ----- Canvas init -----
  function initCanvas(){
    const defaultW = 1200;
    const defaultH = 800;
    canvas.style.width = defaultW + 'px';
    canvas.style.height = defaultH + 'px';
    connectionLayer.setAttribute('width', defaultW);
    connectionLayer.setAttribute('height', defaultH);
    canvasWInput.value = defaultW;
    canvasHInput.value = defaultH;

    connectionLayer.innerHTML = `
      <defs>
        <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L0,6 L8,3 z" fill="#4b5563"></path>
        </marker>
        <marker id="arrowhead-selected" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L0,6 L8,3 z" fill="#10b981"></path>
        </marker>
      </defs>`;
  }
  initCanvas();

  // ----- Palette DnD -----
  document.querySelectorAll('.palette-item').forEach(item=>{
    item.addEventListener('dragstart', e=>{
      e.dataTransfer.setData('text/plain', item.dataset.type);
    });
  });

  canvas.addEventListener('dragover', e=> e.preventDefault());
  canvas.addEventListener('drop', e=>{
    e.preventDefault();
    const type = e.dataTransfer.getData('text/plain');
    if(!type) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    createElement(type, x, y);
  });

  function snapCoord(v){ return Math.round(v / gridSize) * gridSize; }

  // ----- Element creation -----
  function createElement(type, cx, cy){
    const id = 'el'+(elementIdCounter++);
    let w=120, h=40;
    if(type==='line'){ w=160; h=4; }
    if(type==='triangle'){ w=80; h=70; }
    const el = {
      id,
      type,
      x: snapCoord(cx - w/2),
      y: snapCoord(cy - h/2),
      w, h,
      styles:{
        bg:'#ffffff',
        text:(type==='button'?'Button':type==='checkbox'?'Checkbox':type==='textfield'?'Text field':''),
        fontSize:12,
        radius:(type==='circle'?Math.min(w,h)/2:4),
        border:'1px solid #9ca3af',
        shadow:null
      },
      specific:{}
    };

    if(type==='button'){
      el.styles.bg = '#3b82f6';
      el.styles.text = 'Button';
      el.styles.border = '1px solid #1d4ed8';
      el.styles.radius = 4;
    }
    if(type==='input'){
      el.styles.text = 'Input';
    }
    if(type==='dropdown'){
      el.styles.text = 'Option 1';
    }
    if(type==='slider' || type==='progress'){ el.specific.value = 50; }
    if(type==='stepper'){ el.specific.value = 0; }
    if(type==='rect' || type==='circle' || type==='triangle'){
      el.styles.bg = '#e5e7eb';
    }
    if(type==='triangle'){
      el.styles.border = 'none';
    }
    if(type==='line'){
      el.styles.bg = '#111827';
      el.styles.border = 'none';
      el.styles.radius = 2;
    }

    elements.push(el);
    renderElement(el);
    selectElement(el.id);
  }

  // ----- Rendering -----
  function renderAll(){
    canvas.innerHTML = '';
    initCanvas();
    elements.forEach(renderElement);
    renderConnections();
  }

  function renderElement(el){
    const node = document.createElement('div');
    node.className = 'canvas-element';
    node.dataset.id = el.id;
    updateElementNode(node, el);
    canvas.appendChild(node);
    attachElementHandlers(node);
  }

  function updateElementNode(node, el){
    node.style.left = el.x + 'px';
    node.style.top  = el.y + 'px';
    node.style.width  = el.w + 'px';
    node.style.height = el.h + 'px';
    node.style.background = el.styles.bg || 'transparent';
    node.style.border = el.styles.border || 'none';
    node.style.borderRadius = (el.styles.radius||0) + 'px';
    node.style.boxShadow = el.styles.shadow || 'none';
    node.style.display = 'flex';
    node.style.alignItems = 'center';
    node.style.justifyContent = 'center';
    node.style.overflow = 'hidden';

    node.innerHTML = '';

    let inner = null;
    switch(el.type){
      case 'button': {
        inner = document.createElement('button');
        inner.className='ui-button';
        inner.textContent = el.styles.text || 'Button';
        inner.style.fontSize = (el.styles.fontSize||12)+'px';
        inner.style.width='100%';
        inner.style.height='100%';
        inner.style.background=el.styles.bg;
        inner.style.border=el.styles.border;
        inner.style.borderRadius=(el.styles.radius||4)+'px';
        break;
      }
      case 'input': {
        inner=document.createElement('input');
        inner.className='ui-input';
        inner.value = el.styles.text || '';
        inner.style.fontSize=(el.styles.fontSize||12)+'px';
        inner.style.width='100%';
        inner.style.height='100%';
        break;
      }
      case 'textfield': {
        inner=document.createElement('textarea');
        inner.className='ui-textfield';
        inner.value = el.styles.text || '';
        inner.style.fontSize=(el.styles.fontSize||12)+'px';
        inner.style.width='100%';
        inner.style.height='100%';
        break;
      }
      case 'checkbox': {
        inner=document.createElement('label');
        inner.className='ui-checkbox-container';
        const cb=document.createElement('input'); cb.type='checkbox';
        const span=document.createElement('span');
        span.textContent = el.styles.text || 'Checkbox';
        inner.appendChild(cb); inner.appendChild(span);
        break;
      }
      case 'dropdown': {
        inner=document.createElement('select');
        inner.className='ui-dropdown';
        inner.style.fontSize=(el.styles.fontSize||12)+'px';
        inner.style.width='100%';
        inner.style.height='100%';
        ['Option 1','Option 2','Option 3'].forEach(t=>{
          const opt=document.createElement('option'); opt.textContent=t; inner.appendChild(opt);
        });
        break;
      }
      case 'slider': {
        inner=document.createElement('input');
        inner.type='range';
        inner.className='ui-slider';
        inner.value = el.specific.value || 50;
        break;
      }
      case 'stepper': {
        inner=document.createElement('div');
        inner.className='ui-stepper';
        const minus=document.createElement('button'); minus.textContent='-';
        const val=document.createElement('input'); val.type='number'; val.value=el.specific.value||0; val.style.width='40px'; val.style.textAlign='center';
        const plus=document.createElement('button'); plus.textContent='+';
        inner.appendChild(minus); inner.appendChild(val); inner.appendChild(plus);
        break;
      }
      case 'progress': {
        inner=document.createElement('progress');
        inner.className='ui-progress';
        inner.max=100;
        inner.value = el.specific.value || 50;
        break;
      }
      case 'rect': {
        node.classList.add('shape-rect');
        break;
      }
      case 'circle': {
        node.classList.add('shape-circle');
        break;
      }
      case 'triangle': {
        node.classList.add('shape-triangle');
        node.style.width='0';
        node.style.height='0';
        node.style.background='transparent';
        node.style.border='none';
        node.style.borderLeft = (el.w/2)+'px solid transparent';
        node.style.borderRight = (el.w/2)+'px solid transparent';
        node.style.borderBottom = el.h+'px solid '+(el.styles.bg||'#e5e7eb');
        break;
      }
      case 'line': {
        node.classList.add('shape-line');
        node.style.height = el.h+'px';
        node.style.borderRadius = (el.styles.radius||0)+'px';
        break;
      }
    }
    if(inner) node.appendChild(inner);

    // Resize handles
    ['tl','tm','tr','mr','br','bm','bl','ml'].forEach(pos=>{
      const h=document.createElement('div');
      h.className='resize-handle handle-'+pos;
      h.dataset.pos=pos;
      node.appendChild(h);
    });

    // Connector handles (for flowcharting)
    addConnectorHandles(node, el);
  }

  function addConnectorHandles(node, el){
    const positions = [
      {key:'top', x:0.5, y:0},
      {key:'right', x:1, y:0.5},
      {key:'bottom', x:0.5, y:1},
      {key:'left', x:0, y:0.5},
    ];
    positions.forEach(p=>{
      const h=document.createElement('div');
      h.className='connector-handle';
      h.dataset.elementId = el.id;
      h.dataset.side = p.key;
      h.style.left = (p.x*100)+'%';
      h.style.top = (p.y*100)+'%';
      h.style.transform='translate(-50%,-50%)';
      h.style.pointerEvents = connectionMode ? 'auto':'none';
      h.style.display = connectionMode ? 'block':'none';
      node.appendChild(h);
    });
  }

  function refreshConnectorHandles(){
    document.querySelectorAll('.connector-handle').forEach(h=>{
      h.style.pointerEvents = connectionMode ? 'auto':'none';
      h.style.display = connectionMode ? 'block':'none';
    });
  }

  function getElementNode(id){
    return canvas.querySelector('.canvas-element[data-id="'+id+'"]');
  }

  function rerenderElement(id){
    const el = elements.find(e=>e.id===id);
    const node = getElementNode(id);
    if(!el || !node) return;
    updateElementNode(node, el);
  }

  // ----- Element interaction -----
  function attachElementHandlers(node){
    node.addEventListener('mousedown', elementMouseDown);
  }

  function elementMouseDown(e){
    const id = this.dataset.id;
    selectElement(id);

    if(e.target.classList.contains('resize-handle')){
      startResize(e, this, e.target.dataset.pos);
    } else {
      startDrag(e, this);
    }
  }

  function selectElement(id){
    selectedElementId = id;
    selectedConnectionId = null;
    pendingConnectionFrom = null;
    document.querySelectorAll('.canvas-element').forEach(n=>n.classList.remove('selected'));
    document.querySelectorAll('.connection-line').forEach(l=>l.classList.remove('selected'));
    const n = getElementNode(id);
    if(n) n.classList.add('selected');
    updatePropertiesPanel();
  }

  function selectConnection(id){
    selectedElementId = null;
    selectedConnectionId = id;
    pendingConnectionFrom = null;
    document.querySelectorAll('.canvas-element').forEach(n=>n.classList.remove('selected'));
    document.querySelectorAll('.connection-line').forEach(l=>l.classList.remove('selected'));
    const n = connectionLayer.querySelector('.connection-line[data-id="'+id+'"]');
    if(n) n.classList.add('selected');
    updatePropertiesPanel();
  }

  function clearSelection(){
    selectedElementId = null;
    selectedConnectionId = null;
    pendingConnectionFrom = null;
    document.querySelectorAll('.canvas-element').forEach(n=>n.classList.remove('selected'));
    document.querySelectorAll('.connection-line').forEach(l=>l.classList.remove('selected'));
    updatePropertiesPanel();
  }

  // Dragging
  function startDrag(e, node){
    isDraggingElement = true;
    const id = node.dataset.id;
    const el = elements.find(x=>x.id===id);
    const rect = node.getBoundingClientRect();
    const cRect = canvas.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;

    document.addEventListener('mousemove', onDragMove);
    document.addEventListener('mouseup', onDragEnd);
    e.preventDefault();

    function onDragMove(ev){
      if(!isDraggingElement) return;
      let x = ev.clientX - cRect.left - dragOffset.x;
      let y = ev.clientY - cRect.top  - dragOffset.y;
      x = snapCoord(x);
      y = snapCoord(y);

      clearAlignmentGuides();
      const guides = getAlignmentGuides(el.id, x,y, el.w, el.h);
      if(guides.v) x = guides.v.snap;
      if(guides.h) y = guides.h.snap;
      drawAlignmentGuides(guides);

      el.x = x; el.y = y;
      node.style.left = x+'px';
      node.style.top  = y+'px';
      updateConnectionsForElement(el.id);
      updatePropertiesPanelPositions(el);
    }
    function onDragEnd(){
      isDraggingElement = false;
      document.removeEventListener('mousemove', onDragMove);
      document.removeEventListener('mouseup', onDragEnd);
      clearAlignmentGuides();
    }
  }

  // Alignment guides
  function getAlignmentGuides(movingId, x,y,w,h){
    let res = {};
    const movingCenterX = x + w/2;
    const movingCenterY = y + h/2;
    const movingLeft   = x;
    const movingRight  = x + w;
    const movingTop    = y;
    const movingBottom = y + h;

    elements.forEach(el=>{
      if(el.id===movingId) return;
      const cX = el.x + el.w/2;
      const cY = el.y + el.h/2;
      const left = el.x;
      const right = el.x + el.w;
      const top = el.y;
      const bottom = el.y + el.h;

      if(Math.abs(movingCenterX-cX)<=snapThreshold){
        res.v = {x:cX, snap:cX-w/2, type:'center'};
      } else if(Math.abs(movingLeft-left)<=snapThreshold){
        res.v = {x:left, snap:left, type:'left'};
      } else if(Math.abs(movingRight-right)<=snapThreshold){
        res.v = {x:right, snap:right-w, type:'right'};
      }

      if(Math.abs(movingCenterY-cY)<=snapThreshold){
        res.h = {y:cY, snap:cY-h/2, type:'center'};
      } else if(Math.abs(movingTop-top)<=snapThreshold){
        res.h = {y:top, snap:top, type:'top'};
      } else if(Math.abs(movingBottom-bottom)<=snapThreshold){
        res.h = {y:bottom, snap:bottom-h, type:'bottom'};
      }
    });
    return res;
  }

  function clearAlignmentGuides(){
    document.querySelectorAll('.alignment-guide').forEach(g=>g.remove());
  }
  function drawAlignmentGuides(guides){
    if(guides.v){
      const line=document.createElement('div');
      line.className='alignment-guide v';
      line.style.left = guides.v.x+'px';
      line.style.top = '0px';
      line.style.height = canvas.offsetHeight+'px';
      canvas.appendChild(line);
    }
    if(guides.h){
      const line=document.createElement('div');
      line.className='alignment-guide h';
      line.style.top = guides.h.y+'px';
      line.style.left = '0px';
      line.style.width = canvas.offsetWidth+'px';
      canvas.appendChild(line);
    }
  }

  // Resizing elements
  function startResize(e, node, pos){
    resizing = true;
    resizeDir = pos;
    const id = node.dataset.id;
    const el = elements.find(x=>x.id===id);
    startRect = {x:el.x, y:el.y, w:el.w, h:el.h};
    startMouse = {x:e.clientX, y:e.clientY};

    document.addEventListener('mousemove', onResizeMove);
    document.addEventListener('mouseup', onResizeEnd);
    e.preventDefault();

    function onResizeMove(ev){
      if(!resizing) return;
      let dx = ev.clientX - startMouse.x;
      let dy = ev.clientY - startMouse.y;

      let nx = startRect.x;
      let ny = startRect.y;
      let nw = startRect.w;
      let nh = startRect.h;

      if(pos.indexOf('l')>=0){ nx = startRect.x + dx; nw = startRect.w - dx; }
      if(pos.indexOf('r')>=0){ nw = startRect.w + dx; }
      if(pos.indexOf('t')>=0){ ny = startRect.y + dy; nh = startRect.h - dy; }
      if(pos.indexOf('b')>=0){ nh = startRect.h + dy; }

      nw = Math.max(10, nw);
      nh = Math.max(10, nh);

      nx = snapCoord(nx);
      ny = snapCoord(ny);
      nw = snapCoord(nw);
      nh = snapCoord(nh);

      el.x = nx; el.y = ny; el.w = nw; el.h = nh;

      updateElementNode(node, el);
      updateConnectionsForElement(el.id);
      updatePropertiesPanelPositions(el);
    }
    function onResizeEnd(){
      resizing=false;
      document.removeEventListener('mousemove', onResizeMove);
      document.removeEventListener('mouseup', onResizeEnd);
    }
  }

  // Canvas resizing
  canvasSizeHandle.addEventListener('mousedown', e=>{
    isResizingCanvas = true;
    const rect = canvas.getBoundingClientRect();
    canvasStart = {w:rect.width, h:rect.height, x:e.clientX, y:e.clientY};
    document.addEventListener('mousemove', onCanvasResizeMove);
    document.addEventListener('mouseup', onCanvasResizeEnd);
    e.preventDefault();
  });
  function onCanvasResizeMove(e){
    if(!isResizingCanvas) return;
    let w = canvasStart.w + (e.clientX-canvasStart.x);
    let h = canvasStart.h + (e.clientY-canvasStart.y);
    w = Math.max(200, snapCoord(w));
    h = Math.max(200, snapCoord(h));
    canvas.style.width = w+'px';
    canvas.style.height = h+'px';
    connectionLayer.setAttribute('width', w);
    connectionLayer.setAttribute('height', h);
    canvasWInput.value = w;
    canvasHInput.value = h;
  }
  function onCanvasResizeEnd(){
    isResizingCanvas=false;
    document.removeEventListener('mousemove', onCanvasResizeMove);
    document.removeEventListener('mouseup', onCanvasResizeEnd);
  }

  canvasWInput.addEventListener('change', ()=>{
    const w = parseInt(canvasWInput.value)||400;
    canvas.style.width = w+'px';
    connectionLayer.setAttribute('width', w);
  });
  canvasHInput.addEventListener('change', ()=>{
    const h = parseInt(canvasHInput.value)||300;
    canvas.style.height = h+'px';
    connectionLayer.setAttribute('height', h);
  });

  // ----- Properties panel -----
  function updatePropertiesPanel(){
    if(selectedElementId){
      const el = elements.find(e=>e.id===selectedElementId);
      if(!el) return;
      elementPropsPanel.style.display='';
      noSelectionPanel.style.display='none';

      propX.value = el.x;
      propY.value = el.y;
      propW.value = el.w;
      propH.value = el.h;
      propBg.value = rgbToHex(el.styles.bg || '#ffffff');
      propText.value = el.styles.text || '';
      propFont.value = el.styles.fontSize || 12;
      propRadius.value = el.styles.radius || 0;
      propBorder.value = el.styles.border || '';

      if(el.styles.shadow){
        shadowEnable.checked = true;
        const s = parseBoxShadow(el.styles.shadow);
        shadowX.value = s.x;
        shadowY.value = s.y;
        shadowBlur.value = s.blur;
        shadowSpread.value = s.spread;
        shadowColor.value = rgbToHex(s.color);
      }else{
        shadowEnable.checked = false;
      }

      specificProps.innerHTML='';
      if(el.type==='slider' || el.type==='stepper' || el.type==='progress'){
        const row=document.createElement('div');
        row.className='prop-row';
        const label=document.createElement('label');
        label.textContent='Value';
        const input=document.createElement('input');
        input.type='number';
        input.value=el.specific.value || 0;
        input.addEventListener('change',()=>{
          el.specific.value = parseInt(input.value)||0;
          rerenderElement(el.id);
        });
        row.appendChild(label); row.appendChild(input);
        specificProps.appendChild(row);
      }
    }else if(selectedConnectionId){
      elementPropsPanel.style.display='none';
      noSelectionPanel.style.display='';
      noSelectionPanel.textContent='Connection selected (no editable properties yet).';
    }else{
      elementPropsPanel.style.display='none';
      noSelectionPanel.style.display='';
      noSelectionPanel.textContent='Select an element to edit its properties.';
    }
  }

  function updatePropertiesPanelPositions(el){
    if(selectedElementId===el.id){
      propX.value = el.x;
      propY.value = el.y;
      propW.value = el.w;
      propH.value = el.h;
    }
  }

  // Property inputs
  propX.addEventListener('change', ()=>{
    const el = elements.find(e=>e.id===selectedElementId); if(!el) return;
    el.x = parseInt(propX.value)||0;
    rerenderElement(el.id); updateConnectionsForElement(el.id);
  });
  propY.addEventListener('change', ()=>{
    const el = elements.find(e=>e.id===selectedElementId); if(!el) return;
    el.y = parseInt(propY.value)||0;
    rerenderElement(el.id); updateConnectionsForElement(el.id);
  });
  propW.addEventListener('change', ()=>{
    const el = elements.find(e=>e.id===selectedElementId); if(!el) return;
    el.w = Math.max(10,parseInt(propW.value)||10);
    rerenderElement(el.id); updateConnectionsForElement(el.id);
  });
  propH.addEventListener('change', ()=>{
    const el = elements.find(e=>e.id===selectedElementId); if(!el) return;
    el.h = Math.max(10,parseInt(propH.value)||10);
    rerenderElement(el.id); updateConnectionsForElement(el.id);
  });
  propBg.addEventListener('change', ()=>{
    const el = elements.find(e=>e.id===selectedElementId); if(!el) return;
    el.styles.bg = propBg.value;
    rerenderElement(el.id); updateConnectionsForElement(el.id);
  });
  propText.addEventListener('change', ()=>{
    const el = elements.find(e=>e.id===selectedElementId); if(!el) return;
    el.styles.text = propText.value;
    rerenderElement(el.id);
  });
  propFont.addEventListener('change', ()=>{
    const el = elements.find(e=>e.id===selectedElementId); if(!el) return;
    el.styles.fontSize = parseInt(propFont.value)||12;
    rerenderElement(el.id);
  });
  propRadius.addEventListener('change', ()=>{
    const el = elements.find(e=>e.id===selectedElementId); if(!el) return;
    el.styles.radius = parseInt(propRadius.value)||0;
    rerenderElement(el.id);
  });
  propBorder.addEventListener('change', ()=>{
    const el = elements.find(e=>e.id===selectedElementId); if(!el) return;
    el.styles.border = propBorder.value;
    rerenderElement(el.id); updateConnectionsForElement(el.id);
  });

  [shadowEnable,shadowX,shadowY,shadowBlur,shadowSpread,shadowColor].forEach(input=>{
    input.addEventListener('change', ()=>{
      const el = elements.find(e=>e.id===selectedElementId); if(!el) return;
      if(!shadowEnable.checked){
        el.styles.shadow = null;
      }else{
        el.styles.shadow = `${shadowX.value||0}px ${shadowY.value||0}px ${shadowBlur.value||0}px ${shadowSpread.value||0}px ${shadowColor.value||'#000000'}`;
      }
      rerenderElement(el.id);
    });
  });

  function parseBoxShadow(bs){
    const parts = bs.trim().split(/\s+/);
    const nums = parts.filter(p=>p.endsWith('px')).map(p=>parseInt(p));
    const color = parts.find(p=>!p.endsWith('px')) || '#000000';
    return {x:nums[0]||0,y:nums[1]||0,blur:nums[2]||0,spread:nums[3]||0,color};
  }

  function rgbToHex(c){
    if(!c) return '#ffffff';
    if(c.startsWith('#')) return c;
    const m = c.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
    if(!m) return '#ffffff';
    const r=parseInt(m[1]), g=parseInt(m[2]), b=parseInt(m[3]);
    return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');
  }

  // ----- Connections -----
  function toggleConnectionMode(){
    connectionMode = !connectionMode;
    document.getElementById('toggleConnectionMode').textContent =
      'Connection Mode: ' + (connectionMode?'On':'Off');
    document.getElementById('connectionModeIndicator').textContent =
      connectionMode ? 'Click connector dots on elements to create flows.' : '';
    pendingConnectionFrom = null;
    refreshConnectorHandles();
  }
  document.getElementById('toggleConnectionMode').addEventListener('click', toggleConnectionMode);

  // Connector click handling
  canvas.addEventListener('click', e=>{
    if(!connectionMode) return;
    const target = e.target;
    if(target.classList.contains('connector-handle')){
      const elId = target.dataset.elementId;
      const side = target.dataset.side;
      if(!pendingConnectionFrom){
        pendingConnectionFrom = {id:elId, side};
        setStatus('Connection start from '+elId+' ('+side+')');
      }else if(pendingConnectionFrom.id===elId && pendingConnectionFrom.side===side){
        pendingConnectionFrom = null;
      }else{
        createConnection(pendingConnectionFrom.id, pendingConnectionFrom.side, elId, side);
        pendingConnectionFrom = null;
      }
      e.stopPropagation();
    }
  });

  function createConnection(fromId,fromSide,toId,toSide){
    const id = 'conn'+(connectionIdCounter++);
    connections.push({id,fromId,fromSide,toId,toSide});
    renderConnections();
  }

  function getElementConnectPoint(el, side){
    switch(side){
      case 'top':    return {x:el.x+el.w/2, y:el.y};
      case 'right':  return {x:el.x+el.w,   y:el.y+el.h/2};
      case 'bottom': return {x:el.x+el.w/2, y:el.y+el.h};
      case 'left':   return {x:el.x,        y:el.y+el.h/2};
      default:       return {x:el.x+el.w/2, y:el.y+el.h/2};
    }
  }

  function buildSmoothPath(p1,p2){
    const dx = Math.abs(p2.x-p1.x);
    const c1x = p1.x + dx/2;
    const c2x = p2.x - dx/2;
    return `M${p1.x},${p1.y} C${c1x},${p1.y} ${c2x},${p2.y} ${p2.x},${p2.y}`;
  }

  function renderConnections(){
    // Keep defs
    const defs = connectionLayer.querySelector('defs');
    connectionLayer.innerHTML = '';
    if(defs) connectionLayer.appendChild(defs);

    connections.forEach(conn=>{
      const fromEl = elements.find(e=>e.id===conn.fromId);
      const toEl   = elements.find(e=>e.id===conn.toId);
      if(!fromEl || !toEl) return;
      const p1 = getElementConnectPoint(fromEl, conn.fromSide || 'right');
      const p2 = getElementConnectPoint(toEl,   conn.toSide   || 'left');
      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('class','connection-line');
      path.dataset.id = conn.id;
      path.setAttribute('d', buildSmoothPath(p1,p2));
      path.setAttribute('marker-end','url(#arrowhead)');
      path.addEventListener('mousedown', e=>{
        e.stopPropagation();
        selectConnection(conn.id);
      });
      connectionLayer.appendChild(path);
    });
  }

  function updateConnectionsForElement(id){
    // Recompute all for simplicity
    renderConnections();
  }

  // Delete selected element / connection
  document.getElementById('deleteSelected').addEventListener('click', ()=>{
    if(selectedElementId){
      const id = selectedElementId;
      elements = elements.filter(e=>e.id!==id);
      connections = connections.filter(c=>c.fromId!==id && c.toId!==id);
      renderAll();
      clearSelection();
    }else if(selectedConnectionId){
      const id = selectedConnectionId;
      connections = connections.filter(c=>c.id!==id);
      renderConnections();
      clearSelection();
    }
  });

  // Canvas background click -> deselect
  canvas.addEventListener('mousedown', e=>{
    if(e.target===canvas){
      clearSelection();
    }
  });

  // ----- Export -----
  document.getElementById('exportBtn').addEventListener('click', exportHTML);

  function exportHTML(){
    const design = {
      canvas:{
        width:parseInt(canvas.style.width)||1200,
        height:parseInt(canvas.style.height)||800
      },
      elements,
      connections
    };
    let payload = JSON.stringify(design);
    // Avoid breaking <script> in exported file
    payload = payload.replace(/<\/script/gi,'<\\/script');

    const html = buildRuntimeHTML(payload);
    const blob = new Blob([html], {type:'text/html'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'ui-builder-export.html';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function buildRuntimeHTML(payload){
    return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Exported UI / Flowchart</title>
<style>
  body{margin:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;background:#111827;}
  #container{margin:20px;position:relative;display:inline-block;background:#ffffff;box-shadow:0 0 0 1px #d1d5db;}
  #canvas{position:relative;}
  .el{position:absolute;box-sizing:border-box;display:flex;align-items:center;justify-content:center;overflow:hidden;}
  .shape-triangle{width:0;height:0;background:transparent!important;}
  svg{position:absolute;left:0;top:0;overflow:visible;pointer-events:none;}
  .connection-line{stroke:#4b5563;stroke-width:2;fill:none;marker-end:url(#arrowhead);}
  button,input,textarea,select{font-family:inherit;}
</style>
</head>
<body>
<div id="container">
  <div id="canvas"></div>
  <svg id="layer"></svg>
</div>
<script>
const design = ${payload};
const canvas = document.getElementById('canvas');
const svg = document.getElementById('layer');
canvas.style.width = design.canvas.width+'px';
canvas.style.height = design.canvas.height+'px';
svg.setAttribute('width', design.canvas.width);
svg.setAttribute('height', design.canvas.height);

const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
defs.innerHTML = '<marker id="arrowhead" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L8,3 z" fill="#4b5563"/></marker>';
svg.appendChild(defs);

function addEl(el){
  const node=document.createElement('div');
  node.className='el';
  node.style.left=el.x+'px';
  node.style.top=el.y+'px';
  node.style.width=el.w+'px';
  node.style.height=el.h+'px';
  node.style.background=el.styles.bg||'transparent';
  node.style.border=el.styles.border||'none';
  node.style.borderRadius=(el.styles.radius||0)+'px';
  node.style.boxShadow=el.styles.shadow||'none';
  let inner=null;

  switch(el.type){
    case 'button':
      inner=document.createElement('button');
      inner.textContent=el.styles.text||'Button';
      inner.style.fontSize=(el.styles.fontSize||12)+'px';
      inner.style.width='100%';inner.style.height='100%';
      inner.style.background=el.styles.bg;inner.style.border=el.styles.border;inner.style.borderRadius=(el.styles.radius||4)+'px';
      break;
    case 'input':
      inner=document.createElement('input');
      inner.value=el.styles.text||'';inner.style.fontSize=(el.styles.fontSize||12)+'px';inner.style.width='100%';inner.style.height='100%';
      break;
    case 'textfield':
      inner=document.createElement('textarea');
      inner.value=el.styles.text||'';inner.style.fontSize=(el.styles.fontSize||12)+'px';inner.style.width='100%';inner.style.height='100%';
      break;
    case 'checkbox':
      inner=document.createElement('label');
      inner.style.display='flex';inner.style.alignItems='center';inner.style.fontSize='12px';
      const cb=document.createElement('input');cb.type='checkbox';
      const span=document.createElement('span');span.textContent=el.styles.text||'Checkbox';span.style.marginLeft='4px';
      inner.appendChild(cb);inner.appendChild(span);
      break;
    case 'dropdown':
      inner=document.createElement('select');
      inner.style.fontSize=(el.styles.fontSize||12)+'px';inner.style.width='100%';inner.style.height='100%';
      ['Option 1','Option 2','Option 3'].forEach(t=>{const o=document.createElement('option');o.textContent=t;inner.appendChild(o);});
      break;
    case 'slider':
      inner=document.createElement('input');inner.type='range';inner.value=el.specific.value||50;inner.style.width='100%';
      break;
    case 'stepper':
      inner=document.createElement('div');inner.style.display='flex';inner.style.fontSize='12px';
      const m=document.createElement('button');m.textContent='-';
      const v=document.createElement('input');v.type='number';v.value=el.specific.value||0;v.style.width='40px';v.style.textAlign='center';
      const p=document.createElement('button');p.textContent='+';
      inner.appendChild(m);inner.appendChild(v);inner.appendChild(p);
      break;
    case 'progress':
      inner=document.createElement('progress');inner.max=100;inner.value=el.specific.value||50;inner.style.width='100%';
      break;
    case 'triangle':
      node.style.width='0';node.style.height='0';node.style.background='transparent';node.style.border='none';
      node.style.borderLeft=(el.w/2)+'px solid transparent';
      node.style.borderRight=(el.w/2)+'px solid transparent';
      node.style.borderBottom=el.h+'px solid '+(el.styles.bg||'#e5e7eb');
      break;
    case 'line':
      node.style.height=el.h+'px';node.style.background=el.styles.bg||'#111827';node.style.borderRadius=(el.styles.radius||0)+'px';
      break;
  }
  if(inner) node.appendChild(inner);
  canvas.appendChild(node);
}

design.elements.forEach(addEl);

function getPoint(el, side){
  switch(side){
    case 'top':    return {x:el.x+el.w/2, y:el.y};
    case 'right':  return {x:el.x+el.w,   y:el.y+el.h/2};
    case 'bottom': return {x:el.x+el.w/2, y:el.y+el.h};
    case 'left':   return {x:el.x,        y:el.y+el.h/2};
    default:       return {x:el.x+el.w/2, y:el.y+el.h/2};
  }
}
function path(p1,p2){
  const dx=Math.abs(p2.x-p1.x);
  const c1x=p1.x+dx/2;
  const c2x=p2.x-dx/2;
  return 'M'+p1.x+','+p1.y+' C'+c1x+','+p1.y+' '+c2x+','+p2.y+' '+p2.x+','+p2.y;
}

design.connections.forEach(conn=>{
  const from=design.elements.find(e=>e.id===conn.fromId);
  const to=design.elements.find(e=>e.id===conn.toId);
  if(!from||!to)return;
  const p1=getPoint(from, conn.fromSide||'right');
  const p2=getPoint(to,   conn.toSide  ||'left');
  const pathNode=document.createElementNS('http://www.w3.org/2000/svg','path');
  pathNode.setAttribute('class','connection-line');
  pathNode.setAttribute('d', path(p1,p2));
  pathNode.setAttribute('marker-end','url(#arrowhead)');
  svg.appendChild(pathNode);
});
<\/script>
</body>
</html>`;
  }

  // Keyboard delete
  document.addEventListener('keydown', e=>{
    if(e.key==='Delete' || e.key==='Backspace'){
      document.getElementById('deleteSelected').click();
    }
  });

  // Initial hint
  setStatus('Drag components from the left onto the canvas.');
})();
</script>
</body>
</html>