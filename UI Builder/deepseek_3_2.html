<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Figma-like UI Builder</title>
    <style>
        :root {
            --primary-color: #8a2be2;
            --secondary-color: #4a6fa5;
            --background-color: #f8f9fa;
            --sidebar-color: #2c3e50;
            --canvas-color: #ffffff;
            --text-color: #333;
            --border-color: #ddd;
            --grid-color: #f0f0f0;
            --handle-color: #4a90e2;
            --guide-color: #ff4757;
            --connection-color: #00b894;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            background-color: white;
            padding: 12px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .logo {
            display: flex;
            align-items: center;
            font-weight: 700;
            font-size: 22px;
            color: var(--primary-color);
        }

        .logo-icon {
            margin-right: 10px;
            font-size: 24px;
        }

        .header-controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background-color: white;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover {
            background-color: #f5f5f5;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .btn-primary:hover {
            background-color: #7a1fd2;
        }

        /* Main layout */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Left Sidebar - Components */
        .sidebar {
            width: 280px;
            background-color: white;
            border-right: 1px solid var(--border-color);
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .sidebar-section {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid var(--border-color);
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--sidebar-color);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .components-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .component-item {
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            text-align: center;
            cursor: grab;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .component-item:hover {
            border-color: var(--primary-color);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .component-icon {
            font-size: 24px;
            color: var(--secondary-color);
        }

        .component-name {
            font-size: 12px;
            font-weight: 500;
        }

        /* Canvas */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: auto;
            background-color: var(--canvas-color);
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #main-canvas {
            position: relative;
            width: 1000px;
            height: 800px;
            margin: 30px auto;
            box-shadow: 0 0 30px rgba(0,0,0,0.05);
            background-color: white;
            border-radius: 4px;
            overflow: hidden;
        }

        .canvas-element {
            position: absolute;
            border: 1px solid transparent;
            cursor: move;
            user-select: none;
            transition: border-color 0.2s;
        }

        .canvas-element.selected {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 1px var(--primary-color);
        }

        .resize-handle {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: white;
            border: 2px solid var(--handle-color);
            border-radius: 50%;
            z-index: 10;
        }

        .resize-handle.nw { top: -4px; left: -4px; cursor: nw-resize; }
        .resize-handle.ne { top: -4px; right: -4px; cursor: ne-resize; }
        .resize-handle.sw { bottom: -4px; left: -4px; cursor: sw-resize; }
        .resize-handle.se { bottom: -4px; right: -4px; cursor: se-resize; }
        .resize-handle.n { top: -4px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .resize-handle.s { bottom: -4px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        .resize-handle.w { left: -4px; top: 50%; transform: translateY(-50%); cursor: w-resize; }
        .resize-handle.e { right: -4px; top: 50%; transform: translateY(-50%); cursor: e-resize; }

        .connection-point {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: var(--connection-color);
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s;
            cursor: crosshair;
            z-index: 5;
        }

        .canvas-element:hover .connection-point {
            opacity: 1;
        }

        .connection-point.top { top: -6px; left: 50%; transform: translateX(-50%); }
        .connection-point.bottom { bottom: -6px; left: 50%; transform: translateX(-50%); }
        .connection-point.left { left: -6px; top: 50%; transform: translateY(-50%); }
        .connection-point.right { right: -6px; top: 50%; transform: translateY(-50%); }
        .connection-point.center { top: 50%; left: 50%; transform: translate(-50%, -50%); }

        .connection-line {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }

        .connection-line.selected {
            stroke: var(--primary-color) !important;
            stroke-width: 3px !important;
        }

        .connection-handle {
            fill: var(--connection-color);
            r: 6;
            cursor: move;
        }

        /* Right Sidebar - Properties */
        .properties-sidebar {
            width: 320px;
            background-color: white;
            border-left: 1px solid var(--border-color);
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .properties-header {
            font-size: 18px;
            font-weight: 600;
            color: var(--sidebar-color);
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .property-group {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid var(--border-color);
        }

        .property-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--sidebar-color);
        }

        .property-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .property-label {
            width: 120px;
            font-size: 13px;
            color: #555;
        }

        .property-input {
            flex: 1;
            padding: 8px 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-size: 13px;
        }

        .property-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .color-picker {
            width: 40px;
            height: 30px;
            border: none;
            padding: 0;
            cursor: pointer;
            background: transparent;
        }

        .range-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .range-value {
            width: 40px;
            text-align: center;
            font-size: 13px;
        }

        /* UI Component Styles */
        .ui-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px 20px;
            font-weight: 500;
            text-align: center;
            cursor: pointer;
            font-size: 14px;
        }

        .ui-input, .ui-textarea {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px;
            font-size: 14px;
            width: 100%;
        }

        .ui-textarea {
            min-height: 80px;
            resize: vertical;
            font-family: inherit;
        }

        .ui-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .ui-checkbox input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .ui-dropdown {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px;
            font-size: 14px;
            width: 100%;
            background-color: white;
        }

        .ui-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background-color: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
        }

        .ui-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: var(--primary-color);
            cursor: pointer;
        }

        .ui-stepper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ui-stepper button {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            background-color: white;
            font-size: 18px;
            cursor: pointer;
        }

        .ui-stepper-value {
            min-width: 40px;
            text-align: center;
            font-weight: 500;
        }

        .ui-progress {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background-color: #e0e0e0;
            overflow: hidden;
        }

        .ui-progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 4px;
        }

        /* Shapes */
        .shape-rectangle {
            background-color: #e3f2fd;
            border: 2px solid #2196f3;
        }

        .shape-circle {
            background-color: #f3e5f5;
            border: 2px solid #9c27b0;
            border-radius: 50%;
        }

        .shape-triangle {
            width: 0;
            height: 0;
            border-left: 50px solid transparent;
            border-right: 50px solid transparent;
            border-bottom: 86.6px solid #ffebee;
            background-color: transparent !important;
            position: relative;
        }

        .shape-triangle::after {
            content: '';
            position: absolute;
            border-left: 48px solid transparent;
            border-right: 48px solid transparent;
            border-bottom: 83.6px solid #ffcdd2;
            top: 2px;
            left: -48px;
        }

        .shape-line {
            background-color: #757575;
            height: 4px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 12px;
            width: 500px;
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--sidebar-color);
        }

        .modal-textarea {
            width: 100%;
            height: 300px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            font-family: monospace;
            font-size: 13px;
            margin-bottom: 20px;
            resize: vertical;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* Alignment Guides */
        .guide {
            position: absolute;
            background-color: var(--guide-color);
            z-index: 1000;
            pointer-events: none;
        }

        .guide.horizontal {
            width: 100%;
            height: 1px;
        }

        .guide.vertical {
            height: 100%;
            width: 1px;
        }

        /* Status Bar */
        .status-bar {
            background-color: white;
            padding: 8px 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* Checkbox and Radio Customization */
        .checkbox-group, .radio-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .checkbox-item, .radio-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 10000;
            white-space: nowrap;
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="logo">
            <span class="logo-icon">üñåÔ∏è</span>
            <span>UI Builder</span>
        </div>
        <div class="header-controls">
            <button class="btn" id="toggle-grid-btn">
                <span>üóÑÔ∏è</span> Grid
            </button>
            <button class="btn" id="snap-toggle-btn">
                <span>üß≤</span> Snap
            </button>
            <button class="btn" id="clear-btn">
                <span>üóëÔ∏è</span> Clear
            </button>
            <button class="btn btn-primary" id="export-btn">
                <span>üì•</span> Export HTML
            </button>
        </div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Left Sidebar - Components -->
        <div class="sidebar">
            <div class="sidebar-section">
                <div class="section-title">UI Components</div>
                <div class="components-grid">
                    <div class="component-item" data-type="button">
                        <span class="component-icon">üîò</span>
                        <span class="component-name">Button</span>
                    </div>
                    <div class="component-item" data-type="input">
                        <span class="component-icon">üìù</span>
                        <span class="component-name">Input Field</span>
                    </div>
                    <div class="component-item" data-type="textarea">
                        <span class="component-icon">üìÑ</span>
                        <span class="component-name">Text Area</span>
                    </div>
                    <div class="component-item" data-type="checkbox">
                        <span class="component-icon">‚òëÔ∏è</span>
                        <span class="component-name">Checkbox</span>
                    </div>
                    <div class="component-item" data-type="dropdown">
                        <span class="component-icon">‚ñæ</span>
                        <span class="component-name">Dropdown</span>
                    </div>
                    <div class="component-item" data-type="slider">
                        <span class="component-icon">üéöÔ∏è</span>
                        <span class="component-name">Slider</span>
                    </div>
                    <div class="component-item" data-type="stepper">
                        <span class="component-icon">üî¢</span>
                        <span class="component-name">Stepper</span>
                    </div>
                    <div class="component-item" data-type="progress">
                        <span class="component-icon">üìä</span>
                        <span class="component-name">Progress Bar</span>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Shapes</div>
                <div class="components-grid">
                    <div class="component-item" data-type="rectangle">
                        <span class="component-icon">‚¨ú</span>
                        <span class="component-name">Rectangle</span>
                    </div>
                    <div class="component-item" data-type="circle">
                        <span class="component-icon">‚≠ï</span>
                        <span class="component-name">Circle</span>
                    </div>
                    <div class="component-item" data-type="triangle">
                        <span class="component-icon">üî∫</span>
                        <span class="component-name">Triangle</span>
                    </div>
                    <div class="component-item" data-type="line">
                        <span class="component-icon">‚ûñ</span>
                        <span class="component-name">Line</span>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Canvas Tools</div>
                <div class="components-grid">
                    <div class="component-item" id="select-tool">
                        <span class="component-icon">‚úã</span>
                        <span class="component-name">Select</span>
                    </div>
                    <div class="component-item" id="connect-tool">
                        <span class="component-icon">üîó</span>
                        <span class="component-name">Connect</span>
                    </div>
                    <div class="component-item" id="zoom-in">
                        <span class="component-icon">üîç+</span>
                        <span class="component-name">Zoom In</span>
                    </div>
                    <div class="component-item" id="zoom-out">
                        <span class="component-icon">üîç-</span>
                        <span class="component-name">Zoom Out</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="canvas-container" id="canvas-container">
            <div id="main-canvas">
                <!-- Elements will be added here dynamically -->
            </div>
            
            <!-- Alignment guides will be added here -->
            <div id="guides-container"></div>
        </div>

        <!-- Right Sidebar - Properties -->
        <div class="properties-sidebar" id="properties-sidebar">
            <div class="properties-header">Properties</div>
            
            <div class="property-group" id="position-group">
                <div class="property-title">Position & Size</div>
                <div class="property-row">
                    <label class="property-label">X:</label>
                    <input type="number" class="property-input" id="prop-x" min="0">
                </div>
                <div class="property-row">
                    <label class="property-label">Y:</label>
                    <input type="number" class="property-input" id="prop-y" min="0">
                </div>
                <div class="property-row">
                    <label class="property-label">Width:</label>
                    <input type="number" class="property-input" id="prop-width" min="1">
                </div>
                <div class="property-row">
                    <label class="property-label">Height:</label>
                    <input type="number" class="property-input" id="prop-height" min="1">
                </div>
            </div>

            <div class="property-group" id="style-group">
                <div class="property-title">Style</div>
                <div class="property-row">
                    <label class="property-label">Background:</label>
                    <input type="color" class="color-picker" id="prop-bg-color" value="#e3f2fd">
                </div>
                <div class="property-row">
                    <label class="property-label">Border Color:</label>
                    <input type="color" class="color-picker" id="prop-border-color" value="#2196f3">
                </div>
                <div class="property-row">
                    <label class="property-label">Border Width:</label>
                    <div class="range-container">
                        <input type="range" class="property-input" id="prop-border-width" min="0" max="10" value="2">
                        <span class="range-value" id="border-width-value">2px</span>
                    </div>
                </div>
                <div class="property-row">
                    <label class="property-label">Border Radius:</label>
                    <div class="range-container">
                        <input type="range" class="property-input" id="prop-border-radius" min="0" max="50" value="0">
                        <span class="range-value" id="border-radius-value">0px</span>
                    </div>
                </div>
            </div>

            <div class="property-group" id="shadow-group">
                <div class="property-title">Box Shadow</div>
                <div class="property-row">
                    <label class="toggle-switch">
                        <input type="checkbox" id="prop-shadow-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                    <label class="property-label">Enabled</label>
                </div>
                <div class="property-row">
                    <label class="property-label">X Offset:</label>
                    <input type="range" class="property-input" id="prop-shadow-x" min="-20" max="20" value="0" disabled>
                </div>
                <div class="property-row">
                    <label class="property-label">Y Offset:</label>
                    <input type="range" class="property-input" id="prop-shadow-y" min="-20" max="20" value="5" disabled>
                </div>
                <div class="property-row">
                    <label class="property-label">Blur:</label>
                    <input type="range" class="property-input" id="prop-shadow-blur" min="0" max="30" value="10" disabled>
                </div>
                <div class="property-row">
                    <label class="property-label">Color:</label>
                    <input type="color" class="color-picker" id="prop-shadow-color" value="#000000" disabled>
                </div>
            </div>

            <div class="property-group" id="text-group">
                <div class="property-title">Text Content</div>
                <div class="property-row">
                    <label class="property-label">Text:</label>
                    <input type="text" class="property-input" id="prop-text" placeholder="Enter text...">
                </div>
                <div class="property-row">
                    <label class="property-label">Font Size:</label>
                    <input type="number" class="property-input" id="prop-font-size" min="8" max="72" value="14">
                </div>
                <div class="property-row">
                    <label class="property-label">Text Color:</label>
                    <input type="color" class="color-picker" id="prop-text-color" value="#333333">
                </div>
            </div>

            <div class="property-group" id="element-specific-group">
                <!-- Dynamic content for element-specific properties -->
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div class="status-item">
            <span>üñ±Ô∏è</span>
            <span id="cursor-position">X: 0, Y: 0</span>
        </div>
        <div class="status-item">
            <span>üìê</span>
            <span id="canvas-size">1000 √ó 800</span>
        </div>
        <div class="status-item">
            <span>üß©</span>
            <span id="element-count">0 elements</span>
        </div>
        <div class="status-item">
            <span>üîó</span>
            <span id="connection-count">0 connections</span>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal" id="export-modal">
        <div class="modal-content">
            <div class="modal-title">Export HTML</div>
            <textarea class="modal-textarea" id="export-code" readonly></textarea>
            <div class="modal-buttons">
                <button class="btn" id="copy-btn">
                    <span>üìã</span> Copy to Clipboard
                </button>
                <button class="btn btn-primary" id="close-export-btn">
                    <span>‚úï</span> Close
                </button>
            </div>
        </div>
    </div>

    <script>
        // Application state
        const appState = {
            elements: [],
            connections: [],
            selectedElement: null,
            selectedConnection: null,
            activeTool: 'select',
            isDragging: false,
            isResizing: false,
            isConnecting: false,
            dragStartX: 0,
            dragStartY: 0,
            originalX: 0,
            originalY: 0,
            originalWidth: 0,
            originalHeight: 0,
            resizeDirection: '',
            snapToGrid: true,
            gridSize: 20,
            zoomLevel: 1,
            connectionStart: null,
            showGuides: true
        };

        // DOM elements
        const canvas = document.getElementById('main-canvas');
        const canvasContainer = document.getElementById('canvas-container');
        const exportModal = document.getElementById('export-modal');
        const exportCode = document.getElementById('export-code');
        const copyBtn = document.getElementById('copy-btn');
        const closeExportBtn = document.getElementById('close-export-btn');
        const exportBtn = document.getElementById('export-btn');
        const clearBtn = document.getElementById('clear-btn');
        const toggleGridBtn = document.getElementById('toggle-grid-btn');
        const snapToggleBtn = document.getElementById('snap-toggle-btn');
        const connectTool = document.getElementById('connect-tool');
        const selectTool = document.getElementById('select-tool');
        const zoomIn = document.getElementById('zoom-in');
        const zoomOut = document.getElementById('zoom-out');
        
        // Property inputs
        const propX = document.getElementById('prop-x');
        const propY = document.getElementById('prop-y');
        const propWidth = document.getElementById('prop-width');
        const propHeight = document.getElementById('prop-height');
        const propBgColor = document.getElementById('prop-bg-color');
        const propBorderColor = document.getElementById('prop-border-color');
        const propBorderWidth = document.getElementById('prop-border-width');
        const propBorderRadius = document.getElementById('prop-border-radius');
        const propShadowToggle = document.getElementById('prop-shadow-toggle');
        const propShadowX = document.getElementById('prop-shadow-x');
        const propShadowY = document.getElementById('prop-shadow-y');
        const propShadowBlur = document.getElementById('prop-shadow-blur');
        const propShadowColor = document.getElementById('prop-shadow-color');
        const propText = document.getElementById('prop-text');
        const propFontSize = document.getElementById('prop-font-size');
        const propTextColor = document.getElementById('prop-text-color');
        const borderWidthValue = document.getElementById('border-width-value');
        const borderRadiusValue = document.getElementById('border-radius-value');
        
        // Status elements
        const cursorPosition = document.getElementById('cursor-position');
        const canvasSize = document.getElementById('canvas-size');
        const elementCount = document.getElementById('element-count');
        const connectionCount = document.getElementById('connection-count');

        // Component templates
        const componentTemplates = {
            button: {
                type: 'button',
                width: 120,
                height: 40,
                bgColor: '#8a2be2',
                borderColor: '#8a2be2',
                borderWidth: 2,
                borderRadius: 6,
                text: 'Button',
                fontSize: 14,
                textColor: '#ffffff',
                hasShadow: true,
                shadowX: 0,
                shadowY: 2,
                shadowBlur: 8,
                shadowColor: 'rgba(138, 43, 226, 0.3)'
            },
            input: {
                type: 'input',
                width: 200,
                height: 40,
                bgColor: '#ffffff',
                borderColor: '#ddd',
                borderWidth: 1,
                borderRadius: 6,
                text: '',
                fontSize: 14,
                textColor: '#333333',
                placeholder: 'Enter text...'
            },
            textarea: {
                type: 'textarea',
                width: 250,
                height: 100,
                bgColor: '#ffffff',
                borderColor: '#ddd',
                borderWidth: 1,
                borderRadius: 6,
                text: '',
                fontSize: 14,
                textColor: '#333333',
                placeholder: 'Enter text...'
            },
            checkbox: {
                type: 'checkbox',
                width: 150,
                height: 24,
                bgColor: 'transparent',
                borderColor: 'transparent',
                borderWidth: 0,
                borderRadius: 0,
                text: 'Checkbox',
                fontSize: 14,
                textColor: '#333333',
                checked: false
            },
            dropdown: {
                type: 'dropdown',
                width: 200,
                height: 40,
                bgColor: '#ffffff',
                borderColor: '#ddd',
                borderWidth: 1,
                borderRadius: 6,
                text: 'Option 1',
                fontSize: 14,
                textColor: '#333333',
                options: ['Option 1', 'Option 2', 'Option 3']
            },
            slider: {
                type: 'slider',
                width: 200,
                height: 30,
                bgColor: 'transparent',
                borderColor: 'transparent',
                borderWidth: 0,
                borderRadius: 0,
                text: '',
                fontSize: 14,
                textColor: '#333333',
                value: 50,
                min: 0,
                max: 100
            },
            stepper: {
                type: 'stepper',
                width: 120,
                height: 40,
                bgColor: 'transparent',
                borderColor: 'transparent',
                borderWidth: 0,
                borderRadius: 0,
                text: '',
                fontSize: 14,
                textColor: '#333333',
                value: 1,
                min: 0,
                max: 10
            },
            progress: {
                type: 'progress',
                width: 200,
                height: 20,
                bgColor: 'transparent',
                borderColor: 'transparent',
                borderWidth: 0,
                borderRadius: 0,
                text: '',
                fontSize: 14,
                textColor: '#333333',
                value: 60,
                max: 100
            },
            rectangle: {
                type: 'rectangle',
                width: 120,
                height: 80,
                bgColor: '#e3f2fd',
                borderColor: '#2196f3',
                borderWidth: 2,
                borderRadius: 0,
                text: '',
                fontSize: 14,
                textColor: '#333333'
            },
            circle: {
                type: 'circle',
                width: 100,
                height: 100,
                bgColor: '#f3e5f5',
                borderColor: '#9c27b0',
                borderWidth: 2,
                borderRadius: 50,
                text: '',
                fontSize: 14,
                textColor: '#333333'
            },
            triangle: {
                type: 'triangle',
                width: 100,
                height: 86.6,
                bgColor: '#ffebee',
                borderColor: '#f44336',
                borderWidth: 0,
                borderRadius: 0,
                text: '',
                fontSize: 14,
                textColor: '#333333'
            },
            line: {
                type: 'line',
                width: 150,
                height: 4,
                bgColor: '#757575',
                borderColor: '#757575',
                borderWidth: 0,
                borderRadius: 0,
                text: '',
                fontSize: 14,
                textColor: '#333333'
            }
        };

        // Initialize the application
        function init() {
            setupEventListeners();
            loadDemoElements();
            updateStatusBar();
        }

        // Set up event listeners
        function setupEventListeners() {
            // Component drag from sidebar
            document.querySelectorAll('.component-item[data-type]').forEach(item => {
                item.addEventListener('dragstart', handleComponentDragStart);
            });

            // Canvas drop zone
            canvas.addEventListener('dragover', handleDragOver);
            canvas.addEventListener('drop', handleCanvasDrop);
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('click', handleCanvasClick);

            // Canvas container for mouse position tracking
            canvasContainer.addEventListener('mousemove', updateCursorPosition);

            // Control buttons
            exportBtn.addEventListener('click', openExportModal);
            copyBtn.addEventListener('click', copyExportCode);
            closeExportBtn.addEventListener('click', () => exportModal.style.display = 'none');
            clearBtn.addEventListener('click', clearCanvas);
            toggleGridBtn.addEventListener('click', toggleGrid);
            snapToggleBtn.addEventListener('click', toggleSnap);
            connectTool.addEventListener('click', () => setActiveTool('connect'));
            selectTool.addEventListener('click', () => setActiveTool('select'));
            zoomIn.addEventListener('click', () => zoomCanvas(0.1));
            zoomOut.addEventListener('click', () => zoomCanvas(-0.1));

            // Property change listeners
            propX.addEventListener('change', updateElementProperty);
            propY.addEventListener('change', updateElementProperty);
            propWidth.addEventListener('change', updateElementProperty);
            propHeight.addEventListener('change', updateElementProperty);
            propBgColor.addEventListener('input', updateElementProperty);
            propBorderColor.addEventListener('input', updateElementProperty);
            propBorderWidth.addEventListener('input', updateElementProperty);
            propBorderRadius.addEventListener('input', updateElementProperty);
            propShadowToggle.addEventListener('change', toggleShadow);
            propShadowX.addEventListener('input', updateElementProperty);
            propShadowY.addEventListener('input', updateElementProperty);
            propShadowBlur.addEventListener('input', updateElementProperty);
            propShadowColor.addEventListener('input', updateElementProperty);
            propText.addEventListener('input', updateElementProperty);
            propFontSize.addEventListener('change', updateElementProperty);
            propTextColor.addEventListener('input', updateElementProperty);

            // Range value displays
            propBorderWidth.addEventListener('input', () => {
                borderWidthValue.textContent = propBorderWidth.value + 'px';
            });
            
            propBorderRadius.addEventListener('input', () => {
                borderRadiusValue.textContent = propBorderRadius.value + 'px';
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyDown);

            // Prevent context menu on canvas
            canvas.addEventListener('contextmenu', e => e.preventDefault());
        }

        // Handle component drag start from sidebar
        function handleComponentDragStart(e) {
            const componentType = e.target.getAttribute('data-type');
            e.dataTransfer.setData('componentType', componentType);
            e.dataTransfer.effectAllowed = 'copy';
        }

        // Handle drag over canvas
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }

        // Handle drop on canvas
        function handleCanvasDrop(e) {
            e.preventDefault();
            
            const componentType = e.dataTransfer.getData('componentType');
            if (!componentType) return;
            
            // Calculate drop position relative to canvas
            const canvasRect = canvas.getBoundingClientRect();
            const x = e.clientX - canvasRect.left;
            const y = e.clientY - canvasRect.top;
            
            // Create new element
            createElement(componentType, x, y);
        }

        // Create a new element on the canvas
        function createElement(type, x, y, id = null) {
            // Get template for this component type
            const template = {...componentTemplates[type]};
            
            // Create unique ID if not provided
            const elementId = id || `element_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            // Apply snap to grid if enabled
            let snappedX = x;
            let snappedY = y;
            
            if (appState.snapToGrid) {
                snappedX = Math.round(x / appState.gridSize) * appState.gridSize;
                snappedY = Math.round(y / appState.gridSize) * appState.gridSize;
            }
            
            // Adjust position to center the element
            snappedX -= template.width / 2;
            snappedY -= template.height / 2;
            
            // Ensure position is within canvas bounds
            snappedX = Math.max(0, Math.min(snappedX, canvas.offsetWidth - template.width));
            snappedY = Math.max(0, Math.min(snappedY, canvas.offsetHeight - template.height));
            
            // Create element object
            const element = {
                id: elementId,
                type: type,
                x: snappedX,
                y: snappedY,
                width: template.width,
                height: template.height,
                bgColor: template.bgColor,
                borderColor: template.borderColor,
                borderWidth: template.borderWidth,
                borderRadius: template.borderRadius,
                text: template.text,
                fontSize: template.fontSize,
                textColor: template.textColor,
                hasShadow: template.hasShadow || false,
                shadowX: template.shadowX || 0,
                shadowY: template.shadowY || 0,
                shadowBlur: template.shadowBlur || 0,
                shadowColor: template.shadowColor || 'rgba(0,0,0,0)',
                zIndex: appState.elements.length,
                // Element-specific properties
                placeholder: template.placeholder,
                checked: template.checked,
                options: template.options ? [...template.options] : [],
                value: template.value,
                min: template.min,
                max: template.max
            };
            
            // Add to elements array
            appState.elements.push(element);
            
            // Create DOM element
            createElementDOM(element);
            
            // Select the new element
            selectElement(element);
            
            // Update status
            updateStatusBar();
            
            return element;
        }

        // Create DOM element for the canvas
        function createElementDOM(element) {
            // Create container
            const elementDiv = document.createElement('div');
            elementDiv.className = 'canvas-element';
            elementDiv.id = element.id;
            elementDiv.style.left = element.x + 'px';
            elementDiv.style.top = element.y + 'px';
            elementDiv.style.width = element.width + 'px';
            elementDiv.style.height = element.height + 'px';
            elementDiv.style.zIndex = element.zIndex;
            
            // Apply styles
            updateElementStyle(elementDiv, element);
            
            // Create inner content based on element type
            let innerHTML = '';
            
            switch(element.type) {
                case 'button':
                    innerHTML = `<button class="ui-button" style="width:100%;height:100%;border:none;background:none;color:${element.textColor};font-size:${element.fontSize}px">${element.text}</button>`;
                    break;
                case 'input':
                    innerHTML = `<input class="ui-input" type="text" placeholder="${element.placeholder || ''}" style="width:100%;height:100%;border:none;background:none;color:${element.textColor};font-size:${element.fontSize}px" value="${element.text}">`;
                    break;
                case 'textarea':
                    innerHTML = `<textarea class="ui-textarea" placeholder="${element.placeholder || ''}" style="width:100%;height:100%;border:none;background:none;color:${element.textColor};font-size:${element.fontSize}px">${element.text}</textarea>`;
                    break;
                case 'checkbox':
                    innerHTML = `
                        <div class="ui-checkbox" style="width:100%;height:100%;display:flex;align-items:center;padding:5px;color:${element.textColor};font-size:${element.fontSize}px">
                            <input type="checkbox" ${element.checked ? 'checked' : ''}>
                            <span>${element.text}</span>
                        </div>`;
                    break;
                case 'dropdown':
                    innerHTML = `
                        <select class="ui-dropdown" style="width:100%;height:100%;border:none;background:none;color:${element.textColor};font-size:${element.fontSize}px">
                            ${element.options.map(opt => `<option ${opt === element.text ? 'selected' : ''}>${opt}</option>`).join('')}
                        </select>`;
                    break;
                case 'slider':
                    innerHTML = `
                        <div style="width:100%;height:100%;display:flex;align-items:center;padding:0 10px">
                            <input type="range" class="ui-slider" min="${element.min || 0}" max="${element.max || 100}" value="${element.value || 50}" style="width:100%">
                        </div>`;
                    break;
                case 'stepper':
                    innerHTML = `
                        <div class="ui-stepper" style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:${element.textColor};font-size:${element.fontSize}px">
                            <button>-</button>
                            <div class="ui-stepper-value">${element.value || 1}</div>
                            <button>+</button>
                        </div>`;
                    break;
                case 'progress':
                    innerHTML = `
                        <div style="width:100%;height:100%;display:flex;align-items:center;padding:0 10px">
                            <div class="ui-progress">
                                <div class="ui-progress-bar" style="width:${element.value || 60}%"></div>
                            </div>
                        </div>`;
                    break;
                case 'rectangle':
                    innerHTML = `<div class="shape-rectangle" style="width:100%;height:100%"></div>`;
                    break;
                case 'circle':
                    innerHTML = `<div class="shape-circle" style="width:100%;height:100%"></div>`;
                    break;
                case 'triangle':
                    innerHTML = `<div class="shape-triangle" style="width:100%;height:100%"></div>`;
                    break;
                case 'line':
                    innerHTML = `<div class="shape-line" style="width:100%;height:100%"></div>`;
                    break;
                default:
                    innerHTML = `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:${element.textColor};font-size:${element.fontSize}px">${element.text}</div>`;
            }
            
            elementDiv.innerHTML = innerHTML;
            
            // Add resize handles
            if (element.type !== 'line' && element.type !== 'triangle') {
                const handles = ['nw', 'n', 'ne', 'w', 'e', 'sw', 's', 'se'];
                handles.forEach(handle => {
                    const handleDiv = document.createElement('div');
                    handleDiv.className = `resize-handle ${handle}`;
                    handleDiv.addEventListener('mousedown', (e) => startResize(element, handle, e));
                    elementDiv.appendChild(handleDiv);
                });
            } else if (element.type === 'line') {
                // Only add end handles for lines
                const startHandle = document.createElement('div');
                startHandle.className = 'resize-handle w';
                startHandle.addEventListener('mousedown', (e) => startResize(element, 'w', e));
                elementDiv.appendChild(startHandle);
                
                const endHandle = document.createElement('div');
                endHandle.className = 'resize-handle e';
                endHandle.addEventListener('mousedown', (e) => startResize(element, 'e', e));
                elementDiv.appendChild(endHandle);
            }
            
            // Add connection points
            if (element.type !== 'line') {
                const points = ['top', 'bottom', 'left', 'right', 'center'];
                points.forEach(point => {
                    const pointDiv = document.createElement('div');
                    pointDiv.className = `connection-point ${point}`;
                    pointDiv.addEventListener('mousedown', (e) => startConnection(element, point, e));
                    pointDiv.addEventListener('mouseup', (e) => endConnection(element, point, e));
                    elementDiv.appendChild(pointDiv);
                });
            }
            
            // Add click listener to select element
            elementDiv.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('resize-handle') || 
                    e.target.classList.contains('connection-point')) {
                    return;
                }
                
                if (appState.activeTool === 'select') {
                    selectElement(element);
                }
            });
            
            // Add to canvas
            canvas.appendChild(elementDiv);
            
            return elementDiv;
        }

        // Update element style based on properties
        function updateElementStyle(elementDiv, element) {
            // Basic styles
            elementDiv.style.backgroundColor = element.bgColor;
            elementDiv.style.borderColor = element.borderColor;
            elementDiv.style.borderWidth = element.borderWidth + 'px';
            elementDiv.style.borderStyle = 'solid';
            elementDiv.style.borderRadius = element.borderRadius + 'px';
            
            // Box shadow
            if (element.hasShadow) {
                elementDiv.style.boxShadow = 
                    `${element.shadowX}px ${element.shadowY}px ${element.shadowBlur}px ${element.shadowColor}`;
            } else {
                elementDiv.style.boxShadow = 'none';
            }
            
            // Update inner text color if applicable
            const textElement = elementDiv.querySelector('button, input, textarea, select, span, div');
            if (textElement && element.textColor) {
                if (textElement.tagName === 'INPUT' || textElement.tagName === 'TEXTAREA' || textElement.tagName === 'SELECT') {
                    textElement.style.color = element.textColor;
                } else if (textElement.tagName === 'BUTTON') {
                    textElement.style.color = element.textColor;
                } else if (textElement.tagName === 'SPAN' || textElement.tagName === 'DIV') {
                    textElement.style.color = element.textColor;
                }
            }
            
            // Update font size if applicable
            if (textElement && element.fontSize) {
                textElement.style.fontSize = element.fontSize + 'px';
            }
        }

        // Start resizing an element
        function startResize(element, direction, e) {
            e.stopPropagation();
            e.preventDefault();
            
            appState.isResizing = true;
            appState.resizeDirection = direction;
            appState.selectedElement = element;
            
            // Store original dimensions and position
            appState.originalX = element.x;
            appState.originalY = element.y;
            appState.originalWidth = element.width;
            appState.originalHeight = element.height;
            
            // Store mouse start position
            appState.dragStartX = e.clientX;
            appState.dragStartY = e.clientY;
            
            // Update properties panel
            updatePropertiesPanel();
            
            document.addEventListener('mousemove', handleResizeMove);
            document.addEventListener('mouseup', stopResize);
        }

        // Handle resize mouse movement
        function handleResizeMove(e) {
            if (!appState.isResizing || !appState.selectedElement) return;
            
            const element = appState.selectedElement;
            const deltaX = e.clientX - appState.dragStartX;
            const deltaY = e.clientY - appState.dragStartY;
            
            let newX = element.x;
            let newY = element.y;
            let newWidth = element.width;
            let newHeight = element.height;
            
            // Calculate new dimensions based on resize direction
            switch(appState.resizeDirection) {
                case 'nw':
                    newX = appState.originalX + deltaX;
                    newY = appState.originalY + deltaY;
                    newWidth = appState.originalWidth - deltaX;
                    newHeight = appState.originalHeight - deltaY;
                    break;
                case 'n':
                    newY = appState.originalY + deltaY;
                    newHeight = appState.originalHeight - deltaY;
                    break;
                case 'ne':
                    newY = appState.originalY + deltaY;
                    newWidth = appState.originalWidth + deltaX;
                    newHeight = appState.originalHeight - deltaY;
                    break;
                case 'w':
                    newX = appState.originalX + deltaX;
                    newWidth = appState.originalWidth - deltaX;
                    break;
                case 'e':
                    newWidth = appState.originalWidth + deltaX;
                    break;
                case 'sw':
                    newX = appState.originalX + deltaX;
                    newWidth = appState.originalWidth - deltaX;
                    newHeight = appState.originalHeight + deltaY;
                    break;
                case 's':
                    newHeight = appState.originalHeight + deltaY;
                    break;
                case 'se':
                    newWidth = appState.originalWidth + deltaX;
                    newHeight = appState.originalHeight + deltaY;
                    break;
            }
            
            // Apply constraints
            newWidth = Math.max(20, newWidth);
            newHeight = Math.max(20, newHeight);
            
            // Ensure element stays within canvas bounds
            if (newX < 0) {
                newWidth += newX;
                newX = 0;
            }
            
            if (newY < 0) {
                newHeight += newY;
                newY = 0;
            }
            
            if (newX + newWidth > canvas.offsetWidth) {
                newWidth = canvas.offsetWidth - newX;
            }
            
            if (newY + newHeight > canvas.offsetHeight) {
                newHeight = canvas.offsetHeight - newY;
            }
            
            // Apply snap to grid if enabled
            if (appState.snapToGrid) {
                newX = Math.round(newX / appState.gridSize) * appState.gridSize;
                newY = Math.round(newY / appState.gridSize) * appState.gridSize;
                newWidth = Math.round(newWidth / appState.gridSize) * appState.gridSize;
                newHeight = Math.round(newHeight / appState.gridSize) * appState.gridSize;
                
                // Ensure minimum size
                newWidth = Math.max(appState.gridSize, newWidth);
                newHeight = Math.max(appState.gridSize, newHeight);
            }
            
            // Update element
            element.x = newX;
            element.y = newY;
            element.width = newWidth;
            element.height = newHeight;
            
            // Special handling for circles to maintain aspect ratio
            if (element.type === 'circle') {
                const size = Math.min(newWidth, newHeight);
                element.width = size;
                element.height = size;
            }
            
            // Update DOM
            const elementDiv = document.getElementById(element.id);
            elementDiv.style.left = element.x + 'px';
            elementDiv.style.top = element.y + 'px';
            elementDiv.style.width = element.width + 'px';
            elementDiv.style.height = element.height + 'px';
            
            // Update connections to this element
            updateConnectionsForElement(element);
            
            // Update properties panel
            updatePropertiesPanel();
        }

        // Stop resizing
        function stopResize() {
            appState.isResizing = false;
            document.removeEventListener('mousemove', handleResizeMove);
            document.removeEventListener('mouseup', stopResize);
        }

        // Start a connection from an element
        function startConnection(element, point, e) {
            e.stopPropagation();
            
            if (appState.activeTool !== 'connect') return;
            
            appState.isConnecting = true;
            appState.connectionStart = {
                element: element,
                point: point,
                x: e.clientX,
                y: e.clientY
            };
            
            // Create temporary connection line
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            line.id = 'temp-connection';
            line.style.position = 'absolute';
            line.style.top = '0';
            line.style.left = '0';
            line.style.width = '100%';
            line.style.height = '100%';
            line.style.pointerEvents = 'none';
            line.style.zIndex = '1';
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('stroke', '#00b894');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke-dasharray', '5,5');
            line.appendChild(path);
            
            canvas.appendChild(line);
            
            document.addEventListener('mousemove', handleConnectionMove);
            document.addEventListener('mouseup', stopConnection);
        }

        // Handle connection mouse movement
        function handleConnectionMove(e) {
            if (!appState.isConnecting || !appState.connectionStart) return;
            
            const startPoint = getConnectionPoint(
                appState.connectionStart.element, 
                appState.connectionStart.point
            );
            
            const canvasRect = canvas.getBoundingClientRect();
            const endX = e.clientX - canvasRect.left;
            const endY = e.clientY - canvasRect.top;
            
            // Update temporary connection line
            const line = document.getElementById('temp-connection');
            const path = line.querySelector('path');
            
            // Create a curved path
            const midX = (startPoint.x + endX) / 2;
            const d = `M ${startPoint.x} ${startPoint.y} C ${midX} ${startPoint.y}, ${midX} ${endY}, ${endX} ${endY}`;
            path.setAttribute('d', d);
        }

        // End a connection
        function endConnection(element, point, e) {
            if (!appState.isConnecting || !appState.connectionStart) return;
            
            e.stopPropagation();
            
            // Remove temporary connection line
            const tempLine = document.getElementById('temp-connection');
            if (tempLine) tempLine.remove();
            
            // Check if we're connecting to a different element
            if (appState.connectionStart.element.id !== element.id) {
                // Create a permanent connection
                createConnection(
                    appState.connectionStart.element,
                    appState.connectionStart.point,
                    element,
                    point
                );
            }
            
            // Clean up
            appState.isConnecting = false;
            appState.connectionStart = null;
            
            document.removeEventListener('mousemove', handleConnectionMove);
            document.removeEventListener('mouseup', stopConnection);
        }

        // Create a connection between two elements
        function createConnection(fromElement, fromPoint, toElement, toPoint) {
            const connectionId = `connection_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            const connection = {
                id: connectionId,
                from: fromElement.id,
                fromPoint: fromPoint,
                to: toElement.id,
                toPoint: toPoint
            };
            
            appState.connections.push(connection);
            
            // Create connection line
            createConnectionDOM(connection);
            
            // Update status
            updateStatusBar();
            
            return connection;
        }

        // Create DOM for a connection
        function createConnectionDOM(connection) {
            // Find elements
            const fromElement = appState.elements.find(el => el.id === connection.from);
            const toElement = appState.elements.find(el => el.id === connection.to);
            
            if (!fromElement || !toElement) return;
            
            // Get connection points
            const startPoint = getConnectionPoint(fromElement, connection.fromPoint);
            const endPoint = getConnectionPoint(toElement, connection.toPoint);
            
            // Create SVG line
            const svgNS = "http://www.w3.org/2000/svg";
            const line = document.createElementNS(svgNS, "svg");
            line.id = connection.id;
            line.className = 'connection-line';
            line.style.position = 'absolute';
            line.style.top = '0';
            line.style.left = '0';
            line.style.width = '100%';
            line.style.height = '100%';
            line.style.pointerEvents = 'none';
            line.style.zIndex = '1';
            
            // Create path
            const path = document.createElementNS(svgNS, "path");
            path.setAttribute('stroke', '#00b894');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            
            // Create curved path
            const midX = (startPoint.x + endPoint.x) / 2;
            const d = `M ${startPoint.x} ${startPoint.y} C ${midX} ${startPoint.y}, ${midX} ${endPoint.y}, ${endPoint.x} ${endPoint.y}`;
            path.setAttribute('d', d);
            
            // Create control point (draggable)
            const controlCircle = document.createElementNS(svgNS, "circle");
            controlCircle.setAttribute('cx', midX);
            controlCircle.setAttribute('cy', (startPoint.y + endPoint.y) / 2);
            controlCircle.setAttribute('r', '6');
            controlCircle.setAttribute('fill', '#00b894');
            controlCircle.setAttribute('class', 'connection-handle');
            controlCircle.style.pointerEvents = 'all';
            
            // Add event listeners for selecting connection
            path.addEventListener('click', () => selectConnection(connection));
            controlCircle.addEventListener('click', (e) => {
                e.stopPropagation();
                selectConnection(connection);
            });
            
            // Add drag functionality for control point
            let isDraggingControl = false;
            let dragStartX, dragStartY;
            
            controlCircle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                isDraggingControl = true;
                const canvasRect = canvas.getBoundingClientRect();
                dragStartX = e.clientX - canvasRect.left;
                dragStartY = e.clientY - canvasRect.top;
                
                document.addEventListener('mousemove', dragControl);
                document.addEventListener('mouseup', () => {
                    isDraggingControl = false;
                    document.removeEventListener('mousemove', dragControl);
                });
            });
            
            function dragControl(e) {
                if (!isDraggingControl) return;
                
                const canvasRect = canvas.getBoundingClientRect();
                const x = e.clientX - canvasRect.left;
                const y = e.clientY - canvasRect.top;
                
                // Update path with new control point
                const d = `M ${startPoint.x} ${startPoint.y} C ${x} ${y}, ${x} ${y}, ${endPoint.x} ${endPoint.y}`;
                path.setAttribute('d', d);
                
                // Update control circle position
                controlCircle.setAttribute('cx', x);
                controlCircle.setAttribute('cy', y);
            }
            
            line.appendChild(path);
            line.appendChild(controlCircle);
            
            canvas.appendChild(line);
            
            return line;
        }

        // Get connection point coordinates for an element
        function getConnectionPoint(element, point) {
            const elementDiv = document.getElementById(element.id);
            if (!elementDiv) return { x: 0, y: 0 };
            
            const rect = elementDiv.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            
            let x, y;
            
            switch(point) {
                case 'top':
                    x = rect.left - canvasRect.left + rect.width / 2;
                    y = rect.top - canvasRect.top;
                    break;
                case 'bottom':
                    x = rect.left - canvasRect.left + rect.width / 2;
                    y = rect.top - canvasRect.top + rect.height;
                    break;
                case 'left':
                    x = rect.left - canvasRect.left;
                    y = rect.top - canvasRect.top + rect.height / 2;
                    break;
                case 'right':
                    x = rect.left - canvasRect.left + rect.width;
                    y = rect.top - canvasRect.top + rect.height / 2;
                    break;
                case 'center':
                    x = rect.left - canvasRect.left + rect.width / 2;
                    y = rect.top - canvasRect.top + rect.height / 2;
                    break;
                default:
                    x = rect.left - canvasRect.left + rect.width / 2;
                    y = rect.top - canvasRect.top + rect.height / 2;
            }
            
            return { x, y };
        }

        // Update connections for an element (when it moves or resizes)
        function updateConnectionsForElement(element) {
            // Find all connections involving this element
            const connections = appState.connections.filter(
                conn => conn.from === element.id || conn.to === element.id
            );
            
            // Update each connection
            connections.forEach(connection => {
                const fromElement = appState.elements.find(el => el.id === connection.from);
                const toElement = appState.elements.find(el => el.id === connection.to);
                
                if (!fromElement || !toElement) return;
                
                // Get connection points
                const startPoint = getConnectionPoint(fromElement, connection.fromPoint);
                const endPoint = getConnectionPoint(toElement, connection.toPoint);
                
                // Find and update the connection line
                const line = document.getElementById(connection.id);
                if (!line) return;
                
                const path = line.querySelector('path');
                const controlCircle = line.querySelector('circle');
                
                if (path && controlCircle) {
                    // Get current control point position
                    const cx = parseFloat(controlCircle.getAttribute('cx'));
                    const cy = parseFloat(controlCircle.getAttribute('cy'));
                    
                    // Update path
                    const d = `M ${startPoint.x} ${startPoint.y} C ${cx} ${cy}, ${cx} ${cy}, ${endPoint.x} ${endPoint.y}`;
                    path.setAttribute('d', d);
                }
            });
        }

        // Select an element
        function selectElement(element) {
            // Deselect previously selected element
            if (appState.selectedElement) {
                const prevElement = document.getElementById(appState.selectedElement.id);
                if (prevElement) prevElement.classList.remove('selected');
            }
            
            // Deselect connection
            if (appState.selectedConnection) {
                const prevConnection = document.getElementById(appState.selectedConnection.id);
                if (prevConnection) prevConnection.classList.remove('selected');
                appState.selectedConnection = null;
            }
            
            // Select new element
            appState.selectedElement = element;
            const elementDiv = document.getElementById(element.id);
            if (elementDiv) elementDiv.classList.add('selected');
            
            // Update properties panel
            updatePropertiesPanel();
            
            // Bring element to front
            bringToFront(element);
        }

        // Select a connection
        function selectConnection(connection) {
            // Deselect previously selected element
            if (appState.selectedElement) {
                const prevElement = document.getElementById(appState.selectedElement.id);
                if (prevElement) prevElement.classList.remove('selected');
                appState.selectedElement = null;
            }
            
            // Deselect previously selected connection
            if (appState.selectedConnection) {
                const prevConnection = document.getElementById(appState.selectedConnection.id);
                if (prevConnection) prevConnection.classList.remove('selected');
            }
            
            // Select new connection
            appState.selectedConnection = connection;
            const connectionDiv = document.getElementById(connection.id);
            if (connectionDiv) connectionDiv.classList.add('selected');
            
            // Update properties panel for connection
            updatePropertiesPanel();
        }

        // Bring element to front
        function bringToFront(element) {
            // Update z-index for all elements
            appState.elements.forEach(el => {
                if (el.id === element.id) {
                    el.zIndex = appState.elements.length;
                } else if (el.zIndex > element.zIndex) {
                    el.zIndex--;
                }
            });
            
            // Sort elements by z-index
            appState.elements.sort((a, b) => a.zIndex - b.zIndex);
            
            // Update DOM
            appState.elements.forEach((el, index) => {
                const elDiv = document.getElementById(el.id);
                if (elDiv) {
                    elDiv.style.zIndex = index;
                }
            });
        }

        // Update properties panel with selected element's properties
        function updatePropertiesPanel() {
            if (appState.selectedElement) {
                const element = appState.selectedElement;
                
                // Position & Size
                propX.value = Math.round(element.x);
                propY.value = Math.round(element.y);
                propWidth.value = Math.round(element.width);
                propHeight.value = Math.round(element.height);
                
                // Style
                propBgColor.value = element.bgColor;
                propBorderColor.value = element.borderColor;
                propBorderWidth.value = element.borderWidth;
                propBorderRadius.value = element.borderRadius;
                borderWidthValue.textContent = element.borderWidth + 'px';
                borderRadiusValue.textContent = element.borderRadius + 'px';
                
                // Shadow
                propShadowToggle.checked = element.hasShadow;
                propShadowX.value = element.shadowX;
                propShadowY.value = element.shadowY;
                propShadowBlur.value = element.shadowBlur;
                propShadowColor.value = element.shadowColor;
                
                // Enable/disable shadow controls
                propShadowX.disabled = !element.hasShadow;
                propShadowY.disabled = !element.hasShadow;
                propShadowBlur.disabled = !element.hasShadow;
                propShadowColor.disabled = !element.hasShadow;
                
                // Text
                propText.value = element.text;
                propFontSize.value = element.fontSize;
                propTextColor.value = element.textColor;
                
                // Update element-specific properties
                updateElementSpecificProperties(element);
                
            } else if (appState.selectedConnection) {
                // Show connection properties
                updateConnectionProperties();
            } else {
                // Clear properties panel
                clearPropertiesPanel();
            }
        }

        // Update element-specific properties
        function updateElementSpecificProperties(element) {
            const container = document.getElementById('element-specific-group');
            container.innerHTML = `<div class="property-title">${element.type.charAt(0).toUpperCase() + element.type.slice(1)} Settings</div>`;
            
            switch(element.type) {
                case 'button':
                    container.innerHTML += `
                        <div class="property-row">
                            <label class="property-label">Button Text:</label>
                            <input type="text" class="property-input" id="prop-button-text" value="${element.text}">
                        </div>
                    `;
                    document.getElementById('prop-button-text').addEventListener('input', (e) => {
                        element.text = e.target.value;
                        updateElementText(element);
                    });
                    break;
                    
                case 'checkbox':
                    container.innerHTML += `
                        <div class="property-row">
                            <label class="property-label">Checked:</label>
                            <input type="checkbox" id="prop-checkbox-checked" ${element.checked ? 'checked' : ''}>
                        </div>
                        <div class="property-row">
                            <label class="property-label">Label:</label>
                            <input type="text" class="property-input" id="prop-checkbox-label" value="${element.text}">
                        </div>
                    `;
                    document.getElementById('prop-checkbox-checked').addEventListener('change', (e) => {
                        element.checked = e.target.checked;
                        updateElementContent(element);
                    });
                    document.getElementById('prop-checkbox-label').addEventListener('input', (e) => {
                        element.text = e.target.value;
                        updateElementText(element);
                    });
                    break;
                    
                case 'dropdown':
                    container.innerHTML += `
                        <div class="property-row">
                            <label class="property-label">Options:</label>
                            <textarea class="property-input" id="prop-dropdown-options" style="height:80px">${element.options.join('\n')}</textarea>
                        </div>
                    `;
                    document.getElementById('prop-dropdown-options').addEventListener('input', (e) => {
                        element.options = e.target.value.split('\n').filter(opt => opt.trim() !== '');
                        updateElementContent(element);
                    });
                    break;
                    
                case 'slider':
                    container.innerHTML += `
                        <div class="property-row">
                            <label class="property-label">Value:</label>
                            <input type="range" class="property-input" id="prop-slider-value" min="${element.min || 0}" max="${element.max || 100}" value="${element.value || 50}">
                        </div>
                        <div class="property-row">
                            <label class="property-label">Min:</label>
                            <input type="number" class="property-input" id="prop-slider-min" value="${element.min || 0}">
                        </div>
                        <div class="property-row">
                            <label class="property-label">Max:</label>
                            <input type="number" class="property-input" id="prop-slider-max" value="${element.max || 100}">
                        </div>
                    `;
                    document.getElementById('prop-slider-value').addEventListener('input', (e) => {
                        element.value = parseInt(e.target.value);
                        updateElementContent(element);
                    });
                    document.getElementById('prop-slider-min').addEventListener('change', (e) => {
                        element.min = parseInt(e.target.value);
                        updateElementContent(element);
                    });
                    document.getElementById('prop-slider-max').addEventListener('change', (e) => {
                        element.max = parseInt(e.target.value);
                        updateElementContent(element);
                    });
                    break;
                    
                case 'stepper':
                    container.innerHTML += `
                        <div class="property-row">
                            <label class="property-label">Value:</label>
                            <input type="number" class="property-input" id="prop-stepper-value" value="${element.value || 1}">
                        </div>
                        <div class="property-row">
                            <label class="property-label">Min:</label>
                            <input type="number" class="property-input" id="prop-stepper-min" value="${element.min || 0}">
                        </div>
                        <div class="property-row">
                            <label class="property-label">Max:</label>
                            <input type="number" class="property-input" id="prop-stepper-max" value="${element.max || 10}">
                        </div>
                    `;
                    document.getElementById('prop-stepper-value').addEventListener('change', (e) => {
                        element.value = parseInt(e.target.value);
                        updateElementContent(element);
                    });
                    document.getElementById('prop-stepper-min').addEventListener('change', (e) => {
                        element.min = parseInt(e.target.value);
                    });
                    document.getElementById('prop-stepper-max').addEventListener('change', (e) => {
                        element.max = parseInt(e.target.value);
                    });
                    break;
                    
                case 'progress':
                    container.innerHTML += `
                        <div class="property-row">
                            <label class="property-label">Value:</label>
                            <input type="range" class="property-input" id="prop-progress-value" min="0" max="${element.max || 100}" value="${element.value || 60}">
                        </div>
                        <div class="property-row">
                            <label class="property-label">Max:</label>
                            <input type="number" class="property-input" id="prop-progress-max" value="${element.max || 100}">
                        </div>
                    `;
                    document.getElementById('prop-progress-value').addEventListener('input', (e) => {
                        element.value = parseInt(e.target.value);
                        updateElementContent(element);
                    });
                    document.getElementById('prop-progress-max').addEventListener('change', (e) => {
                        element.max = parseInt(e.target.value);
                        updateElementContent(element);
                    });
                    break;
                    
                case 'input':
                case 'textarea':
                    container.innerHTML += `
                        <div class="property-row">
                            <label class="property-label">Placeholder:</label>
                            <input type="text" class="property-input" id="prop-input-placeholder" value="${element.placeholder || ''}">
                        </div>
                    `;
                    document.getElementById('prop-input-placeholder').addEventListener('input', (e) => {
                        element.placeholder = e.target.value;
                        updateElementContent(element);
                    });
                    break;
            }
        }

        // Update connection properties
        function updateConnectionProperties() {
            const container = document.getElementById('element-specific-group');
            container.innerHTML = `<div class="property-title">Connection Settings</div>`;
            
            // Hide other property groups
            document.getElementById('position-group').style.display = 'none';
            document.getElementById('style-group').style.display = 'none';
            document.getElementById('shadow-group').style.display = 'none';
            document.getElementById('text-group').style.display = 'none';
        }

        // Clear properties panel
        function clearPropertiesPanel() {
            // Clear all inputs
            propX.value = '';
            propY.value = '';
            propWidth.value = '';
            propHeight.value = '';
            
            // Show all property groups
            document.getElementById('position-group').style.display = 'block';
            document.getElementById('style-group').style.display = 'block';
            document.getElementById('shadow-group').style.display = 'block';
            document.getElementById('text-group').style.display = 'block';
            
            // Clear element-specific properties
            document.getElementById('element-specific-group').innerHTML = '';
        }

        // Update element property from properties panel
        function updateElementProperty() {
            if (!appState.selectedElement) return;
            
            const element = appState.selectedElement;
            const elementDiv = document.getElementById(element.id);
            
            // Update properties based on which input changed
            if (this === propX) element.x = parseInt(this.value);
            if (this === propY) element.y = parseInt(this.value);
            if (this === propWidth) element.width = parseInt(this.value);
            if (this === propHeight) element.height = parseInt(this.value);
            if (this === propBgColor) element.bgColor = this.value;
            if (this === propBorderColor) element.borderColor = this.value;
            if (this === propBorderWidth) element.borderWidth = parseInt(this.value);
            if (this === propBorderRadius) element.borderRadius = parseInt(this.value);
            if (this === propShadowX) element.shadowX = parseInt(this.value);
            if (this === propShadowY) element.shadowY = parseInt(this.value);
            if (this === propShadowBlur) element.shadowBlur = parseInt(this.value);
            if (this === propShadowColor) element.shadowColor = this.value;
            if (this === propText) element.text = this.value;
            if (this === propFontSize) element.fontSize = parseInt(this.value);
            if (this === propTextColor) element.textColor = this.value;
            
            // Update DOM
            if (elementDiv) {
                elementDiv.style.left = element.x + 'px';
                elementDiv.style.top = element.y + 'px';
                elementDiv.style.width = element.width + 'px';
                elementDiv.style.height = element.height + 'px';
                
                updateElementStyle(elementDiv, element);
                
                // Update text content if needed
                if (this === propText || this === propFontSize || this === propTextColor) {
                    updateElementText(element);
                }
                
                // Update connections
                updateConnectionsForElement(element);
            }
        }

        // Update element text content
        function updateElementText(element) {
            const elementDiv = document.getElementById(element.id);
            if (!elementDiv) return;
            
            switch(element.type) {
                case 'button':
                    const button = elementDiv.querySelector('button');
                    if (button) button.textContent = element.text;
                    break;
                case 'checkbox':
                    const span = elementDiv.querySelector('span');
                    if (span) span.textContent = element.text;
                    break;
                case 'input':
                    const input = elementDiv.querySelector('input');
                    if (input) input.value = element.text;
                    break;
                case 'textarea':
                    const textarea = elementDiv.querySelector('textarea');
                    if (textarea) textarea.value = element.text;
                    break;
                case 'dropdown':
                    const select = elementDiv.querySelector('select');
                    if (select) {
                        // Update selected option
                        Array.from(select.options).forEach(option => {
                            option.selected = option.text === element.text;
                        });
                    }
                    break;
                case 'stepper':
                    const stepperValue = elementDiv.querySelector('.ui-stepper-value');
                    if (stepperValue) stepperValue.textContent = element.value || 1;
                    break;
                default:
                    const div = elementDiv.querySelector('div:not(.resize-handle):not(.connection-point)');
                    if (div && !div.classList.contains('ui-progress') && !div.classList.contains('ui-checkbox')) {
                        div.textContent = element.text;
                    }
            }
        }

        // Update element content (for special elements)
        function updateElementContent(element) {
            const elementDiv = document.getElementById(element.id);
            if (!elementDiv) return;
            
            // Recreate inner content based on element type
            let innerHTML = '';
            
            switch(element.type) {
                case 'checkbox':
                    innerHTML = `
                        <div class="ui-checkbox" style="width:100%;height:100%;display:flex;align-items:center;padding:5px;color:${element.textColor};font-size:${element.fontSize}px">
                            <input type="checkbox" ${element.checked ? 'checked' : ''}>
                            <span>${element.text}</span>
                        </div>`;
                    break;
                case 'dropdown':
                    innerHTML = `
                        <select class="ui-dropdown" style="width:100%;height:100%;border:none;background:none;color:${element.textColor};font-size:${element.fontSize}px">
                            ${element.options.map(opt => `<option ${opt === element.text ? 'selected' : ''}>${opt}</option>`).join('')}
                        </select>`;
                    break;
                case 'slider':
                    innerHTML = `
                        <div style="width:100%;height:100%;display:flex;align-items:center;padding:0 10px">
                            <input type="range" class="ui-slider" min="${element.min || 0}" max="${element.max || 100}" value="${element.value || 50}" style="width:100%">
                        </div>`;
                    break;
                case 'stepper':
                    innerHTML = `
                        <div class="ui-stepper" style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:${element.textColor};font-size:${element.fontSize}px">
                            <button>-</button>
                            <div class="ui-stepper-value">${element.value || 1}</div>
                            <button>+</button>
                        </div>`;
                    break;
                case 'progress':
                    innerHTML = `
                        <div style="width:100%;height:100%;display:flex;align-items:center;padding:0 10px">
                            <div class="ui-progress">
                                <div class="ui-progress-bar" style="width:${element.value || 60}%"></div>
                            </div>
                        </div>`;
                    break;
                case 'input':
                    innerHTML = `<input class="ui-input" type="text" placeholder="${element.placeholder || ''}" style="width:100%;height:100%;border:none;background:none;color:${element.textColor};font-size:${element.fontSize}px" value="${element.text}">`;
                    break;
                case 'textarea':
                    innerHTML = `<textarea class="ui-textarea" placeholder="${element.placeholder || ''}" style="width:100%;height:100%;border:none;background:none;color:${element.textColor};font-size:${element.fontSize}px">${element.text}</textarea>`;
                    break;
            }
            
            if (innerHTML) {
                // Find the first child that's not a resize handle or connection point
                const oldContent = Array.from(elementDiv.children).find(child => 
                    !child.classList.contains('resize-handle') && 
                    !child.classList.contains('connection-point')
                );
                
                if (oldContent) {
                    elementDiv.replaceChild(
                        document.createRange().createContextualFragment(innerHTML),
                        oldContent
                    );
                }
            }
        }

        // Toggle shadow controls
        function toggleShadow() {
            const enabled = propShadowToggle.checked;
            
            propShadowX.disabled = !enabled;
            propShadowY.disabled = !enabled;
            propShadowBlur.disabled = !enabled;
            propShadowColor.disabled = !enabled;
            
            if (appState.selectedElement) {
                appState.selectedElement.hasShadow = enabled;
                const elementDiv = document.getElementById(appState.selectedElement.id);
                if (elementDiv) updateElementStyle(elementDiv, appState.selectedElement);
            }
        }

        // Canvas mouse handlers
        function handleCanvasMouseDown(e) {
            if (e.target !== canvas && 
                !e.target.classList.contains('canvas-element') &&
                !e.target.classList.contains('resize-handle') &&
                !e.target.classList.contains('connection-point')) {
                return;
            }
            
            // If clicking on canvas background, deselect everything
            if (e.target === canvas) {
                if (appState.selectedElement) {
                    const elementDiv = document.getElementById(appState.selectedElement.id);
                    if (elementDiv) elementDiv.classList.remove('selected');
                    appState.selectedElement = null;
                }
                
                if (appState.selectedConnection) {
                    const connectionDiv = document.getElementById(appState.selectedConnection.id);
                    if (connectionDiv) connectionDiv.classList.remove('selected');
                    appState.selectedConnection = null;
                }
                
                updatePropertiesPanel();
                return;
            }
            
            // If clicking on a canvas element (not handles), start dragging
            if (e.target.classList.contains('canvas-element') && 
                appState.activeTool === 'select') {
                appState.isDragging = true;
                appState.dragStartX = e.clientX;
                appState.dragStartY = e.clientY;
                
                // Store original position
                if (appState.selectedElement) {
                    appState.originalX = appState.selectedElement.x;
                    appState.originalY = appState.selectedElement.y;
                }
                
                document.addEventListener('mousemove', handleCanvasDrag);
                document.addEventListener('mouseup', stopDragging);
            }
        }

        function handleCanvasDrag(e) {
            if (!appState.isDragging || !appState.selectedElement) return;
            
            const element = appState.selectedElement;
            const deltaX = e.clientX - appState.dragStartX;
            const deltaY = e.clientY - appState.dragStartY;
            
            let newX = appState.originalX + deltaX;
            let newY = appState.originalY + deltaY;
            
            // Apply snap to grid if enabled
            if (appState.snapToGrid) {
                newX = Math.round(newX / appState.gridSize) * appState.gridSize;
                newY = Math.round(newY / appState.gridSize) * appState.gridSize;
            }
            
            // Ensure element stays within canvas bounds
            newX = Math.max(0, Math.min(newX, canvas.offsetWidth - element.width));
            newY = Math.max(0, Math.min(newY, canvas.offsetHeight - element.height));
            
            // Update element
            element.x = newX;
            element.y = newY;
            
            // Update DOM
            const elementDiv = document.getElementById(element.id);
            elementDiv.style.left = newX + 'px';
            elementDiv.style.top = newY + 'px';
            
            // Update connections
            updateConnectionsForElement(element);
            
            // Update properties panel
            updatePropertiesPanel();
            
            // Show alignment guides
            if (appState.showGuides) {
                showAlignmentGuides(element);
            }
        }

        function stopDragging() {
            appState.isDragging = false;
            document.removeEventListener('mousemove', handleCanvasDrag);
            document.removeEventListener('mouseup', stopDragging);
            
            // Hide alignment guides
            hideAlignmentGuides();
        }

        function handleCanvasMouseMove(e) {
            // Update cursor position
            updateCursorPosition(e);
            
            // If dragging, continue
            if (appState.isDragging || appState.isResizing || appState.isConnecting) {
                return;
            }
        }

        function handleCanvasMouseUp(e) {
            // Handle mouse up events
        }

        function handleCanvasClick(e) {
            // Handle canvas clicks
        }

        // Show alignment guides
        function showAlignmentGuides(element) {
            // Clear existing guides
            hideAlignmentGuides();
            
            const guidesContainer = document.getElementById('guides-container');
            if (!guidesContainer) return;
            
            // Get element position and size
            const elementRect = {
                left: element.x,
                top: element.y,
                right: element.x + element.width,
                bottom: element.y + element.height,
                centerX: element.x + element.width / 2,
                centerY: element.y + element.height / 2
            };
            
            // Check alignment with other elements
            appState.elements.forEach(otherElement => {
                if (otherElement.id === element.id) return;
                
                const otherRect = {
                    left: otherElement.x,
                    top: otherElement.y,
                    right: otherElement.x + otherElement.width,
                    bottom: otherElement.y + otherElement.height,
                    centerX: otherElement.x + otherElement.width / 2,
                    centerY: otherElement.y + otherElement.height / 2
                };
                
                // Check for alignment within 5 pixels
                const threshold = 5;
                
                // Left edges align
                if (Math.abs(elementRect.left - otherRect.left) < threshold) {
                    createGuide('vertical', elementRect.left);
                }
                
                // Right edges align
                if (Math.abs(elementRect.right - otherRect.right) < threshold) {
                    createGuide('vertical', elementRect.right);
                }
                
                // Top edges align
                if (Math.abs(elementRect.top - otherRect.top) < threshold) {
                    createGuide('horizontal', elementRect.top);
                }
                
                // Bottom edges align
                if (Math.abs(elementRect.bottom - otherRect.bottom) < threshold) {
                    createGuide('horizontal', elementRect.bottom);
                }
                
                // Centers align horizontally
                if (Math.abs(elementRect.centerX - otherRect.centerX) < threshold) {
                    createGuide('vertical', elementRect.centerX);
                }
                
                // Centers align vertically
                if (Math.abs(elementRect.centerY - otherRect.centerY) < threshold) {
                    createGuide('horizontal', elementRect.centerY);
                }
                
                // Element left aligns with other right
                if (Math.abs(elementRect.left - otherRect.right) < threshold) {
                    createGuide('vertical', elementRect.left);
                }
                
                // Element right aligns with other left
                if (Math.abs(elementRect.right - otherRect.left) < threshold) {
                    createGuide('vertical', elementRect.right);
                }
                
                // Element top aligns with other bottom
                if (Math.abs(elementRect.top - otherRect.bottom) < threshold) {
                    createGuide('horizontal', elementRect.top);
                }
                
                // Element bottom aligns with other top
                if (Math.abs(elementRect.bottom - otherRect.top) < threshold) {
                    createGuide('horizontal', elementRect.bottom);
                }
            });
            
            // Check alignment with canvas center
            const canvasCenterX = canvas.offsetWidth / 2;
            const canvasCenterY = canvas.offsetHeight / 2;
            
            if (Math.abs(elementRect.centerX - canvasCenterX) < threshold) {
                createGuide('vertical', canvasCenterX);
            }
            
            if (Math.abs(elementRect.centerY - canvasCenterY) < threshold) {
                createGuide('horizontal', canvasCenterY);
            }
            
            function createGuide(type, position) {
                const guide = document.createElement('div');
                guide.className = `guide ${type}`;
                
                if (type === 'vertical') {
                    guide.style.left = position + 'px';
                    guide.style.top = '0';
                    guide.style.height = '100%';
                } else {
                    guide.style.top = position + 'px';
                    guide.style.left = '0';
                    guide.style.width = '100%';
                }
                
                guidesContainer.appendChild(guide);
            }
        }

        // Hide alignment guides
        function hideAlignmentGuides() {
            const guidesContainer = document.getElementById('guides-container');
            if (guidesContainer) {
                guidesContainer.innerHTML = '';
            }
        }

        // Update cursor position display
        function updateCursorPosition(e) {
            const canvasRect = canvas.getBoundingClientRect();
            const x = Math.round(e.clientX - canvasRect.left);
            const y = Math.round(e.clientY - canvasRect.top);
            
            cursorPosition.textContent = `X: ${x}, Y: ${y}`;
        }

        // Update status bar
        function updateStatusBar() {
            elementCount.textContent = `${appState.elements.length} elements`;
            connectionCount.textContent = `${appState.connections.length} connections`;
        }

        // Set active tool
        function setActiveTool(tool) {
            appState.activeTool = tool;
            
            // Update UI
            document.querySelectorAll('.component-item').forEach(item => {
                item.style.borderColor = '';
            });
            
            if (tool === 'connect') {
                connectTool.style.borderColor = 'var(--primary-color)';
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'select') {
                selectTool.style.borderColor = 'var(--primary-color)';
                canvas.style.cursor = 'default';
            }
        }

        // Zoom canvas
        function zoomCanvas(delta) {
            appState.zoomLevel += delta;
            appState.zoomLevel = Math.max(0.5, Math.min(2, appState.zoomLevel));
            
            canvas.style.transform = `scale(${appState.zoomLevel})`;
            canvas.style.transformOrigin = 'top left';
            
            // Update canvas container size
            const canvasWidth = 1000 * appState.zoomLevel;
            const canvasHeight = 800 * appState.zoomLevel;
            canvasContainer.style.width = canvasWidth + 'px';
            canvasContainer.style.height = canvasHeight + 'px';
            
            canvasSize.textContent = `${Math.round(canvasWidth)} √ó ${Math.round(canvasHeight)}`;
        }

        // Toggle grid
        function toggleGrid() {
            const isVisible = canvas.style.backgroundImage !== 'none';
            
            if (isVisible) {
                canvas.style.backgroundImage = 'none';
                toggleGridBtn.innerHTML = '<span>üóÑÔ∏è</span> Grid: Off';
            } else {
                canvas.style.backgroundImage = `
                    linear-gradient(var(--grid-color) 1px, transparent 1px),
                    linear-gradient(90deg, var(--grid-color) 1px, transparent 1px)`;
                canvas.style.backgroundSize = `${appState.gridSize}px ${appState.gridSize}px`;
                toggleGridBtn.innerHTML = '<span>üóÑÔ∏è</span> Grid: On';
            }
        }

        // Toggle snap to grid
        function toggleSnap() {
            appState.snapToGrid = !appState.snapToGrid;
            
            if (appState.snapToGrid) {
                snapToggleBtn.innerHTML = '<span>üß≤</span> Snap: On';
            } else {
                snapToggleBtn.innerHTML = '<span>üß≤</span> Snap: Off';
            }
        }

        // Clear canvas
        function clearCanvas() {
            if (confirm('Are you sure you want to clear the canvas? All elements and connections will be deleted.')) {
                appState.elements = [];
                appState.connections = [];
                appState.selectedElement = null;
                appState.selectedConnection = null;
                
                canvas.innerHTML = '';
                updatePropertiesPanel();
                updateStatusBar();
            }
        }

        // Open export modal
        function openExportModal() {
            exportModal.style.display = 'flex';
            exportCode.value = generateExportCode();
        }

        // Copy export code to clipboard
        function copyExportCode() {
            exportCode.select();
            exportCode.setSelectionRange(0, 99999); // For mobile devices
            
            try {
                navigator.clipboard.writeText(exportCode.value);
                copyBtn.innerHTML = '<span>‚úì</span> Copied!';
                setTimeout(() => {
                    copyBtn.innerHTML = '<span>üìã</span> Copy to Clipboard';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy: ', err);
                copyBtn.innerHTML = '<span>‚úó</span> Failed';
                setTimeout(() => {
                    copyBtn.innerHTML = '<span>üìã</span> Copy to Clipboard';
                }, 2000);
            }
        }

        // Generate export code
        function generateExportCode() {
            let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exported UI Design</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .container {
            position: relative;
            width: ${canvas.offsetWidth}px;
            height: ${canvas.offsetHeight}px;
            background-color: white;
            box-shadow: 0 0 30px rgba(0,0,0,0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .exported-element {
            position: absolute;
            box-sizing: border-box;
        }
        
        /* UI Component Styles */
        .ui-button {
            background-color: #8a2be2;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px 20px;
            font-weight: 500;
            text-align: center;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
            height: 100%;
        }
        
        .ui-input, .ui-textarea {
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 10px;
            font-size: 14px;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }
        
        .ui-textarea {
            min-height: 80px;
            resize: vertical;
            font-family: inherit;
        }
        
        .ui-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            height: 100%;
            padding: 5px;
        }
        
        .ui-checkbox input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .ui-dropdown {
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 10px;
            font-size: 14px;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            background-color: white;
        }
        
        .ui-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background-color: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
        }
        
        .ui-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #8a2be2;
            cursor: pointer;
        }
        
        .ui-stepper {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            height: 100%;
        }
        
        .ui-stepper button {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 1px solid #ddd;
            background-color: white;
            font-size: 18px;
            cursor: pointer;
        }
        
        .ui-stepper-value {
            min-width: 40px;
            text-align: center;
            font-weight: 500;
        }
        
        .ui-progress {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background-color: #e0e0e0;
            overflow: hidden;
        }
        
        .ui-progress-bar {
            height: 100%;
            background-color: #8a2be2;
            border-radius: 4px;
        }
        
        .shape-rectangle {
            width: 100%;
            height: 100%;
        }
        
        .shape-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
        }
        
        .shape-triangle {
            width: 0;
            height: 0;
            border-left: 50px solid transparent;
            border-right: 50px solid transparent;
            border-bottom: 86.6px solid #ffebee;
            background-color: transparent !important;
            position: relative;
        }
        
        .shape-triangle::after {
            content: '';
            position: absolute;
            border-left: 48px solid transparent;
            border-right: 48px solid transparent;
            border-bottom: 83.6px solid #ffcdd2;
            top: 2px;
            left: -48px;
        }
        
        .shape-line {
            width: 100%;
            height: 100%;
        }
        
        .connection-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div class="container">\n`;
            
            // Add elements
            appState.elements.forEach(element => {
                const style = `
                    left: ${element.x}px;
                    top: ${element.y}px;
                    width: ${element.width}px;
                    height: ${element.height}px;
                    background-color: ${element.bgColor};
                    border: ${element.borderWidth}px solid ${element.borderColor};
                    border-radius: ${element.borderRadius}px;
                    ${element.hasShadow ? `box-shadow: ${element.shadowX}px ${element.shadowY}px ${element.shadowBlur}px ${element.shadowColor};` : ''}
                    z-index: ${element.zIndex};
                `;
                
                let content = '';
                
                switch(element.type) {
                    case 'button':
                        content = `<button class="ui-button" style="color:${element.textColor};font-size:${element.fontSize}px">${element.text}</button>`;
                        break;
                    case 'input':
                        content = `<input class="ui-input" type="text" placeholder="${element.placeholder || ''}" style="color:${element.textColor};font-size:${element.fontSize}px" value="${element.text}">`;
                        break;
                    case 'textarea':
                        content = `<textarea class="ui-textarea" placeholder="${element.placeholder || ''}" style="color:${element.textColor};font-size:${element.fontSize}px">${element.text}</textarea>`;
                        break;
                    case 'checkbox':
                        content = `
                            <div class="ui-checkbox" style="color:${element.textColor};font-size:${element.fontSize}px">
                                <input type="checkbox" ${element.checked ? 'checked' : ''}>
                                <span>${element.text}</span>
                            </div>`;
                        break;
                    case 'dropdown':
                        content = `
                            <select class="ui-dropdown" style="color:${element.textColor};font-size:${element.fontSize}px">
                                ${element.options.map(opt => `<option ${opt === element.text ? 'selected' : ''}>${opt}</option>`).join('')}
                            </select>`;
                        break;
                    case 'slider':
                        content = `
                            <div style="width:100%;height:100%;display:flex;align-items:center;padding:0 10px">
                                <input type="range" class="ui-slider" min="${element.min || 0}" max="${element.max || 100}" value="${element.value || 50}" style="width:100%">
                            </div>`;
                        break;
                    case 'stepper':
                        content = `
                            <div class="ui-stepper" style="color:${element.textColor};font-size:${element.fontSize}px">
                                <button>-</button>
                                <div class="ui-stepper-value">${element.value || 1}</div>
                                <button>+</button>
                            </div>`;
                        break;
                    case 'progress':
                        content = `
                            <div style="width:100%;height:100%;display:flex;align-items:center;padding:0 10px">
                                <div class="ui-progress">
                                    <div class="ui-progress-bar" style="width:${element.value || 60}%"></div>
                                </div>
                            </div>`;
                        break;
                    case 'rectangle':
                        content = `<div class="shape-rectangle"></div>`;
                        break;
                    case 'circle':
                        content = `<div class="shape-circle"></div>`;
                        break;
                    case 'triangle':
                        content = `<div class="shape-triangle"></div>`;
                        break;
                    case 'line':
                        content = `<div class="shape-line"></div>`;
                        break;
                    default:
                        content = `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:${element.textColor};font-size:${element.fontSize}px">${element.text}</div>`;
                }
                
                html += `        <div class="exported-element" style="${style}">${content}</div>\n`;
            });
            
            // Add connections as SVG
            if (appState.connections.length > 0) {
                html += `        <svg class="connection-line" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1">\n`;
                
                appState.connections.forEach(connection => {
                    const fromElement = appState.elements.find(el => el.id === connection.from);
                    const toElement = appState.elements.find(el => el.id === connection.to);
                    
                    if (fromElement && toElement) {
                        const startPoint = getConnectionPoint(fromElement, connection.fromPoint);
                        const endPoint = getConnectionPoint(toElement, connection.toPoint);
                        
                        const midX = (startPoint.x + endPoint.x) / 2;
                        const d = `M ${startPoint.x} ${startPoint.y} C ${midX} ${startPoint.y}, ${midX} ${endPoint.y}, ${endPoint.x} ${endPoint.y}`;
                        
                        html += `            <path d="${d}" stroke="#00b894" stroke-width="2" fill="none" />\n`;
                    }
                });
                
                html += `        </svg>\n`;
            }
            
            html += `    </div>
</body>
</html>`;
            
            return html;
        }

        // Handle keyboard shortcuts
        function handleKeyDown(e) {
            // Delete key
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (appState.selectedElement) {
                    deleteElement(appState.selectedElement);
                } else if (appState.selectedConnection) {
                    deleteConnection(appState.selectedConnection);
                }
            }
            
            // Escape key
            if (e.key === 'Escape') {
                if (appState.selectedElement) {
                    const elementDiv = document.getElementById(appState.selectedElement.id);
                    if (elementDiv) elementDiv.classList.remove('selected');
                    appState.selectedElement = null;
                    updatePropertiesPanel();
                }
                
                if (appState.selectedConnection) {
                    const connectionDiv = document.getElementById(appState.selectedConnection.id);
                    if (connectionDiv) connectionDiv.classList.remove('selected');
                    appState.selectedConnection = null;
                    updatePropertiesPanel();
                }
            }
            
            // Copy (Ctrl+C)
            if (e.ctrlKey && e.key === 'c' && appState.selectedElement) {
                // Clone selected element
                cloneElement(appState.selectedElement);
            }
            
            // Undo (Ctrl+Z)
            if (e.ctrlKey && e.key === 'z') {
                // Undo functionality would be implemented here
                console.log('Undo');
            }
        }

        // Delete an element
        function deleteElement(element) {
            if (!confirm('Delete this element?')) return;
            
            // Remove from array
            const index = appState.elements.findIndex(el => el.id === element.id);
            if (index !== -1) {
                appState.elements.splice(index, 1);
            }
            
            // Remove from DOM
            const elementDiv = document.getElementById(element.id);
            if (elementDiv) {
                elementDiv.remove();
            }
            
            // Remove connections involving this element
            const connectionsToRemove = appState.connections.filter(
                conn => conn.from === element.id || conn.to === element.id
            );
            
            connectionsToRemove.forEach(conn => {
                const connDiv = document.getElementById(conn.id);
                if (connDiv) connDiv.remove();
                
                const connIndex = appState.connections.findIndex(c => c.id === conn.id);
                if (connIndex !== -1) {
                    appState.connections.splice(connIndex, 1);
                }
            });
            
            // Clear selection
            appState.selectedElement = null;
            
            // Update UI
            updatePropertiesPanel();
            updateStatusBar();
        }

        // Delete a connection
        function deleteConnection(connection) {
            if (!confirm('Delete this connection?')) return;
            
            // Remove from array
            const index = appState.connections.findIndex(conn => conn.id === connection.id);
            if (index !== -1) {
                appState.connections.splice(index, 1);
            }
            
            // Remove from DOM
            const connectionDiv = document.getElementById(connection.id);
            if (connectionDiv) {
                connectionDiv.remove();
            }
            
            // Clear selection
            appState.selectedConnection = null;
            
            // Update UI
            updatePropertiesPanel();
            updateStatusBar();
        }

        // Clone an element
        function cloneElement(element) {
            // Create a copy with new ID
            const clonedElement = {...element};
            clonedElement.id = `element_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            clonedElement.x += 20;
            clonedElement.y += 20;
            clonedElement.zIndex = appState.elements.length;
            
            // Add to array
            appState.elements.push(clonedElement);
            
            // Create DOM element
            createElementDOM(clonedElement);
            
            // Select the cloned element
            selectElement(clonedElement);
            
            // Update status
            updateStatusBar();
        }

        // Load demo elements
        function loadDemoElements() {
            // Create a button
            const button = createElement('button', 200, 100);
            button.text = 'Click Me';
            button.bgColor = '#8a2be2';
            
            // Create an input
            const input = createElement('input', 400, 100);
            input.text = 'Enter text...';
            input.placeholder = 'Type here';
            
            // Create a dropdown
            const dropdown = createElement('dropdown', 200, 200);
            
            // Create a slider
            const slider = createElement('slider', 400, 200);
            
            // Create a rectangle
            const rectangle = createElement('rectangle', 200, 300);
            
            // Create a circle
            const circle = createElement('circle', 400, 300);
            
            // Create a connection between button and input
            createConnection(button, 'right', input, 'left');
            
            // Select the button
            selectElement(button);
        }

        // Initialize the application
        init();
    </script>
</body>
</html>