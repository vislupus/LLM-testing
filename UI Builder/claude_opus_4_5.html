<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI Builder Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --bg-dark: #1e1e2e;
            --bg-darker: #181825;
            --bg-light: #313244;
            --text: #cdd6f4;
            --text-dim: #a6adc8;
            --border: #45475a;
            --success: #a6e3a1;
            --warning: #f9e2af;
            --danger: #f38ba8;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
        }

        .app-container {
            display: grid;
            grid-template-columns: 260px 1fr 300px;
            grid-template-rows: 50px 1fr 30px;
            height: 100vh;
        }

        /* Toolbar */
        .toolbar {
            grid-column: 1 / -1;
            background: var(--bg-darker);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 15px;
            gap: 10px;
        }

        .toolbar-logo {
            font-weight: 700;
            font-size: 18px;
            color: var(--primary);
            margin-right: 20px;
        }

        .toolbar-btn {
            background: var(--bg-light);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }

        .toolbar-btn:hover {
            background: var(--primary);
            border-color: var(--primary);
        }

        .toolbar-btn.primary {
            background: var(--primary);
            border-color: var(--primary);
        }

        .toolbar-divider {
            width: 1px;
            height: 30px;
            background: var(--border);
            margin: 0 10px;
        }

        .toolbar-group {
            display: flex;
            gap: 5px;
        }

        .zoom-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }

        .zoom-value {
            font-size: 13px;
            min-width: 50px;
            text-align: center;
        }

        /* Left Panel - Components */
        .left-panel {
            background: var(--bg-darker);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            padding: 15px;
        }

        .panel-section {
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-dim);
            margin-bottom: 10px;
            font-weight: 600;
        }

        .component-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .component-item {
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px 8px;
            text-align: center;
            cursor: grab;
            transition: all 0.2s;
            font-size: 11px;
        }

        .component-item:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
        }

        .component-item:active {
            cursor: grabbing;
        }

        .component-icon {
            font-size: 20px;
            margin-bottom: 6px;
            display: block;
        }

        /* Canvas Area */
        .canvas-container {
            background: #2a2a3e;
            overflow: auto;
            position: relative;
        }

        .canvas-wrapper {
            min-width: 100%;
            min-height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 50px;
        }

        .canvas {
            background: white;
            position: relative;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            background-image: 
                linear-gradient(rgba(0,0,0,0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,0,0,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .canvas-element {
            position: absolute;
            cursor: move;
            user-select: none;
        }

        .canvas-element.selected {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }

        .canvas-element:hover:not(.selected) {
            outline: 1px solid var(--primary);
            outline-offset: 2px;
        }

        /* Resize Handles */
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: white;
            border: 2px solid var(--primary);
            border-radius: 2px;
            z-index: 100;
        }

        .resize-handle.nw { top: -5px; left: -5px; cursor: nwse-resize; }
        .resize-handle.n { top: -5px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .resize-handle.ne { top: -5px; right: -5px; cursor: nesw-resize; }
        .resize-handle.e { top: 50%; right: -5px; transform: translateY(-50%); cursor: ew-resize; }
        .resize-handle.se { bottom: -5px; right: -5px; cursor: nwse-resize; }
        .resize-handle.s { bottom: -5px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .resize-handle.sw { bottom: -5px; left: -5px; cursor: nesw-resize; }
        .resize-handle.w { top: 50%; left: -5px; transform: translateY(-50%); cursor: ew-resize; }

        /* Connection Points */
        .connection-point {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--success);
            border: 2px solid white;
            border-radius: 50%;
            cursor: crosshair;
            z-index: 101;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .canvas-element:hover .connection-point,
        .canvas-element.selected .connection-point {
            opacity: 1;
        }

        .connection-point.top { top: -6px; left: 50%; transform: translateX(-50%); }
        .connection-point.right { right: -6px; top: 50%; transform: translateY(-50%); }
        .connection-point.bottom { bottom: -6px; left: 50%; transform: translateX(-50%); }
        .connection-point.left { left: -6px; top: 50%; transform: translateY(-50%); }

        /* Alignment Guides */
        .alignment-guide {
            position: absolute;
            background: #ff6b6b;
            z-index: 1000;
            pointer-events: none;
        }

        .alignment-guide.horizontal {
            height: 1px;
            left: 0;
            right: 0;
        }

        .alignment-guide.vertical {
            width: 1px;
            top: 0;
            bottom: 0;
        }

        /* Right Panel - Properties */
        .right-panel {
            background: var(--bg-darker);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            padding: 15px;
        }

        .property-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border);
        }

        .property-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .property-label {
            font-size: 12px;
            color: var(--text-dim);
            width: 80px;
            flex-shrink: 0;
        }

        .property-input {
            flex: 1;
            background: var(--bg-light);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
        }

        .property-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .property-input-group {
            display: flex;
            gap: 5px;
            flex: 1;
        }

        .property-input-small {
            width: 60px;
            text-align: center;
        }

        .color-input-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        .color-preview {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            border: 1px solid var(--border);
            cursor: pointer;
        }

        input[type="color"] {
            opacity: 0;
            position: absolute;
            width: 30px;
            height: 30px;
        }

        .property-slider {
            flex: 1;
            -webkit-appearance: none;
            background: var(--bg-light);
            height: 4px;
            border-radius: 2px;
        }

        .property-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
        }

        .property-checkbox {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
        }

        .property-select {
            flex: 1;
            background: var(--bg-light);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
        }

        /* Status Bar */
        .status-bar {
            grid-column: 1 / -1;
            background: var(--bg-darker);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 15px;
            font-size: 11px;
            color: var(--text-dim);
        }

        .status-item {
            margin-right: 20px;
        }

        /* SVG Connections */
        .connections-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        .connection-line {
            stroke: var(--primary);
            stroke-width: 2;
            fill: none;
            pointer-events: stroke;
            cursor: pointer;
        }

        .connection-line:hover {
            stroke-width: 3;
        }

        .connection-line.selected {
            stroke: var(--warning);
            stroke-width: 3;
        }

        .connection-arrow {
            fill: var(--primary);
        }

        /* Element Content Styles */
        .element-button {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            width: 100%;
            height: 100%;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .element-input {
            width: 100%;
            height: 100%;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 14px;
        }

        .element-textarea {
            width: 100%;
            height: 100%;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 14px;
            resize: none;
        }

        .element-checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            height: 100%;
        }

        .element-checkbox {
            width: 20px;
            height: 20px;
        }

        .element-select {
            width: 100%;
            height: 100%;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 14px;
        }

        .element-slider {
            width: 100%;
        }

        .element-progress {
            width: 100%;
            height: 100%;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
        }

        .element-progress-fill {
            height: 100%;
            background: var(--primary);
            transition: width 0.3s;
        }

        .element-stepper {
            display: flex;
            align-items: center;
            height: 100%;
            gap: 5px;
        }

        .element-stepper button {
            width: 30px;
            height: 30px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 4px;
        }

        .element-stepper input {
            width: 50px;
            text-align: center;
            border: 1px solid #ddd;
            padding: 5px;
            border-radius: 4px;
        }

        .element-text {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            padding: 5px;
            overflow: hidden;
        }

        /* Shapes */
        .shape-rectangle {
            width: 100%;
            height: 100%;
            background: #4a90d9;
        }

        .shape-circle {
            width: 100%;
            height: 100%;
            background: #e74c3c;
            border-radius: 50%;
        }

        .shape-triangle {
            width: 0;
            height: 0;
            border-left: 50px solid transparent;
            border-right: 50px solid transparent;
            border-bottom: 86px solid #2ecc71;
        }

        .shape-line {
            width: 100%;
            height: 2px;
            background: #333;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Layers Panel */
        .layers-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .layer-item {
            display: flex;
            align-items: center;
            padding: 8px;
            background: var(--bg-light);
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .layer-item:hover {
            background: var(--border);
        }

        .layer-item.selected {
            background: var(--primary);
        }

        .layer-icon {
            margin-right: 8px;
        }

        .layer-visibility {
            margin-left: auto;
            opacity: 0.5;
            cursor: pointer;
        }

        .layer-visibility:hover {
            opacity: 1;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-dark);
            border-radius: 12px;
            padding: 25px;
            width: 500px;
            max-width: 90%;
            border: 1px solid var(--border);
        }

        .modal-title {
            font-size: 18px;
            margin-bottom: 20px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 5px;
            z-index: 3000;
            display: none;
            min-width: 150px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .context-menu.active {
            display: block;
        }

        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .context-menu-item:hover {
            background: var(--bg-light);
        }

        .context-menu-divider {
            height: 1px;
            background: var(--border);
            margin: 5px 0;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 50px;
            right: 20px;
            z-index: 4000;
        }

        .toast {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px 20px;
            margin-top: 10px;
            animation: slideIn 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toast.success {
            border-color: var(--success);
        }

        .toast.error {
            border-color: var(--danger);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }

        /* Keyboard Shortcuts Tooltip */
        .shortcut {
            font-size: 10px;
            color: var(--text-dim);
            margin-left: auto;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 40px;
            color: var(--text-dim);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Toolbar -->
        <div class="toolbar">
            <div class="toolbar-logo">‚óà UI Builder Pro</div>
            
            <div class="toolbar-group">
                <button class="toolbar-btn" onclick="app.newProject()" title="New Project (Ctrl+N)">
                    üìÑ New
                </button>
                <button class="toolbar-btn" onclick="app.saveProject()" title="Save Project (Ctrl+S)">
                    üíæ Save
                </button>
                <button class="toolbar-btn" onclick="app.loadProject()" title="Load Project (Ctrl+O)">
                    üìÇ Load
                </button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <button class="toolbar-btn" onclick="app.undo()" title="Undo (Ctrl+Z)">‚Ü∂</button>
                <button class="toolbar-btn" onclick="app.redo()" title="Redo (Ctrl+Y)">‚Ü∑</button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <button class="toolbar-btn" onclick="app.deleteSelected()" title="Delete (Del)">üóëÔ∏è</button>
                <button class="toolbar-btn" onclick="app.duplicateSelected()" title="Duplicate (Ctrl+D)">üìã</button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <button class="toolbar-btn" id="connectModeBtn" onclick="app.toggleConnectMode()" title="Connection Mode (C)">
                üîó Connect
            </button>
            
            <div class="zoom-control">
                <button class="toolbar-btn" onclick="app.zoomOut()">‚àí</button>
                <span class="zoom-value" id="zoomValue">100%</span>
                <button class="toolbar-btn" onclick="app.zoomIn()">+</button>
                <button class="toolbar-btn" onclick="app.resetZoom()">Fit</button>
            </div>
            
            <button class="toolbar-btn primary" onclick="app.exportHTML()">
                üöÄ Export HTML
            </button>
        </div>

        <!-- Left Panel - Components -->
        <div class="left-panel">
            <div class="panel-section">
                <div class="panel-title">UI Components</div>
                <div class="component-grid">
                    <div class="component-item" draggable="true" data-type="button">
                        <span class="component-icon">üîò</span>
                        Button
                    </div>
                    <div class="component-item" draggable="true" data-type="input">
                        <span class="component-icon">üìù</span>
                        Input
                    </div>
                    <div class="component-item" draggable="true" data-type="textarea">
                        <span class="component-icon">üìÑ</span>
                        Text Area
                    </div>
                    <div class="component-item" draggable="true" data-type="checkbox">
                        <span class="component-icon">‚òëÔ∏è</span>
                        Checkbox
                    </div>
                    <div class="component-item" draggable="true" data-type="dropdown">
                        <span class="component-icon">üìã</span>
                        Dropdown
                    </div>
                    <div class="component-item" draggable="true" data-type="slider">
                        <span class="component-icon">üéöÔ∏è</span>
                        Slider
                    </div>
                    <div class="component-item" draggable="true" data-type="stepper">
                        <span class="component-icon">üî¢</span>
                        Stepper
                    </div>
                    <div class="component-item" draggable="true" data-type="progress">
                        <span class="component-icon">üìä</span>
                        Progress
                    </div>
                    <div class="component-item" draggable="true" data-type="text">
                        <span class="component-icon">üî§</span>
                        Text
                    </div>
                    <div class="component-item" draggable="true" data-type="image">
                        <span class="component-icon">üñºÔ∏è</span>
                        Image
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">Shapes</div>
                <div class="component-grid">
                    <div class="component-item" draggable="true" data-type="rectangle">
                        <span class="component-icon">‚¨ú</span>
                        Rectangle
                    </div>
                    <div class="component-item" draggable="true" data-type="circle">
                        <span class="component-icon">‚≠ï</span>
                        Circle
                    </div>
                    <div class="component-item" draggable="true" data-type="triangle">
                        <span class="component-icon">üî∫</span>
                        Triangle
                    </div>
                    <div class="component-item" draggable="true" data-type="line">
                        <span class="component-icon">‚ûñ</span>
                        Line
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">Layers</div>
                <div class="layers-list" id="layersList"></div>
            </div>
        </div>

        <!-- Canvas -->
        <div class="canvas-container" id="canvasContainer">
            <div class="canvas-wrapper">
                <div class="canvas" id="canvas" style="width: 1200px; height: 800px;">
                    <svg class="connections-svg" id="connectionsSvg">
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" class="connection-arrow"/>
                            </marker>
                        </defs>
                    </svg>
                </div>
            </div>
        </div>

        <!-- Right Panel - Properties -->
        <div class="right-panel">
            <div id="propertiesPanel">
                <div class="empty-state">
                    <div class="empty-state-icon">üé®</div>
                    <p>Select an element to edit its properties</p>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <span class="status-item" id="statusPosition">X: 0, Y: 0</span>
            <span class="status-item" id="statusSize">1200 √ó 800</span>
            <span class="status-item" id="statusElements">Elements: 0</span>
            <span class="status-item" id="statusConnections">Connections: 0</span>
            <span class="status-item" style="margin-left: auto;">Grid: 20px | Snap: On</span>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" onclick="app.cutSelected()">‚úÇÔ∏è Cut <span class="shortcut">Ctrl+X</span></div>
        <div class="context-menu-item" onclick="app.copySelected()">üìã Copy <span class="shortcut">Ctrl+C</span></div>
        <div class="context-menu-item" onclick="app.paste()">üìÑ Paste <span class="shortcut">Ctrl+V</span></div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" onclick="app.duplicateSelected()">‚ßâ Duplicate <span class="shortcut">Ctrl+D</span></div>
        <div class="context-menu-item" onclick="app.deleteSelected()">üóëÔ∏è Delete <span class="shortcut">Del</span></div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" onclick="app.bringToFront()">‚¨ÜÔ∏è Bring to Front</div>
        <div class="context-menu-item" onclick="app.sendToBack()">‚¨áÔ∏è Send to Back</div>
    </div>

    <!-- Canvas Size Modal -->
    <div class="modal-overlay" id="canvasSizeModal">
        <div class="modal">
            <h3 class="modal-title">Canvas Size</h3>
            <div class="property-row">
                <label class="property-label">Width</label>
                <input type="number" class="property-input" id="canvasWidth" value="1200">
            </div>
            <div class="property-row">
                <label class="property-label">Height</label>
                <input type="number" class="property-input" id="canvasHeight" value="800">
            </div>
            <div class="modal-actions">
                <button class="toolbar-btn" onclick="app.closeModal('canvasSizeModal')">Cancel</button>
                <button class="toolbar-btn primary" onclick="app.applyCanvasSize()">Apply</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Hidden file input for loading projects -->
    <input type="file" id="fileInput" accept=".json" style="display: none;">

    <script>
        // Main Application
        const app = {
            elements: [],
            connections: [],
            selectedElement: null,
            selectedConnection: null,
            clipboard: null,
            history: [],
            historyIndex: -1,
            zoom: 1,
            gridSize: 20,
            snapToGrid: true,
            connectMode: false,
            connectStart: null,
            isDragging: false,
            isResizing: false,
            dragOffset: { x: 0, y: 0 },
            resizeHandle: null,
            elementCounter: 0,

            // Initialize
            init() {
                this.setupEventListeners();
                this.updateStatus();
                this.saveState();
            },

            // Setup Event Listeners
            setupEventListeners() {
                const canvas = document.getElementById('canvas');
                const canvasContainer = document.getElementById('canvasContainer');

                // Component drag events
                document.querySelectorAll('.component-item').forEach(item => {
                    item.addEventListener('dragstart', (e) => this.handleDragStart(e));
                });

                // Canvas events
                canvas.addEventListener('dragover', (e) => e.preventDefault());
                canvas.addEventListener('drop', (e) => this.handleDrop(e));
                canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));

                // Context menu
                canvas.addEventListener('contextmenu', (e) => this.handleContextMenu(e));
                document.addEventListener('click', () => this.hideContextMenu());

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));

                // File input
                document.getElementById('fileInput').addEventListener('change', (e) => this.handleFileLoad(e));

                // Window resize
                window.addEventListener('resize', () => this.updateConnections());
            },

            // Handle Drag Start
            handleDragStart(e) {
                e.dataTransfer.setData('type', e.target.dataset.type);
            },

            // Handle Drop
            handleDrop(e) {
                e.preventDefault();
                const type = e.dataTransfer.getData('type');
                if (!type) return;

                const canvas = document.getElementById('canvas');
                const rect = canvas.getBoundingClientRect();
                let x = (e.clientX - rect.left) / this.zoom;
                let y = (e.clientY - rect.top) / this.zoom;

                if (this.snapToGrid) {
                    x = Math.round(x / this.gridSize) * this.gridSize;
                    y = Math.round(y / this.gridSize) * this.gridSize;
                }

                this.createElement(type, x, y);
            },

            // Create Element
            createElement(type, x, y, props = {}) {
                const id = `element-${++this.elementCounter}`;
                const defaults = this.getElementDefaults(type);
                
                const element = {
                    id,
                    type,
                    x,
                    y,
                    width: props.width || defaults.width,
                    height: props.height || defaults.height,
                    content: props.content || defaults.content,
                    styles: { ...defaults.styles, ...props.styles }
                };

                this.elements.push(element);
                this.renderElement(element);
                this.selectElement(element);
                this.updateLayers();
                this.updateStatus();
                this.saveState();
                
                return element;
            },

            // Get Element Defaults
            getElementDefaults(type) {
                const defaults = {
                    button: { width: 120, height: 40, content: 'Button', styles: { backgroundColor: '#6366f1', color: '#ffffff', borderRadius: 6, fontSize: 14 }},
                    input: { width: 200, height: 40, content: '', styles: { borderWidth: 1, borderColor: '#ddd', borderRadius: 4, fontSize: 14 }},
                    textarea: { width: 200, height: 100, content: '', styles: { borderWidth: 1, borderColor: '#ddd', borderRadius: 4, fontSize: 14 }},
                    checkbox: { width: 120, height: 30, content: 'Option', styles: {}},
                    dropdown: { width: 200, height: 40, content: 'Option 1,Option 2,Option 3', styles: { borderRadius: 4 }},
                    slider: { width: 200, height: 30, content: '50', styles: {}},
                    stepper: { width: 130, height: 40, content: '0', styles: {}},
                    progress: { width: 200, height: 20, content: '60', styles: { backgroundColor: '#e0e0e0', fillColor: '#6366f1', borderRadius: 10 }},
                    text: { width: 200, height: 40, content: 'Text Label', styles: { fontSize: 16, color: '#333333', fontWeight: 'normal' }},
                    image: { width: 200, height: 150, content: '', styles: { borderRadius: 0 }},
                    rectangle: { width: 100, height: 100, content: '', styles: { backgroundColor: '#4a90d9', borderRadius: 0 }},
                    circle: { width: 100, height: 100, content: '', styles: { backgroundColor: '#e74c3c' }},
                    triangle: { width: 100, height: 86, content: '', styles: { backgroundColor: '#2ecc71' }},
                    line: { width: 150, height: 4, content: '', styles: { backgroundColor: '#333333' }}
                };
                return defaults[type] || { width: 100, height: 100, content: '', styles: {}};
            },

            // Render Element
            renderElement(element) {
                const canvas = document.getElementById('canvas');
                
                const el = document.createElement('div');
                el.id = element.id;
                el.className = 'canvas-element';
                el.style.left = `${element.x}px`;
                el.style.top = `${element.y}px`;
                el.style.width = `${element.width}px`;
                el.style.height = `${element.height}px`;
                
                el.innerHTML = this.getElementHTML(element);
                this.applyElementStyles(el, element);
                
                // Add resize handles
                const handles = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];
                handles.forEach(pos => {
                    const handle = document.createElement('div');
                    handle.className = `resize-handle ${pos}`;
                    handle.style.display = 'none';
                    handle.addEventListener('mousedown', (e) => this.startResize(e, element, pos));
                    el.appendChild(handle);
                });
                
                // Add connection points
                const points = ['top', 'right', 'bottom', 'left'];
                points.forEach(pos => {
                    const point = document.createElement('div');
                    point.className = `connection-point ${pos}`;
                    point.addEventListener('mousedown', (e) => this.startConnection(e, element, pos));
                    el.appendChild(point);
                });
                
                // Element events
                el.addEventListener('mousedown', (e) => this.startDrag(e, element));
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectElement(element);
                });
                
                canvas.appendChild(el);
            },

            // Get Element HTML
            getElementHTML(element) {
                switch (element.type) {
                    case 'button':
                        return `<button class="element-button">${element.content}</button>`;
                    case 'input':
                        return `<input type="text" class="element-input" placeholder="${element.content || 'Enter text...'}">`;
                    case 'textarea':
                        return `<textarea class="element-textarea" placeholder="${element.content || 'Enter text...'}">${element.content}</textarea>`;
                    case 'checkbox':
                        return `<label class="element-checkbox-wrapper"><input type="checkbox" class="element-checkbox"><span>${element.content}</span></label>`;
                    case 'dropdown':
                        const options = element.content.split(',').map(o => `<option>${o.trim()}</option>`).join('');
                        return `<select class="element-select">${options}</select>`;
                    case 'slider':
                        return `<input type="range" class="element-slider" value="${element.content}" min="0" max="100">`;
                    case 'stepper':
                        return `<div class="element-stepper"><button>-</button><input type="text" value="${element.content}"><button>+</button></div>`;
                    case 'progress':
                        return `<div class="element-progress"><div class="element-progress-fill" style="width: ${element.content}%"></div></div>`;
                    case 'text':
                        return `<div class="element-text">${element.content}</div>`;
                    case 'image':
                        return element.content 
                            ? `<img src="${element.content}" style="width:100%;height:100%;object-fit:cover;">` 
                            : `<div style="width:100%;height:100%;background:#ddd;display:flex;align-items:center;justify-content:center;color:#666;">üì∑ Image</div>`;
                    case 'rectangle':
                        return `<div class="shape-rectangle"></div>`;
                    case 'circle':
                        return `<div class="shape-circle"></div>`;
                    case 'triangle':
                        return `<div style="width:0;height:0;border-left:${element.width/2}px solid transparent;border-right:${element.width/2}px solid transparent;border-bottom:${element.height}px solid ${element.styles.backgroundColor || '#2ecc71'}"></div>`;
                    case 'line':
                        return `<div class="shape-line"></div>`;
                    default:
                        return '';
                }
            },

            // Apply Element Styles
            applyElementStyles(el, element) {
                const styles = element.styles || {};
                
                if (element.type === 'rectangle') {
                    const shape = el.querySelector('.shape-rectangle');
                    if (shape) {
                        shape.style.backgroundColor = styles.backgroundColor || '#4a90d9';
                        shape.style.borderRadius = `${styles.borderRadius || 0}px`;
                        if (styles.boxShadow) {
                            shape.style.boxShadow = `${styles.shadowX || 0}px ${styles.shadowY || 4}px ${styles.shadowBlur || 10}px ${styles.shadowColor || 'rgba(0,0,0,0.2)'}`;
                        }
                    }
                } else if (element.type === 'circle') {
                    const shape = el.querySelector('.shape-circle');
                    if (shape) {
                        shape.style.backgroundColor = styles.backgroundColor || '#e74c3c';
                        if (styles.boxShadow) {
                            shape.style.boxShadow = `${styles.shadowX || 0}px ${styles.shadowY || 4}px ${styles.shadowBlur || 10}px ${styles.shadowColor || 'rgba(0,0,0,0.2)'}`;
                        }
                    }
                } else if (element.type === 'line') {
                    const shape = el.querySelector('.shape-line');
                    if (shape) {
                        shape.style.backgroundColor = styles.backgroundColor || '#333';
                    }
                } else if (element.type === 'button') {
                    const btn = el.querySelector('.element-button');
                    if (btn) {
                        btn.style.backgroundColor = styles.backgroundColor || '#6366f1';
                        btn.style.color = styles.color || '#ffffff';
                        btn.style.borderRadius = `${styles.borderRadius || 6}px`;
                        btn.style.fontSize = `${styles.fontSize || 14}px`;
                        if (styles.boxShadow) {
                            btn.style.boxShadow = `${styles.shadowX || 0}px ${styles.shadowY || 4}px ${styles.shadowBlur || 10}px ${styles.shadowColor || 'rgba(0,0,0,0.2)'}`;
                        }
                    }
                } else if (element.type === 'text') {
                    const text = el.querySelector('.element-text');
                    if (text) {
                        text.style.fontSize = `${styles.fontSize || 16}px`;
                        text.style.color = styles.color || '#333333';
                        text.style.fontWeight = styles.fontWeight || 'normal';
                        text.style.textAlign = styles.textAlign || 'left';
                    }
                } else if (element.type === 'progress') {
                    const progress = el.querySelector('.element-progress');
                    const fill = el.querySelector('.element-progress-fill');
                    if (progress) {
                        progress.style.backgroundColor = styles.backgroundColor || '#e0e0e0';
                        progress.style.borderRadius = `${styles.borderRadius || 10}px`;
                    }
                    if (fill) {
                        fill.style.backgroundColor = styles.fillColor || '#6366f1';
                    }
                } else if (element.type === 'input' || element.type === 'textarea') {
                    const input = el.querySelector('.element-input, .element-textarea');
                    if (input) {
                        input.style.borderRadius = `${styles.borderRadius || 4}px`;
                        input.style.fontSize = `${styles.fontSize || 14}px`;
                    }
                }
                
                el.style.opacity = styles.opacity !== undefined ? styles.opacity : 1;
            },

            // Select Element
            selectElement(element) {
                if (this.selectedElement) {
                    const prevEl = document.getElementById(this.selectedElement.id);
                    if (prevEl) {
                        prevEl.classList.remove('selected');
                        prevEl.querySelectorAll('.resize-handle').forEach(h => h.style.display = 'none');
                    }
                }
                
                this.selectedElement = element;
                this.selectedConnection = null;
                
                if (element) {
                    const el = document.getElementById(element.id);
                    if (el) {
                        el.classList.add('selected');
                        el.querySelectorAll('.resize-handle').forEach(h => h.style.display = 'block');
                    }
                }
                
                this.updatePropertiesPanel();
                this.updateLayers();
            },

            // Update Properties Panel
            updatePropertiesPanel() {
                const panel = document.getElementById('propertiesPanel');
                
                if (!this.selectedElement) {
                    panel.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üé®</div>
                            <p>Select an element to edit its properties</p>
                        </div>
                    `;
                    return;
                }
                
                const element = this.selectedElement;
                const styles = element.styles || {};
                
                let html = `
                    <div class="property-group">
                        <div class="panel-title">Element: ${element.type}</div>
                        
                        <div class="property-row">
                            <label class="property-label">ID</label>
                            <input type="text" class="property-input" value="${element.id}" readonly>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="panel-title">Position & Size</div>
                        
                        <div class="property-row">
                            <label class="property-label">X</label>
                            <input type="number" class="property-input" id="propX" value="${element.x}" onchange="app.updateProperty('x', this.value)">
                        </div>
                        <div class="property-row">
                            <label class="property-label">Y</label>
                            <input type="number" class="property-input" id="propY" value="${element.y}" onchange="app.updateProperty('y', this.value)">
                        </div>
                        <div class="property-row">
                            <label class="property-label">Width</label>
                            <input type="number" class="property-input" id="propWidth" value="${element.width}" onchange="app.updateProperty('width', this.value)">
                        </div>
                        <div class="property-row">
                            <label class="property-label">Height</label>
                            <input type="number" class="property-input" id="propHeight" value="${element.height}" onchange="app.updateProperty('height', this.value)">
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="panel-title">Content</div>
                        <div class="property-row">
                            <label class="property-label">Text</label>
                            <input type="text" class="property-input" id="propContent" value="${element.content}" onchange="app.updateProperty('content', this.value)">
                        </div>
                    </div>
                `;
                
                // Style properties
                html += `
                    <div class="property-group">
                        <div class="panel-title">Appearance</div>
                        
                        <div class="property-row">
                            <label class="property-label">BG Color</label>
                            <div class="color-input-wrapper">
                                <div class="color-preview" style="background: ${styles.backgroundColor || '#ffffff'}" onclick="document.getElementById('propBgColor').click()"></div>
                                <input type="color" id="propBgColor" value="${styles.backgroundColor || '#ffffff'}" onchange="app.updateStyle('backgroundColor', this.value)">
                                <input type="text" class="property-input" value="${styles.backgroundColor || '#ffffff'}" onchange="app.updateStyle('backgroundColor', this.value)">
                            </div>
                        </div>
                        
                        <div class="property-row">
                            <label class="property-label">Text Color</label>
                            <div class="color-input-wrapper">
                                <div class="color-preview" style="background: ${styles.color || '#333333'}" onclick="document.getElementById('propColor').click()"></div>
                                <input type="color" id="propColor" value="${styles.color || '#333333'}" onchange="app.updateStyle('color', this.value)">
                                <input type="text" class="property-input" value="${styles.color || '#333333'}" onchange="app.updateStyle('color', this.value)">
                            </div>
                        </div>
                        
                        <div class="property-row">
                            <label class="property-label">Font Size</label>
                            <input type="number" class="property-input" value="${styles.fontSize || 14}" onchange="app.updateStyle('fontSize', this.value)">
                        </div>
                        
                        <div class="property-row">
                            <label class="property-label">Opacity</label>
                            <input type="range" class="property-slider" min="0" max="1" step="0.1" value="${styles.opacity !== undefined ? styles.opacity : 1}" onchange="app.updateStyle('opacity', this.value)">
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="panel-title">Border</div>
                        
                        <div class="property-row">
                            <label class="property-label">Radius</label>
                            <input type="number" class="property-input" value="${styles.borderRadius || 0}" onchange="app.updateStyle('borderRadius', this.value)">
                        </div>
                        
                        <div class="property-row">
                            <label class="property-label">Width</label>
                            <input type="number" class="property-input" value="${styles.borderWidth || 0}" onchange="app.updateStyle('borderWidth', this.value)">
                        </div>
                        
                        <div class="property-row">
                            <label class="property-label">Color</label>
                            <div class="color-input-wrapper">
                                <div class="color-preview" style="background: ${styles.borderColor || '#dddddd'}" onclick="document.getElementById('propBorderColor').click()"></div>
                                <input type="color" id="propBorderColor" value="${styles.borderColor || '#dddddd'}" onchange="app.updateStyle('borderColor', this.value)">
                            </div>
                        </div>
                    </div>
                    
                    <div class="property-group">
                        <div class="panel-title">Shadow</div>
                        
                        <div class="property-row">
                            <label class="property-label">Enable</label>
                            <input type="checkbox" class="property-checkbox" ${styles.boxShadow ? 'checked' : ''} onchange="app.updateStyle('boxShadow', this.checked)">
                        </div>
                        
                        <div class="property-row">
                            <label class="property-label">X Offset</label>
                            <input type="number" class="property-input" value="${styles.shadowX || 0}" onchange="app.updateStyle('shadowX', this.value)">
                        </div>
                        
                        <div class="property-row">
                            <label class="property-label">Y Offset</label>
                            <input type="number" class="property-input" value="${styles.shadowY || 4}" onchange="app.updateStyle('shadowY', this.value)">
                        </div>
                        
                        <div class="property-row">
                            <label class="property-label">Blur</label>
                            <input type="number" class="property-input" value="${styles.shadowBlur || 10}" onchange="app.updateStyle('shadowBlur', this.value)">
                        </div>
                        
                        <div class="property-row">
                            <label class="property-label">Color</label>
                            <div class="color-input-wrapper">
                                <div class="color-preview" style="background: ${styles.shadowColor || 'rgba(0,0,0,0.2)'}"></div>
                                <input type="text" class="property-input" value="${styles.shadowColor || 'rgba(0,0,0,0.2)'}" onchange="app.updateStyle('shadowColor', this.value)">
                            </div>
                        </div>
                    </div>
                `;
                
                // Fill color for progress bars
                if (element.type === 'progress') {
                    html += `
                        <div class="property-group">
                            <div class="panel-title">Progress</div>
                            <div class="property-row">
                                <label class="property-label">Fill Color</label>
                                <div class="color-input-wrapper">
                                    <div class="color-preview" style="background: ${styles.fillColor || '#6366f1'}" onclick="document.getElementById('propFillColor').click()"></div>
                                    <input type="color" id="propFillColor" value="${styles.fillColor || '#6366f1'}" onchange="app.updateStyle('fillColor', this.value)">
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                panel.innerHTML = html;
            },

            // Update Property
            updateProperty(prop, value) {
                if (!this.selectedElement) return;
                
                const numValue = parseFloat(value);
                this.selectedElement[prop] = isNaN(numValue) ? value : numValue;
                
                const el = document.getElementById(this.selectedElement.id);
                if (el) {
                    if (prop === 'x') el.style.left = `${value}px`;
                    else if (prop === 'y') el.style.top = `${value}px`;
                    else if (prop === 'width') el.style.width = `${value}px`;
                    else if (prop === 'height') el.style.height = `${value}px`;
                    else if (prop === 'content') el.innerHTML = this.getElementHTML(this.selectedElement);
                    
                    this.applyElementStyles(el, this.selectedElement);
                }
                
                // Re-add resize handles and connection points
                if (prop === 'content') {
                    const handles = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];
                    handles.forEach(pos => {
                        const handle = document.createElement('div');
                        handle.className = `resize-handle ${pos}`;
                        handle.style.display = 'block';
                        handle.addEventListener('mousedown', (e) => this.startResize(e, this.selectedElement, pos));
                        el.appendChild(handle);
                    });
                    
                    const points = ['top', 'right', 'bottom', 'left'];
                    points.forEach(pos => {
                        const point = document.createElement('div');
                        point.className = `connection-point ${pos}`;
                        point.addEventListener('mousedown', (e) => this.startConnection(e, this.selectedElement, pos));
                        el.appendChild(point);
                    });
                }
                
                this.updateConnections();
                this.saveState();
            },

            // Update Style
            updateStyle(prop, value) {
                if (!this.selectedElement) return;
                
                const numValue = parseFloat(value);
                this.selectedElement.styles[prop] = isNaN(numValue) ? value : numValue;
                
                const el = document.getElementById(this.selectedElement.id);
                if (el) {
                    this.applyElementStyles(el, this.selectedElement);
                }
                
                this.updatePropertiesPanel();
                this.saveState();
            },

            // Start Drag
            startDrag(e, element) {
                if (e.target.classList.contains('resize-handle') || e.target.classList.contains('connection-point')) return;
                
                this.isDragging = true;
                this.selectElement(element);
                
                const el = document.getElementById(element.id);
                const rect = el.getBoundingClientRect();
                this.dragOffset = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                
                e.preventDefault();
            },

            // Start Resize
            startResize(e, element, handle) {
                e.stopPropagation();
                this.isResizing = true;
                this.resizeHandle = handle;
                this.selectElement(element);
                
                this.resizeStart = {
                    x: e.clientX,
                    y: e.clientY,
                    width: element.width,
                    height: element.height,
                    left: element.x,
                    top: element.y
                };
            },

            // Handle Mouse Move
            handleMouseMove(e) {
                const canvas = document.getElementById('canvas');
                const rect = canvas.getBoundingClientRect();
                const x = Math.round((e.clientX - rect.left) / this.zoom);
                const y = Math.round((e.clientY - rect.top) / this.zoom);
                
                document.getElementById('statusPosition').textContent = `X: ${x}, Y: ${y}`;
                
                if (this.isDragging && this.selectedElement) {
                    let newX = (e.clientX - rect.left) / this.zoom - this.dragOffset.x;
                    let newY = (e.clientY - rect.top) / this.zoom - this.dragOffset.y;
                    
                    if (this.snapToGrid) {
                        newX = Math.round(newX / this.gridSize) * this.gridSize;
                        newY = Math.round(newY / this.gridSize) * this.gridSize;
                    }
                    
                    // Boundary check
                    newX = Math.max(0, Math.min(canvas.offsetWidth - this.selectedElement.width, newX));
                    newY = Math.max(0, Math.min(canvas.offsetHeight - this.selectedElement.height, newY));
                    
                    this.selectedElement.x = newX;
                    this.selectedElement.y = newY;
                    
                    const el = document.getElementById(this.selectedElement.id);
                    if (el) {
                        el.style.left = `${newX}px`;
                        el.style.top = `${newY}px`;
                    }
                    
                    this.showAlignmentGuides();
                    this.updateConnections();
                }
                
                if (this.isResizing && this.selectedElement) {
                    const dx = (e.clientX - this.resizeStart.x) / this.zoom;
                    const dy = (e.clientY - this.resizeStart.y) / this.zoom;
                    
                    let newWidth = this.resizeStart.width;
                    let newHeight = this.resizeStart.height;
                    let newX = this.resizeStart.left;
                    let newY = this.resizeStart.top;
                    
                    switch (this.resizeHandle) {
                        case 'e':
                            newWidth = Math.max(20, this.resizeStart.width + dx);
                            break;
                        case 'w':
                            newWidth = Math.max(20, this.resizeStart.width - dx);
                            newX = this.resizeStart.left + this.resizeStart.width - newWidth;
                            break;
                        case 's':
                            newHeight = Math.max(20, this.resizeStart.height + dy);
                            break;
                        case 'n':
                            newHeight = Math.max(20, this.resizeStart.height - dy);
                            newY = this.resizeStart.top + this.resizeStart.height - newHeight;
                            break;
                        case 'se':
                            newWidth = Math.max(20, this.resizeStart.width + dx);
                            newHeight = Math.max(20, this.resizeStart.height + dy);
                            break;
                        case 'sw':
                            newWidth = Math.max(20, this.resizeStart.width - dx);
                            newHeight = Math.max(20, this.resizeStart.height + dy);
                            newX = this.resizeStart.left + this.resizeStart.width - newWidth;
                            break;
                        case 'ne':
                            newWidth = Math.max(20, this.resizeStart.width + dx);
                            newHeight = Math.max(20, this.resizeStart.height - dy);
                            newY = this.resizeStart.top + this.resizeStart.height - newHeight;
                            break;
                        case 'nw':
                            newWidth = Math.max(20, this.resizeStart.width - dx);
                            newHeight = Math.max(20, this.resizeStart.height - dy);
                            newX = this.resizeStart.left + this.resizeStart.width - newWidth;
                            newY = this.resizeStart.top + this.resizeStart.height - newHeight;
                            break;
                    }
                    
                    if (this.snapToGrid) {
                        newWidth = Math.round(newWidth / this.gridSize) * this.gridSize;
                        newHeight = Math.round(newHeight / this.gridSize) * this.gridSize;
                        newX = Math.round(newX / this.gridSize) * this.gridSize;
                        newY = Math.round(newY / this.gridSize) * this.gridSize;
                    }
                    
                    this.selectedElement.width = newWidth;
                    this.selectedElement.height = newHeight;
                    this.selectedElement.x = newX;
                    this.selectedElement.y = newY;
                    
                    const el = document.getElementById(this.selectedElement.id);
                    if (el) {
                        el.style.width = `${newWidth}px`;
                        el.style.height = `${newHeight}px`;
                        el.style.left = `${newX}px`;
                        el.style.top = `${newY}px`;
                        
                        // Update triangle shape
                        if (this.selectedElement.type === 'triangle') {
                            el.innerHTML = this.getElementHTML(this.selectedElement);
                        }
                    }
                    
                    this.updateConnections();
                    this.updatePropertiesPanel();
                }
                
                // Draw temporary connection line
                if (this.connectMode && this.connectStart) {
                    this.drawTempConnection(e.clientX - rect.left, e.clientY - rect.top);
                }
            },

            // Handle Mouse Up
            handleMouseUp(e) {
                if (this.isDragging || this.isResizing) {
                    this.hideAlignmentGuides();
                    this.saveState();
                }
                
                this.isDragging = false;
                this.isResizing = false;
                this.resizeHandle = null;
                
                if (this.connectMode && this.connectStart) {
                    this.removeTempConnection();
                }
            },

            // Show Alignment Guides
            showAlignmentGuides() {
                this.hideAlignmentGuides();
                
                if (!this.selectedElement) return;
                
                const canvas = document.getElementById('canvas');
                const currentRect = {
                    left: this.selectedElement.x,
                    top: this.selectedElement.y,
                    right: this.selectedElement.x + this.selectedElement.width,
                    bottom: this.selectedElement.y + this.selectedElement.height,
                    centerX: this.selectedElement.x + this.selectedElement.width / 2,
                    centerY: this.selectedElement.y + this.selectedElement.height / 2
                };
                
                const threshold = 5;
                
                this.elements.forEach(element => {
                    if (element.id === this.selectedElement.id) return;
                    
                    const rect = {
                        left: element.x,
                        top: element.y,
                        right: element.x + element.width,
                        bottom: element.y + element.height,
                        centerX: element.x + element.width / 2,
                        centerY: element.y + element.height / 2
                    };
                    
                    // Vertical guides
                    if (Math.abs(currentRect.left - rect.left) < threshold) {
                        this.createGuide('vertical', rect.left);
                    }
                    if (Math.abs(currentRect.right - rect.right) < threshold) {
                        this.createGuide('vertical', rect.right);
                    }
                    if (Math.abs(currentRect.centerX - rect.centerX) < threshold) {
                        this.createGuide('vertical', rect.centerX);
                    }
                    
                    // Horizontal guides
                    if (Math.abs(currentRect.top - rect.top) < threshold) {
                        this.createGuide('horizontal', rect.top);
                    }
                    if (Math.abs(currentRect.bottom - rect.bottom) < threshold) {
                        this.createGuide('horizontal', rect.bottom);
                    }
                    if (Math.abs(currentRect.centerY - rect.centerY) < threshold) {
                        this.createGuide('horizontal', rect.centerY);
                    }
                });
            },

            // Create Alignment Guide
            createGuide(type, position) {
                const canvas = document.getElementById('canvas');
                const guide = document.createElement('div');
                guide.className = `alignment-guide ${type}`;
                
                if (type === 'horizontal') {
                    guide.style.top = `${position}px`;
                } else {
                    guide.style.left = `${position}px`;
                }
                
                canvas.appendChild(guide);
            },

            // Hide Alignment Guides
            hideAlignmentGuides() {
                document.querySelectorAll('.alignment-guide').forEach(g => g.remove());
            },

            // Start Connection
            startConnection(e, element, position) {
                e.stopPropagation();
                
                if (!this.connectMode) {
                    this.connectMode = true;
                    document.getElementById('connectModeBtn').classList.add('primary');
                }
                
                this.connectStart = { element, position };
            },

            // Draw Temporary Connection
            drawTempConnection(x, y) {
                this.removeTempConnection();
                
                const svg = document.getElementById('connectionsSvg');
                const startPos = this.getConnectionPoint(this.connectStart.element, this.connectStart.position);
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                line.id = 'temp-connection';
                line.setAttribute('class', 'connection-line');
                line.setAttribute('d', this.createCurvePath(startPos.x, startPos.y, x / this.zoom, y / this.zoom));
                line.style.opacity = 0.5;
                
                svg.appendChild(line);
            },

            // Remove Temporary Connection
            removeTempConnection() {
                const temp = document.getElementById('temp-connection');
                if (temp) temp.remove();
            },

            // Complete Connection
            completeConnection(element, position) {
                if (!this.connectStart || this.connectStart.element.id === element.id) {
                    this.connectStart = null;
                    return;
                }
                
                const connection = {
                    id: `conn-${Date.now()}`,
                    from: { elementId: this.connectStart.element.id, position: this.connectStart.position },
                    to: { elementId: element.id, position: position },
                    style: { stroke: '#6366f1', strokeWidth: 2, type: 'curve' }
                };
                
                this.connections.push(connection);
                this.renderConnection(connection);
                
                this.connectStart = null;
                this.removeTempConnection();
                this.updateStatus();
                this.saveState();
                
                this.showToast('Connection created', 'success');
            },

            // Get Connection Point
            getConnectionPoint(element, position) {
                const points = {
                    top: { x: element.x + element.width / 2, y: element.y },
                    right: { x: element.x + element.width, y: element.y + element.height / 2 },
                    bottom: { x: element.x + element.width / 2, y: element.y + element.height },
                    left: { x: element.x, y: element.y + element.height / 2 }
                };
                return points[position];
            },

            // Create Curve Path
            createCurvePath(x1, y1, x2, y2) {
                const dx = Math.abs(x2 - x1) / 2;
                const dy = Math.abs(y2 - y1) / 2;
                
                const cx1 = x1 + dx;
                const cy1 = y1;
                const cx2 = x2 - dx;
                const cy2 = y2;
                
                return `M ${x1} ${y1} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${x2} ${y2}`;
            },

            // Render Connection
            renderConnection(connection) {
                const fromElement = this.elements.find(e => e.id === connection.from.elementId);
                const toElement = this.elements.find(e => e.id === connection.to.elementId);
                
                if (!fromElement || !toElement) return;
                
                const svg = document.getElementById('connectionsSvg');
                const fromPos = this.getConnectionPoint(fromElement, connection.from.position);
                const toPos = this.getConnectionPoint(toElement, connection.to.position);
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.id = connection.id;
                path.setAttribute('class', 'connection-line');
                path.setAttribute('d', this.createCurvePath(fromPos.x, fromPos.y, toPos.x, toPos.y));
                path.setAttribute('marker-end', 'url(#arrowhead)');
                path.style.stroke = connection.style.stroke;
                path.style.strokeWidth = connection.style.strokeWidth;
                path.style.pointerEvents = 'stroke';
                
                path.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectConnection(connection);
                });
                
                svg.appendChild(path);
            },

            // Update Connections
            updateConnections() {
                const svg = document.getElementById('connectionsSvg');
                
                this.connections.forEach(connection => {
                    const path = document.getElementById(connection.id);
                    if (!path) return;
                    
                    const fromElement = this.elements.find(e => e.id === connection.from.elementId);
                    const toElement = this.elements.find(e => e.id === connection.to.elementId);
                    
                    if (!fromElement || !toElement) {
                        path.remove();
                        return;
                    }
                    
                    const fromPos = this.getConnectionPoint(fromElement, connection.from.position);
                    const toPos = this.getConnectionPoint(toElement, connection.to.position);
                    
                    path.setAttribute('d', this.createCurvePath(fromPos.x, fromPos.y, toPos.x, toPos.y));
                });
            },

            // Select Connection
            selectConnection(connection) {
                this.selectedElement = null;
                this.selectedConnection = connection;
                
                document.querySelectorAll('.connection-line').forEach(l => l.classList.remove('selected'));
                document.getElementById(connection.id)?.classList.add('selected');
                
                this.updatePropertiesPanel();
            },

            // Toggle Connect Mode
            toggleConnectMode() {
                this.connectMode = !this.connectMode;
                document.getElementById('connectModeBtn').classList.toggle('primary', this.connectMode);
                
                if (!this.connectMode) {
                    this.connectStart = null;
                    this.removeTempConnection();
                }
            },

            // Handle Canvas Click
            handleCanvasClick(e) {
                if (e.target.id === 'canvas' || e.target.classList.contains('connections-svg')) {
                    this.selectElement(null);
                }
                
                // Check if clicking on a connection point
                if (e.target.classList.contains('connection-point') && this.connectStart) {
                    const parentEl = e.target.closest('.canvas-element');
                    const element = this.elements.find(el => el.id === parentEl.id);
                    const position = e.target.classList.contains('top') ? 'top' :
                                    e.target.classList.contains('right') ? 'right' :
                                    e.target.classList.contains('bottom') ? 'bottom' : 'left';
                    this.completeConnection(element, position);
                }
            },

            // Handle Context Menu
            handleContextMenu(e) {
                e.preventDefault();
                
                const menu = document.getElementById('contextMenu');
                menu.style.left = `${e.clientX}px`;
                menu.style.top = `${e.clientY}px`;
                menu.classList.add('active');
            },

            // Hide Context Menu
            hideContextMenu() {
                document.getElementById('contextMenu').classList.remove('active');
            },

            // Delete Selected
            deleteSelected() {
                if (this.selectedElement) {
                    const el = document.getElementById(this.selectedElement.id);
                    if (el) el.remove();
                    
                    // Remove associated connections
                    this.connections = this.connections.filter(c => {
                        if (c.from.elementId === this.selectedElement.id || c.to.elementId === this.selectedElement.id) {
                            document.getElementById(c.id)?.remove();
                            return false;
                        }
                        return true;
                    });
                    
                    this.elements = this.elements.filter(e => e.id !== this.selectedElement.id);
                    this.selectedElement = null;
                    this.updatePropertiesPanel();
                    this.updateLayers();
                    this.updateStatus();
                    this.saveState();
                }
                
                if (this.selectedConnection) {
                    document.getElementById(this.selectedConnection.id)?.remove();
                    this.connections = this.connections.filter(c => c.id !== this.selectedConnection.id);
                    this.selectedConnection = null;
                    this.updateStatus();
                    this.saveState();
                }
            },

            // Duplicate Selected
            duplicateSelected() {
                if (!this.selectedElement) return;
                
                const newElement = this.createElement(
                    this.selectedElement.type,
                    this.selectedElement.x + 20,
                    this.selectedElement.y + 20,
                    {
                        width: this.selectedElement.width,
                        height: this.selectedElement.height,
                        content: this.selectedElement.content,
                        styles: { ...this.selectedElement.styles }
                    }
                );
                
                this.showToast('Element duplicated', 'success');
            },

            // Copy/Cut/Paste
            copySelected() {
                if (this.selectedElement) {
                    this.clipboard = { ...this.selectedElement };
                    this.showToast('Element copied', 'success');
                }
            },

            cutSelected() {
                if (this.selectedElement) {
                    this.clipboard = { ...this.selectedElement };
                    this.deleteSelected();
                    this.showToast('Element cut', 'success');
                }
            },

            paste() {
                if (this.clipboard) {
                    this.createElement(
                        this.clipboard.type,
                        this.clipboard.x + 20,
                        this.clipboard.y + 20,
                        {
                            width: this.clipboard.width,
                            height: this.clipboard.height,
                            content: this.clipboard.content,
                            styles: { ...this.clipboard.styles }
                        }
                    );
                    this.showToast('Element pasted', 'success');
                }
            },

            // Bring to Front / Send to Back
            bringToFront() {
                if (!this.selectedElement) return;
                
                const index = this.elements.findIndex(e => e.id === this.selectedElement.id);
                if (index > -1) {
                    const element = this.elements.splice(index, 1)[0];
                    this.elements.push(element);
                    
                    const el = document.getElementById(element.id);
                    if (el) {
                        el.style.zIndex = this.elements.length;
                    }
                }
                this.updateLayers();
            },

            sendToBack() {
                if (!this.selectedElement) return;
                
                const index = this.elements.findIndex(e => e.id === this.selectedElement.id);
                if (index > -1) {
                    const element = this.elements.splice(index, 1)[0];
                    this.elements.unshift(element);
                    
                    this.elements.forEach((el, i) => {
                        const domEl = document.getElementById(el.id);
                        if (domEl) domEl.style.zIndex = i + 1;
                    });
                }
                this.updateLayers();
            },

            // Zoom Controls
            zoomIn() {
                this.zoom = Math.min(2, this.zoom + 0.1);
                this.applyZoom();
            },

            zoomOut() {
                this.zoom = Math.max(0.25, this.zoom - 0.1);
                this.applyZoom();
            },

            resetZoom() {
                this.zoom = 1;
                this.applyZoom();
            },

            applyZoom() {
                const canvas = document.getElementById('canvas');
                canvas.style.transform = `scale(${this.zoom})`;
                canvas.style.transformOrigin = 'top left';
                document.getElementById('zoomValue').textContent = `${Math.round(this.zoom * 100)}%`;
            },

            // Update Layers Panel
            updateLayers() {
                const list = document.getElementById('layersList');
                list.innerHTML = '';
                
                [...this.elements].reverse().forEach(element => {
                    const item = document.createElement('div');
                    item.className = `layer-item ${this.selectedElement?.id === element.id ? 'selected' : ''}`;
                    item.innerHTML = `
                        <span class="layer-icon">${this.getTypeIcon(element.type)}</span>
                        <span>${element.type} - ${element.id}</span>
                        <span class="layer-visibility" onclick="event.stopPropagation(); app.toggleVisibility('${element.id}')">üëÅÔ∏è</span>
                    `;
                    item.addEventListener('click', () => this.selectElement(element));
                    list.appendChild(item);
                });
            },

            // Get Type Icon
            getTypeIcon(type) {
                const icons = {
                    button: 'üîò', input: 'üìù', textarea: 'üìÑ', checkbox: '‚òëÔ∏è',
                    dropdown: 'üìã', slider: 'üéöÔ∏è', stepper: 'üî¢', progress: 'üìä',
                    text: 'üî§', image: 'üñºÔ∏è', rectangle: '‚¨ú', circle: '‚≠ï',
                    triangle: 'üî∫', line: '‚ûñ'
                };
                return icons[type] || 'üì¶';
            },

            // Toggle Visibility
            toggleVisibility(id) {
                const el = document.getElementById(id);
                if (el) {
                    el.style.display = el.style.display === 'none' ? 'block' : 'none';
                }
            },

            // Update Status Bar
            updateStatus() {
                document.getElementById('statusElements').textContent = `Elements: ${this.elements.length}`;
                document.getElementById('statusConnections').textContent = `Connections: ${this.connections.length}`;
            },

            // Handle Keyboard Shortcuts
            handleKeyDown(e) {
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key.toLowerCase()) {
                        case 'z':
                            e.preventDefault();
                            this.undo();
                            break;
                        case 'y':
                            e.preventDefault();
                            this.redo();
                            break;
                        case 's':
                            e.preventDefault();
                            this.saveProject();
                            break;
                        case 'c':
                            e.preventDefault();
                            this.copySelected();
                            break;
                        case 'x':
                            e.preventDefault();
                            this.cutSelected();
                            break;
                        case 'v':
                            e.preventDefault();
                            this.paste();
                            break;
                        case 'd':
                            e.preventDefault();
                            this.duplicateSelected();
                            break;
                    }
                } else {
                    switch (e.key) {
                        case 'Delete':
                        case 'Backspace':
                            if (!e.target.matches('input, textarea')) {
                                this.deleteSelected();
                            }
                            break;
                        case 'c':
                            if (!e.target.matches('input, textarea')) {
                                this.toggleConnectMode();
                            }
                            break;
                        case 'Escape':
                            this.selectElement(null);
                            this.connectMode = false;
                            this.connectStart = null;
                            document.getElementById('connectModeBtn').classList.remove('primary');
                            break;
                    }
                }
            },

            // Save State for Undo/Redo
            saveState() {
                const state = {
                    elements: JSON.parse(JSON.stringify(this.elements)),
                    connections: JSON.parse(JSON.stringify(this.connections))
                };
                
                this.history = this.history.slice(0, this.historyIndex + 1);
                this.history.push(state);
                this.historyIndex = this.history.length - 1;
                
                // Limit history size
                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyIndex--;
                }
            },

            // Undo
            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.restoreState(this.history[this.historyIndex]);
                    this.showToast('Undo', 'success');
                }
            },

            // Redo
            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.restoreState(this.history[this.historyIndex]);
                    this.showToast('Redo', 'success');
                }
            },

            // Restore State
            restoreState(state) {
                // Clear current elements
                document.querySelectorAll('.canvas-element').forEach(el => el.remove());
                document.querySelectorAll('.connection-line:not(#temp-connection)').forEach(el => el.remove());
                
                this.elements = JSON.parse(JSON.stringify(state.elements));
                this.connections = JSON.parse(JSON.stringify(state.connections));
                
                // Re-render
                this.elements.forEach(element => this.renderElement(element));
                this.connections.forEach(connection => this.renderConnection(connection));
                
                this.selectedElement = null;
                this.updatePropertiesPanel();
                this.updateLayers();
                this.updateStatus();
            },

            // New Project
            newProject() {
                if (this.elements.length > 0) {
                    if (!confirm('Create new project? All unsaved changes will be lost.')) return;
                }
                
                document.querySelectorAll('.canvas-element').forEach(el => el.remove());
                document.querySelectorAll('.connection-line').forEach(el => el.remove());
                
                this.elements = [];
                this.connections = [];
                this.selectedElement = null;
                this.history = [];
                this.historyIndex = -1;
                this.elementCounter = 0;
                
                this.saveState();
                this.updatePropertiesPanel();
                this.updateLayers();
                this.updateStatus();
                
                this.showToast('New project created', 'success');
            },

            // Save Project
            saveProject() {
                const project = {
                    version: '1.0',
                    canvasWidth: document.getElementById('canvas').offsetWidth,
                    canvasHeight: document.getElementById('canvas').offsetHeight,
                    elements: this.elements,
                    connections: this.connections
                };
                
                const blob = new Blob([JSON.stringify(project, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ui-builder-project-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.showToast('Project saved', 'success');
            },

            // Load Project
            loadProject() {
                document.getElementById('fileInput').click();
            },

            // Handle File Load
            handleFileLoad(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const project = JSON.parse(event.target.result);
                        
                        // Clear current
                        document.querySelectorAll('.canvas-element').forEach(el => el.remove());
                        document.querySelectorAll('.connection-line').forEach(el => el.remove());
                        
                        // Apply canvas size
                        const canvas = document.getElementById('canvas');
                        canvas.style.width = `${project.canvasWidth}px`;
                        canvas.style.height = `${project.canvasHeight}px`;
                        
                        // Load elements
                        this.elements = project.elements || [];
                        this.connections = project.connections || [];
                        this.elementCounter = this.elements.length;
                        
                        // Re-render
                        this.elements.forEach(element => this.renderElement(element));
                        this.connections.forEach(connection => this.renderConnection(connection));
                        
                        this.selectedElement = null;
                        this.history = [];
                        this.historyIndex = -1;
                        this.saveState();
                        
                        this.updatePropertiesPanel();
                        this.updateLayers();
                        this.updateStatus();
                        
                        this.showToast('Project loaded', 'success');
                    } catch (err) {
                        this.showToast('Error loading project', 'error');
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            },

            // Export HTML
            exportHTML() {
                const canvas = document.getElementById('canvas');
                const canvasWidth = canvas.offsetWidth;
                const canvasHeight = canvas.offsetHeight;
                
                let elementsHTML = '';
                let elementsCSS = '';
                
                this.elements.forEach(element => {
                    const styles = element.styles || {};
                    let css = `
                        position: absolute;
                        left: ${element.x}px;
                        top: ${element.y}px;
                        width: ${element.width}px;
                        height: ${element.height}px;
                    `;
                    
                    if (styles.backgroundColor) css += `background-color: ${styles.backgroundColor};`;
                    if (styles.color) css += `color: ${styles.color};`;
                    if (styles.borderRadius) css += `border-radius: ${styles.borderRadius}px;`;
                    if (styles.fontSize) css += `font-size: ${styles.fontSize}px;`;
                    if (styles.opacity !== undefined) css += `opacity: ${styles.opacity};`;
                    if (styles.boxShadow) {
                        css += `box-shadow: ${styles.shadowX || 0}px ${styles.shadowY || 4}px ${styles.shadowBlur || 10}px ${styles.shadowColor || 'rgba(0,0,0,0.2)'};`;
                    }
                    
                    let html = '';
                    switch (element.type) {
                        case 'button':
                            html = `<button style="${css} border: none; cursor: pointer; display: flex; align-items: center; justify-content: center;">${element.content}</button>`;
                            break;
                        case 'input':
                            html = `<input type="text" placeholder="${element.content}" style="${css} border: 1px solid #ddd; padding: 8px 12px;">`;
                            break;
                        case 'textarea':
                            html = `<textarea placeholder="${element.content}" style="${css} border: 1px solid #ddd; padding: 8px 12px; resize: none;"></textarea>`;
                            break;
                        case 'checkbox':
                            html = `<label style="${css} display: flex; align-items: center; gap: 8px;"><input type="checkbox"><span>${element.content}</span></label>`;
                            break;
                        case 'dropdown':
                            const opts = element.content.split(',').map(o => `<option>${o.trim()}</option>`).join('');
                            html = `<select style="${css} border: 1px solid #ddd; padding: 8px 12px;">${opts}</select>`;
                            break;
                        case 'slider':
                            html = `<input type="range" value="${element.content}" style="${css}">`;
                            break;
                        case 'progress':
                            html = `<div style="${css} background: ${styles.backgroundColor || '#e0e0e0'}; overflow: hidden;"><div style="width: ${element.content}%; height: 100%; background: ${styles.fillColor || '#6366f1'};"></div></div>`;
                            break;
                        case 'text':
                            html = `<div style="${css} display: flex; align-items: center; font-weight: ${styles.fontWeight || 'normal'};">${element.content}</div>`;
                            break;
                        case 'rectangle':
                            html = `<div style="${css}"></div>`;
                            break;
                        case 'circle':
                            html = `<div style="${css} border-radius: 50%;"></div>`;
                            break;
                        case 'triangle':
                            html = `<div style="position: absolute; left: ${element.x}px; top: ${element.y}px; width: 0; height: 0; border-left: ${element.width/2}px solid transparent; border-right: ${element.width/2}px solid transparent; border-bottom: ${element.height}px solid ${styles.backgroundColor || '#2ecc71'};"></div>`;
                            break;
                        case 'line':
                            html = `<div style="${css} background: ${styles.backgroundColor || '#333'};"></div>`;
                            break;
                        default:
                            html = `<div style="${css}">${element.content}</div>`;
                    }
                    
                    elementsHTML += html + '\n';
                });
                
                // Generate SVG for connections
                let connectionsHTML = '';
                if (this.connections.length > 0) {
                    let paths = '';
                    this.connections.forEach(connection => {
                        const fromElement = this.elements.find(e => e.id === connection.from.elementId);
                        const toElement = this.elements.find(e => e.id === connection.to.elementId);
                        
                        if (fromElement && toElement) {
                            const fromPos = this.getConnectionPoint(fromElement, connection.from.position);
                            const toPos = this.getConnectionPoint(toElement, connection.to.position);
                            
                            paths += `<path d="${this.createCurvePath(fromPos.x, fromPos.y, toPos.x, toPos.y)}" 
                                fill="none" stroke="${connection.style.stroke}" stroke-width="${connection.style.strokeWidth}"
                                marker-end="url(#arrowhead)"/>\n`;
                        }
                    });
                    
                    connectionsHTML = `
                    <svg style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0;">
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#6366f1"/>
                            </marker>
                        </defs>
                        ${paths}
                    </svg>`;
                }
                
                const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI Builder Export</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #f0f0f0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .container {
            position: relative;
            width: ${canvasWidth}px;
            height: ${canvasHeight}px;
            background: white;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        ${connectionsHTML}
        ${elementsHTML}
    </div>
</body>
</html>`;
                
                const blob = new Blob([html], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ui-export-${Date.now()}.html`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.showToast('HTML exported successfully!', 'success');
            },

            // Open Modal
            openModal(id) {
                document.getElementById(id).classList.add('active');
            },

            // Close Modal
            closeModal(id) {
                document.getElementById(id).classList.remove('active');
            },

            // Apply Canvas Size
            applyCanvasSize() {
                const width = document.getElementById('canvasWidth').value;
                const height = document.getElementById('canvasHeight').value;
                
                const canvas = document.getElementById('canvas');
                canvas.style.width = `${width}px`;
                canvas.style.height = `${height}px`;
                
                document.getElementById('statusSize').textContent = `${width} √ó ${height}`;
                
                this.closeModal('canvasSizeModal');
                this.showToast('Canvas resized', 'success');
            },

            // Show Toast
            showToast(message, type = 'success') {
                const container = document.getElementById('toastContainer');
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.innerHTML = `${type === 'success' ? '‚úì' : '‚úï'} ${message}`;
                container.appendChild(toast);
                
                setTimeout(() => toast.remove(), 3000);
            }
        };

        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => app.init());
    </script>
</body>
</html>