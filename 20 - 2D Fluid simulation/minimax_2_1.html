<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Fluid Simulation - Navier-Stokes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a12 0%, #1a1a2e 50%, #0f0f1a 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        h1 {
            margin-bottom: 20px;
            font-size: 2rem;
            color: #00d4ff;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
            letter-spacing: 2px;
        }

        .main-container {
            display: flex;
            gap: 25px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1450px;
            width: 100%;
        }

        .canvas-wrapper {
            background: linear-gradient(145deg, #12121f, #0a0a14);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6),
                        inset 0 1px 0 rgba(255, 255, 255, 0.05),
                        0 0 40px rgba(0, 212, 255, 0.1);
        }

        canvas {
            display: block;
            border-radius: 12px;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5);
        }

        .controls {
            background: linear-gradient(145deg, #12121f, #0a0a14);
            border-radius: 20px;
            padding: 25px;
            min-width: 320px;
            max-width: 380px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6),
                        inset 0 1px 0 rgba(255, 255, 255, 0.05);
            max-height: fit-content;
        }

        .section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .section-title {
            color: #00d4ff;
            font-size: 0.9rem;
            font-weight: 700;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title::before {
            content: '';
            width: 5px;
            height: 18px;
            background: linear-gradient(180deg, #00d4ff, #00a8cc);
            border-radius: 3px;
        }

        .control-group {
            margin-bottom: 18px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 0.85rem;
            color: #b0b0c0;
        }

        .control-group label span:last-child {
            color: #00ff88;
            font-weight: 700;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg, #1a1a3a, #2a2a4a);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        input[type="range"]:hover {
            background: linear-gradient(90deg, #2a2a4a, #3a3a5a);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(145deg, #00d4ff, #00a8cc);
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.6),
                        0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 25px rgba(0, 212, 255, 0.8);
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .color-btn {
            aspect-ratio: 1;
            border: 3px solid transparent;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .color-btn:hover {
            transform: scale(1.1) rotate(5deg);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }

        .color-btn.active {
            border-color: #00d4ff;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5),
                        inset 0 0 10px rgba(255, 255, 255, 0.1);
            transform: scale(1.05);
        }

        .toggle-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .toggle-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: linear-gradient(145deg, #1a1a3a, #12122a);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .toggle-item:hover {
            background: linear-gradient(145deg, #252545, #1a1a3a);
            border-color: rgba(0, 212, 255, 0.2);
        }

        .toggle-item.active {
            background: linear-gradient(145deg, #1a3a4a, #0f2030);
            border-color: rgba(0, 212, 255, 0.3);
        }

        .toggle-label {
            font-size: 0.85rem;
            color: #c0c0d0;
        }

        .toggle-switch {
            width: 52px;
            height: 28px;
            background: linear-gradient(145deg, #2a2a4a, #1a1a3a);
            border-radius: 14px;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 24px;
            height: 24px;
            background: linear-gradient(145deg, #e0e0e0, #b0b0b0);
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .toggle-switch.active {
            background: linear-gradient(145deg, #00d4ff, #00a8cc);
        }

        .toggle-switch.active::after {
            transform: translateX(24px);
            background: white;
        }

        .action-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .action-btn {
            padding: 14px 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            background: linear-gradient(145deg, #1a1a3a, #12122a);
            color: #c0c0d0;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
        }

        .action-btn:hover {
            background: linear-gradient(145deg, #252550, #1a1a3a);
            border-color: rgba(0, 212, 255, 0.4);
            color: #00d4ff;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.2);
        }

        .action-btn:active {
            transform: translateY(0);
        }

        .action-btn .key-hint {
            display: block;
            font-size: 0.85rem;
            color: #e0e0e0;
            margin-bottom: 4px;
            font-family: 'Courier New', monospace;
        }

        .stats-panel {
            background: linear-gradient(145deg, #0f0f20, #0a0a14);
            border-radius: 14px;
            padding: 18px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .stat-item {
            background: linear-gradient(145deg, #15152a, #101020);
            padding: 14px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.03);
        }

        .stat-value {
            font-size: 1.4rem;
            font-weight: 800;
            background: linear-gradient(135deg, #00ff88, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-family: 'Courier New', monospace;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #808090;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 4px;
        }

        .help-box {
            background: linear-gradient(145deg, #1a2030, #101520);
            border-radius: 12px;
            padding: 18px;
            border-left: 4px solid #00d4ff;
        }

        .help-box h4 {
            color: #00d4ff;
            font-size: 0.85rem;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .help-box h4::before {
            content: '⌨';
            font-size: 1rem;
        }

        .help-grid {
            display: grid;
            gap: 8px;
        }

        .help-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.8rem;
            color: #a0a0b0;
        }

        .key-badge {
            display: inline-block;
            background: linear-gradient(145deg, #2a2a4a, #1a1a3a);
            padding: 3px 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-weight: 700;
            color: #00d4ff;
            font-size: 0.75rem;
            min-width: 28px;
            text-align: center;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }

        @media (max-width: 1150px) {
            .main-container {
                flex-direction: column;
                align-items: center;
            }

            .controls {
                width: 100%;
                max-width: 600px;
            }
        }
    </style>
</head>
<body>
    <h1>2D Fluid Simulation</h1>

    <div class="main-container">
        <div class="canvas-wrapper">
            <div id="canvas-container"></div>
        </div>

        <div class="controls">
            <div class="section">
                <div class="section-title">Fluid Dynamics</div>

                <div class="control-group">
                    <label>
                        <span>Viscosity</span>
                        <span id="visc-val">0.0002</span>
                    </label>
                    <input type="range" id="viscosity" min="0" max="100" value="30">
                </div>

                <div class="control-group">
                    <label>
                        <span>Diffusion</span>
                        <span id="diff-val">0.0001</span>
                    </label>
                    <input type="range" id="diffusion" min="0" max="100" value="20">
                </div>

                <div class="control-group">
                    <label>
                        <span>Vorticity Confinement</span>
                        <span id="vort-val">1.5</span>
                    </label>
                    <input type="range" id="vorticity" min="0" max="100" value="30">
                </div>

                <div class="control-group">
                    <label>
                        <span>Grid Resolution</span>
                        <span id="res-val">64</span>
                    </label>
                    <input type="range" id="resolution" min="32" max="128" value="64" step="8">
                </div>

                <div class="control-group">
                    <label>
                        <span>Color Fade Rate</span>
                        <span id="fade-val">0.015</span>
                    </label>
                    <input type="range" id="fade" min="1" max="100" value="30">
                </div>

                <div class="control-group">
                    <label>
                        <span>Density Amount</span>
                        <span id="dens-val">150</span>
                    </label>
                    <input type="range" id="density" min="50" max="300" value="150">
                </div>
            </div>

            <div class="section">
                <div class="section-title">Color Palette</div>
                <div class="color-grid">
                    <button class="color-btn active" data-color="0" style="background: linear-gradient(135deg, #ff4757, #ff6b81);" title="Red">R</button>
                    <button class="color-btn" data-color="1" style="background: linear-gradient(135deg, #2ed573, #7bed9f);" title="Green">G</button>
                    <button class="color-btn" data-color="2" style="background: linear-gradient(135deg, #3742fa, #5352ed);" title="Blue">B</button>
                    <button class="color-btn" data-color="3" style="background: linear-gradient(135deg, #ffa502, #ffbe76);" title="Orange">O</button>
                    <button class="color-btn" data-color="4" style="background: linear-gradient(135deg, #e056fd, #be2edd);" title="Purple">P</button>
                    <button class="color-btn" data-color="5" style="background: linear-gradient(135deg, #00d2d3, #01a3a4);" title="Teal">T</button>
                    <button class="color-btn" data-color="6" style="background: linear-gradient(135deg, #f1c40f, #f39c12);" title="Yellow">Y</button>
                    <button class="color-btn" data-color="7" style="background: linear-gradient(135deg, #ffffff, #dfe6e9);" title="White">W</button>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Options</div>
                <div class="toggle-grid">
                    <div class="toggle-item" id="vortex-toggle" data-enabled="false">
                        <span class="toggle-label">Vortex Force</span>
                        <div class="toggle-switch"></div>
                    </div>
                    <div class="toggle-item" id="velocity-toggle" data-enabled="false">
                        <span class="toggle-label">Show Flow</span>
                        <div class="toggle-switch"></div>
                    </div>
                    <div class="toggle-item" id="obstacle-toggle" data-enabled="true">
                        <span class="toggle-label">Obstacles</span>
                        <div class="toggle-switch active"></div>
                    </div>
                    <div class="toggle-item" id="flow-toggle" data-enabled="false">
                        <span class="toggle-label">Auto Flow</span>
                        <div class="toggle-switch"></div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Controls</div>
                <div class="action-grid">
                    <button class="action-btn" id="btn-reset">
                        <span class="key-hint">R</span>
                        Reset
                    </button>
                    <button class="action-btn" id="btn-pause">
                        <span class="key-hint">Space</span>
                        Pause
                    </button>
                    <button class="action-btn" id="btn-clear">
                        <span class="key-hint">C</span>
                        Clear
                    </button>
                </div>
            </div>

            <div class="section">
                <div class="stats-panel">
                    <div class="section-title">Statistics</div>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="fps-stat">0</div>
                            <div class="stat-label">FPS</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="cells-stat">0</div>
                            <div class="stat-label">Cells</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="total-stat">0</div>
                            <div class="stat-label">Total Mass</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="iter-stat">4</div>
                            <div class="stat-label">Iterations</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="help-box">
                <h4>Keyboard Shortcuts</h4>
                <div class="help-grid">
                    <div class="help-item">
                        <span class="key-badge">Drag</span>
                        <span>Add fluid & velocity</span>
                    </div>
                    <div class="help-item">
                        <span class="key-badge">1-8</span>
                        <span>Select color</span>
                    </div>
                    <div class="help-item">
                        <span class="key-badge">V</span>
                        <span>Toggle vortex</span>
                    </div>
                    <div class="help-item">
                        <span class="key-badge">O</span>
                        <span>Toggle obstacles</span>
                    </div>
                    <div class="help-item">
                        <span class="key-badge">F</span>
                        <span>Toggle auto flow</span>
                    </div>
                    <div class="help-item">
                        <span class="key-badge">Space</span>
                        <span>Pause/Resume</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Fluid Simulation - Based on Jos Stam's Stable Fluids
        // Using p5.js for rendering

        // Simulation parameters
        const SOLVER_ITER = 4;
        let fluid = null;
        let canvas;
        let config = {
            N: 64,
            viscosity: 0.0002,
            diffusion: 0.0001,
            vorticity: 1.5,
            fadeRate: 0.015,
            densityAmount: 150
        };

        // State
        let isPaused = false;
        let vortexEnabled = false;
        let showVelocity = false;
        let obstaclesEnabled = true;
        let autoFlow = false;
        let selectedColor = 0;
        let obstacles = [];

        // Color palette with RGB values (0-1 range)
        const colors = [
            { r: 1.0, g: 0.28, b: 0.34 },    // Red
            { r: 0.18, g: 0.84, b: 0.45 },   // Green
            { r: 0.22, g: 0.26, b: 0.98 },   // Blue
            { r: 1.0, g: 0.65, b: 0.01 },    // Orange
            { r: 0.88, g: 0.34, b: 0.99 },   // Purple
            { r: 0.0, g: 0.82, b: 0.83 },    // Teal
            { r: 0.95, g: 0.77, b: 0.06 },   // Yellow
            { r: 1.0, g: 1.0, b: 1.0 }       // White
        ];

        // Fluid class implementing Navier-Stokes
        class Fluid {
            constructor(N, diffusion, viscosity, vorticity) {
                this.N = N;
                this.size = (N + 2) * (N + 2);
                this.diff = diffusion;
                this.visc = viscosity;
                this.vort = vorticity;

                // Velocity field
                this.u = new Float32Array(this.size);
                this.v = new Float32Array(this.size);
                this.u_prev = new Float32Array(this.size);
                this.v_prev = new Float32Array(this.size);

                // Density field (combined)
                this.dens = new Float32Array(this.size);

                // RGB density fields for color mixing
                this.densR = new Float32Array(this.size);
                this.densG = new Float32Array(this.size);
                this.densB = new Float32Array(this.size);
                this.densR_prev = new Float32Array(this.size);
                this.densG_prev = new Float32Array(this.size);
                this.densB_prev = new Float32Array(this.size);

                // Vorticity field
                this.curl = new Float32Array(this.size);
            }

            // Convert 2D coordinates to 1D index
            IX(x, y) {
                x = Math.max(0, Math.min(this.N + 1, x));
                y = Math.max(0, Math.min(this.N + 1, y));
                return x + (this.N + 2) * y;
            }

            addDensity(x, y, amount) {
                const idx = this.IX(x, y);
                this.dens[idx] += amount;
            }

            addColor(x, y, r, g, b, amount) {
                const idx = this.IX(x, y);
                this.densR[idx] += r * amount;
                this.densG[idx] += g * amount;
                this.densB[idx] += b * amount;
                this.dens[idx] += amount;
            }

            addVelocity(x, y, amountX, amountY) {
                const idx = this.IX(x, y);
                this.u[idx] += amountX;
                this.v[idx] += amountY;
            }

            step() {
                const dt = 0.1;
                const N = this.N;
                const visc = this.visc;
                const diff = this.diff;
                const vort = this.vort;

                // Calculate vorticity
                this.calculateCurl();

                // Apply vorticity confinement
                if (vort > 0) {
                    this.applyVorticityConfinement(vort);
                }

                // Velocity step: diffuse -> project -> advect -> project
                this.diffuse(1, this.u_prev, this.u, visc, dt);
                this.diffuse(2, this.v_prev, this.v, visc, dt);
                this.project(this.u_prev, this.v_prev, this.u, this.v);
                this.advect(1, this.u, this.u_prev, this.u_prev, this.v_prev, dt);
                this.advect(2, this.v, this.v_prev, this.u_prev, this.v_prev, dt);
                this.project(this.u, this.v, this.u_prev, this.v_prev);

                // Density step: diffuse -> advect
                this.diffuse(0, this.dens_prev, this.dens, diff, dt);
                this.advect(0, this.dens, this.dens_prev, this.u, this.v, dt);

                // RGB density steps
                this.diffuse(3, this.densR_prev, this.densR, diff, dt);
                this.advect(3, this.densR, this.densR_prev, this.u, this.v, dt);

                this.diffuse(4, this.densG_prev, this.densG, diff, dt);
                this.advect(4, this.densG, this.densG_prev, this.u, this.v, dt);

                this.diffuse(5, this.densB_prev, this.densB, diff, dt);
                this.advect(5, this.densB, this.densB_prev, this.u, this.v, dt);

                // Apply obstacles
                if (obstaclesEnabled) {
                    this.applyObstacles();
                }

                // Fade out density
                this.fade(config.fadeRate);
            }

            calculateCurl() {
                const N = this.N;
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const idx = this.IX(i, j);
                        this.curl[idx] = 0.5 * (
                            (this.v[this.IX(i + 1, j)] - this.v[this.IX(i - 1, j)]) -
                            (this.u[this.IX(i, j + 1)] - this.u[this.IX(i, j - 1)])
                        );
                    }
                }
            }

            applyVorticityConfinement(strength) {
                const N = this.N;
                const dt = 0.1;
                const force = strength * 0.5;

                for (let j = 2; j <= N - 1; j++) {
                    for (let i = 2; i <= N - 1; i++) {
                        const idx = this.IX(i, j);

                        const curlVal = this.curl[idx];
                        const curlMag = Math.abs(curlVal) + 0.0001;

                        // Calculate gradient of curl magnitude
                        const dx = (Math.abs(this.curl[this.IX(i + 1, j)]) - Math.abs(this.curl[this.IX(i - 1, j)])) / 2;
                        const dy = (Math.abs(this.curl[this.IX(i, j + 1)]) - Math.abs(this.curl[this.IX(i, j - 1)])) / 2;

                        const len = Math.sqrt(dx * dx + dy * dy) + 0.0001;
                        const nx = dx / len;
                        const ny = dy / len;

                        // Apply perpendicular force
                        this.u[idx] += ny * curlVal * force * dt;
                        this.v[idx] -= nx * curlVal * force * dt;
                    }
                }
            }

            fade(rate) {
                for (let i = 0; i < this.size; i++) {
                    this.dens[i] *= (1 - rate);
                    this.densR[i] *= (1 - rate);
                    this.densG[i] *= (1 - rate);
                    this.densB[i] *= (1 - rate);

                    // Ensure no negative values
                    this.dens[i] = Math.max(0, this.dens[i]);
                    this.densR[i] = Math.max(0, this.densR[i]);
                    this.densG[i] = Math.max(0, this.densG[i]);
                    this.densB[i] = Math.max(0, this.densB[i]);
                }
            }

            applyObstacles() {
                for (const obs of obstacles) {
                    if (obs.type === 'circle') {
                        const cx = Math.floor(obs.x);
                        const cy = Math.floor(obs.y);
                        const r = Math.floor(obs.r);

                        for (let j = cy - r; j <= cy + r; j++) {
                            for (let i = cx - r; i <= cx + r; i++) {
                                const dx = i - cx;
                                const dy = j - cy;
                                if (dx * dx + dy * dy <= r * r && i >= 1 && i <= this.N && j >= 1 && j <= this.N) {
                                    const idx = this.IX(i, j);
                                    this.u[idx] *= 0.1;
                                    this.v[idx] *= 0.1;
                                }
                            }
                        }
                    } else if (obs.type === 'rect') {
                        for (let j = Math.floor(obs.y); j <= Math.ceil(obs.y + obs.h); j++) {
                            for (let i = Math.floor(obs.x); i <= Math.ceil(obs.x + obs.w); i++) {
                                if (i >= 1 && i <= this.N && j >= 1 && j <= this.N) {
                                    const idx = this.IX(i, j);
                                    this.u[idx] *= 0.1;
                                    this.v[idx] *= 0.1;
                                }
                            }
                        }
                    }
                }
            }

            diffuse(b, x, x0, diff, dt) {
                const a = dt * diff * this.N * this.N;
                this.lin_solve(b, x, x0, a, 1 + 4 * a);
            }

            lin_solve(b, x, x0, a, c) {
                const N = this.N;
                const cRecip = 1.0 / c;

                for (let k = 0; k < SOLVER_ITER; k++) {
                    for (let j = 1; j <= N; j++) {
                        for (let i = 1; i <= N; i++) {
                            const idx = this.IX(i, j);
                            x[idx] = (
                                x0[idx] +
                                a * (
                                    x[this.IX(i + 1, j)] +
                                    x[this.IX(i - 1, j)] +
                                    x[this.IX(i, j + 1)] +
                                    x[this.IX(i, j - 1)]
                                )
                            ) * cRecip;
                        }
                    }
                    this.set_bnd(b, x);
                }
            }

            project(velocX, velocY, p, div) {
                const N = this.N;
                const h = 1.0 / N;

                // Calculate divergence
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const idx = this.IX(i, j);
                        div[idx] = -0.5 * h * (
                            velocX[this.IX(i + 1, j)] - velocX[this.IX(i - 1, j)] +
                            velocY[this.IX(i, j + 1)] - velocY[this.IX(i, j - 1)]
                        );
                        p[idx] = 0;
                    }
                }

                this.set_bnd(0, div);
                this.set_bnd(0, p);
                this.lin_solve(0, p, div, 1, 4);

                // Subtract gradient
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const idx = this.IX(i, j);
                        velocX[idx] -= 0.5 * (p[this.IX(i + 1, j)] - p[this.IX(i - 1, j)]) / h;
                        velocY[idx] -= 0.5 * (p[this.IX(i, j + 1)] - p[this.IX(i, j - 1)]) / h;
                    }
                }

                this.set_bnd(1, velocX);
                this.set_bnd(2, velocY);
            }

            advect(b, d, d0, velocX, velocY, dt) {
                const N = this.N;
                const dt0 = dt * N;

                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const idx = this.IX(i, j);

                        // Backtrace
                        let x = i - dt0 * velocX[idx];
                        let y = j - dt0 * velocY[idx];

                        // Clamp
                        x = Math.max(0.5, Math.min(N + 0.5, x));
                        y = Math.max(0.5, Math.min(N + 0.5, y));

                        // Bilinear interpolation
                        const i0 = Math.floor(x);
                        const i1 = i0 + 1;
                        const j0 = Math.floor(y);
                        const j1 = j0 + 1;

                        const s1 = x - i0;
                        const s0 = 1 - s1;
                        const t1 = y - j0;
                        const t0 = 1 - t1;

                        d[idx] = s0 * (t0 * d0[this.IX(i0, j0)] + t1 * d0[this.IX(i0, j1)]) +
                                s1 * (t0 * d0[this.IX(i1, j0)] + t1 * d0[this.IX(i1, j1)]);
                    }
                }

                this.set_bnd(b, d);
            }

            set_bnd(b, x) {
                const N = this.N;

                // Handle edges (no-slip boundary)
                for (let i = 1; i <= N; i++) {
                    x[this.IX(i, 0)] = b === 2 ? -x[this.IX(i, 1)] : x[this.IX(i, 1)];
                    x[this.IX(i, N + 1)] = b === 2 ? -x[this.IX(i, N)] : x[this.IX(i, N)];
                    x[this.IX(0, i)] = b === 1 ? -x[this.IX(1, i)] : x[this.IX(1, i)];
                    x[this.IX(N + 1, i)] = b === 1 ? -x[this.IX(N, i)] : x[this.IX(N, i)];
                }

                // Handle corners
                x[this.IX(0, 0)] = 0.5 * (x[this.IX(1, 0)] + x[this.IX(0, 1)]);
                x[this.IX(0, N + 1)] = 0.5 * (x[this.IX(1, N + 1)] + x[this.IX(0, N)]);
                x[this.IX(N + 1, 0)] = 0.5 * (x[this.IX(N, 0)] + x[this.IX(N + 1, 1)]);
                x[this.IX(N + 1, N + 1)] = 0.5 * (x[this.IX(N, N + 1)] + x[this.IX(N + 1, N)]);
            }

            getTotalDensity() {
                let total = 0;
                for (let i = 0; i < this.size; i++) {
                    total += this.dens[i];
                }
                return total;
            }
        }

        function setup() {
            const resolution = parseInt(document.getElementById('resolution').value);
            const cellSize = 8;
            const canvasSize = resolution * cellSize;

            canvas = createCanvas(canvasSize, canvasSize);
            canvas.parent('canvas-container');

            initFluid(resolution);
            setupUI();
        }

        function initFluid(N) {
            config.N = N;
            fluid = new Fluid(
                N,
                config.diffusion,
                config.viscosity,
                config.vorticity
            );
            createObstacles();
        }

        function createObstacles() {
            obstacles = [];

            // Central circle obstacle
            obstacles.push({
                type: 'circle',
                x: config.N / 2,
                y: config.N / 2,
                r: config.N * 0.08
            });

            // Left rectangle
            obstacles.push({
                type: 'rect',
                x: config.N * 0.15,
                y: config.N * 0.25,
                w: config.N * 0.12,
                h: config.N * 0.05
            });

            // Right rectangle
            obstacles.push({
                type: 'rect',
                x: config.N * 0.73,
                y: config.N * 0.60,
                w: config.N * 0.05,
                h: config.N * 0.12
            });
        }

        function setupUI() {
            // Sliders
            document.getElementById('viscosity').addEventListener('input', function() {
                const val = this.value / 100000;
                document.getElementById('visc-val').textContent = val.toFixed(6);
                config.viscosity = val;
                if (fluid) fluid.visc = val;
            });

            document.getElementById('diffusion').addEventListener('input', function() {
                const val = this.value / 100000;
                document.getElementById('diff-val').textContent = val.toFixed(6);
                config.diffusion = val;
                if (fluid) fluid.diff = val;
            });

            document.getElementById('vorticity').addEventListener('input', function() {
                const val = this.value / 20;
                document.getElementById('vort-val').textContent = val.toFixed(1);
                config.vorticity = val;
                if (fluid) fluid.vort = val;
            });

            document.getElementById('resolution').addEventListener('input', function() {
                document.getElementById('res-val').textContent = this.value;
                initFluid(parseInt(this.value));
            });

            document.getElementById('fade').addEventListener('input', function() {
                const val = this.value / 2000;
                document.getElementById('fade-val').textContent = val.toFixed(3);
                config.fadeRate = val;
            });

            document.getElementById('density').addEventListener('input', function() {
                document.getElementById('dens-val').textContent = this.value;
                config.densityAmount = parseInt(this.value);
            });

            // Color buttons
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    selectedColor = parseInt(this.dataset.color);
                });
            });

            // Toggle buttons
            document.getElementById('vortex-toggle').addEventListener('click', function() {
                const enabled = this.dataset.enabled === 'true';
                this.dataset.enabled = !enabled;
                this.classList.toggle('active');
                this.querySelector('.toggle-switch').classList.toggle('active');
                vortexEnabled = !enabled;
            });

            document.getElementById('velocity-toggle').addEventListener('click', function() {
                const enabled = this.dataset.enabled === 'true';
                this.dataset.enabled = !enabled;
                this.classList.toggle('active');
                this.querySelector('.toggle-switch').classList.toggle('active');
                showVelocity = !enabled;
            });

            document.getElementById('obstacle-toggle').addEventListener('click', function() {
                const enabled = this.dataset.enabled === 'true';
                this.dataset.enabled = !enabled;
                this.classList.toggle('active');
                this.querySelector('.toggle-switch').classList.toggle('active');
                obstaclesEnabled = !enabled;
            });

            document.getElementById('flow-toggle').addEventListener('click', function() {
                const enabled = this.dataset.enabled === 'true';
                this.dataset.enabled = !enabled;
                this.classList.toggle('active');
                this.querySelector('.toggle-switch').classList.toggle('active');
                autoFlow = !enabled;
            });

            // Action buttons
            document.getElementById('btn-reset').addEventListener('click', resetSimulation);
            document.getElementById('btn-pause').addEventListener('click', togglePause);
            document.getElementById('btn-clear').addEventListener('click', clearFluid);
        }

        function resetSimulation() {
            initFluid(config.N);
        }

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('btn-pause').querySelector('.key-hint').textContent = isPaused ? 'Space' : 'Pause';
        }

        function clearFluid() {
            if (!fluid) return;
            for (let i = 0; i < fluid.size; i++) {
                fluid.dens[i] = 0;
                fluid.densR[i] = 0;
                fluid.densG[i] = 0;
                fluid.densB[i] = 0;
            }
        }

        function mouseDragged() {
            if (!fluid || mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) return;

            const N = fluid.N;
            const cellSize = width / N;
            const cellX = Math.floor(mouseX / cellSize) + 1;
            const cellY = Math.floor(mouseY / cellSize) + 1;

            // Calculate velocity from mouse movement
            const velX = (mouseX - pmouseX) * 1.5;
            const velY = (mouseY - pmouseY) * 1.5;

            // Get current color
            const col = colors[selectedColor];

            // Add density and velocity in a radius
            const radius = 3;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const x = cellX + dx;
                    const y = cellY + dy;
                    if (x >= 1 && x <= N && y >= 1 && y <= N) {
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist <= radius) {
                            const amount = (1 - dist / radius) * config.densityAmount * 0.1;

                            fluid.addColor(x, y, col.r, col.g, col.b, amount);
                            fluid.addVelocity(x, y, velX * amount * 0.01, velY * amount * 0.01);
                        }
                    }
                }
            }
        }

        function mousePressed() {
            mouseDragged();
        }

        function keyPressed() {
            // Number keys for color selection
            if (key >= '1' && key <= '8') {
                const colorIdx = parseInt(key) - 1;
                selectedColor = colorIdx;
                document.querySelectorAll('.color-btn').forEach((btn, i) => {
                    btn.classList.toggle('active', i === colorIdx);
                });
            }

            // Toggle keys
            if (key === 'v' || key === 'V') {
                document.getElementById('vortex-toggle').click();
            }
            if (key === 'o' || key === 'O') {
                document.getElementById('obstacle-toggle').click();
            }
            if (key === 'f' || key === 'F') {
                document.getElementById('flow-toggle').click();
            }
            if (key === ' ') {
                togglePause();
                return false; // Prevent scrolling
            }
            if (key === 'r' || key === 'R') {
                resetSimulation();
            }
            if (key === 'c' || key === 'C') {
                clearFluid();
            }
        }

        // FPS tracking
        let lastFrameTime = 0;
        let frameCount = 0;
        let currentFPS = 0;

        function draw() {
            // Dark background with subtle gradient
            background(8, 8, 15);

            // Calculate FPS
            frameCount++;
            if (millis() - lastFrameTime >= 1000) {
                currentFPS = frameCount;
                frameCount = 0;
                lastFrameTime = millis();
            }

            if (!fluid) return;

            // Update fluid
            if (!isPaused) {
                fluid.step();

                // Auto flow mode
                if (autoFlow) {
                    const t = millis() * 0.001;
                    for (let i = 5; i < fluid.N - 5; i += 4) {
                        const col = colors[Math.floor(t * 0.5 + i * 0.1) % 8];
                        const phase = Math.sin(t + i * 0.2) * 0.5 + 0.5;
                        fluid.addColor(i, 2, col.r, col.g, col.b, phase * 3);
                        fluid.addVelocity(i, 2, 0, phase * 2);
                    }
                }

                // Vortex mode
                if (vortexEnabled) {
                    const cx = fluid.N / 2;
                    const cy = fluid.N / 2;
                    const radius = fluid.N * 0.15;

                    for (let j = Math.floor(cy - radius); j <= Math.ceil(cy + radius); j++) {
                        for (let i = Math.floor(cx - radius); i <= Math.ceil(cx + radius); i++) {
                            const dx = i - cx;
                            const dy = j - cy;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < radius && dist > radius * 0.2) {
                                const force = 0.8;
                                const angle = Math.atan2(dy, dx);
                                fluid.addVelocity(i, j, -Math.sin(angle) * force, Math.cos(angle) * force);
                            }
                        }
                    }
                }
            }

            // Render fluid
            const N = fluid.N;
            const cellSize = width / N;

            noStroke();
            for (let j = 1; j <= N; j++) {
                for (let i = 1; i <= N; i++) {
                    const idx = fluid.IX(i, j);
                    const x = (i - 1) * cellSize;
                    const y = (j - 1) * cellSize;

                    // Get RGB values
                    let r = fluid.densR[idx] * 255;
                    let g = fluid.densG[idx] * 255;
                    let b = fluid.densB[idx] * 255;

                    // Clamp values
                    r = Math.min(255, Math.max(0, r));
                    g = Math.min(255, Math.max(0, g));
                    b = Math.min(255, Math.max(0, b));

                    // Add glow effect for high density
                    const density = fluid.dens[idx];
                    if (density > 0.3) {
                        const glow = Math.min(1, (density - 0.3) * 0.4);
                        r += glow * 40;
                        g += glow * 40;
                        b += glow * 40;
                    }

                    // Draw cell
                    fill(r, g, b);
                    rect(x, y, cellSize + 0.5, cellSize + 0.5);
                }
            }

            // Draw obstacles
            if (obstaclesEnabled) {
                fill(60, 60, 80);
                stroke(80, 80, 100);
                strokeWeight(1);

                for (const obs of obstacles) {
                    if (obs.type === 'circle') {
                        ellipse(
                            (obs.x) * cellSize,
                            (obs.y) * cellSize,
                            obs.r * 2 * cellSize,
                            obs.r * 2 * cellSize
                        );
                    } else {
                        rect(
                            obs.x * cellSize,
                            obs.y * cellSize,
                            obs.w * cellSize,
                            obs.h * cellSize
                        );
                    }
                }
                noStroke();
            }

            // Draw velocity field
            if (showVelocity) {
                stroke(255, 255, 255, 80);
                strokeWeight(1);
                const step = 4;

                for (let j = step; j <= N; j += step) {
                    for (let i = step; i <= N; i += step) {
                        const idx = fluid.IX(i, j);
                        const x = (i - 0.5) * cellSize;
                        const y = (j - 0.5) * cellSize;

                        const vx = fluid.u[idx] * 8;
                        const vy = fluid.v[idx] * 8;

                        const len = Math.sqrt(vx * vx + vy * vy);
                        if (len > 0.3) {
                            const scale = Math.min(len, 8) / len;
                            line(x, y, x + vx * scale, y + vy * scale);
                        }
                    }
                }
                noStroke();
            }

            // Update statistics
            document.getElementById('fps-stat').textContent = currentFPS;
            document.getElementById('cells-stat').textContent = (N * N).toLocaleString();
            document.getElementById('total-stat').textContent = Math.floor(fluid.getTotalDensity()).toLocaleString();
            document.getElementById('iter-stat').textContent = SOLVER_ITER;
        }
    </script>

<script>
/**
 * Iframe 元素高亮注入脚本
 * 需要在目标网站中引入此脚本来支持跨域 iframe 高亮功能
 *
 * 使用方法：
 * 1. 将此脚本添加到目标网站的 HTML 中
 * 2. 或通过浏览器扩展、用户脚本等方式注入
 */

(function () {
  "use strict";

  // 检查是否在 iframe 中
  if (window.self === window.top) {
    return; // 不在 iframe 中，不执行
  }

  // 检查是否已经初始化过
  if (window.__iframeHighlightInitialized) {
    return;
  }
  window.__iframeHighlightInitialized = true;
  console.log("Iframe 高亮脚本已加载");

  // 创建高亮覆盖层
  var overlay = document.createElement("div");
  overlay.id = "iframe-highlight-overlay";
  overlay.style.cssText = "\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n    pointer-events: none;\n    z-index: 999999;\n    overflow: hidden;\n  ";

  // 创建悬停高亮框（虚线边框）
  var highlightBox = document.createElement("div");
  highlightBox.id = "iframe-highlight-box";
  highlightBox.style.cssText = "\n    position: absolute;\n    border: 2px dashed #007AFF;\n    background: rgba(0, 122, 255, 0.08);\n    pointer-events: none;\n    display: none;\n    transition: all 0.1s ease;\n    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.8);\n    border-radius: 2px;\n  ";

  // 创建选中节点的常驻高亮框（实线边框）
  var selectedBox = document.createElement("div");
  selectedBox.id = "iframe-selected-box";
  selectedBox.style.cssText = "\n    position: absolute;\n    border: 2px solid #007AFF;\n    pointer-events: none;\n    display: none;\n    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.9), 0 0 8px rgba(255, 107, 53, 0.4);\n    border-radius: 2px;\n    z-index: 1000000;\n  ";

  // 创建悬停标签显示
  var tagLabel = document.createElement("div");
  tagLabel.id = "iframe-tag-label";
  tagLabel.style.cssText = "\n    position: absolute;\n    background: #007AFF;\n    color: white;\n    padding: 2px 6px;\n    font-size: 11px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    border-radius: 2px;\n    pointer-events: none;\n    display: none;\n    white-space: nowrap;\n    z-index: 1000001;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    font-weight: 500;\n  ";

  // 创建选中节点标签
  var selectedLabel = document.createElement("div");
  selectedLabel.id = "iframe-selected-label";
  selectedLabel.style.cssText = "\n    position: absolute;\n    background: #007AFF;\n    color: white;\n    padding: 3px 8px;\n    font-size: 11px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    border-radius: 3px;\n    pointer-events: none;\n    display: none;\n    white-space: nowrap;\n    z-index: 1000002;\n    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);\n    font-weight: 600;\n  ";
  overlay.appendChild(highlightBox);
  overlay.appendChild(selectedBox);
  overlay.appendChild(tagLabel);
  overlay.appendChild(selectedLabel);
  document.body.appendChild(overlay);

  // 存储当前选中的元素
  var selectedElement = null;
  var highlightEnabled = false;

  // 更新选中元素的高亮显示
  function updateSelectedHighlight(element) {
    console.log("updateSelectedHighlight called with:", element);
    if (!element) {
      selectedBox.style.display = "none";
      selectedLabel.style.display = "none";
      selectedElement = null;
      console.log("Cleared selected highlight");
      return;
    }
    selectedElement = element;
    var rect = element.getBoundingClientRect();
    console.log("Selected element rect:", rect);

    // 更新选中高亮框位置
    selectedBox.style.display = "block";
    selectedBox.style.left = "".concat(rect.left - 2, "px");
    selectedBox.style.top = "".concat(rect.top - 2, "px");
    selectedBox.style.width = "".concat(rect.width + 4, "px");
    selectedBox.style.height = "".concat(rect.height + 4, "px");

    // 更新选中标签位置和内容
    selectedLabel.style.display = "block";
    selectedLabel.textContent = "\u2713 <".concat(element.tagName.toLowerCase(), ">");

    // 计算标签位置，确保不超出视窗
    var labelTop = rect.top - 28;
    var labelLeft = rect.left;

    // 如果标签会超出顶部，显示在元素下方
    if (labelTop < 5) {
      labelTop = rect.bottom + 5;
    }

    // 如果标签会超出右侧，向左调整
    var labelWidth = selectedLabel.offsetWidth || 100; // 预估宽度
    if (labelLeft + labelWidth > window.innerWidth - 10) {
      labelLeft = window.innerWidth - labelWidth - 10;
    }
    selectedLabel.style.left = "".concat(Math.max(5, labelLeft), "px");
    selectedLabel.style.top = "".concat(labelTop, "px");
    console.log("Selected highlight positioned at:", {
      left: selectedBox.style.left,
      top: selectedBox.style.top,
      width: selectedBox.style.width,
      height: selectedBox.style.height
    });
  }
  function getElementSelector(element) {
    if (!(element instanceof Element)) throw new Error('Argument must be a DOM element');
    var segments = [];
    var current = element;
    while (current !== document.documentElement) {
      var selector = '';
      // 优先检查唯一ID
      if (current.id && document.querySelectorAll("#".concat(current.id)).length === 1) {
        segments.unshift("#".concat(current.id));
        break; // ID唯一，无需继续向上
      }

      // 生成类名选择器（取第一个有效类名）
      var classes = Array.from(current.classList).filter(function (c) {
        return !c.startsWith('js-');
      });
      var className = classes.length > 0 ? ".".concat(classes[0]) : '';

      // 生成位置索引（nth-child）
      var tag = current.tagName.toLowerCase();
      if (!className) {
        var siblings = Array.from(current.parentNode.children);
        var index = siblings.findIndex(function (el) {
          return el === current;
        }) + 1;
        selector = "".concat(tag, ":nth-child(").concat(index, ")");
      } else {
        selector = className;
      }
      segments.unshift(selector);
      current = current.parentElement;
    }

    // 处理根元素
    if (current === document.documentElement) {
      segments.unshift('html');
    }
    return segments.join(' > ');
  }

  // 获取元素文本内容
  function getElementText(element) {
    var _element$textContent;
    if (element.tagName === "INPUT") {
      return element.value || element.placeholder || "";
    }
    if (element.tagName === "TEXTAREA") {
      return element.value || element.placeholder || "";
    }
    var text = ((_element$textContent = element.textContent) === null || _element$textContent === void 0 ? void 0 : _element$textContent.trim()) || "";
    return text.length > 50 ? text.substring(0, 50) + "..." : text;
  }

  // 获取元素属性信息
  function getElementAttributes(element) {
    var attrs = {};
    for (var i = 0; i < element.attributes.length; i++) {
      var attr = element.attributes[i];
      attrs[attr.name] = attr.value;
    }
    return attrs;
  }

  // 鼠标悬停事件处理
  function handleMouseOver(e) {
    if (!highlightEnabled) return;
    var target = e.target;
    if (!target || target === overlay || target === highlightBox || target === tagLabel || target === selectedBox || target === selectedLabel) {
      return;
    }

    // 避免高亮 html 和 body 元素
    if (target === document.documentElement || target === document.body) {
      return;
    }

    // 如果是已选中的元素，不显示悬停高亮
    if (target === selectedElement) {
      highlightBox.style.display = "none";
      tagLabel.style.display = "none";
      return;
    }
    var rect = target.getBoundingClientRect();
    var selector = getElementSelector(target);
    var text = getElementText(target);
    var attributes = getElementAttributes(target);

    // 更新悬停高亮框位置
    highlightBox.style.display = "block";
    highlightBox.style.left = "".concat(rect.left - 2, "px");
    highlightBox.style.top = "".concat(rect.top - 2, "px");
    highlightBox.style.width = "".concat(rect.width + 4, "px");
    highlightBox.style.height = "".concat(rect.height + 4, "px");

    // 更新标签位置和内容
    tagLabel.style.display = "block";
    tagLabel.textContent = "<".concat(target.tagName.toLowerCase(), ">");

    // 计算标签位置，确保不超出视窗
    var labelTop = rect.top - 22;
    var labelLeft = rect.left;

    // 如果标签会超出顶部，显示在元素下方
    if (labelTop < 0) {
      labelTop = rect.bottom + 5;
    }

    // 如果标签会超出右侧，向左调整
    if (labelLeft + tagLabel.offsetWidth > window.innerWidth) {
      labelLeft = window.innerWidth - tagLabel.offsetWidth - 5;
    }
    tagLabel.style.left = "".concat(Math.max(0, labelLeft), "px");
    tagLabel.style.top = "".concat(labelTop, "px");

    // 发送消息到父窗口
    var elementInfo = {
      tagName: target.tagName.toLowerCase(),
      rect: {
        left: rect.left,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.width,
        height: rect.height,
        x: rect.x,
        y: rect.y
      },
      selector: selector,
      text: text,
      attributes: attributes,
      url: window.location.href,
      path: window.location.pathname,
      timestamp: Date.now()
    };
    try {
      window.parent.postMessage({
        type: "iframe-element-hover",
        data: elementInfo,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("无法发送消息到父窗口:", error);
    }
  }

  // 鼠标离开事件处理
  function handleMouseOut(e) {
    if (!highlightEnabled) return;
    var relatedTarget = e.relatedTarget;

    // 如果鼠标移动到高亮相关元素上，不隐藏高亮
    if (relatedTarget && (relatedTarget === highlightBox || relatedTarget === tagLabel || relatedTarget === overlay || relatedTarget === selectedBox || relatedTarget === selectedLabel)) {
      return;
    }
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    try {
      window.parent.postMessage({
        type: "iframe-element-hover",
        data: null,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("无法发送消息到父窗口:", error);
    }
  }

  // 点击事件处理
  function handleClick(e) {
    var target = e.target;
    if (!target || target === overlay || target === highlightBox || target === tagLabel || target === selectedBox || target === selectedLabel) {
      return;
    }

    // 避免处理 html 和 body 元素
    if (target === document.documentElement || target === document.body) {
      return;
    }

    // 检查是否是交互元素，这些元素需要保留默认行为
    var isInteractiveElement = ['input', 'textarea', 'select', 'button', 'a'].includes(target.tagName.toLowerCase());

    // 如果高亮功能启用，对于非交互元素阻止默认行为和事件传播
    if (highlightEnabled) {
      e.preventDefault();
      e.stopPropagation();
    }
    var rect = target.getBoundingClientRect();
    var selector = getElementSelector(target);
    var text = getElementText(target);
    var attributes = getElementAttributes(target);
    console.log("Element clicked:", {
      tagName: target.tagName,
      selector: selector,
      rect: rect
    });

    // 立即更新选中高亮
    updateSelectedHighlight(target);

    // 隐藏悬停高亮，因为现在是选中状态
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    var elementInfo = {
      tagName: target.tagName.toLowerCase(),
      rect: {
        left: rect.left,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.width,
        height: rect.height,
        x: rect.x,
        y: rect.y
      },
      selector: selector,
      text: text,
      attributes: attributes,
      url: window.location.href,
      path: window.location.pathname,
      timestamp: Date.now()
    };
    try {
      window.parent.postMessage({
        type: "iframe-element-click",
        data: elementInfo,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("无法发送消息到父窗口:", error);
    }
  }

  // 监听来自父窗口的消息
  function handleParentMessage(event) {
    console.log("Received message from parent:", event.data);
    if (event.data.type === "iframe-highlight-toggle") {
      var enabled = event.data.enabled;
      console.log("Highlight toggle:", enabled);
      if (enabled) {
        enableHighlight();
      } else {
        disableHighlight();
      }
    } else if (event.data.type === "enable-iframe-highlight") {
      console.log("Enable iframe highlight");
      enableHighlight();
    } else if (event.data.type === "disable-iframe-highlight") {
      console.log("Disable iframe highlight");
      disableHighlight();
    } else if (event.data.type === "toggle-iframe-highlight") {
      var _enabled = event.data.enabled !== undefined ? event.data.enabled : !highlightEnabled;
      console.log("Toggle iframe highlight to:", _enabled);
      if (_enabled) {
        enableHighlight();
      } else {
        disableHighlight();
      }
    } else if (event.data.type === "update-selected-element") {
      var selector = event.data.selector;
      console.log("Update selected element with selector:", selector);
      if (selector) {
        try {
          var element = document.querySelector(selector);
          console.log("Found element by selector:", element);
          updateSelectedHighlight(element);
        } catch (error) {
          console.warn("Failed to select element:", error);
          updateSelectedHighlight(null);
        }
      } else {
        updateSelectedHighlight(null);
      }
    } else if (event.data.type === "clear-selected-element") {
      console.log("Clear selected element");
      updateSelectedHighlight(null);
    }
  }

  // 启用高亮功能
  function enableHighlight() {
    console.log("Enabling highlight");
    document.addEventListener("mouseover", handleMouseOver, true);
    document.addEventListener("mouseout", handleMouseOut, true);
    document.addEventListener("click", handleClick, true);
    highlightEnabled = true;
    overlay.style.display = "block";
  }

  // 禁用高亮功能
  function disableHighlight() {
    console.log("Disabling highlight");
    highlightEnabled = false;
    // 保持事件监听器，但通过 highlightEnabled 变量控制行为
    // 这样可以保留选中状态的显示
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    // 不隐藏 selectedBox 和 selectedLabel，保留选中状态
  }

  // 完全禁用高亮功能（移除所有监听器）
  function fullyDisableHighlight() {
    console.log("Fully disabling highlight");
    highlightEnabled = false;
    document.removeEventListener("mouseover", handleMouseOver, true);
    document.removeEventListener("mouseout", handleMouseOut, true);
    document.removeEventListener("click", handleClick, true);
    overlay.style.display = "none";
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    selectedBox.style.display = "none";
    selectedLabel.style.display = "none";
  }

  // 添加事件监听
  enableHighlight();
  window.addEventListener("message", handleParentMessage);

  // 暴露全局函数供外部调用
  window.__iframeHighlightControl = {
    enable: enableHighlight,
    disable: disableHighlight,
    fullyDisable: fullyDisableHighlight,
    isEnabled: function isEnabled() {
      return highlightEnabled;
    },
    getSelectedElement: function getSelectedElement() {
      return selectedElement;
    },
    updateSelected: updateSelectedHighlight,
    // 通过消息发送开关控制
    sendToggleMessage: function sendToggleMessage(enabled) {
      window.parent.postMessage({
        type: 'iframe-highlight-status',
        enabled: enabled || highlightEnabled,
        source: 'iframe-highlight-injector'
      }, '*');
    }
  };

  // 通知父窗口脚本已加载
  try {
    window.parent.postMessage({
      type: "iframe-highlight-ready",
      data: {
        url: window.location.href,
        userAgent: navigator.userAgent,
        timestamp: Date.now()
      },
      source: "iframe-highlight-injector"
    }, "*");
  } catch (error) {
    console.warn("无法发送就绪消息到父窗口:", error);
  }

  // 清理函数
  window.__iframeHighlightCleanup = function () {
    fullyDisableHighlight();
    window.removeEventListener("message", handleParentMessage);
    if (overlay.parentElement) {
      overlay.parentElement.removeChild(overlay);
    }
    delete window.__iframeHighlightInitialized;
    delete window.__iframeHighlightCleanup;
  };
})();

</script>
</body>
</html>