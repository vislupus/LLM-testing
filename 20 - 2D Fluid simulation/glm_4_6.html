<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Fluid Dynamics Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #canvas-container {
            position: relative;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 300px;
            transition: transform 0.3s ease;
        }

        .controls.hidden {
            transform: translateX(-320px);
        }

        .controls h3 {
            margin-top: 0;
            color: #64b5f6;
            font-size: 18px;
            margin-bottom: 15px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #b3e5fc;
        }

        .slider {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #64b5f6;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #64b5f6;
            cursor: pointer;
        }

        .color-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .color-btn {
            width: 40px;
            height: 40px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .color-btn:hover {
            transform: scale(1.1);
            border-color: white;
        }

        .color-btn.active {
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            flex: 1;
            padding: 8px 12px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            font-size: 12px;
            max-width: 250px;
        }

        .info h4 {
            margin-top: 0;
            color: #64b5f6;
            margin-bottom: 10px;
        }

        .info div {
            margin: 5px 0;
        }

        .toggle-btn {
            position: absolute;
            top: 20px;
            left: 340px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 0 10px 10px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-btn.shifted {
            left: 20px;
        }

        .toggle-btn:hover {
            background: rgba(0, 0, 0, 0.9);
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div class="controls" id="controls">
            <h3>üåä Fluid Controls</h3>
            
            <div class="control-group">
                <label>Viscosity: <span id="viscosityValue">0.0001</span></label>
                <input type="range" class="slider" id="viscosity" min="0" max="0.001" step="0.00001" value="0.0001">
            </div>
            
            <div class="control-group">
                <label>Diffusion: <span id="diffusionValue">0.00001</span></label>
                <input type="range" class="slider" id="diffusion" min="0" max="0.0001" step="0.000001" value="0.00001">
            </div>
            
            <div class="control-group">
                <label>Force Scale: <span id="forceValue">5</span></label>
                <input type="range" class="slider" id="force" min="1" max="20" step="0.5" value="5">
            </div>
            
            <div class="control-group">
                <label>Color Palette</label>
                <div class="color-buttons">
                    <div class="color-btn active" style="background: linear-gradient(45deg, #ff6b6b, #4ecdc4)" data-color="gradient"></div>
                    <div class="color-btn" style="background: #ff6b6b" data-color="red"></div>
                    <div class="color-btn" style="background: #4ecdc4" data-color="cyan"></div>
                    <div class="color-btn" style="background: #45b7d1" data-color="blue"></div>
                    <div class="color-btn" style="background: #96ceb4" data-color="green"></div>
                    <div class="color-btn" style="background: #ffeaa7" data-color="yellow"></div>
                    <div class="color-btn" style="background: #dfe6e9" data-color="white"></div>
                    <div class="color-btn" style="background: #a29bfe" data-color="purple"></div>
                </div>
            </div>
            
            <div class="action-buttons">
                <button class="btn" onclick="fluidSim.toggleVortex()">üåÄ Vortex</button>
                <button class="btn" onclick="fluidSim.toggleObstacles()">üöß Walls</button>
                <button class="btn" onclick="fluidSim.reset()">üîÑ Reset</button>
            </div>
        </div>
        
        <button class="toggle-btn" id="toggleBtn" onclick="toggleControls()">‚ò∞</button>
        
        <div class="info">
            <h4>üéÆ Instructions</h4>
            <div>üñ±Ô∏è <strong>Click & Drag:</strong> Add fluid and velocity</div>
            <div>‚å®Ô∏è <strong>Space:</strong> Pause/Resume</div>
            <div>‚å®Ô∏è <strong>C:</strong> Clear density</div>
            <div>‚å®Ô∏è <strong>R:</strong> Random burst</div>
            <div>‚å®Ô∏è <strong>1-8:</strong> Quick colors</div>
        </div>
    </div>

    <script>
        class FluidSimulation {
            constructor() {
                this.size = 128;
                this.dt = 0.016;
                this.diff = 0.00001;
                this.visc = 0.0001;
                this.forceScale = 5;
                
                this.s = [];
                this.density = [];
                this.densityPrev = [];
                this.vx = [];
                this.vy = [];
                this.vxPrev = [];
                this.vyPrev = [];
                
                this.currentColor = { r: 1, g: 0.5, b: 0.5 };
                this.colorMode = 'gradient';
                this.vortexEnabled = false;
                this.obstaclesEnabled = false;
                this.paused = false;
                
                this.mouseX = 0;
                this.mouseY = 0;
                this.prevMouseX = 0;
                this.prevMouseY = 0;
                this.mouseDown = false;
                
                this.obstacles = [];
                this.init();
            }
            
            init() {
                const N = this.size;
                for (let i = 0; i < N * N; i++) {
                    this.s[i] = 0;
                    this.density[i] = 0;
                    this.densityPrev[i] = 0;
                    this.vx[i] = 0;
                    this.vy[i] = 0;
                    this.vxPrev[i] = 0;
                    this.vyPrev[i] = 0;
                }
                
                // Create some initial obstacles
                this.createObstacles();
            }
            
            createObstacles() {
                this.obstacles = [];
                const N = this.size;
                
                // Add boundary walls
                for (let i = 0; i < N; i++) {
                    this.obstacles.push(i); // Top
                    this.obstacles.push((N - 1) * N + i); // Bottom
                    this.obstacles.push(i * N); // Left
                    this.obstacles.push(i * N + N - 1); // Right
                }
                
                // Add some internal obstacles
                const cx = Math.floor(N / 2);
                const cy = Math.floor(N / 2);
                const radius = Math.floor(N / 8);
                
                for (let i = -radius; i <= radius; i++) {
                    for (let j = -radius; j <= radius; j++) {
                        if (i * i + j * j <= radius * radius) {
                            const idx = (cy + i) * N + (cx + j);
                            if (idx >= 0 && idx < N * N) {
                                this.obstacles.push(idx);
                            }
                        }
                    }
                }
            }
            
            IX(x, y) {
                x = constrain(x, 0, this.size - 1);
                y = constrain(y, 0, this.size - 1);
                return x + y * this.size;
            }
            
            addDensity(x, y, amount) {
                const idx = this.IX(x, y);
                this.density[idx] += amount;
            }
            
            addVelocity(x, y, amountX, amountY) {
                const idx = this.IX(x, y);
                this.vx[idx] += amountX;
                this.vy[idx] += amountY;
            }
            
            diffuse(b, x, x0, diff, dt) {
                const a = dt * diff * (this.size - 2) * (this.size - 2);
                this.linearSolve(b, x, x0, a, 1 + 6 * a);
            }
            
            linearSolve(b, x, x0, a, c) {
                const cRecip = 1.0 / c;
                
                for (let k = 0; k < 20; k++) {
                    for (let j = 1; j < this.size - 1; j++) {
                        for (let i = 1; i < this.size - 1; i++) {
                            const idx = this.IX(i, j);
                            if (this.obstaclesEnabled && this.obstacles.includes(idx)) continue;
                            
                            x[idx] = (x0[idx] + a * (
                                x[this.IX(i + 1, j)] +
                                x[this.IX(i - 1, j)] +
                                x[this.IX(i, j + 1)] +
                                x[this.IX(i, j - 1)]
                            )) * cRecip;
                        }
                    }
                    this.setBounds(b, x);
                }
            }
            
            project(velocX, velocY, p, div) {
                const N = this.size;
                
                for (let j = 1; j < N - 1; j++) {
                    for (let i = 1; i < N - 1; i++) {
                        const idx = this.IX(i, j);
                        if (this.obstaclesEnabled && this.obstacles.includes(idx)) continue;
                        
                        div[idx] = -0.5 * (
                            velocX[this.IX(i + 1, j)] -
                            velocX[this.IX(i - 1, j)] +
                            velocY[this.IX(i, j + 1)] -
                            velocY[this.IX(i, j - 1)]
                        ) / N;
                        p[idx] = 0;
                    }
                }
                
                this.setBounds(0, div);
                this.setBounds(0, p);
                this.linearSolve(0, p, div, 1, 6);
                
                for (let j = 1; j < N - 1; j++) {
                    for (let i = 1; i < N - 1; i++) {
                        const idx = this.IX(i, j);
                        if (this.obstaclesEnabled && this.obstacles.includes(idx)) continue;
                        
                        velocX[idx] -= 0.5 * (p[this.IX(i + 1, j)] - p[this.IX(i - 1, j)]) * N;
                        velocY[idx] -= 0.5 * (p[this.IX(i, j + 1)] - p[this.IX(i, j - 1)]) * N;
                    }
                }
                
                this.setBounds(1, velocX);
                this.setBounds(2, velocY);
            }
            
            advect(b, d, d0, velocX, velocY, dt) {
                const N = this.size;
                const dt0 = dt * N;
                
                for (let j = 1; j < N - 1; j++) {
                    for (let i = 1; i < N - 1; i++) {
                        const idx = this.IX(i, j);
                        if (this.obstaclesEnabled && this.obstacles.includes(idx)) {
                            d[idx] = 0;
                            continue;
                        }
                        
                        let x = i - dt0 * velocX[idx];
                        let y = j - dt0 * velocY[idx];
                        
                        x = constrain(x, 0.5, N - 1.5);
                        y = constrain(y, 0.5, N - 1.5);
                        
                        const i0 = Math.floor(x);
                        const i1 = i0 + 1;
                        const j0 = Math.floor(y);
                        const j1 = j0 + 1;
                        
                        const s1 = x - i0;
                        const s0 = 1 - s1;
                        const t1 = y - j0;
                        const t0 = 1 - t1;
                        
                        d[idx] = s0 * (t0 * d0[this.IX(i0, j0)] + t1 * d0[this.IX(i0, j1)]) +
                                 s1 * (t0 * d0[this.IX(i1, j0)] + t1 * d0[this.IX(i1, j1)]);
                    }
                }
                
                this.setBounds(b, d);
            }
            
            setBounds(b, x) {
                const N = this.size;
                
                for (let i = 1; i < N - 1; i++) {
                    x[this.IX(i, 0)] = b === 2 ? -x[this.IX(i, 1)] : x[this.IX(i, 1)];
                    x[this.IX(i, N - 1)] = b === 2 ? -x[this.IX(i, N - 2)] : x[this.IX(i, N - 2)];
                }
                
                for (let j = 1; j < N - 1; j++) {
                    x[this.IX(0, j)] = b === 1 ? -x[this.IX(1, j)] : x[this.IX(1, j)];
                    x[this.IX(N - 1, j)] = b === 1 ? -x[this.IX(N - 2, j)] : x[this.IX(N - 2, j)];
                }
                
                x[this.IX(0, 0)] = 0.5 * (x[this.IX(1, 0)] + x[this.IX(0, 1)]);
                x[this.IX(0, N - 1)] = 0.5 * (x[this.IX(1, N - 1)] + x[this.IX(0, N - 2)]);
                x[this.IX(N - 1, 0)] = 0.5 * (x[this.IX(N - 2, 0)] + x[this.IX(N - 1, 1)]);
                x[this.IX(N - 1, N - 1)] = 0.5 * (x[this.IX(N - 2, N - 1)] + x[this.IX(N - 1, N - 2)]);
            }
            
            step() {
                if (this.paused) return;
                
                const N = this.size;
                const visc = this.visc;
                const diff = this.diff;
                const dt = this.dt;
                
                // Add vortex if enabled
                if (this.vortexEnabled) {
                    const cx = N / 2;
                    const cy = N / 2;
                    const strength = 50;
                    
                    for (let j = 1; j < N - 1; j++) {
                        for (let i = 1; i < N - 1; i++) {
                            const dx = i - cx;
                            const dy = j - cy;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 0 && dist < N / 3) {
                                const force = strength / (dist * dist);
                                const idx = this.IX(i, j);
                                this.vx[idx] += -dy * force * dt;
                                this.vy[idx] += dx * force * dt;
                            }
                        }
                    }
                }
                
                // Velocity step
                this.diffuse(1, this.vxPrev, this.vx, visc, dt);
                this.diffuse(2, this.vyPrev, this.vy, visc, dt);
                
                this.project(this.vxPrev, this.vyPrev, this.vx, this.vy);
                
                this.advect(1, this.vx, this.vxPrev, this.vxPrev, this.vyPrev, dt);
                this.advect(2, this.vy, this.vyPrev, this.vxPrev, this.vyPrev, dt);
                
                this.project(this.vx, this.vy, this.vxPrev, this.vyPrev);
                
                // Density step
                this.diffuse(0, this.densityPrev, this.density, diff, dt);
                this.advect(0, this.density, this.densityPrev, this.vx, this.vy, dt);
                
                // Fade density slightly
                for (let i = 0; i < N * N; i++) {
                    this.density[i] *= 0.999;
                }
            }
            
            render() {
                const cellSize = width / this.size;
                
                for (let j = 0; j < this.size; j++) {
                    for (let i = 0; i < this.size; i++) {
                        const idx = this.IX(i, j);
                        const d = this.density[idx];
                        
                        if (this.obstaclesEnabled && this.obstacles.includes(idx)) {
                            fill(50);
                            noStroke();
                            rect(i * cellSize, j * cellSize, cellSize, cellSize);
                        } else if (d > 0.01) {
                            let r, g, b;
                            
                            if (this.colorMode === 'gradient') {
                                // Create rainbow gradient based on position and time
                                const hue = (frameCount * 2 + i * 2 + j * 2) % 360;
                                const col = this.hslToRgb(hue / 360, 0.7, 0.5);
                                r = col.r * d;
                                g = col.g * d;
                                b = col.b * d;
                            } else {
                                r = this.currentColor.r * d;
                                g = this.currentColor.g * d;
                                b = this.currentColor.b * d;
                            }
                            
                            // Add velocity-based coloring
                            const velIdx = this.IX(i, j);
                            const velMag = Math.sqrt(this.vx[velIdx] * this.vx[velIdx] + this.vy[velIdx] * this.vy[velIdx]);
                            const velColor = Math.min(velMag * 10, 1);
                            
                            r = Math.min(255, r * 255 + velColor * 50);
                            g = Math.min(255, g * 255 + velColor * 30);
                            b = Math.min(255, b * 255 + velColor * 80);
                            
                            fill(r, g, b, d * 255);
                            noStroke();
                            rect(i * cellSize, j * cellSize, cellSize, cellSize);
                        }
                    }
                }
            }
            
            hslToRgb(h, s, l) {
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                return { r: r, g: g, b: b };
            }
            
            setColor(color) {
                const colors = {
                    red: { r: 1, g: 0.2, b: 0.2 },
                    cyan: { r: 0.2, g: 0.8, b: 0.8 },
                    blue: { r: 0.2, g: 0.4, b: 1 },
                    green: { r: 0.2, g: 0.8, b: 0.4 },
                    yellow: { r: 1, g: 0.9, b: 0.2 },
                    white: { r: 1, g: 1, b: 1 },
                    purple: { r: 0.6, g: 0.2, b: 0.8 },
                    gradient: null
                };
                
                if (color === 'gradient') {
                    this.colorMode = 'gradient';
                } else if (colors[color]) {
                    this.colorMode = 'solid';
                    this.currentColor = colors[color];
                }
            }
            
            reset() {
                const N = this.size * this.size;
                for (let i = 0; i < N; i++) {
                    this.density[i] = 0;
                    this.densityPrev[i] = 0;
                    this.vx[i] = 0;
                    this.vy[i] = 0;
                    this.vxPrev[i] = 0;
                    this.vyPrev[i] = 0;
                }
            }
            
            toggleVortex() {
                this.vortexEnabled = !this.vortexEnabled;
            }
            
            toggleObstacles() {
                this.obstaclesEnabled = !this.obstaclesEnabled;
            }
            
            randomBurst() {
                const x = Math.floor(Math.random() * this.size);
                const y = Math.floor(Math.random() * this.size);
                const amount = 100;
                
                for (let i = -5; i <= 5; i++) {
                    for (let j = -5; j <= 5; j++) {
                        if (x + i >= 0 && x + i < this.size && y + j >= 0 && y + j < this.size) {
                            this.addDensity(x + i, y + j, amount * Math.exp(-(i * i + j * j) / 10));
                            this.addVelocity(x + i, y + j, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
                        }
                    }
                }
            }
        }
        
        let fluidSim;
        
        function setup() {
            const canvas = createCanvas(800, 800);
            canvas.parent('canvas-container');
            
            fluidSim = new FluidSimulation();
            
            // Setup UI controls
            setupControls();
        }
        
        function draw() {
            background(0);
            
            // Handle mouse input
            if (fluidSim.mouseDown) {
                const x = Math.floor(mouseX / (width / fluidSim.size));
                const y = Math.floor(mouseY / (height / fluidSim.size));
                
                const dx = mouseX - fluidSim.prevMouseX;
                const dy = mouseY - fluidSim.prevMouseY;
                
                fluidSim.addDensity(x, y, 100);
                fluidSim.addVelocity(x, y, dx * fluidSim.forceScale, dy * fluidSim.forceScale);
            }
            
            fluidSim.prevMouseX = mouseX;
            fluidSim.prevMouseY = mouseY;
            
            // Update and render
            for (let i = 0; i < 2; i++) {
                fluidSim.step();
            }
            fluidSim.render();
        }
        
        function mousePressed() {
            fluidSim.mouseDown = true;
            fluidSim.mouseX = mouseX;
            fluidSim.mouseY = mouseY;
        }
        
        function mouseReleased() {
            fluidSim.mouseDown = false;
        }
        
        function keyPressed() {
            if (key === ' ') {
                fluidSim.paused = !fluidSim.paused;
            } else if (key === 'c' || key === 'C') {
                fluidSim.reset();
            } else if (key === 'r' || key === 'R') {
                fluidSim.randomBurst();
            } else if (key >= '1' && key <= '8') {
                const colors = ['gradient', 'red', 'cyan', 'blue', 'green', 'yellow', 'white', 'purple'];
                const index = parseInt(key) - 1;
                fluidSim.setColor(colors[index]);
                updateColorButtons(colors[index]);
            }
        }
        
        function setupControls() {
            // Viscosity slider
            const viscSlider = document.getElementById('viscosity');
            viscSlider.addEventListener('input', (e) => {
                fluidSim.visc = parseFloat(e.target.value);
                document.getElementById('viscosityValue').textContent = e.target.value;
            });
            
            // Diffusion slider
            const diffSlider = document.getElementById('diffusion');
            diffSlider.addEventListener('input', (e) => {
                fluidSim.diff = parseFloat(e.target.value);
                document.getElementById('diffusionValue').textContent = e.target.value;
            });
            
            // Force slider
            const forceSlider = document.getElementById('force');
            forceSlider.addEventListener('input', (e) => {
                fluidSim.forceScale = parseFloat(e.target.value);
                document.getElementById('forceValue').textContent = e.target.value;
            });
            
            // Color buttons
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const color = btn.dataset.color;
                    fluidSim.setColor(color);
                    updateColorButtons(color);
                });
            });
        }
        
        function updateColorButtons(selectedColor) {
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.color === selectedColor) {
                    btn.classList.add('active');
                }
            });
        }
        
        function toggleControls() {
            const controls = document.getElementById('controls');
            const toggleBtn = document.getElementById('toggleBtn');
            controls.classList.toggle('hidden');
            toggleBtn.classList.toggle('shifted');
        }
    </script>
</body>
</html>