<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Fluid Dynamics Simulation - SPH Method</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/addons/p5.dom.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #0c0e1a 0%, #1a1b3a 100%);
            color: #e0f0ff;
            min-height: 100vh;
            overflow-x: hidden;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        header {
            text-align: center;
            padding: 25px;
            background: rgba(10, 12, 28, 0.7);
            border-radius: 16px;
            border: 1px solid rgba(64, 156, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
        }

        h1 {
            color: #7bc8ff;
            margin-bottom: 15px;
            font-size: 2.8rem;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            background: linear-gradient(to right, #7bc8ff, #a855f7);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .subtitle {
            color: #a8d2ff;
            font-size: 1.2rem;
            max-width: 900px;
            margin: 0 auto 15px;
            line-height: 1.6;
        }

        .method-explanation {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .method-point {
            background: rgba(25, 30, 60, 0.6);
            padding: 15px 20px;
            border-radius: 10px;
            border: 1px solid rgba(64, 156, 255, 0.2);
            text-align: center;
            min-width: 200px;
        }

        .method-point h3 {
            color: #ff7b00;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .simulation-area {
            flex: 3;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #fluid-canvas {
            width: 100%;
            height: 600px;
            border-radius: 16px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
            background: rgba(5, 8, 22, 0.9);
            border: 1px solid rgba(64, 156, 255, 0.15);
        }

        .canvas-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(15, 20, 45, 0.7);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(64, 156, 255, 0.15);
        }

        .fps-counter {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #2ed573;
            background: rgba(46, 213, 115, 0.1);
            padding: 8px 15px;
            border-radius: 8px;
        }

        .particle-count {
            font-family: 'Courier New', monospace;
            color: #ff7b00;
            background: rgba(255, 123, 0, 0.1);
            padding: 8px 15px;
            border-radius: 8px;
        }

        .method-display {
            font-size: 1.1rem;
            color: #ff7b00;
            font-weight: 600;
        }

        .controls-panel {
            flex: 1;
            min-width: 320px;
            background: rgba(15, 20, 45, 0.7);
            border-radius: 16px;
            padding: 25px;
            border: 1px solid rgba(64, 156, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 25px;
            max-height: 800px;
            overflow-y: auto;
        }

        .panel-section {
            background: rgba(25, 30, 60, 0.6);
            border-radius: 12px;
            padding: 20px;
            border-left: 4px solid;
        }

        .fluid-section {
            border-left-color: #409cff;
        }

        .interaction-section {
            border-left-color: #ff7b00;
        }

        .visualization-section {
            border-left-color: #2ed573;
        }

        .simulation-section {
            border-left-color: #a855f7;
        }

        h2 {
            color: #7bc8ff;
            font-size: 1.5rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        h2 i {
            font-size: 1.3rem;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 10px;
            color: #a8d2ff;
            font-weight: 500;
            font-size: 1.05rem;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        input[type="range"] {
            flex: 1;
            height: 10px;
            -webkit-appearance: none;
            border-radius: 5px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 12px rgba(64, 156, 255, 0.8);
            border: 2px solid white;
        }

        .viscosity-slider {
            background: linear-gradient(to right, #1a3a5f, #409cff);
        }

        .viscosity-slider::-webkit-slider-thumb {
            background: #409cff;
        }

        .density-slider {
            background: linear-gradient(to right, #1b5e20, #2ed573);
        }

        .density-slider::-webkit-slider-thumb {
            background: #2ed573;
        }

        .pressure-slider {
            background: linear-gradient(to right, #b71c1c, #ff4757);
        }

        .pressure-slider::-webkit-slider-thumb {
            background: #ff4757;
        }

        .size-slider {
            background: linear-gradient(to right, #0d47a1, #ff7b00);
        }

        .size-slider::-webkit-slider-thumb {
            background: #ff7b00;
        }

        .value-display {
            min-width: 70px;
            text-align: center;
            background: rgba(10, 15, 35, 0.6);
            padding: 8px 12px;
            border-radius: 8px;
            color: #a8d2ff;
            font-weight: 600;
            font-family: 'Courier New', monospace;
            border: 1px solid rgba(64, 156, 255, 0.2);
        }

        .toggle-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(10, 15, 35, 0.4);
            border-radius: 10px;
            border: 1px solid rgba(64, 156, 255, 0.1);
            transition: all 0.3s;
        }

        .toggle-group:hover {
            background: rgba(64, 156, 255, 0.1);
        }

        .toggle-label {
            color: #a8d2ff;
            font-weight: 500;
            margin: 0;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(64, 156, 255, 0.2);
            transition: .4s;
            border-radius: 30px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #409cff;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(30px);
        }

        button {
            background: linear-gradient(to right, #409cff, #2a7de0);
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
            font-size: 1.05rem;
        }

        button:hover {
            background: linear-gradient(to right, #2a7de0, #1a6bc8);
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25);
        }

        button:active {
            transform: translateY(0);
        }

        .color-button {
            background: linear-gradient(to right, #ff7b00, #ff5500);
        }

        .color-button:hover {
            background: linear-gradient(to right, #ff5500, #ff3d00);
        }

        .danger-button {
            background: linear-gradient(to right, #ff4757, #ff3742);
        }

        .danger-button:hover {
            background: linear-gradient(to right, #ff3742, #ff2b36);
        }

        .color-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 10px;
        }

        .color-button-small {
            padding: 12px;
            font-size: 0.95rem;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .color-button-small::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .color-button-small:hover::before {
            opacity: 1;
        }

        .force-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 10px;
        }

        .force-button {
            background: rgba(25, 30, 60, 0.8);
            padding: 12px;
            font-size: 0.95rem;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 10px;
        }

        .preset-button {
            background: rgba(25, 30, 60, 0.8);
            padding: 12px;
            font-size: 0.95rem;
        }

        .keyboard-hint {
            font-size: 0.9rem;
            color: #8ab4f8;
            margin-top: 15px;
            text-align: center;
            font-style: italic;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: #8ab4f8;
            font-size: 0.95rem;
            background: rgba(10, 12, 28, 0.7);
            border-radius: 12px;
            border: 1px solid rgba(64, 156, 255, 0.2);
            margin-top: 20px;
        }

        @media (max-width: 1200px) {
            .content {
                flex-direction: column;
            }
            
            .simulation-area, .controls-panel {
                width: 100%;
            }
        }

        @media (max-width: 600px) {
            .controls-panel {
                padding: 15px;
            }
            
            .color-buttons, .force-buttons, .preset-buttons {
                grid-template-columns: 1fr;
            }
            
            .method-explanation {
                flex-direction: column;
                align-items: center;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            #fluid-canvas {
                height: 450px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Realistic Fluid Dynamics Simulation</h1>
            <p class="subtitle">Smoothed Particle Hydrodynamics (SPH) simulation with realistic fluid behavior including swirling, splashing, and natural mixing of colored fluids.</p>
            <div class="method-explanation">
                <div class="method-point">
                    <h3>SPH Method</h3>
                    <p>Lagrangian particle-based approach for fluid simulation</p>
                </div>
                <div class="method-point">
                    <h3>Real-time Physics</h3>
                    <p>Pressure, viscosity, surface tension, and gravity forces</p>
                </div>
                <div class="method-point">
                    <h3>Color Mixing</h3>
                    <p>Natural blending of differently colored fluids</p>
                </div>
            </div>
        </header>
        
        <div class="content">
            <div class="simulation-area">
                <div id="fluid-canvas"></div>
                <div class="canvas-info">
                    <div class="fps-counter">FPS: 60</div>
                    <div class="method-display">Smoothed Particle Hydrodynamics</div>
                    <div class="particle-count">Particles: 0</div>
                </div>
            </div>
            
            <div class="controls-panel">
                <div class="panel-section fluid-section">
                    <h2>Fluid Properties</h2>
                    
                    <div class="control-group">
                        <label>Viscosity: <span id="viscosity-value">0.1</span></label>
                        <div class="slider-container">
                            <input type="range" id="viscosity" class="viscosity-slider" min="0.01" max="1.0" value="0.1" step="0.01">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Density: <span id="density-value">1.0</span></label>
                        <div class="slider-container">
                            <input type="range" id="density" class="density-slider" min="0.1" max="2.0" value="1.0" step="0.1">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Pressure Strength: <span id="pressure-value">1.0</span></label>
                        <div class="slider-container">
                            <input type="range" id="pressure-strength" class="pressure-slider" min="0.1" max="3.0" value="1.0" step="0.1">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Surface Tension: <span id="tension-value">0.5</span></label>
                        <div class="slider-container">
                            <input type="range" id="surface-tension" class="viscosity-slider" min="0.0" max="2.0" value="0.5" step="0.1">
                        </div>
                    </div>
                </div>
                
                <div class="panel-section interaction-section">
                    <h2>Interaction & Forces</h2>
                    
                    <div class="control-group">
                        <label>Mouse Force Strength: <span id="force-value">5.0</span></label>
                        <div class="slider-container">
                            <input type="range" id="mouse-force" class="size-slider" min="1.0" max="20.0" value="5.0" step="0.5">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Apply Color When Clicking</label>
                        <div class="color-buttons">
                            <button class="color-button-small" id="color-blue" style="background: linear-gradient(to right, #2196f3, #1976d2);">Blue</button>
                            <button class="color-button-small" id="color-red" style="background: linear-gradient(to right, #f44336, #d32f2f);">Red</button>
                            <button class="color-button-small" id="color-green" style="background: linear-gradient(to right, #4caf50, #388e3c);">Green</button>
                            <button class="color-button-small" id="color-yellow" style="background: linear-gradient(to right, #ffeb3b, #fbc02d);">Yellow</button>
                            <button class="color-button-small" id="color-purple" style="background: linear-gradient(to right, #9c27b0, #7b1fa2);">Purple</button>
                            <button class="color-button-small" id="color-white" style="background: linear-gradient(to right, #ffffff, #e0e0e0); color: #333;">White</button>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Apply External Forces</label>
                        <div class="force-buttons">
                            <button class="force-button" id="force-vortex">üåÄ Vortex Force</button>
                            <button class="force-button" id="force-explosion">üí• Explosion</button>
                            <button class="force-button" id="force-gravity">‚¨áÔ∏è Gravity</button>
                            <button class="force-button" id="force-updraft">‚¨ÜÔ∏è Updraft</button>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section visualization-section">
                    <h2>Visualization</h2>
                    
                    <div class="control-group">
                        <div class="toggle-group">
                            <span class="toggle-label">Show Velocity Vectors</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="show-vectors">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <div class="toggle-group">
                            <span class="toggle-label">Show Pressure Field</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="show-pressure">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <div class="toggle-group">
                            <span class="toggle-label">Enable Bloom Effect</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="bloom-effect" checked>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Particle Size: <span id="particle-size-value">3</span></label>
                        <div class="slider-container">
                            <input type="range" id="particle-size" class="size-slider" min="1" max="8" value="3" step="0.5">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Color Mixing Speed: <span id="mixing-value">0.1</span></label>
                        <div class="slider-container">
                            <input type="range" id="color-mixing" class="viscosity-slider" min="0.01" max="0.5" value="0.1" step="0.01">
                        </div>
                    </div>
                </div>
                
                <div class="panel-section simulation-section">
                    <h2>Simulation Controls</h2>
                    
                    <div class="control-group">
                        <label>Simulation Speed: <span id="sim-speed-value">1.0</span>x</label>
                        <div class="slider-container">
                            <input type="range" id="sim-speed" class="viscosity-slider" min="0.1" max="3.0" value="1.0" step="0.1">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <div class="toggle-group">
                            <span class="toggle-label">Pause Simulation</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="pause-toggle">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <div class="toggle-group">
                            <span class="toggle-label">Enable Obstacles</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="obstacles-toggle">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="preset-buttons">
                        <button class="preset-button" id="preset-water">üíß Water (Low Viscosity)</button>
                        <button class="preset-button" id="preset-oil">üõ¢Ô∏è Oil (High Viscosity)</button>
                        <button class="preset-button" id="preset-multicolor">üåà Multicolor Mix</button>
                        <button class="preset-button danger-button" id="reset-button">üîÑ Reset Simulation</button>
                    </div>
                    
                    <div class="keyboard-hint">
                        Keyboard: CLICK/DRAG = Interact, 1-6 = Colors, SPACE = Pause, R = Reset, V = Vortex, E = Explosion
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>Real-time SPH Fluid Simulation | Smoothed Particle Hydrodynamics | Interactive Physics Visualization</p>
        </footer>
    </div>

    <script>
// SPH Fluid Simulation Class
class SPHFluidSimulation {
    constructor() {
        // Simulation parameters
        this.particles = [];
        this.maxParticles = 2000;
        this.particleCount = 0;
        
        // SPH parameters
        this.params = {
            // Fluid properties
            density: 1.0,               // Rest density
            viscosity: 0.1,             // Viscosity coefficient
            pressureStrength: 1.0,      // Pressure force strength
            surfaceTension: 0.5,        // Surface tension coefficient
            gravity: 0.5,               // Gravity strength
            
            // Simulation parameters
            smoothingRadius: 20,        // Kernel smoothing radius
            timeStep: 0.1,              // Simulation time step
            boundaryDamping: 0.8,       // Boundary collision damping
            
            // Visualization
            particleSize: 3,
            showVectors: false,
            showPressure: false,
            bloomEffect: true,
            colorMixingSpeed: 0.1,
            
            // Interaction
            mouseForceStrength: 5.0,
            currentColor: [100, 200, 255], // Blue by default
            simulationSpeed: 1.0
        };
        
        // Obstacles
        this.obstacles = [];
        this.obstaclesEnabled = false;
        
        // Spatial grid for neighbor search optimization
        this.grid = new Map();
        this.gridSize = this.params.smoothingRadius;
        
        // Performance tracking
        this.fps = 60;
        this.isPaused = false;
        this.time = 0;
        
        // Initialize fluid
        this.initializeFluid();
        
        // Create obstacles
        this.createObstacles();
        
        // Set up UI controls
        this.setupControls();
    }
    
    // Initialize fluid particles
    initializeFluid() {
        this.particles = [];
        this.particleCount = 0;
        
        // Create initial fluid blob
        const centerX = 300;
        const centerY = 300;
        const radius = 100;
        
        for (let i = 0; i < this.maxParticles; i++) {
            // Create particles in a circular blob
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * radius;
            
            const x = centerX + Math.cos(angle) * distance;
            const y = centerY + Math.sin(angle) * distance;
            
            // Skip if outside canvas bounds
            if (x < 0 || x > 800 || y < 0 || y > 600) continue;
            
            this.addParticle(x, y, [...this.params.currentColor]);
        }
    }
    
    // Add a particle to the simulation
    addParticle(x, y, color = null) {
        if (this.particleCount >= this.maxParticles) return null;
        
        const particle = {
            position: [x, y],
            velocity: [0, 0],
            acceleration: [0, 0],
            density: this.params.density,
            pressure: 0,
            color: color || [...this.params.currentColor],
            id: this.particleCount++,
            mass: 1.0
        };
        
        this.particles.push(particle);
        return particle;
    }
    
    // Create obstacles in the simulation
    createObstacles() {
        this.obstacles = [
            // Circular obstacle
            {
                type: 'circle',
                x: 400,
                y: 200,
                radius: 50
            },
            // Rectangular obstacle
            {
                type: 'rectangle',
                x: 600,
                y: 400,
                width: 80,
                height: 120
            },
            // Triangular obstacle
            {
                type: 'triangle',
                x: 200,
                y: 450,
                size: 60
            }
        ];
    }
    
    // Build spatial grid for neighbor search optimization
    buildSpatialGrid() {
        this.grid.clear();
        
        for (const particle of this.particles) {
            const [x, y] = particle.position;
            const gridX = Math.floor(x / this.gridSize);
            const gridY = Math.floor(y / this.gridSize);
            const key = `${gridX},${gridY}`;
            
            if (!this.grid.has(key)) {
                this.grid.set(key, []);
            }
            this.grid.get(key).push(particle);
        }
    }
    
    // Find neighbors for a particle using spatial grid
    findNeighbors(particle) {
        const neighbors = [];
        const [x, y] = particle.position;
        const gridX = Math.floor(x / this.gridSize);
        const gridY = Math.floor(y / this.gridSize);
        
        // Check 3x3 grid around the particle
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                const key = `${gridX + dx},${gridY + dy}`;
                const cellParticles = this.grid.get(key);
                
                if (cellParticles) {
                    for (const neighbor of cellParticles) {
                        if (neighbor === particle) continue;
                        
                        const [nx, ny] = neighbor.position;
                        const dx = x - nx;
                        const dy = y - ny;
                        const distanceSq = dx * dx + dy * dy;
                        
                        if (distanceSq < this.params.smoothingRadius * this.params.smoothingRadius) {
                            neighbors.push({
                                particle: neighbor,
                                distance: Math.sqrt(distanceSq),
                                dx: dx,
                                dy: dy
                            });
                        }
                    }
                }
            }
        }
        
        return neighbors;
    }
    
    // SPH smoothing kernel (poly6)
    smoothingKernel(distance, radius) {
        if (distance >= radius) return 0;
        
        const volume = Math.PI * Math.pow(radius, 8) / 4;
        const value = Math.pow(radius * radius - distance * distance, 3);
        return value / volume;
    }
    
    // Kernel gradient (spiky kernel)
    gradientKernel(distance, radius) {
        if (distance >= radius) return 0;
        
        const scale = 15 / (Math.PI * Math.pow(radius, 6));
        const v = radius - distance;
        return scale * v * v;
    }
    
    // Kernel laplacian (viscosity kernel)
    laplacianKernel(distance, radius) {
        if (distance >= radius) return 0;
        
        const scale = 45 / (Math.PI * Math.pow(radius, 6));
        return scale * (radius - distance);
    }
    
    // Calculate density and pressure for all particles
    calculateDensityPressure() {
        // First pass: calculate density
        for (const particle of this.particles) {
            let density = 0;
            const neighbors = this.findNeighbors(particle);
            
            for (const neighborData of neighbors) {
                const kernel = this.smoothingKernel(neighborData.distance, this.params.smoothingRadius);
                density += neighborData.particle.mass * kernel;
            }
            
            // Self contribution
            const selfKernel = this.smoothingKernel(0, this.params.smoothingRadius);
            density += particle.mass * selfKernel;
            
            particle.density = Math.max(density, 0.001); // Avoid division by zero
            
            // Calculate pressure using ideal gas equation: P = k(œÅ - œÅ‚ÇÄ)
            const pressureConstant = this.params.pressureStrength;
            particle.pressure = pressureConstant * (particle.density - this.params.density);
        }
        
        // Second pass: mix colors based on neighbors
        this.mixColors();
    }
    
    // Mix colors between neighboring particles
    mixColors() {
        for (const particle of this.particles) {
            const neighbors = this.findNeighbors(particle);
            
            if (neighbors.length === 0) continue;
            
            let totalWeight = 0;
            let mixedColor = [0, 0, 0];
            
            for (const neighborData of neighbors) {
                const weight = 1 - (neighborData.distance / this.params.smoothingRadius);
                const neighbor = neighborData.particle;
                
                mixedColor[0] += neighbor.color[0] * weight;
                mixedColor[1] += neighbor.color[1] * weight;
                mixedColor[2] += neighbor.color[2] * weight;
                totalWeight += weight;
            }
            
            if (totalWeight > 0) {
                // Blend current color with neighbor colors
                const blendFactor = this.params.colorMixingSpeed * this.params.timeStep;
                
                particle.color[0] = particle.color[0] * (1 - blendFactor) + 
                                   (mixedColor[0] / totalWeight) * blendFactor;
                particle.color[1] = particle.color[1] * (1 - blendFactor) + 
                                   (mixedColor[1] / totalWeight) * blendFactor;
                particle.color[2] = particle.color[2] * (1 - blendFactor) + 
                                   (mixedColor[2] / totalWeight) * blendFactor;
            }
        }
    }
    
    // Calculate forces (pressure, viscosity, surface tension, gravity)
    calculateForces() {
        for (const particle of this.particles) {
            // Reset acceleration
            particle.acceleration = [0, 0];
            
            const neighbors = this.findNeighbors(particle);
            
            let pressureForce = [0, 0];
            let viscosityForce = [0, 0];
            let tensionForce = [0, 0];
            
            // Calculate forces from neighbors
            for (const neighborData of neighbors) {
                const neighbor = neighborData.particle;
                
                // Pressure force
                const pressureKernel = this.gradientKernel(neighborData.distance, this.params.smoothingRadius);
                const pressureDir = [neighborData.dx / neighborData.distance, 
                                    neighborData.dy / neighborData.distance];
                
                const pressureMag = (particle.pressure / (particle.density * particle.density) +
                                   neighbor.pressure / (neighbor.density * neighbor.density)) *
                                   pressureKernel;
                
                pressureForce[0] += pressureMag * pressureDir[0];
                pressureForce[1] += pressureMag * pressureDir[1];
                
                // Viscosity force
                const viscosityKernel = this.laplacianKernel(neighborData.distance, this.params.smoothingRadius);
                
                viscosityForce[0] += (neighbor.velocity[0] - particle.velocity[0]) * viscosityKernel;
                viscosityForce[1] += (neighbor.velocity[1] - particle.velocity[1]) * viscosityKernel;
                
                // Surface tension (simplified)
                if (this.params.surfaceTension > 0) {
                    const tensionStrength = this.params.surfaceTension;
                    tensionForce[0] += neighborData.dx * tensionStrength;
                    tensionForce[1] += neighborData.dy * tensionStrength;
                }
            }
            
            // Apply forces
            particle.acceleration[0] = -pressureForce[0] + 
                                      viscosityForce[0] * this.params.viscosity +
                                      tensionForce[0];
            particle.acceleration[1] = -pressureForce[1] + 
                                      viscosityForce[1] * this.params.viscosity +
                                      tensionForce[1];
            
            // Add gravity
            particle.acceleration[1] += this.params.gravity;
        }
    }
    
    // Handle boundary collisions
    handleBoundaries() {
        for (const particle of this.particles) {
            const [x, y] = particle.position;
            const [vx, vy] = particle.velocity;
            
            // Left boundary
            if (x < 0) {
                particle.position[0] = 0;
                particle.velocity[0] = -vx * this.params.boundaryDamping;
            }
            // Right boundary
            else if (x > 800) {
                particle.position[0] = 800;
                particle.velocity[0] = -vx * this.params.boundaryDamping;
            }
            
            // Top boundary
            if (y < 0) {
                particle.position[1] = 0;
                particle.velocity[1] = -vy * this.params.boundaryDamping;
            }
            // Bottom boundary
            else if (y > 600) {
                particle.position[1] = 600;
                particle.velocity[1] = -vy * this.params.boundaryDamping;
            }
        }
    }
    
    // Handle obstacle collisions
    handleObstacles() {
        if (!this.obstaclesEnabled) return;
        
        for (const particle of this.particles) {
            const [x, y] = particle.position;
            const [vx, vy] = particle.velocity;
            
            for (const obstacle of this.obstacles) {
                let collision = false;
                let normal = [0, 0];
                let penetration = 0;
                
                switch (obstacle.type) {
                    case 'circle':
                        const dx = x - obstacle.x;
                        const dy = y - obstacle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < obstacle.radius) {
                            collision = true;
                            normal = [dx / distance, dy / distance];
                            penetration = obstacle.radius - distance;
                        }
                        break;
                        
                    case 'rectangle':
                        if (x > obstacle.x - obstacle.width / 2 &&
                            x < obstacle.x + obstacle.width / 2 &&
                            y > obstacle.y - obstacle.height / 2 &&
                            y < obstacle.y + obstacle.height / 2) {
                            
                            collision = true;
                            
                            // Find closest side
                            const leftDist = Math.abs(x - (obstacle.x - obstacle.width / 2));
                            const rightDist = Math.abs(x - (obstacle.x + obstacle.width / 2));
                            const topDist = Math.abs(y - (obstacle.y - obstacle.height / 2));
                            const bottomDist = Math.abs(y - (obstacle.y + obstacle.height / 2));
                            
                            const minDist = Math.min(leftDist, rightDist, topDist, bottomDist);
                            
                            if (minDist === leftDist) {
                                normal = [-1, 0];
                                penetration = leftDist;
                            } else if (minDist === rightDist) {
                                normal = [1, 0];
                                penetration = rightDist;
                            } else if (minDist === topDist) {
                                normal = [0, -1];
                                penetration = topDist;
                            } else {
                                normal = [0, 1];
                                penetration = bottomDist;
                            }
                        }
                        break;
                        
                    case 'triangle':
                        // Simplified triangle collision (circular approximation)
                        const dxTri = x - obstacle.x;
                        const dyTri = y - obstacle.y;
                        const distanceTri = Math.sqrt(dxTri * dxTri + dyTri * dyTri);
                        
                        if (distanceTri < obstacle.size) {
                            collision = true;
                            normal = [dxTri / distanceTri, dyTri / distanceTri];
                            penetration = obstacle.size - distanceTri;
                        }
                        break;
                }
                
                if (collision) {
                    // Push particle out of obstacle
                    particle.position[0] += normal[0] * penetration * 1.1;
                    particle.position[1] += normal[1] * penetration * 1.1;
                    
                    // Reflect velocity
                    const dot = vx * normal[0] + vy * normal[1];
                    particle.velocity[0] = (vx - 2 * dot * normal[0]) * this.params.boundaryDamping;
                    particle.velocity[1] = (vy - 2 * dot * normal[1]) * this.params.boundaryDamping;
                }
            }
        }
    }
    
    // Integrate particle positions (semi-implicit Euler)
    integrate() {
        const dt = this.params.timeStep * this.params.simulationSpeed;
        
        for (const particle of this.particles) {
            // Update velocity
            particle.velocity[0] += particle.acceleration[0] * dt;
            particle.velocity[1] += particle.acceleration[1] * dt;
            
            // Apply damping
            const damping = 0.999;
            particle.velocity[0] *= damping;
            particle.velocity[1] *= damping;
            
            // Update position
            particle.position[0] += particle.velocity[0] * dt;
            particle.position[1] += particle.velocity[1] * dt;
        }
    }
    
    // Apply mouse interaction force
    applyMouseForce(mouseX, mouseY, forceX, forceY) {
        if (mouseX < 0 || mouseX > 800 || mouseY < 0 || mouseY > 600) return;
        
        for (const particle of this.particles) {
            const [x, y] = particle.position;
            const dx = mouseX - x;
            const dy = mouseY - y;
            const distanceSq = dx * dx + dy * dy;
            const forceRadius = 100;
            
            if (distanceSq < forceRadius * forceRadius) {
                const distance = Math.sqrt(distanceSq);
                const forceFactor = this.params.mouseForceStrength * 
                                   (1 - distance / forceRadius);
                
                particle.velocity[0] += forceX * forceFactor;
                particle.velocity[1] += forceY * forceFactor;
                
                // Apply color at mouse position
                if (Math.abs(forceX) > 0.1 || Math.abs(forceY) > 0.1) {
                    const colorInfluence = (1 - distance / forceRadius) * 0.3;
                    particle.color[0] = particle.color[0] * (1 - colorInfluence) + 
                                       this.params.currentColor[0] * colorInfluence;
                    particle.color[1] = particle.color[1] * (1 - colorInfluence) + 
                                       this.params.currentColor[1] * colorInfluence;
                    particle.color[2] = particle.color[2] * (1 - colorInfluence) + 
                                       this.params.currentColor[2] * colorInfluence;
                }
            }
        }
    }
    
    // Apply external force (vortex, explosion, etc.)
    applyExternalForce(type, x, y, strength = 1.0) {
        for (const particle of this.particles) {
            const [px, py] = particle.position;
            const dx = x - px;
            const dy = y - py;
            const distanceSq = dx * dx + dy * dy;
            const forceRadius = 150;
            
            if (distanceSq < forceRadius * forceRadius) {
                const distance = Math.sqrt(distanceSq);
                const forceFactor = strength * (1 - distance / forceRadius);
                
                switch (type) {
                    case 'vortex':
                        // Tangential force (swirling)
                        const tangentX = -dy;
                        const tangentY = dx;
                        const tangentLength = Math.sqrt(tangentX * tangentX + tangentY * tangentY);
                        
                        particle.velocity[0] += (tangentX / tangentLength) * forceFactor * 2;
                        particle.velocity[1] += (tangentY / tangentLength) * forceFactor * 2;
                        
                        // Inward force
                        particle.velocity[0] += (dx / distance) * forceFactor * 0.5;
                        particle.velocity[1] += (dy / distance) * forceFactor * 0.5;
                        break;
                        
                    case 'explosion':
                        // Radial outward force
                        particle.velocity[0] -= (dx / distance) * forceFactor * 3;
                        particle.velocity[1] -= (dy / distance) * forceFactor * 3;
                        break;
                        
                    case 'gravity':
                        // Downward force
                        particle.velocity[1] += forceFactor * 2;
                        break;
                        
                    case 'updraft':
                        // Upward force
                        particle.velocity[1] -= forceFactor * 2;
                        break;
                }
            }
        }
    }
    
    // Main simulation step
    step() {
        if (this.isPaused) return;
        
        this.time += this.params.timeStep;
        
        // Build spatial grid for neighbor search
        this.buildSpatialGrid();
        
        // Calculate density and pressure
        this.calculateDensityPressure();
        
        // Calculate forces
        this.calculateForces();
        
        // Integrate motion
        this.integrate();
        
        // Handle boundaries and obstacles
        this.handleBoundaries();
        this.handleObstacles();
    }
    
    // Draw the simulation
    draw(canvas) {
        // Clear with gradient background
        this.drawBackground(canvas);
        
        // Draw obstacles if enabled
        if (this.obstaclesEnabled) {
            this.drawObstacles(canvas);
        }
        
        // Draw particles
        this.drawParticles(canvas);
        
        // Draw additional visualizations
        if (this.params.showVectors) {
            this.drawVelocityVectors(canvas);
        }
        
        if (this.params.showPressure) {
            this.drawPressureField(canvas);
        }
        
        // Update UI
        this.updateUI();
    }
    
    // Draw gradient background
    drawBackground(canvas) {
        // Create gradient
        let gradient = canvas.drawingContext.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, 'rgba(10, 12, 28, 0.9)');
        gradient.addColorStop(0.5, 'rgba(15, 20, 45, 0.8)');
        gradient.addColorStop(1, 'rgba(10, 12, 28, 0.9)');
        
        canvas.drawingContext.fillStyle = gradient;
        canvas.rect(0, 0, canvas.width, canvas.height);
        canvas.fill();
        
        // Add subtle grid for depth
        canvas.strokeWeight(0.5);
        canvas.stroke(30, 40, 70, 20);
        
        const gridSize = 50;
        for (let x = 0; x < canvas.width; x += gridSize) {
            canvas.line(x, 0, x, canvas.height);
        }
        for (let y = 0; y < canvas.height; y += gridSize) {
            canvas.line(0, y, canvas.width, y);
        }
    }
    
    // Draw obstacles
    drawObstacles(canvas) {
        for (const obstacle of this.obstacles) {
            canvas.fill(40, 40, 50, 150);
            canvas.stroke(100, 100, 120, 200);
            canvas.strokeWeight(2);
            
            switch (obstacle.type) {
                case 'circle':
                    canvas.circle(obstacle.x, obstacle.y, obstacle.radius * 2);
                    break;
                    
                case 'rectangle':
                    canvas.rectMode(canvas.CENTER);
                    canvas.rect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    canvas.rectMode(canvas.CORNER);
                    break;
                    
                case 'triangle':
                    canvas.push();
                    canvas.translate(obstacle.x, obstacle.y);
                    canvas.triangle(
                        0, -obstacle.size,
                        -obstacle.size * 0.866, obstacle.size * 0.5,
                        obstacle.size * 0.866, obstacle.size * 0.5
                    );
                    canvas.pop();
                    break;
            }
        }
    }
    
    // Draw particles with bloom effect
    drawParticles(canvas) {
        const size = this.params.particleSize;
        const bloom = this.params.bloomEffect;
        
        // First pass: draw particle glow if bloom is enabled
        if (bloom) {
            for (const particle of this.particles) {
                const [x, y] = particle.position;
                const [r, g, b] = particle.color;
                
                // Draw glow (larger, more transparent circle)
                canvas.noStroke();
                canvas.fill(r, g, b, 30);
                canvas.circle(x, y, size * 4);
                
                canvas.fill(r, g, b, 60);
                canvas.circle(x, y, size * 2);
            }
        }
        
        // Second pass: draw actual particles
        for (const particle of this.particles) {
            const [x, y] = particle.position;
            const [r, g, b] = particle.color;
            
            // Draw particle
            canvas.noStroke();
            canvas.fill(r, g, b, 200);
            canvas.circle(x, y, size);
            
            // Add highlight for 3D effect
            canvas.fill(255, 255, 255, 100);
            canvas.circle(x - size/3, y - size/3, size/2);
        }
    }
    
    // Draw velocity vectors
    drawVelocityVectors(canvas) {
        canvas.strokeWeight(1);
        canvas.stroke(255, 255, 255, 150);
        
        // Draw vectors for a subset of particles
        const step = Math.max(1, Math.floor(this.particles.length / 50));
        
        for (let i = 0; i < this.particles.length; i += step) {
            const particle = this.particles[i];
            const [x, y] = particle.position;
            const [vx, vy] = particle.velocity;
            
            const speed = Math.sqrt(vx * vx + vy * vy);
            if (speed < 0.1) continue;
            
            // Draw vector
            const scale = 5;
            const endX = x + vx * scale;
            const endY = y + vy * scale;
            
            canvas.line(x, y, endX, endY);
            
            // Draw arrow head
            const angle = Math.atan2(vy, vx);
            const arrowSize = 3;
            
            canvas.push();
            canvas.translate(endX, endY);
            canvas.rotate(angle);
            
            canvas.line(0, 0, -arrowSize, -arrowSize);
            canvas.line(0, 0, -arrowSize, arrowSize);
            
            canvas.pop();
        }
    }
    
    // Draw pressure field visualization
    drawPressureField(canvas) {
        // Create a grid for pressure visualization
        const gridSize = 20;
        const cols = Math.ceil(canvas.width / gridSize);
        const rows = Math.ceil(canvas.height / gridSize);
        
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                const x = i * gridSize + gridSize / 2;
                const y = j * gridSize + gridSize / 2;
                
                // Find nearby particles to estimate pressure
                let pressure = 0;
                let count = 0;
                
                for (const particle of this.particles) {
                    const [px, py] = particle.position;
                    const dx = px - x;
                    const dy = py - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < gridSize * 2) {
                        pressure += particle.pressure;
                        count++;
                    }
                }
                
                if (count > 0) {
                    pressure /= count;
                    
                    // Normalize pressure for visualization
                    const normalizedPressure = Math.min(Math.abs(pressure) * 0.1, 1);
                    
                    if (pressure > 0) {
                        // High pressure - red
                        canvas.fill(255, 100, 100, normalizedPressure * 100);
                    } else {
                        // Low pressure - blue
                        canvas.fill(100, 100, 255, normalizedPressure * 100);
                    }
                    
                    canvas.noStroke();
                    canvas.rect(i * gridSize, j * gridSize, gridSize, gridSize);
                }
            }
        }
    }
    
    // Update UI elements
    updateUI() {
        // Update particle count
        document.querySelector('.particle-count').textContent = `Particles: ${this.particles.length}`;
    }
    
    // Setup UI controls
    setupControls() {
        // Viscosity slider
        const viscositySlider = document.getElementById('viscosity');
        const viscosityValue = document.getElementById('viscosity-value');
        
        viscositySlider.addEventListener('input', () => {
            this.params.viscosity = parseFloat(viscositySlider.value);
            viscosityValue.textContent = this.params.viscosity.toFixed(2);
        });
        
        // Density slider
        const densitySlider = document.getElementById('density');
        const densityValue = document.getElementById('density-value');
        
        densitySlider.addEventListener('input', () => {
            this.params.density = parseFloat(densitySlider.value);
            densityValue.textContent = this.params.density.toFixed(1);
        });
        
        // Pressure strength slider
        const pressureSlider = document.getElementById('pressure-strength');
        const pressureValue = document.getElementById('pressure-value');
        
        pressureSlider.addEventListener('input', () => {
            this.params.pressureStrength = parseFloat(pressureSlider.value);
            pressureValue.textContent = this.params.pressureStrength.toFixed(1);
        });
        
        // Surface tension slider
        const tensionSlider = document.getElementById('surface-tension');
        const tensionValue = document.getElementById('tension-value');
        
        tensionSlider.addEventListener('input', () => {
            this.params.surfaceTension = parseFloat(tensionSlider.value);
            tensionValue.textContent = this.params.surfaceTension.toFixed(1);
        });
        
        // Mouse force slider
        const forceSlider = document.getElementById('mouse-force');
        const forceValue = document.getElementById('force-value');
        
        forceSlider.addEventListener('input', () => {
            this.params.mouseForceStrength = parseFloat(forceSlider.value);
            forceValue.textContent = this.params.mouseForceStrength.toFixed(1);
        });
        
        // Particle size slider
        const particleSizeSlider = document.getElementById('particle-size');
        const particleSizeValue = document.getElementById('particle-size-value');
        
        particleSizeSlider.addEventListener('input', () => {
            this.params.particleSize = parseFloat(particleSizeSlider.value);
            particleSizeValue.textContent = this.params.particleSize.toFixed(1);
        });
        
        // Color mixing slider
        const mixingSlider = document.getElementById('color-mixing');
        const mixingValue = document.getElementById('mixing-value');
        
        mixingSlider.addEventListener('input', () => {
            this.params.colorMixingSpeed = parseFloat(mixingSlider.value);
            mixingValue.textContent = this.params.colorMixingSpeed.toFixed(2);
        });
        
        // Simulation speed slider
        const speedSlider = document.getElementById('sim-speed');
        const speedValue = document.getElementById('sim-speed-value');
        
        speedSlider.addEventListener('input', () => {
            this.params.simulationSpeed = parseFloat(speedSlider.value);
            speedValue.textContent = this.params.simulationSpeed.toFixed(1);
        });
        
        // Toggles
        document.getElementById('show-vectors').addEventListener('change', (e) => {
            this.params.showVectors = e.target.checked;
        });
        
        document.getElementById('show-pressure').addEventListener('change', (e) => {
            this.params.showPressure = e.target.checked;
        });
        
        document.getElementById('bloom-effect').addEventListener('change', (e) => {
            this.params.bloomEffect = e.target.checked;
        });
        
        document.getElementById('pause-toggle').addEventListener('change', (e) => {
            this.isPaused = e.target.checked;
        });
        
        document.getElementById('obstacles-toggle').addEventListener('change', (e) => {
            this.obstaclesEnabled = e.target.checked;
        });
        
        // Color buttons
        document.getElementById('color-blue').addEventListener('click', () => {
            this.params.currentColor = [100, 200, 255]; // Blue
        });
        
        document.getElementById('color-red').addEventListener('click', () => {
            this.params.currentColor = [255, 100, 100]; // Red
        });
        
        document.getElementById('color-green').addEventListener('click', () => {
            this.params.currentColor = [100, 255, 150]; // Green
        });
        
        document.getElementById('color-yellow').addEventListener('click', () => {
            this.params.currentColor = [255, 255, 100]; // Yellow
        });
        
        document.getElementById('color-purple').addEventListener('click', () => {
            this.params.currentColor = [200, 100, 255]; // Purple
        });
        
        document.getElementById('color-white').addEventListener('click', () => {
            this.params.currentColor = [255, 255, 255]; // White
        });
        
        // Force buttons
        document.getElementById('force-vortex').addEventListener('click', () => {
            this.applyExternalForce('vortex', 400, 300, 2.0);
        });
        
        document.getElementById('force-explosion').addEventListener('click', () => {
            this.applyExternalForce('explosion', 400, 300, 3.0);
        });
        
        document.getElementById('force-gravity').addEventListener('click', () => {
            this.params.gravity = Math.min(this.params.gravity + 0.5, 5.0);
        });
        
        document.getElementById('force-updraft').addEventListener('click', () => {
            this.params.gravity = Math.max(this.params.gravity - 0.5, -5.0);
        });
        
        // Preset buttons
        document.getElementById('preset-water').addEventListener('click', () => {
            this.params.viscosity = 0.1;
            this.params.density = 1.0;
            this.params.pressureStrength = 1.0;
            this.params.surfaceTension = 0.5;
            
            viscositySlider.value = 0.1;
            viscosityValue.textContent = '0.10';
            densitySlider.value = 1.0;
            densityValue.textContent = '1.0';
            pressureSlider.value = 1.0;
            pressureValue.textContent = '1.0';
            tensionSlider.value = 0.5;
            tensionValue.textContent = '0.5';
        });
        
        document.getElementById('preset-oil').addEventListener('click', () => {
            this.params.viscosity = 0.8;
            this.params.density = 1.5;
            this.params.pressureStrength = 0.5;
            this.params.surfaceTension = 1.5;
            
            viscositySlider.value = 0.8;
            viscosityValue.textContent = '0.80';
            densitySlider.value = 1.5;
            densityValue.textContent = '1.5';
            pressureSlider.value = 0.5;
            pressureValue.textContent = '0.5';
            tensionSlider.value = 1.5;
            tensionValue.textContent = '1.5';
        });
        
        document.getElementById('preset-multicolor').addEventListener('click', () => {
            // Add particles with different colors
            const colors = [
                [255, 100, 100], // Red
                [100, 200, 255], // Blue
                [100, 255, 150], // Green
                [255, 255, 100], // Yellow
                [200, 100, 255]  // Purple
            ];
            
            for (let i = 0; i < 200; i++) {
                const x = Math.random() * 800;
                const y = Math.random() * 600;
                const color = colors[Math.floor(Math.random() * colors.length)];
                this.addParticle(x, y, color);
            }
        });
        
        document.getElementById('reset-button').addEventListener('click', () => {
            this.initializeFluid();
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            switch(event.key) {
                case ' ':
                    // Space to toggle pause
                    this.isPaused = !this.isPaused;
                    document.getElementById('pause-toggle').checked = this.isPaused;
                    break;
                    
                case 'r':
                case 'R':
                    // R to reset
                    this.initializeFluid();
                    break;
                    
                case 'v':
                case 'V':
                    // V for vortex
                    this.applyExternalForce('vortex', 400, 300, 2.0);
                    break;
                    
                case 'e':
                case 'E':
                    // E for explosion
                    this.applyExternalForce('explosion', 400, 300, 3.0);
                    break;
                    
                case '1':
                    this.params.currentColor = [100, 200, 255];
                    break;
                case '2':
                    this.params.currentColor = [255, 100, 100];
                    break;
                case '3':
                    this.params.currentColor = [100, 255, 150];
                    break;
                case '4':
                    this.params.currentColor = [255, 255, 100];
                    break;
                case '5':
                    this.params.currentColor = [200, 100, 255];
                    break;
                case '6':
                    this.params.currentColor = [255, 255, 255];
                    break;
                    
                case 'g':
                case 'G':
                    // Toggle gravity
                    this.params.gravity = this.params.gravity > 0 ? 0 : 0.5;
                    break;
            }
        });
    }
}

// p5.js Sketch
let fluidSim;
let lastMouseX = 0;
let lastMouseY = 0;

function setup() {
    const canvasContainer = document.getElementById('fluid-canvas');
    const canvasWidth = canvasContainer.offsetWidth;
    const canvasHeight = canvasContainer.offsetHeight;
    
    // Create canvas
    const canvas = createCanvas(canvasWidth, canvasHeight);
    canvas.parent('fluid-canvas');
    
    // Initialize fluid simulation
    fluidSim = new SPHFluidSimulation();
    
    // Initialize mouse position
    lastMouseX = mouseX;
    lastMouseY = mouseY;
}

function draw() {
    // Calculate FPS
    const fps = Math.round(frameRate());
    document.querySelector('.fps-counter').textContent = `FPS: ${fps}`;
    
    // Calculate mouse movement for interaction
    const mouseForceX = mouseX - lastMouseX;
    const mouseForceY = mouseY - lastMouseY;
    
    // Apply mouse force if mouse is pressed
    if (mouseIsPressed) {
        fluidSim.applyMouseForce(mouseX, mouseY, mouseForceX, mouseForceY);
    }
    
    // Update simulation
    fluidSim.step();
    
    // Draw simulation
    fluidSim.draw(canvas);
    
    // Update mouse position
    lastMouseX = mouseX;
    lastMouseY = mouseY;
}

function windowResized() {
    const canvasContainer = document.getElementById('fluid-canvas');
    const canvasWidth = canvasContainer.offsetWidth;
    const canvasHeight = canvasContainer.offsetHeight;
    resizeCanvas(canvasWidth, canvasHeight);
}

// Initialize the simulation when the page loads
window.addEventListener('DOMContentLoaded', () => {
    // p5.js will call setup() and draw() automatically
});
    </script>
</body>
</html>