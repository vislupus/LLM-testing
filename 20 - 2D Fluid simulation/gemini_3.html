<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Fluid Dynamics - Navier Stokes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            /* Smooth scaling for the fluid texture */
            image-rendering: linear; 
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 8px;
            pointer-events: auto;
            user-select: none;
            width: 250px;
            backdrop-filter: blur(5px);
            border: 1px solid #444;
        }
        h2 { margin: 0 0 10px 0; font-size: 18px; color: #00d2ff; }
        .instruction { font-size: 12px; color: #aaa; margin-bottom: 15px; }
        .slider-group { margin-bottom: 10px; }
        label { display: flex; justify-content: space-between; font-size: 13px; }
        input[type=range] { width: 100%; margin-top: 5px; cursor: pointer; }
        .btn-group { display: flex; gap: 5px; margin-top: 15px; }
        button {
            flex: 1;
            padding: 8px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        button:hover { background: #555; }
        button.active { background: #00d2ff; color: #000; border-color: #00d2ff; }
    </style>
</head>
<body>

<div id="controls">
    <h2>Fluid Dynamics</h2>
    <div class="instruction">
        Left Click & Drag: Add Dye & Velocity<br>
        Right Click & Drag: Add Velocity Only
    </div>

    <div class="slider-group">
        <label>Viscosity <span id="val-visc">0.000</span></label>
        <input type="range" id="sl-visc" min="0" max="0.005" step="0.0001" value="0.0000">
    </div>

    <div class="slider-group">
        <label>Diffusion (Spread) <span id="val-diff">0.000</span></label>
        <input type="range" id="sl-diff" min="0" max="0.005" step="0.0001" value="0.0000">
    </div>

    <div class="slider-group">
        <label>Dissipation (Fade) <span id="val-fade">0.002</span></label>
        <input type="range" id="sl-fade" min="0" max="0.05" step="0.001" value="0.002">
    </div>

    <div class="btn-group">
        <button id="btn-rainbow" class="active">Rainbow</button>
        <button id="btn-reset">Clear</button>
    </div>
</div>

<script>
/**
 * FLUID SIMULATION ENGINE
 * Based on Jos Stam's "Real-Time Fluid Dynamics for Games"
 * Implements a grid-based Navier-Stokes solver.
 */

// Simulation Constants
const N = 128; // Grid Resolution (128x128)
const ITER = 10; // Solver Iterations (Higher = more accurate pressure/incompressibility)
const SCALE = 4; // Visual scaling factor (will be adjusted dynamically)

let fluid;
let colorModeRainbow = true;
let hueOffset = 0;

// P5.js Setup
function setup() {
    createCanvas(windowWidth, windowHeight);
    
    // Adjust density to screen size
    // We run the sim at a fixed resolution (N) and scale it up
    fluid = new Fluid(N, 0.00000, 0.00000, 0.002);
    
    // UI Setup
    const slVisc = select('#sl-visc');
    const slDiff = select('#sl-diff');
    const slFade = select('#sl-fade');
    
    slVisc.input(() => { 
        fluid.visc = parseFloat(slVisc.value()); 
        select('#val-visc').html(fluid.visc.toFixed(4));
    });
    slDiff.input(() => { 
        fluid.diff = parseFloat(slDiff.value()); 
        select('#val-diff').html(fluid.diff.toFixed(4));
    });
    slFade.input(() => { 
        fluid.fade = parseFloat(slFade.value()); 
        select('#val-fade').html(fluid.fade.toFixed(3));
    });

    select('#btn-rainbow').mousePressed(() => {
        colorModeRainbow = !colorModeRainbow;
        select('#btn-rainbow').toggleClass('active');
    });

    select('#btn-reset').mousePressed(() => {
        fluid = new Fluid(N, parseFloat(slVisc.value()), parseFloat(slDiff.value()), parseFloat(slFade.value()));
    });
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
}

function draw() {
    background(0);

    // 1. Handle Input
    if (mouseIsPressed) {
        // Map mouse coordinates to grid coordinates
        let x = mouseX / width * N;
        let y = mouseY / height * N;
        
        // Calculate velocity from mouse movement
        let amtX = mouseX - pmouseX;
        let amtY = mouseY - pmouseY;
        
        // Add Velocity
        fluid.addVelocity(x, y, amtX, amtY);

        // Add Dye (if left click)
        if (mouseButton === LEFT) {
            let r, g, b;
            if (colorModeRainbow) {
                hueOffset += 1;
                let c = color(`hsb(${hueOffset % 360}, 80%, 100%)`);
                r = red(c); g = green(c); b = blue(c);
            } else {
                r = 255; g = 255; b = 255;
            }
            fluid.addDensity(x, y, r, g, b, 150);
        }
    }
    
    // 2. Auto-drift for visual interest if idle
    if (!mouseIsPressed && frameCount % 200 === 0) {
        let cx = N/2;
        let cy = N/2;
        for(let i=0; i<2; i++) {
            fluid.addVelocity(cx + random(-10,10), cy + random(-10,10), random(-5,5), random(-5,5));
            fluid.addDensity(cx, cy, random(255), random(255), random(255), 200);
        }
    }

    // 3. Step Physics
    fluid.step();

    // 4. Render
    fluid.render();
}


/**
 * Fluid Class
 * Handles the density and velocity fields
 */
class Fluid {
    constructor(size, diffusion, viscosity, fade) {
        this.size = size;
        this.dt = 0.2; // Time step
        this.diff = diffusion;
        this.visc = viscosity;
        this.fade = fade; // How fast dye dissipates

        // Initialize Arrays
        // Density (Color channels stored separately for RGB mixing)
        this.densityR = new Float32Array(size * size);
        this.densityG = new Float32Array(size * size);
        this.densityB = new Float32Array(size * size);

        this.sR = new Float32Array(size * size);
        this.sG = new Float32Array(size * size);
        this.sB = new Float32Array(size * size);

        // Velocity (X and Y)
        this.Vx = new Float32Array(size * size);
        this.Vy = new Float32Array(size * size);
        this.Vx0 = new Float32Array(size * size);
        this.Vy0 = new Float32Array(size * size);

        // Create an offscreen graphics buffer for rendering efficiency
        // We draw pixels to this small image, then scale it up to fit the screen
        this.img = createImage(size, size);
    }

    // Add matter to the grid
    addDensity(x, y, r, g, b, amount) {
        let index = this.IX(Math.floor(x), Math.floor(y));
        this.densityR[index] += amount * (r/255);
        this.densityG[index] += amount * (g/255);
        this.densityB[index] += amount * (b/255);
    }

    // Add force to the grid
    addVelocity(x, y, amountX, amountY) {
        let index = this.IX(Math.floor(x), Math.floor(y));
        this.Vx[index] += amountX;
        this.Vy[index] += amountY;
    }

    // The Main Physics Step
    step() {
        let N = this.size;
        let visc = this.visc;
        let diff = this.diff;
        let dt = this.dt;
        let Vx = this.Vx;
        let Vy = this.Vy;
        let Vx0 = this.Vx0;
        let Vy0 = this.Vy0;

        // 1. Diffuse Velocity (Viscosity)
        this.diffuse(1, Vx0, Vx, visc, dt);
        this.diffuse(2, Vy0, Vy, visc, dt);

        // 2. Project (Make fluid incompressible / mass conserving - Creates Swirls)
        this.project(Vx0, Vy0, Vx, Vy);

        // 3. Advect Velocity (Move velocity along itself)
        this.advect(1, Vx, Vx0, Vx0, Vy0, dt);
        this.advect(2, Vy, Vy0, Vx0, Vy0, dt);

        // 4. Project Again (Clean up errors from advection)
        this.project(Vx, Vy, Vx0, Vy0);

        // 5. Diffuse Density (Color spreading)
        this.diffuse(0, this.sR, this.densityR, diff, dt);
        this.diffuse(0, this.sG, this.densityG, diff, dt);
        this.diffuse(0, this.sB, this.densityB, diff, dt);

        // 6. Advect Density (Move color along velocity field)
        this.advect(0, this.densityR, this.sR, Vx, Vy, dt);
        this.advect(0, this.densityG, this.sG, Vx, Vy, dt);
        this.advect(0, this.densityB, this.sB, Vx, Vy, dt);
        
        // 7. Fade out
        this.fadeDensity();
    }

    fadeDensity() {
        for (let i = 0; i < this.densityR.length; i++) {
            let d = 1 - this.fade;
            this.densityR[i] *= d;
            this.densityG[i] *= d;
            this.densityB[i] *= d;
        }
    }

    // --- Solver Core Functions ---

    // IX: Helper to get 1D array index from 2D coordinates
    IX(x, y) {
        // Clamp coords
        x = x < 0 ? 0 : x > this.size - 1 ? this.size - 1 : x;
        y = y < 0 ? 0 : y > this.size - 1 ? this.size - 1 : y;
        return x + y * this.size;
    }

    // Gauss-Seidel relaxation solver for diffusion
    diffuse(b, x, x0, diff, dt) {
        let a = dt * diff * (this.size - 2) * (this.size - 2);
        this.lin_solve(b, x, x0, a, 1 + 6 * a);
    }

    // Linear Solver
    lin_solve(b, x, x0, a, c) {
        let reciprocalC = 1.0 / c;
        for (let k = 0; k < ITER; k++) {
            for (let j = 1; j < this.size - 1; j++) {
                for (let i = 1; i < this.size - 1; i++) {
                    x[this.IX(i, j)] =
                        (x0[this.IX(i, j)] +
                            a * (x[this.IX(i + 1, j)] +
                                    x[this.IX(i - 1, j)] +
                                    x[this.IX(i, j + 1)] +
                                    x[this.IX(i, j - 1)]
                            )) * reciprocalC;
                }
            }
            this.set_bnd(b, x);
        }
    }

    // Project: Subtracts the gradient of the pressure field to ensure mass conservation
    project(velocX, velocY, p, div) {
        for (let j = 1; j < this.size - 1; j++) {
            for (let i = 1; i < this.size - 1; i++) {
                div[this.IX(i, j)] = -0.5 * (
                        velocX[this.IX(i + 1, j)] - velocX[this.IX(i - 1, j)] +
                        velocY[this.IX(i, j + 1)] - velocY[this.IX(i, j - 1)]
                    ) / this.size;
                p[this.IX(i, j)] = 0;
            }
        }
        this.set_bnd(0, div);
        this.set_bnd(0, p);
        this.lin_solve(0, p, div, 1, 6);

        for (let j = 1; j < this.size - 1; j++) {
            for (let i = 1; i < this.size - 1; i++) {
                velocX[this.IX(i, j)] -= 0.5 * (p[this.IX(i + 1, j)] - p[this.IX(i - 1, j)]) * this.size;
                velocY[this.IX(i, j)] -= 0.5 * (p[this.IX(i, j + 1)] - p[this.IX(i, j - 1)]) * this.size;
            }
        }
        this.set_bnd(1, velocX);
        this.set_bnd(2, velocY);
    }

    // Advect: Move quantities (density or velocity) along the velocity field
    advect(b, d, d0, velocX, velocY, dt) {
        let i0, i1, j0, j1;
        
        let dtx = dt * (this.size - 2);
        let dty = dt * (this.size - 2);
        
        let s0, s1, t0, t1;
        let tmp1, tmp2, x, y;
        
        let Nfloat = this.size - 2;
        let ifloat, jfloat;
        
        for (let j = 1, jfloat = 1; j < this.size - 1; j++, jfloat++) {
            for (let i = 1, ifloat = 1; i < this.size - 1; i++, ifloat++) {
                tmp1 = dtx * velocX[this.IX(i, j)];
                tmp2 = dty * velocY[this.IX(i, j)];
                
                x = ifloat - tmp1;
                y = jfloat - tmp2;
                
                if (x < 0.5) x = 0.5;
                if (x > Nfloat + 0.5) x = Nfloat + 0.5;
                i0 = Math.floor(x);
                i1 = i0 + 1;
                
                if (y < 0.5) y = 0.5;
                if (y > Nfloat + 0.5) y = Nfloat + 0.5;
                j0 = Math.floor(y);
                j1 = j0 + 1;
                
                s1 = x - i0;
                s0 = 1.0 - s1;
                t1 = y - j0;
                t0 = 1.0 - t1;
                
                let i0j0 = this.IX(i0, j0);
                let i0j1 = this.IX(i0, j1);
                let i1j0 = this.IX(i1, j0);
                let i1j1 = this.IX(i1, j1);
                
                d[this.IX(i, j)] =
                    s0 * (t0 * d0[i0j0] + t1 * d0[i0j1]) +
                    s1 * (t0 * d0[i1j0] + t1 * d0[i1j1]);
            }
        }
        this.set_bnd(b, d);
    }

    // Boundary conditions: Reflection for velocity, continuity for density
    set_bnd(b, x) {
        for (let i = 1; i < this.size - 1; i++) {
            x[this.IX(i, 0)] = b == 2 ? -x[this.IX(i, 1)] : x[this.IX(i, 1)];
            x[this.IX(i, this.size - 1)] = b == 2 ? -x[this.IX(i, this.size - 2)] : x[this.IX(i, this.size - 2)];
        }
        for (let j = 1; j < this.size - 1; j++) {
            x[this.IX(0, j)] = b == 1 ? -x[this.IX(1, j)] : x[this.IX(1, j)];
            x[this.IX(this.size - 1, j)] = b == 1 ? -x[this.IX(this.size - 2, j)] : x[this.IX(this.size - 2, j)];
        }
        
        x[this.IX(0, 0)] = 0.5 * (x[this.IX(1, 0)] + x[this.IX(0, 1)]);
        x[this.IX(0, this.size - 1)] = 0.5 * (x[this.IX(1, this.size - 1)] + x[this.IX(0, this.size - 2)]);
        x[this.IX(this.size - 1, 0)] = 0.5 * (x[this.IX(this.size - 2, 0)] + x[this.IX(this.size - 1, 1)]);
        x[this.IX(this.size - 1, this.size - 1)] = 0.5 * (x[this.IX(this.size - 2, this.size - 1)] + x[this.IX(this.size - 1, this.size - 2)]);
    }

    // Draw fluid to screen
    render() {
        this.img.loadPixels();
        for (let y = 0; y < this.size; y++) {
            for (let x = 0; x < this.size; x++) {
                let index = this.IX(x, y);
                let pxIndex = (x + y * this.size) * 4;
                
                // Retrieve separate color channels
                let r = this.densityR[index] * 255;
                let g = this.densityG[index] * 255;
                let b = this.densityB[index] * 255;
                
                // Optional: Visualize pressure/velocity (commented out for cleaner dye look)
                // let velMag = Math.sqrt(this.Vx[index]**2 + this.Vy[index]**2) * 500;
                // b += velMag; 

                this.img.pixels[pxIndex + 0] = constrain(r, 0, 255);
                this.img.pixels[pxIndex + 1] = constrain(g, 0, 255);
                this.img.pixels[pxIndex + 2] = constrain(b, 0, 255);
                this.img.pixels[pxIndex + 3] = 255; // Alpha
            }
        }
        this.img.updatePixels();
        
        // Draw the low-res fluid texture scaled up to full screen
        // The browser/p5 automatically applies interpolation smoothing
        image(this.img, 0, 0, width, height);
    }
}
</script>
</body>
</html>