<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Fluid Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            animation: fadeIn 0.5s ease-out;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        #sketch-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: slideUp 0.6s ease-out;
        }

        .controls {
            margin-top: 20px;
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            color: #333;
            max-width: 600px;
            animation: slideUp 0.7s ease-out;
        }

        .controls h2 {
            margin-bottom: 15px;
            color: #667eea;
            font-size: 1.5rem;
        }

        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .control-group {
            background: #f8f8f8;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .control-group h3 {
            font-size: 1rem;
            margin-bottom: 8px;
            color: #555;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .key {
            background: #667eea;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .status {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-around;
            text-align: center;
        }

        .status-item {
            flex: 1;
        }

        .status-label {
            font-size: 0.85rem;
            color: #777;
            margin-bottom: 5px;
        }

        .status-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { 
                opacity: 0;
                transform: translateY(20px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Interactive Fluid Simulation</h1>
        <p class="subtitle">Click and drag to inject velocity • Press keys to add colors and forces</p>
    </header>

    <div id="sketch-container"></div>

    <div class="controls">
        <h2>Controls</h2>
        <div class="control-grid">
            <div class="control-group">
                <h3>Color Injection</h3>
                <div class="control-item">
                    <span>Red fluid</span>
                    <span class="key">1</span>
                </div>
                <div class="control-item">
                    <span>Blue fluid</span>
                    <span class="key">2</span>
                </div>
                <div class="control-item">
                    <span>Green fluid</span>
                    <span class="key">3</span>
                </div>
                <div class="control-item">
                    <span>Yellow fluid</span>
                    <span class="key">4</span>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Forces & Effects</h3>
                <div class="control-item">
                    <span>Add vortex</span>
                    <span class="key">SPACE</span>
                </div>
                <div class="control-item">
                    <span>Toggle vortex mode</span>
                    <span class="key">V</span>
                </div>
                <div class="control-item">
                    <span>Increase viscosity</span>
                    <span class="key">↑</span>
                </div>
                <div class="control-item">
                    <span>Decrease viscosity</span>
                    <span class="key">↓</span>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Simulation</h3>
                <div class="control-item">
                    <span>Reset scene</span>
                    <span class="key">R</span>
                </div>
                <div class="control-item">
                    <span>Toggle obstacles</span>
                    <span class="key">O</span>
                </div>
                <div class="control-item">
                    <span>Pause/Resume</span>
                    <span class="key">P</span>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Display</h3>
                <div class="control-item">
                    <span>Toggle velocity field</span>
                    <span class="key">F</span>
                </div>
                <div class="control-item">
                    <span>Toggle pressure view</span>
                    <span class="key">G</span>
                </div>
                <div class="control-item">
                    <span>Clear colors</span>
                    <span class="key">C</span>
                </div>
            </div>
        </div>
        
        <div class="status">
            <div class="status-item">
                <div class="status-label">Viscosity</div>
                <div class="status-value" id="viscosityValue">0.000001</div>
            </div>
            <div class="status-item">
                <div class="status-label">Vortex Mode</div>
                <div class="status-value" id="vortexStatus">OFF</div>
            </div>
            <div class="status-item">
                <div class="status-label">FPS</div>
                <div class="status-value" id="fpsValue">60</div>
            </div>
        </div>
    </div>

    <script>
        let fluid;
        let currentColor = [255, 100, 100];
        let showVelocity = false;
        let showPressure = false;
        let vortexMode = false;
        let showObstacles = true;
        let isPaused = false;
        let fps = 60;

        // Fluid simulation class
        class Fluid {
            constructor(N, dt, diffusion, viscosity) {
                this.N = N;
                this.dt = dt;
                this.diff = diffusion;
                this.visc = viscosity;
                
                this.size = (N + 2) * (N + 2);
                this.s = new Array(this.size).fill(0);
                this.density = new Array(this.size).fill(0);
                
                this.Vx = new Array(this.size).fill(0);
                this.Vy = new Array(this.size).fill(0);
                
                this.Vx0 = new Array(this.size).fill(0);
                this.Vy0 = new Array(this.size).fill(0);
                
                // Color channels
                this.red = new Array(this.size).fill(0);
                this.green = new Array(this.size).fill(0);
                this.blue = new Array(this.size).fill(0);
                
                // Obstacles
                this.obstacles = new Array(this.size).fill(0);
                this.initObstacles();
            }
            
            initObstacles() {
                // Add some circular obstacles
                for (let i = 1; i <= this.N; i++) {
                    for (let j = 1; j <= this.N; j++) {
                        let idx = this.IX(i, j);
                        let x = (i / this.N) * width;
                        let y = (j / this.N) * height;
                        
                        // Add obstacles at specific positions
                        if (dist(x, y, width * 0.3, height * 0.5) < 30 ||
                            dist(x, y, width * 0.7, height * 0.3) < 25 ||
                            dist(x, y, width * 0.6, height * 0.7) < 35) {
                            this.obstacles[idx] = 1;
                        }
                    }
                }
            }
            
            IX(i, j) {
                return i + (this.N + 2) * j;
            }
            
            addDensity(x, y, amount, color) {
                let index = this.IX(x, y);
                this.density[index] += amount;
                this.red[index] += color[0] * amount;
                this.green[index] += color[1] * amount;
                this.blue[index] += color[2] * amount;
            }
            
            addVelocity(x, y, amountX, amountY) {
                let index = this.IX(x, j);
                this.Vx[index] += amountX;
                this.Vy[index] += amountY;
            }
            
            step() {
                if (isPaused) return;
                
                let visc = this.visc;
                let diff = this.diff;
                let dt = this.dt;
                let Vx = this.Vx;
                let Vy = this.Vy;
                let Vx0 = this.Vx0;
                let Vy0 = this.Vy0;
                let s = this.s;
                let density = this.density;
                let N = this.N;
                
                // Velocity step
                this.diffuse(1, Vx0, Vx, visc, dt);
                this.diffuse(2, Vy0, Vy, visc, dt);
                
                this.project(Vx0, Vy0, Vx, Vy);
                
                this.advect(1, Vx, Vx0, Vx0, Vy0, dt);
                this.advect(2, Vy, Vy0, Vx0, Vy0, dt);
                
                this.project(Vx, Vy, Vx0, Vy0);
                
                // Density step
                this.diffuse(0, s, density, diff, dt);
                this.advect(0, density, s, Vx, Vy, dt);
                
                // Color diffusion
                this.diffuseColor(this.red, dt);
                this.diffuseColor(this.green, dt);
                this.diffuseColor(this.blue, dt);
                
                this.advectColor(this.red, Vx, Vy, dt);
                this.advectColor(this.green, Vx, Vy, dt);
                this.advectColor(this.blue, Vx, Vy, dt);
                
                // Apply obstacles
                this.applyObstacles();
                
                // Vortex mode
                if (vortexMode) {
                    this.addVortexForce();
                }
            }
            
            applyObstacles() {
                for (let i = 1; i <= this.N; i++) {
                    for (let j = 1; j <= this.N; j++) {
                        let idx = this.IX(i, j);
                        if (this.obstacles[idx] === 1) {
                            this.Vx[idx] = 0;
                            this.Vy[idx] = 0;
                            this.density[idx] = 0;
                            this.red[idx] = 0;
                            this.green[idx] = 0;
                            this.blue[idx] = 0;
                        }
                    }
                }
            }
            
            addVortexForce() {
                let centerX = Math.floor((mouseX / width) * this.N) + 1;
                let centerY = Math.floor((mouseY / height) * this.N) + 1;
                
                for (let i = -5; i <= 5; i++) {
                    for (let j = -5; j <= 5; j++) {
                        let x = centerX + i;
                        let y = centerY + j;
                        
                        if (x > 0 && x <= this.N && y > 0 && y <= this.N) {
                            let idx = this.IX(x, y);
                            let angle = atan2(j, i) + PI / 2;
                            let force = 50 / (1 + sqrt(i * i + j * j));
                            
                            this.Vx[idx] += cos(angle) * force;
                            this.Vy[idx] += sin(angle) * force;
                        }
                    }
                }
            }
            
            diffuseColor(colorArr, dt) {
                let a = dt * this.diff * this.N * this.N;
                this.lin_solve(0, colorArr, colorArr, a, 1 + 4 * a);
            }
            
            advectColor(colorArr, Vx, Vy, dt) {
                let N = this.N;
                let dt0 = dt * N;
                let Np1 = N + 1;
                let Np2 = N + 2;
                
                for (let i = 1; i <= N; i++) {
                    for (let j = 1; j <= N; j++) {
                        let x = i - dt0 * Vx[this.IX(i, j)];
                        let y = j - dt0 * Vy[this.IX(i, j)];
                        
                        if (x < 0.5) x = 0.5;
                        if (x > N + 0.5) x = N + 0.5;
                        let i0 = Math.floor(x);
                        let i1 = i0 + 1;
                        
                        if (y < 0.5) y = 0.5;
                        if (y > N + 0.5) y = N + 0.5;
                        let j0 = Math.floor(y);
                        let j1 = j0 + 1;
                        
                        let s1 = x - i0;
                        let s0 = 1 - s1;
                        let t1 = y - j0;
                        let t0 = 1 - t1;
                        
                        let idx = this.IX(i, j);
                        colorArr[idx] = s0 * (t0 * colorArr[this.IX(i0, j0)] + t1 * colorArr[this.IX(i0, j1)]) +
                                        s1 * (t0 * colorArr[this.IX(i1, j0)] + t1 * colorArr[this.IX(i1, j1)]);
                    }
                }
            }
            
            diffuse(b, x, x0, diff, dt) {
                let a = dt * diff * this.N * this.N;
                this.lin_solve(b, x, x0, a, 1 + 4 * a);
            }
            
            lin_solve(b, x, x0, a, c) {
                let N = this.N;
                let cRecip = 1.0 / c;
                
                for (let k = 0; k < 4; k++) {
                    for (let j = 1; j <= N; j++) {
                        for (let i = 1; i <= N; i++) {
                            let idx = this.IX(i, j);
                            x[idx] = (x0[idx] + a * (x[this.IX(i + 1, j)] + x[this.IX(i - 1, j)] +
                                                     x[this.IX(i, j + 1)] + x[this.IX(i, j - 1)])) * cRecip;
                        }
                    }
                    this.set_bnd(b, x);
                }
            }
            
            project(velocX, velocY, p, div) {
                let N = this.N;
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        let idx = this.IX(i, j);
                        div[idx] = -0.5 * (velocX[this.IX(i + 1, j)] - velocX[this.IX(i - 1, j)] +
                                          velocY[this.IX(i, j + 1)] - velocY[this.IX(i, j - 1)]) / N;
                        p[idx] = 0;
                    }
                }
                
                this.set_bnd(0, div);
                this.set_bnd(0, p);
                this.lin_solve(0, p, div, 1, 4);
                
                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        let idx = this.IX(i, j);
                        velocX[idx] -= 0.5 * N * (p[this.IX(i + 1, j)] - p[this.IX(i - 1, j)]);
                        velocY[idx] -= 0.5 * N * (p[this.IX(i, j + 1)] - p[this.IX(i, j - 1)]);
                    }
                }
                
                this.set_bnd(1, velocX);
                this.set_bnd(2, velocY);
            }
            
            advect(b, d, d0, velocX, velocY, dt) {
                let N = this.N;
                let dt0 = dt * N;
                let Np1 = N + 1;
                let Np2 = N + 2;
                
                for (let i = 1; i <= N; i++) {
                    for (let j = 1; j <= N; j++) {
                        let x = i - dt0 * velocX[this.IX(i, j)];
                        let y = j - dt0 * velocY[this.IX(i, j)];
                        
                        if (x < 0.5) x = 0.5;
                        if (x > N + 0.5) x = N + 0.5;
                        let i0 = Math.floor(x);
                        let i1 = i0 + 1;
                        
                        if (y < 0.5) y = 0.5;
                        if (y > N + 0.5) y = N + 0.5;
                        let j0 = Math.floor(y);
                        let j1 = j0 + 1;
                        
                        let s1 = x - i0;
                        let s0 = 1 - s1;
                        let t1 = y - j0;
                        let t0 = 1 - t1;
                        
                        let idx = this.IX(i, j);
                        d[idx] = s0 * (t0 * d0[this.IX(i0, j0)] + t1 * d0[this.IX(i0, j1)]) +
                                 s1 * (t0 * d0[this.IX(i1, j0)] + t1 * d0[this.IX(i1, j1)]);
                    }
                }
                
                this.set_bnd(b, d);
            }
            
            set_bnd(b, x) {
                let N = this.N;
                
                for (let i = 1; i <= N; i++) {
                    x[this.IX(0, i)] = b === 1 ? -x[this.IX(1, i)] : x[this.IX(1, i)];
                    x[this.IX(N + 1, i)] = b === 1 ? -x[this.IX(N, i)] : x[this.IX(N, i)];
                    x[this.IX(i, 0)] = b === 2 ? -x[this.IX(i, 1)] : x[this.IX(i, 1)];
                    x[this.IX(i, N + 1)] = b === 2 ? -x[this.IX(i, N)] : x[this.IX(i, N)];
                }
                
                x[this.IX(0, 0)] = 0.5 * (x[this.IX(1, 0)] + x[this.IX(0, 1)]);
                x[this.IX(0, N + 1)] = 0.5 * (x[this.IX(1, N + 1)] + x[this.IX(0, N)]);
                x[this.IX(N + 1, 0)] = 0.5 * (x[this.IX(N, 0)] + x[this.IX(N + 1, 1)]);
                x[this.IX(N + 1, N + 1)] = 0.5 * (x[this.IX(N, N + 1)] + x[this.IX(N + 1, N)]);
            }
            
            render() {
                let N = this.N;
                let cellSize = width / N;
                
                loadPixels();
                
                for (let i = 1; i <= N; i++) {
                    for (let j = 1; j <= N; j++) {
                        let idx = this.IX(i, j);
                        let x = (i - 1) * cellSize;
                        let y = (j - 1) * cellSize;
                        
                        let density = this.density[idx];
                        let r = this.red[idx];
                        let g = this.green[idx];
                        let b = this.blue[idx];
                        
                        // Normalize colors
                        if (density > 0) {
                            r = (r / density) * 255;
                            g = (g / density) * 255;
                            b = (b / density) * 255;
                        } else {
                            r = g = b = 0;
                        }
                        
                        // Add pressure visualization
                        if (showPressure) {
                            let pressure = Math.abs(this.Vx[idx]) + Math.abs(this.Vy[idx]);
                            let pressureColor = map(pressure, 0, 100, 0, 255);
                            r = lerp(r, pressureColor, 0.3);
                            g = lerp(g, pressureColor * 0.5, 0.3);
                        }
                        
                        // Fade to background
                        let fadeFactor = 0.92;
                        r *= fadeFactor;
                        g *= fadeFactor;
                        b *= fadeFactor;
                        
                        // Draw cell
                        for (let px = 0; px < cellSize; px++) {
                            for (let py = 0; py < cellSize; py++) {
                                let pixelIdx = 4 * ((Math.floor(y + py) * width + Math.floor(x + px)));
                                if (pixelIdx < pixels.length - 3) {
                                    pixels[pixelIdx] = r;
                                    pixels[pixelIdx + 1] = g;
                                    pixels[pixelIdx + 2] = b;
                                    pixels[pixelIdx + 3] = 255;
                                }
                            }
                        }
                    }
                }
                
                updatePixels();
                
                // Draw velocity field
                if (showVelocity) {
                    stroke(255, 100);
                    strokeWeight(1);
                    for (let i = 5; i <= N; i += 5) {
                        for (let j = 5; j <= N; j += 5) {
                            let idx = this.IX(i, j);
                            let x = (i - 1) * cellSize;
                            let y = (j - 1) * cellSize;
                            let vx = this.Vx[idx];
                            let vy = this.Vy[idx];
                            
                            if (abs(vx) > 0.1 || abs(vy) > 0.1) {
                                line(x, y, x + vx * 10, y + vy * 10);
                            }
                        }
                    }
                }
                
                // Draw obstacles
                if (showObstacles) {
                    fill(50, 50, 50, 200);
                    noStroke();
                    for (let i = 1; i <= N; i++) {
                        for (let j = 1; j <= N; j++) {
                            let idx = this.IX(i, j);
                            if (this.obstacles[idx] === 1) {
                                let x = (i - 1) * cellSize;
                                let y = (j - 1) * cellSize;
                                rect(x, y, cellSize, cellSize);
                            }
                        }
                    }
                }
            }
        }

        function setup() {
            let canvas = createCanvas(800, 600);
            canvas.parent('sketch-container');
            
            let N = 120;
            let dt = 0.016;
            let diff = 0.000001;
            let visc = 0.000001;
            
            fluid = new Fluid(N, dt, diff, visc);
            
            // Set initial conditions
            for (let i = 0; i < N * N * 0.1; i++) {
                let x = Math.floor(random(20, N - 20));
                let y = Math.floor(random(20, N - 20));
                fluid.addDensity(x, y, random(50, 150), [random(100, 255), random(100, 255), random(100, 255)]);
            }
        }

        function draw() {
            // Update FPS
            fps = frameRate();
            document.getElementById('fpsValue').textContent = Math.round(fps);
            
            // Step fluid simulation
            fluid.step();
            
            // Render fluid
            fluid.render();
            
            // Mouse interaction
            if (mouseIsPressed && mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {
                let x = Math.floor((mouseX / width) * fluid.N) + 1;
                let y = Math.floor((mouseY / height) * fluid.N) + 1;
                
                if (x > 0 && x <= fluid.N && y > 0 && y <= fluid.N) {
                    // Add density
                    fluid.addDensity(x, y, 80, currentColor);
                    
                    // Add velocity based on mouse movement
                    let vx = (mouseX - pmouseX) * 0.5;
                    let vy = (mouseY - pmouseY) * 0.5;
                    
                    for (let i = -2; i <= 2; i++) {
                        for (let j = -2; j <= 2; j++) {
                            let xi = x + i;
                            let yj = y + j;
                            if (xi > 0 && xi <= fluid.N && yj > 0 && yj <= fluid.N) {
                                fluid.Vx[fluid.IX(xi, yj)] += vx * (3 - abs(i) - abs(j));
                                fluid.Vy[fluid.IX(xi, yj)] += vy * (3 - abs(i) - abs(j));
                            }
                        }
                    }
                }
            }
            
            // Add random disturbances
            if (frameCount % 60 === 0 && !vortexMode) {
                let x = Math.floor(random(10, fluid.N - 10));
                let y = Math.floor(random(10, fluid.N - 10));
                let angle = random(TWO_PI);
                let force = random(20, 40);
                fluid.Vx[fluid.IX(x, y)] += cos(angle) * force;
                fluid.Vy[fluid.IX(x, y)] += sin(angle) * force;
            }
        }

        function keyPressed() {
            switch(key) {
                case '1':
                    currentColor = [255, 100, 100];
                    break;
                case '2':
                    currentColor = [100, 100, 255];
                    break;
                case '3':
                    currentColor = [100, 255, 100];
                    break;
                case '4':
                    currentColor = [255, 255, 100];
                    break;
                case ' ':
                    // Add vortex at mouse position
                    let vx = Math.floor((mouseX / width) * fluid.N) + 1;
                    let vy = Math.floor((mouseY / height) * fluid.N) + 1;
                    if (vx > 5 && vx < fluid.N - 5 && vy > 5 && vy < fluid.N - 5) {
                        for (let i = -5; i <= 5; i++) {
                            for (let j = -5; j <= 5; j++) {
                                let angle = atan2(j, i) + PI / 2;
                                let force = 50 / (1 + sqrt(i * i + j * j));
                                fluid.Vx[fluid.IX(vx + i, vy + j)] += cos(angle) * force;
                                fluid.Vy[fluid.IX(vx + i, vy + j)] += sin(angle) * force;
                            }
                        }
                    }
                    break;
                case 'v':
                case 'V':
                    vortexMode = !vortexMode;
                    document.getElementById('vortexStatus').textContent = vortexMode ? 'ON' : 'OFF';
                    break;
                case 'f':
                case 'F':
                    showVelocity = !showVelocity;
                    break;
                case 'g':
                case 'G':
                    showPressure = !showPressure;
                    break;
                case 'o':
                case 'O':
                    showObstacles = !showObstacles;
                    break;
                case 'p':
                case 'P':
                    isPaused = !isPaused;
                    break;
                case 'c':
                case 'C':
                    // Clear colors
                    for (let i = 0; i < fluid.size; i++) {
                        fluid.red[i] = 0;
                        fluid.green[i] = 0;
                        fluid.blue[i] = 0;
                    }
                    break;
                case 'r':
                case 'R':
                    // Reset simulation
                    setup();
                    vortexMode = false;
                    showVelocity = false;
                    showPressure = false;
                    isPaused = false;
                    document.getElementById('vortexStatus').textContent = 'OFF';
                    break;
            }
            
            // Viscosity control
            if (keyCode === UP_ARROW) {
                fluid.visc *= 1.5;
                fluid.diff *= 1.5;
                document.getElementById('viscosityValue').textContent = fluid.visc.toExponential(6);
            } else if (keyCode === DOWN_ARROW) {
                fluid.visc /= 1.5;
                fluid.diff /= 1.5;
                document.getElementById('viscosityValue').textContent = fluid.visc.toExponential(6);
            }
        }

        // Prevent context menu on right click
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>