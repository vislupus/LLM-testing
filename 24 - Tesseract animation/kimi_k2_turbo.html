<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 4D Tesseract</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0a1929, #0d1f33);
            color: #e0f7fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        
        #ui {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(25, 118, 210, 0.15);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 16px;
            font-size: 13px;
            line-height: 1.6;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 300px;
            z-index: 1000;
        }
        
        #ui strong {
            color: #4fc3f7;
            font-size: 14px;
        }
        
        #ui span {
            color: #bbdefb;
        }
        
        .status-line {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(79, 195, 247, 0.3);
        }
    </style>
</head>
<body>
    <div id="ui">
        <strong>4D Tesseract Controls</strong><br>
        <span>Space: Pause/Resume Rotation</span><br>
        <span>1: Toggle XY Plane</span><br>
        <span>2: Toggle XZ Plane</span><br>
        <span>3: Toggle XW Plane</span><br>
        <span>4: Toggle YZ Plane</span><br>
        <span>5: Toggle YW Plane</span><br>
        <span>6: Toggle ZW Plane</span><br>
        <span>O: Ortho/Perspective Projection</span><br>
        <span>+/-: Adjust Projection Distance</span><br>
        <div class="status-line">
            <span id="status">Active: XY, XW, YZ, ZW | Perspective | Dist: 300</span>
        </div>
    </div>
    
    <script>
        // Global state
        let tesseract = {
            vertices: [],
            edges: [],
            rotationAngles: { XY: 0, XZ: 0, XW: 0, YZ: 0, YW: 0, ZW: 0 },
            rotationSpeeds: { XY: 0.01, XZ: 0.008, XW: 0.015, YZ: 0.012, YW: 0.009, ZW: 0.006 },
            activeRotations: ['XY', 'XW', 'YZ', 'ZW'],
            projectionDistance: 300,
            orthographic: false,
            isPaused: false,
            size: 120
        };
        
        // 4D Vector operations
        function rotate4D(v, plane, angle) {
            const c = cos(angle);
            const s = sin(angle);
            const result = [...v];
            
            if (plane === 'XY') {
                result[0] = v[0] * c - v[1] * s;
                result[1] = v[0] * s + v[1] * c;
            } else if (plane === 'XZ') {
                result[0] = v[0] * c - v[2] * s;
                result[2] = v[0] * s + v[2] * c;
            } else if (plane === 'XW') {
                result[0] = v[0] * c - v[3] * s;
                result[3] = v[0] * s + v[3] * c;
            } else if (plane === 'YZ') {
                result[1] = v[1] * c - v[2] * s;
                result[2] = v[1] * s + v[2] * c;
            } else if (plane === 'YW') {
                result[1] = v[1] * c - v[3] * s;
                result[3] = v[1] * s + v[3] * c;
            } else if (plane === 'ZW') {
                result[2] = v[2] * c - v[3] * s;
                result[3] = v[2] * s + v[3] * c;
            }
            return result;
        }
        
        // Project 4D to 3D
        function project4DTo3D(v4, distance, orthographic) {
            if (orthographic) {
                return [v4[0], v4[1], v4[2]];
            } else {
                const w = v4[3];
                const factor = distance / (distance - w);
                return [v4[0] * factor, v4[1] * factor, v4[2] * factor];
            }
        }
        
        // Get color based on 4D depth (w coordinate)
        function getEdgeColor(w1, w2) {
            const avgW = (w1 + w2) / 2;
            const hue = map(avgW, -tesseract.size, tesseract.size, 180, 360);
            colorMode(HSB);
            const c = color(hue, 70, 90, 180);
            colorMode(RGB);
            return c;
        }
        
        // Initialize tesseract geometry
        function initTesseract() {
            // Generate 16 vertices (all combinations of Â±1)
            tesseract.vertices = [];
            for (let i = 0; i < 16; i++) {
                tesseract.vertices.push([
                    (i & 1 ? 1 : -1) * tesseract.size,
                    (i & 2 ? 1 : -1) * tesseract.size,
                    (i & 4 ? 1 : -1) * tesseract.size,
                    (i & 8 ? 1 : -1) * tesseract.size
                ]);
            }
            
            // Generate 32 edges (vertices differ by exactly one bit)
            tesseract.edges = [];
            for (let i = 0; i < 16; i++) {
                for (let j = i + 1; j < 16; j++) {
                    const diff = i ^ j;
                    if ((diff & (diff - 1)) === 0) { // Check if power of 2 (one bit set)
                        tesseract.edges.push([i, j]);
                    }
                }
            }
        }
        
        // p5.js setup
        function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
            frameRate(60);
            smooth();
            initTesseract();
        }
        
        // p5.js draw loop
        function draw() {
            background(10, 15, 25);
            
            // Lighting
            ambientLight(50);
            directionalLight(255, 255, 255, 0, 0, -1);
            
            // Camera
            const camDist = 400;
            camera(0, 0, camDist, 0, 0, 0, 0, 1, 0);
            
            // Update rotations
            if (!tesseract.isPaused) {
                for (const plane of tesseract.activeRotations) {
                    tesseract.rotationAngles[plane] += tesseract.rotationSpeeds[plane];
                }
            }
            
            // Rotate and project vertices
            const rotatedVertices = [];
            for (const v of tesseract.vertices) {
                let vRot = [...v];
                vRot = rotate4D(vRot, 'XY', tesseract.rotationAngles.XY);
                vRot = rotate4D(vRot, 'XZ', tesseract.rotationAngles.XZ);
                vRot = rotate4D(vRot, 'XW', tesseract.rotationAngles.XW);
                vRot = rotate4D(vRot, 'YZ', tesseract.rotationAngles.YZ);
                vRot = rotate4D(vRot, 'YW', tesseract.rotationAngles.YW);
                vRot = rotate4D(vRot, 'ZW', tesseract.rotationAngles.ZW);
                rotatedVertices.push(vRot);
            }
            
            // Project to 3D
            const projectedVertices = [];
            for (const v of rotatedVertices) {
                projectedVertices.push(project4DTo3D(v, tesseract.projectionDistance, tesseract.orthographic));
            }
            
            // Draw edges
            strokeWeight(1.5);
            for (const [i, j] of tesseract.edges) {
                const v1 = projectedVertices[i];
                const v2 = projectedVertices[j];
                const v1_4d = rotatedVertices[i];
                const v2_4d = rotatedVertices[j];
                
                // Color based on 4D depth
                stroke(getEdgeColor(v1_4d[3], v2_4d[3]));
                
                line(v1[0], v1[1], v1[2], v2[0], v2[1], v2[2]);
            }
            
            // Draw vertices (optional)
            fill(255, 100);
            noStroke();
            for (const v of projectedVertices) {
                push();
                translate(v[0], v[1], v[2]);
                sphere(2);
                pop();
            }
        }
        
        // Keyboard controls
        function keyPressed() {
            if (key === ' ') {
                tesseract.isPaused = !tesseract.isPaused;
            } else if (key === '1') {
                toggleRotation('XY');
            } else if (key === '2') {
                toggleRotation('XZ');
            } else if (key === '3') {
                toggleRotation('XW');
            } else if (key === '4') {
                toggleRotation('YZ');
            } else if (key === '5') {
                toggleRotation('YW');
            } else if (key === '6') {
                toggleRotation('ZW');
            } else if (key === 'o' || key === 'O') {
                tesseract.orthographic = !tesseract.orthographic;
            } else if (key === '=' || key === '+') {
                tesseract.projectionDistance = min(tesseract.projectionDistance + 50, 1000);
            } else if (key === '-') {
                tesseract.projectionDistance = max(tesseract.projectionDistance - 50, 100);
            }
            updateStatus();
        }
        
        function toggleRotation(plane) {
            if (tesseract.activeRotations.includes(plane)) {
                tesseract.activeRotations = tesseract.activeRotations.filter(p => p !== plane);
            } else {
                tesseract.activeRotations.push(plane);
            }
        }
        
        function updateStatus() {
            const status = document.getElementById('status');
            const activeText = tesseract.activeRotations.length > 0 ? tesseract.activeRotations.join(', ') : 'None';
            const projText = tesseract.orthographic ? 'Orthographic' : 'Perspective';
            status.innerHTML = `Active: ${activeText} | ${projText} | Dist: ${tesseract.projectionDistance}`;
        }
        
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>
</html>