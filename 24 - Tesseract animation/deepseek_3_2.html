<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D Tesseract Visualization - Interactive Hypercube</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/addons/p5.dom.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #0c0e1a 0%, #1a1b3a 100%);
            color: #e0f0ff;
            min-height: 100vh;
            overflow-x: hidden;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        header {
            text-align: center;
            padding: 25px;
            background: rgba(10, 12, 28, 0.7);
            border-radius: 16px;
            border: 1px solid rgba(64, 156, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
        }

        h1 {
            color: #7bc8ff;
            margin-bottom: 15px;
            font-size: 2.8rem;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            background: linear-gradient(to right, #7bc8ff, #a855f7);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .subtitle {
            color: #a8d2ff;
            font-size: 1.2rem;
            max-width: 900px;
            margin: 0 auto 15px;
            line-height: 1.6;
        }

        .dimensional-explanation {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .dimension {
            background: rgba(25, 30, 60, 0.6);
            padding: 12px 20px;
            border-radius: 10px;
            border: 1px solid rgba(64, 156, 255, 0.2);
            text-align: center;
            min-width: 180px;
        }

        .dimension h3 {
            color: #ff7b00;
            margin-bottom: 5px;
            font-size: 1.1rem;
        }

        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .visualization-area {
            flex: 3;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #tesseract-canvas {
            width: 100%;
            height: 600px;
            border-radius: 16px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
            background: rgba(5, 8, 22, 0.9);
            border: 1px solid rgba(64, 156, 255, 0.15);
        }

        .canvas-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(15, 20, 45, 0.7);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(64, 156, 255, 0.15);
        }

        .fps-counter {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #2ed573;
            background: rgba(46, 213, 115, 0.1);
            padding: 8px 15px;
            border-radius: 8px;
        }

        .dimension-label {
            font-size: 1.1rem;
            color: #ff7b00;
            font-weight: 600;
        }

        .controls-panel {
            flex: 1;
            min-width: 320px;
            background: rgba(15, 20, 45, 0.7);
            border-radius: 16px;
            padding: 25px;
            border: 1px solid rgba(64, 156, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 25px;
            max-height: 800px;
            overflow-y: auto;
        }

        .panel-section {
            background: rgba(25, 30, 60, 0.6);
            border-radius: 12px;
            padding: 20px;
            border-left: 4px solid;
        }

        .rotation-section {
            border-left-color: #ff7b00;
        }

        .projection-section {
            border-left-color: #409cff;
        }

        .display-section {
            border-left-color: #2ed573;
        }

        .dimensions-section {
            border-left-color: #a855f7;
        }

        h2 {
            color: #7bc8ff;
            font-size: 1.5rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        h2 i {
            font-size: 1.3rem;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 10px;
            color: #a8d2ff;
            font-weight: 500;
            font-size: 1.05rem;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        input[type="range"] {
            flex: 1;
            height: 10px;
            -webkit-appearance: none;
            background: linear-gradient(to right, #1a3a5f, #409cff);
            border-radius: 5px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #409cff;
            cursor: pointer;
            box-shadow: 0 0 12px rgba(64, 156, 255, 0.8);
            border: 2px solid white;
        }

        .value-display {
            min-width: 70px;
            text-align: center;
            background: rgba(10, 15, 35, 0.6);
            padding: 8px 12px;
            border-radius: 8px;
            color: #a8d2ff;
            font-weight: 600;
            font-family: 'Courier New', monospace;
            border: 1px solid rgba(64, 156, 255, 0.2);
        }

        .toggle-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(10, 15, 35, 0.4);
            border-radius: 10px;
            border: 1px solid rgba(64, 156, 255, 0.1);
            transition: all 0.3s;
        }

        .toggle-group:hover {
            background: rgba(64, 156, 255, 0.1);
        }

        .toggle-label {
            color: #a8d2ff;
            font-weight: 500;
            margin: 0;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(64, 156, 255, 0.2);
            transition: .4s;
            border-radius: 30px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #409cff;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(30px);
        }

        button {
            background: linear-gradient(to right, #409cff, #2a7de0);
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
            font-size: 1.05rem;
        }

        button:hover {
            background: linear-gradient(to right, #2a7de0, #1a6bc8);
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25);
        }

        button:active {
            transform: translateY(0);
        }

        .danger-button {
            background: linear-gradient(to right, #ff4757, #ff3742);
        }

        .danger-button:hover {
            background: linear-gradient(to right, #ff3742, #ff2b36);
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 10px;
        }

        .preset-button {
            background: rgba(25, 30, 60, 0.8);
            padding: 12px;
            font-size: 0.95rem;
        }

        .color-scheme {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 10px;
        }

        .color-option {
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            background: rgba(25, 30, 60, 0.8);
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .color-option:hover {
            transform: translateY(-3px);
        }

        .color-option.active {
            border-color: #409cff;
            box-shadow: 0 0 15px rgba(64, 156, 255, 0.4);
        }

        .dimension-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        .dimension-button {
            background: rgba(25, 30, 60, 0.8);
            padding: 14px 8px;
            font-size: 0.95rem;
        }

        .dimension-button.active {
            background: linear-gradient(to right, #a855f7, #8b5cf6);
        }

        .info-panel {
            background: rgba(25, 30, 60, 0.6);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid rgba(64, 156, 255, 0.2);
        }

        .info-panel h3 {
            color: #ff7b00;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .info-panel p {
            color: #a8d2ff;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .keyboard-hint {
            font-size: 0.9rem;
            color: #8ab4f8;
            margin-top: 15px;
            text-align: center;
            font-style: italic;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: #8ab4f8;
            font-size: 0.95rem;
            background: rgba(10, 12, 28, 0.7);
            border-radius: 12px;
            border: 1px solid rgba(64, 156, 255, 0.2);
            margin-top: 20px;
        }

        @media (max-width: 1200px) {
            .content {
                flex-direction: column;
            }
            
            .visualization-area, .controls-panel {
                width: 100%;
            }
        }

        @media (max-width: 600px) {
            .controls-panel {
                padding: 15px;
            }
            
            .preset-buttons, .dimension-buttons {
                grid-template-columns: 1fr;
            }
            
            .dimensional-explanation {
                flex-direction: column;
                align-items: center;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            #tesseract-canvas {
                height: 450px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>4D Tesseract Visualization</h1>
            <p class="subtitle">An interactive visualization of a 4-dimensional hypercube (tesseract) projected into 3D and then to 2D. Watch as the tesseract rotates through the fourth dimension, morphing between different 3D projections.</p>
            
            <div class="dimensional-explanation">
                <div class="dimension">
                    <h3>2D Square</h3>
                    <p>4 vertices, 4 edges</p>
                </div>
                <div class="dimension">
                    <h3>3D Cube</h3>
                    <p>8 vertices, 12 edges</p>
                </div>
                <div class="dimension">
                    <h3>4D Tesseract</h3>
                    <p>16 vertices, 32 edges</p>
                </div>
            </div>
        </header>
        
        <div class="content">
            <div class="visualization-area">
                <div id="tesseract-canvas"></div>
                <div class="canvas-info">
                    <div class="fps-counter">FPS: 60</div>
                    <div class="dimension-label">4D → 3D → 2D Projection</div>
                    <div class="value-display" id="projection-type">Perspective</div>
                </div>
            </div>
            
            <div class="controls-panel">
                <div class="panel-section rotation-section">
                    <h2>Rotation Controls</h2>
                    
                    <div class="control-group">
                        <label>Rotation Speed: <span id="rotation-speed-value">0.5</span></label>
                        <div class="slider-container">
                            <input type="range" id="rotation-speed" min="0" max="1" value="0.5" step="0.05">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <div class="toggle-group">
                            <span class="toggle-label">Auto Rotation</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="auto-rotate" checked>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <div class="toggle-group">
                            <span class="toggle-label">Rotation Smoothing</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="rotation-smoothing" checked>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <button id="pause-button">
                        <span id="pause-icon">⏸</span>
                        <span id="pause-text">Pause Rotation</span>
                    </button>
                </div>
                
                <div class="panel-section projection-section">
                    <h2>Projection Settings</h2>
                    
                    <div class="control-group">
                        <label>Projection Distance: <span id="projection-distance-value">400</span></label>
                        <div class="slider-container">
                            <input type="range" id="projection-distance" min="100" max="800" value="400" step="10">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <div class="toggle-group">
                            <span class="toggle-label">Perspective Projection</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="perspective-toggle" checked>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="preset-buttons">
                        <button class="preset-button" id="preset-cube">Cube View</button>
                        <button class="preset-button" id="preset-cross">Cross View</button>
                        <button class="preset-button" id="preset-complex">Complex View</button>
                        <button class="preset-button" id="preset-reset">Reset View</button>
                    </div>
                </div>
                
                <div class="panel-section display-section">
                    <h2>Display Settings</h2>
                    
                    <div class="control-group">
                        <label>Line Thickness: <span id="line-thickness-value">2</span></label>
                        <div class="slider-container">
                            <input type="range" id="line-thickness" min="1" max="5" value="2" step="0.5">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Vertex Size: <span id="vertex-size-value">8</span></label>
                        <div class="slider-container">
                            <input type="range" id="vertex-size" min="2" max="15" value="8" step="1">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Color Scheme</label>
                        <div class="color-scheme">
                            <div class="color-option active" id="color-gradient">
                                <div>Gradient</div>
                            </div>
                            <div class="color-option" id="color-monochrome">
                                <div>Monochrome</div>
                            </div>
                            <div class="color-option" id="color-rainbow">
                                <div>Rainbow</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section dimensions-section">
                    <h2>4D Rotation Planes</h2>
                    <p>Toggle which 4D planes the tesseract rotates in:</p>
                    
                    <div class="dimension-buttons">
                        <button class="dimension-button active" id="plane-xy">XY Plane</button>
                        <button class="dimension-button active" id="plane-xz">XZ Plane</button>
                        <button class="dimension-button" id="plane-xw">XW Plane</button>
                        <button class="dimension-button active" id="plane-yz">YZ Plane</button>
                        <button class="dimension-button" id="plane-yw">YW Plane</button>
                        <button class="dimension-button" id="plane-zw">ZW Plane</button>
                    </div>
                    
                    <div class="keyboard-hint">
                        Keyboard: SPACE = Pause, R = Reset, 1-6 = Toggle Planes, P = Toggle Perspective, +/- = Adjust Speed
                    </div>
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <h3>What is a Tesseract?</h3>
            <p>A tesseract is the 4-dimensional analog of a cube. Just as a cube unfolds into 6 squares, a tesseract unfolds into 8 cubes.</p>
            <p>In this visualization, we're projecting the 4D tesseract into 3D space (by dropping the W coordinate or using perspective projection), then rendering that 3D projection in 2D using p5.js.</p>
            <p>The "cube within a cube" effect happens when we view the tesseract along an axis where the inner cube represents vertices with negative W coordinates and the outer cube represents vertices with positive W coordinates.</p>
        </div>
        
        <footer>
            <p>4D Tesseract Visualization | Interactive Hypercube Projection | Mathematical Visualization of Higher Dimensions</p>
        </footer>
    </div>

    <script>
// Tesseract Visualization Class
class TesseractVisualization {
    constructor() {
        // Tesseract vertices in 4D space (±1, ±1, ±1, ±1)
        this.vertices4D = [];
        this.vertices3D = [];
        this.vertices2D = [];
        
        // Edge connections (32 edges of a tesseract)
        this.edges = [];
        
        // Rotation angles for each 4D plane
        this.angles = {
            xy: 0,
            xz: 0,
            xw: 0,
            yz: 0,
            yw: 0,
            zw: 0
        };
        
        // Rotation speeds for each plane
        this.speeds = {
            xy: 0.003,
            xz: 0.002,
            xw: 0.0015,
            yz: 0.0025,
            yw: 0.001,
            zw: 0.002
        };
        
        // Which planes are actively rotating
        this.activePlanes = {
            xy: true,
            xz: true,
            xw: false,
            yz: true,
            yw: false,
            zw: false
        };
        
        // Visualization settings
        this.settings = {
            rotationSpeed: 0.5,
            projectionDistance: 400,
            perspectiveProjection: true,
            lineThickness: 2,
            vertexSize: 8,
            colorScheme: 'gradient',
            autoRotate: true,
            rotationSmoothing: true
        };
        
        // Canvas and rendering
        this.canvas = null;
        this.fps = 60;
        this.lastFrameTime = 0;
        this.isPaused = false;
        
        // Initialize tesseract data
        this.initTesseract();
        
        // Set up UI controls
        this.setupControls();
    }
    
    // Initialize tesseract vertices and edges
    initTesseract() {
        // Create all 16 vertices of a tesseract (±1, ±1, ±1, ±1)
        for (let w = -1; w <= 1; w += 2) {
            for (let z = -1; z <= 1; z += 2) {
                for (let y = -1; y <= 1; y += 2) {
                    for (let x = -1; x <= 1; x += 2) {
                        this.vertices4D.push([x, y, z, w]);
                    }
                }
            }
        }
        
        // Initialize 3D and 2D vertex arrays
        for (let i = 0; i < this.vertices4D.length; i++) {
            this.vertices3D.push([0, 0, 0]);
            this.vertices2D.push([0, 0]);
        }
        
        // Create edges (connect vertices that differ in exactly one coordinate)
        for (let i = 0; i < this.vertices4D.length; i++) {
            for (let j = i + 1; j < this.vertices4D.length; j++) {
                let diffCount = 0;
                for (let k = 0; k < 4; k++) {
                    if (Math.abs(this.vertices4D[i][k] - this.vertices4D[j][k]) > 0.1) {
                        diffCount++;
                    }
                }
                if (diffCount === 1) {
                    this.edges.push([i, j]);
                }
            }
        }
    }
    
    // Apply 4D rotation matrix to a point
    rotate4D(point, angle, plane) {
        const [x, y, z, w] = point;
        let cosA = Math.cos(angle);
        let sinA = Math.sin(angle);
        
        // Apply rotation in the specified plane
        switch (plane) {
            case 'xy':
                return [
                    x * cosA - y * sinA,
                    x * sinA + y * cosA,
                    z,
                    w
                ];
            case 'xz':
                return [
                    x * cosA - z * sinA,
                    y,
                    x * sinA + z * cosA,
                    w
                ];
            case 'xw':
                return [
                    x * cosA - w * sinA,
                    y,
                    z,
                    x * sinA + w * cosA
                ];
            case 'yz':
                return [
                    x,
                    y * cosA - z * sinA,
                    y * sinA + z * cosA,
                    w
                ];
            case 'yw':
                return [
                    x,
                    y * cosA - w * sinA,
                    z,
                    y * sinA + w * cosA
                ];
            case 'zw':
                return [
                    x,
                    y,
                    z * cosA - w * sinA,
                    z * sinA + w * cosA
                ];
            default:
                return point;
        }
    }
    
    // Project 4D point to 3D (with optional perspective)
    project4Dto3D(point) {
        const [x, y, z, w] = point;
        
        if (this.settings.perspectiveProjection) {
            // Perspective projection: divide by (distance - w)
            const distance = this.settings.projectionDistance / 100;
            const factor = 1 / (distance - w);
            return [
                x * factor * 200,
                y * factor * 200,
                z * factor * 200
            ];
        } else {
            // Orthographic projection: simply drop the w coordinate
            return [x * 150, y * 150, z * 150];
        }
    }
    
    // Update rotation angles
    updateRotation() {
        if (this.isPaused || !this.settings.autoRotate) return;
        
        // Update angles for active planes
        for (const plane in this.activePlanes) {
            if (this.activePlanes[plane]) {
                this.angles[plane] += this.speeds[plane] * this.settings.rotationSpeed;
            }
        }
    }
    
    // Update vertex positions
    updateVertices() {
        for (let i = 0; i < this.vertices4D.length; i++) {
            let point = [...this.vertices4D[i]];
            
            // Apply all active rotations
            for (const plane in this.activePlanes) {
                if (this.activePlanes[plane]) {
                    point = this.rotate4D(point, this.angles[plane], plane);
                }
            }
            
            // Project to 3D
            this.vertices3D[i] = this.project4Dto3D(point);
        }
    }
    
    // Draw the tesseract
    draw() {
        // Clear background with gradient
        this.drawBackground();
        
        // Apply smoothing if enabled
        if (this.settings.rotationSmoothing) {
            this.canvas.drawingContext.shadowBlur = 15;
            this.canvas.drawingContext.shadowColor = 'rgba(64, 156, 255, 0.3)';
        }
        
        // Draw edges
        this.drawEdges();
        
        // Draw vertices
        this.drawVertices();
        
        // Reset shadow
        this.canvas.drawingContext.shadowBlur = 0;
    }
    
    // Draw gradient background
    drawBackground() {
        // Create radial gradient
        let gradient = this.canvas.drawingContext.createRadialGradient(
            this.canvas.width / 2, this.canvas.height / 2, 0,
            this.canvas.width / 2, this.canvas.height / 2, this.canvas.width / 2
        );
        
        gradient.addColorStop(0, 'rgba(10, 12, 28, 0.8)');
        gradient.addColorStop(1, 'rgba(5, 8, 22, 0.95)');
        
        this.canvas.drawingContext.fillStyle = gradient;
        this.canvas.rect(0, 0, this.canvas.width, this.canvas.height);
        this.canvas.fill();
        
        // Draw a subtle grid
        this.canvas.strokeWeight(0.5);
        this.canvas.stroke(30, 40, 70, 30);
        
        const gridSize = 50;
        for (let x = 0; x < this.canvas.width; x += gridSize) {
            this.canvas.line(x, 0, x, this.canvas.height);
        }
        for (let y = 0; y < this.canvas.height; y += gridSize) {
            this.canvas.line(0, y, this.canvas.width, y);
        }
    }
    
    // Draw edges of the tesseract
    drawEdges() {
        this.canvas.strokeWeight(this.settings.lineThickness);
        
        for (const [i, j] of this.edges) {
            const v1 = this.vertices3D[i];
            const v2 = this.vertices3D[j];
            
            // Calculate depth for color gradient
            const depth1 = v1[2];
            const depth2 = v2[2];
            const avgDepth = (depth1 + depth2) / 2;
            
            // Set color based on color scheme and depth
            this.setEdgeColor(avgDepth);
            
            // Project 3D to 2D with perspective
            const scale = 200;
            const x1 = this.canvas.width / 2 + v1[0];
            const y1 = this.canvas.height / 2 + v1[1];
            const x2 = this.canvas.width / 2 + v2[0];
            const y2 = this.canvas.height / 2 + v2[1];
            
            // Draw the edge
            this.canvas.line(x1, y1, x2, y2);
        }
    }
    
    // Set edge color based on current color scheme
    setEdgeColor(depth) {
        const normalizedDepth = (depth + 200) / 400; // Normalize to 0-1
        
        switch (this.settings.colorScheme) {
            case 'gradient':
                // Blue to purple gradient based on depth
                const r = Math.floor(100 + 155 * normalizedDepth);
                const g = Math.floor(150 * (1 - normalizedDepth));
                const b = Math.floor(255 - 100 * normalizedDepth);
                this.canvas.stroke(r, g, b, 200);
                break;
                
            case 'monochrome':
                // White to gray based on depth
                const brightness = Math.floor(150 + 100 * normalizedDepth);
                this.canvas.stroke(brightness, brightness, brightness, 220);
                break;
                
            case 'rainbow':
                // Rainbow colors based on depth
                const hue = (normalizedDepth * 360) % 360;
                this.canvas.stroke(this.canvas.color(`hsb(${hue}, 80%, 100%)`));
                break;
        }
    }
    
    // Draw vertices
    drawVertices() {
        this.canvas.noStroke();
        
        for (let i = 0; i < this.vertices3D.length; i++) {
            const v = this.vertices3D[i];
            
            // Calculate position
            const x = this.canvas.width / 2 + v[0];
            const y = this.canvas.height / 2 + v[1];
            
            // Determine if vertex is inner or outer cube
            const isInner = this.vertices4D[i][3] < 0; // Negative w coordinate
            
            // Set fill color
            if (isInner) {
                this.canvas.fill(255, 100, 100, 220); // Red for inner cube
            } else {
                this.canvas.fill(100, 200, 255, 220); // Blue for outer cube
            }
            
            // Draw vertex
            this.canvas.circle(x, y, this.settings.vertexSize);
            
            // Add glow effect
            this.canvas.drawingContext.shadowBlur = 15;
            this.canvas.drawingContext.shadowColor = isInner ? 
                'rgba(255, 100, 100, 0.7)' : 'rgba(100, 200, 255, 0.7)';
            this.canvas.circle(x, y, this.settings.vertexSize / 2);
            this.canvas.drawingContext.shadowBlur = 0;
        }
    }
    
    // Setup UI controls
    setupControls() {
        // Rotation speed slider
        const rotationSpeedSlider = document.getElementById('rotation-speed');
        const rotationSpeedValue = document.getElementById('rotation-speed-value');
        
        rotationSpeedSlider.addEventListener('input', () => {
            this.settings.rotationSpeed = parseFloat(rotationSpeedSlider.value);
            rotationSpeedValue.textContent = this.settings.rotationSpeed.toFixed(2);
        });
        
        // Projection distance slider
        const projectionDistanceSlider = document.getElementById('projection-distance');
        const projectionDistanceValue = document.getElementById('projection-distance-value');
        
        projectionDistanceSlider.addEventListener('input', () => {
            this.settings.projectionDistance = parseInt(projectionDistanceSlider.value);
            projectionDistanceValue.textContent = this.settings.projectionDistance;
        });
        
        // Line thickness slider
        const lineThicknessSlider = document.getElementById('line-thickness');
        const lineThicknessValue = document.getElementById('line-thickness-value');
        
        lineThicknessSlider.addEventListener('input', () => {
            this.settings.lineThickness = parseFloat(lineThicknessSlider.value);
            lineThicknessValue.textContent = this.settings.lineThickness.toFixed(1);
        });
        
        // Vertex size slider
        const vertexSizeSlider = document.getElementById('vertex-size');
        const vertexSizeValue = document.getElementById('vertex-size-value');
        
        vertexSizeSlider.addEventListener('input', () => {
            this.settings.vertexSize = parseInt(vertexSizeSlider.value);
            vertexSizeValue.textContent = this.settings.vertexSize;
        });
        
        // Perspective toggle
        const perspectiveToggle = document.getElementById('perspective-toggle');
        const projectionTypeDisplay = document.getElementById('projection-type');
        
        perspectiveToggle.addEventListener('change', () => {
            this.settings.perspectiveProjection = perspectiveToggle.checked;
            projectionTypeDisplay.textContent = this.settings.perspectiveProjection ? 
                'Perspective' : 'Orthographic';
        });
        
        // Auto rotate toggle
        const autoRotateToggle = document.getElementById('auto-rotate');
        autoRotateToggle.addEventListener('change', () => {
            this.settings.autoRotate = autoRotateToggle.checked;
        });
        
        // Rotation smoothing toggle
        const rotationSmoothingToggle = document.getElementById('rotation-smoothing');
        rotationSmoothingToggle.addEventListener('change', () => {
            this.settings.rotationSmoothing = rotationSmoothingToggle.checked;
        });
        
        // Pause button
        const pauseButton = document.getElementById('pause-button');
        const pauseIcon = document.getElementById('pause-icon');
        const pauseText = document.getElementById('pause-text');
        
        pauseButton.addEventListener('click', () => {
            this.isPaused = !this.isPaused;
            pauseIcon.textContent = this.isPaused ? '▶' : '⏸';
            pauseText.textContent = this.isPaused ? 'Resume Rotation' : 'Pause Rotation';
        });
        
        // Color scheme buttons
        const colorOptions = document.querySelectorAll('.color-option');
        colorOptions.forEach(option => {
            option.addEventListener('click', () => {
                // Remove active class from all options
                colorOptions.forEach(opt => opt.classList.remove('active'));
                // Add active class to clicked option
                option.classList.add('active');
                // Update color scheme
                this.settings.colorScheme = option.id.replace('color-', '');
            });
        });
        
        // Plane toggle buttons
        const planeButtons = document.querySelectorAll('.dimension-button');
        planeButtons.forEach(button => {
            button.addEventListener('click', () => {
                const plane = button.id.replace('plane-', '');
                this.activePlanes[plane] = !this.activePlanes[plane];
                button.classList.toggle('active', this.activePlanes[plane]);
            });
        });
        
        // Preset buttons
        document.getElementById('preset-cube').addEventListener('click', () => {
            // Set angles to show cube-within-cube view
            this.angles = { xy: 0, xz: 0, xw: 0, yz: 0, yw: 0, zw: 0 };
            this.activePlanes = { xy: true, xz: false, xw: false, yz: false, yw: false, zw: false };
            this.updatePlaneButtons();
        });
        
        document.getElementById('preset-cross').addEventListener('click', () => {
            // Set angles to show cross view
            this.angles = { xy: 0.5, xz: 0.3, xw: 0.7, yz: 0.2, yw: 0.4, zw: 0.6 };
            this.activePlanes = { xy: true, xz: true, xw: true, yz: true, yw: true, zw: true };
            this.updatePlaneButtons();
        });
        
        document.getElementById('preset-complex').addEventListener('click', () => {
            // Set angles for complex rotation
            this.angles = { xy: 0.2, xz: 0.8, xw: 1.2, yz: 0.5, yw: 1.0, zw: 0.3 };
            this.activePlanes = { xy: true, xz: true, xw: true, yz: true, yw: false, zw: false };
            this.updatePlaneButtons();
        });
        
        document.getElementById('preset-reset').addEventListener('click', () => {
            // Reset to initial state
            this.angles = { xy: 0, xz: 0, xw: 0, yz: 0, yw: 0, zw: 0 };
            this.activePlanes = { xy: true, xz: true, xw: false, yz: true, yw: false, zw: false };
            this.settings.rotationSpeed = 0.5;
            rotationSpeedSlider.value = 0.5;
            rotationSpeedValue.textContent = '0.5';
            this.updatePlaneButtons();
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            switch(event.key) {
                case ' ':
                    // Space to toggle pause
                    this.isPaused = !this.isPaused;
                    pauseIcon.textContent = this.isPaused ? '▶' : '⏸';
                    pauseText.textContent = this.isPaused ? 'Resume Rotation' : 'Pause Rotation';
                    break;
                    
                case 'r':
                case 'R':
                    // R to reset view
                    this.angles = { xy: 0, xz: 0, xw: 0, yz: 0, yw: 0, zw: 0 };
                    break;
                    
                case 'p':
                case 'P':
                    // P to toggle perspective
                    this.settings.perspectiveProjection = !this.settings.perspectiveProjection;
                    perspectiveToggle.checked = this.settings.perspectiveProjection;
                    projectionTypeDisplay.textContent = this.settings.perspectiveProjection ? 
                        'Perspective' : 'Orthographic';
                    break;
                    
                case '1':
                    this.togglePlane('xy');
                    break;
                case '2':
                    this.togglePlane('xz');
                    break;
                case '3':
                    this.togglePlane('xw');
                    break;
                case '4':
                    this.togglePlane('yz');
                    break;
                case '5':
                    this.togglePlane('yw');
                    break;
                case '6':
                    this.togglePlane('zw');
                    break;
                    
                case '+':
                case '=':
                    // Increase rotation speed
                    this.settings.rotationSpeed = Math.min(1, this.settings.rotationSpeed + 0.05);
                    rotationSpeedSlider.value = this.settings.rotationSpeed;
                    rotationSpeedValue.textContent = this.settings.rotationSpeed.toFixed(2);
                    break;
                    
                case '-':
                case '_':
                    // Decrease rotation speed
                    this.settings.rotationSpeed = Math.max(0, this.settings.rotationSpeed - 0.05);
                    rotationSpeedSlider.value = this.settings.rotationSpeed;
                    rotationSpeedValue.textContent = this.settings.rotationSpeed.toFixed(2);
                    break;
            }
        });
    }
    
    // Toggle a rotation plane and update button state
    togglePlane(plane) {
        this.activePlanes[plane] = !this.activePlanes[plane];
        const button = document.getElementById(`plane-${plane}`);
        if (button) {
            button.classList.toggle('active', this.activePlanes[plane]);
        }
    }
    
    // Update plane button states
    updatePlaneButtons() {
        for (const plane in this.activePlanes) {
            const button = document.getElementById(`plane-${plane}`);
            if (button) {
                button.classList.toggle('active', this.activePlanes[plane]);
            }
        }
    }
    
    // Main animation loop
    animate() {
        // Calculate FPS
        const now = performance.now();
        if (this.lastFrameTime > 0) {
            this.fps = Math.round(1000 / (now - this.lastFrameTime));
        }
        this.lastFrameTime = now;
        
        // Update FPS display
        document.querySelector('.fps-counter').textContent = `FPS: ${this.fps}`;
        
        // Update rotation
        this.updateRotation();
        
        // Update vertices
        this.updateVertices();
        
        // Draw the tesseract
        this.draw();
    }
}

// p5.js Sketch
let tesseractViz;

function setup() {
    const canvasContainer = document.getElementById('tesseract-canvas');
    const canvasWidth = canvasContainer.offsetWidth;
    const canvasHeight = canvasContainer.offsetHeight;
    
    // Create canvas
    const canvas = createCanvas(canvasWidth, canvasHeight, WEBGL);
    canvas.parent('tesseract-canvas');
    
    // Disable WEBGL depth test for proper line rendering
    drawingContext.disable(drawingContext.DEPTH_TEST);
    
    // Initialize tesseract visualization
    tesseractViz = new TesseractVisualization();
    tesseractViz.canvas = canvas;
}

function draw() {
    // Clear with slight transparency for motion blur effect
    clear();
    
    // Update and draw tesseract
    tesseractViz.animate();
}

function windowResized() {
    const canvasContainer = document.getElementById('tesseract-canvas');
    const canvasWidth = canvasContainer.offsetWidth;
    const canvasHeight = canvasContainer.offsetHeight;
    resizeCanvas(canvasWidth, canvasHeight);
}

// Initialize the visualization when the page loads
window.addEventListener('DOMContentLoaded', () => {
    // p5.js will call setup() and draw() automatically
});
    </script>
</body>
</html>