<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>4D Tesseract Visualization</title>
   <script src="https://cdn.tailwindcss.com"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
   <style>
       body { margin: 0; padding: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
       canvas { display: block; }
       .glass-panel {
           background: rgba(10, 10, 15, 0.7);
           backdrop-filter: blur(10px);
           border: 1px solid rgba(255, 255, 255, 0.1);
           box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
       }
       .control-btn {
           transition: all 0.2s;
       }
       .control-btn:hover {
           background: rgba(0, 255, 255, 0.2);
           text-shadow: 0 0 8px rgba(0, 255, 255, 0.8);
       }
       .active {
           background: rgba(0, 255, 255, 0.3);
           border-color: rgba(0, 255, 255, 0.5);
           color: #0ff;
           box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
       }
   </style>
</head>
<body class="text-gray-300">

   <!-- UI Overlay -->
   <div class="absolute top-4 left-4 z-10 w-72 glass-panel rounded-lg p-5 select-none">
       <h1 class="text-xl font-bold mb-1 text-cyan-400 tracking-widest uppercase">Tesseract</h1>
       <p class="text-xs text-gray-500 mb-4">4D Hypercube Projection</p>

       <!-- Playback Controls -->
       <div class="flex gap-2 mb-6">
           <button id="btn-pause" class="control-btn flex-1 py-2 px-3 border border-gray-700 rounded text-xs font-bold uppercase tracking-wider bg-gray-900/50">
               Pause
           </button>
           <button id="btn-reset" class="control-btn flex-1 py-2 px-3 border border-gray-700 rounded text-xs font-bold uppercase tracking-wider bg-gray-900/50">
               Reset
           </button>
       </div>

       <!-- Projection Settings -->
       <div class="space-y-4 mb-6">
           <div class="flex justify-between items-center">
               <span class="text-xs uppercase tracking-wider text-gray-400">Projection</span>
               <button id="btn-proj" class="control-btn px-3 py-1 text-xs border border-gray-600 rounded bg-black/30 w-24 text-center">
                   Perspective
               </button>
           </div>

           <div>
               <div class="flex justify-between text-xs mb-1">
                   <span class="text-gray-400">4D Distance</span>
                   <span id="val-dist" class="text-cyan-400 font-mono">2.0</span>
               </div>
               <input type="range" id="slider-dist" min="1.5" max="5.0" step="0.1" value="2.0" 
                      class="w-full h-1 bg-gray-800 rounded-lg appearance-none cursor-pointer accent-cyan-500">
           </div>

           <div>
               <div class="flex justify-between text-xs mb-1">
                   <span class="text-gray-400">Rotation Speed</span>
                   <span id="val-speed" class="text-cyan-400 font-mono">1.0</span>
               </div>
               <input type="range" id="slider-speed" min="0" max="3.0" step="0.1" value="1.0" 
                      class="w-full h-1 bg-gray-800 rounded-lg appearance-none cursor-pointer accent-cyan-500">
           </div>
       </div>

       <!-- Rotation Planes -->
       <div class="mb-4">
           <div class="text-xs uppercase tracking-wider text-gray-400 mb-2">Rotation Planes</div>
           <div class="grid grid-cols-3 gap-2">
               <button id="rot-xy" class="control-btn active py-2 border border-gray-700 rounded text-[10px] font-bold">X-Y</button>
               <button id="rot-xz" class="control-btn active py-2 border border-gray-700 rounded text-[10px] font-bold">X-Z</button>
               <button id="rot-xw" class="control-btn active py-2 border border-gray-700 rounded text-[10px] font-bold">X-W</button>
               <button id="rot-yz" class="control-btn py-2 border border-gray-700 rounded text-[10px] font-bold text-gray-600">Y-Z</button>
               <button id="rot-yw" class="control-btn py-2 border border-gray-700 rounded text-[10px] font-bold text-gray-600">Y-W</button>
               <button id="rot-zw" class="control-btn py-2 border border-gray-700 rounded text-[10px] font-bold text-gray-600">Z-W</button>
           </div>
       </div>
       
       <div class="text-[10px] text-gray-600 mt-4 border-t border-gray-800 pt-2">
           Drag to rotate â€¢ Scroll to zoom
       </div>
   </div>

   <script>
       // --- Configuration & State ---
       const CONFIG = {
           size: 120,              // Base size of the cube
           perspective3D: 800,     // 3D projection distance (camera Z)
           zoomSensitivity: 0.001
       };

       let state = {
           angle: 0,
           speed: 1.0,
           dist4D: 2.0,            // 4D Projection distance (W coordinate divisor)
           isRunning: true,
           isPerspective: true,
           autoRotate: { x: 0, y: 0 },
           mouseRotate: { x: 0, y: 0 },
           targetMouseRotate: { x: 0, y: 0 },
           zoom: 1,
           planes: {
               xy: true,
               xz: true,
               xw: true,
               yz: false,
               yw: false,
               zw: false
           }
       };

       // --- 4D Geometry Data ---
       // Vertices of a tesseract (16 points, 4D)
       // Format: [x, y, z, w] normalized to -1..1
       const vertices4D = [];
       for (let i = 0; i < 16; i++) {
           vertices4D.push([
               (i & 1) ? 1 : -1,
               (i & 2) ? 1 : -1,
               (i & 4) ? 1 : -1,
               (i & 8) ? 1 : -1
           ]);
       }

       // Edges connecting vertices (32 edges)
       // Connect vertices that differ by exactly one bit
       const edges = [];
       for (let i = 0; i < 16; i++) {
           for (let j = i + 1; j < 16; j++) {
               let diff = i ^ j;
               // Check if power of 2 (only one bit different)
               if ((diff & (diff - 1)) === 0) {
                   edges.push([i, j]);
               }
           }
       }

       // --- Math Helpers ---

       // 4D Rotation Matrix Generator
       // Rotates in the plane defined by axes a and b
       function getRotationMatrix4D(angle, axis1, axis2) {
           const c = Math.cos(angle);
           const s = Math.sin(angle);
           // Initialize identity 4x4
           let m = [
               [1, 0, 0, 0],
               [0, 1, 0, 0],
               [0, 0, 1, 0],
               [0, 0, 0, 1]
           ];
           
           // Set rotation components
           m[axis1][axis1] = c;
           m[axis1][axis2] = -s;
           m[axis2][axis1] = s;
           m[axis2][axis2] = c;
           
           return m;
       }

       // Multiply 4D vector by 4x4 matrix
       function multiplyMatrixVector(m, v) {
           return [
               m[0][0]*v[0] + m[0][1]*v[1] + m[0][2]*v[2] + m[0][3]*v[3],
               m[1][0]*v[0] + m[1][1]*v[1] + m[1][2]*v[2] + m[1][3]*v[3],
               m[2][0]*v[0] + m[2][1]*v[1] + m[2][2]*v[2] + m[2][3]*v[3],
               m[3][0]*v[0] + m[3][1]*v[1] + m[3][2]*v[2] + m[3][3]*v[3]
           ];
       }

       // --- P5.js Lifecycle ---

       function setup() {
           createCanvas(windowWidth, windowHeight);
           document.getElementById('btn-pause').addEventListener('click', togglePause);
           document.getElementById('btn-reset').addEventListener('click', resetView);
           document.getElementById('btn-proj').addEventListener('click', toggleProjection);
           
           document.getElementById('slider-dist').addEventListener('input', (e) => {
               state.dist4D = parseFloat(e.target.value);
               document.getElementById('val-dist').innerText = state.dist4D.toFixed(1);
           });
           
           document.getElementById('slider-speed').addEventListener('input', (e) => {
               state.speed = parseFloat(e.target.value);
               document.getElementById('val-speed').innerText = state.speed.toFixed(1);
           });

           // Plane toggles
           ['xy', 'xz', 'xw', 'yz', 'yw', 'zw'].forEach(p => {
               document.getElementById(`rot-${p}`).addEventListener('click', (e) => {
                   state.planes[p] = !state.planes[p];
                   e.target.classList.toggle('active');
                   e.target.classList.toggle('text-gray-600');
               });
           });
       }

       function windowResized() {
           resizeCanvas(windowWidth, windowHeight);
       }

       function draw() {
           background(5, 5, 10); // Deep space black
           
           // Center origin
           translate(width / 2, height / 2);
           
           // Apply user zoom
           scale(state.zoom);

           // --- Logic Update ---
           
           if (state.isRunning) {
               state.angle += 0.01 * state.speed;
           }

           // Smooth mouse rotation interpolation
           state.mouseRotate.x = lerp(state.mouseRotate.x, state.targetMouseRotate.x, 0.1);
           state.mouseRotate.y = lerp(state.mouseRotate.y, state.targetMouseRotate.y, 0.1);

           // --- Projection Pipeline ---

           // 1. Calculate accumulated 4D Rotation Matrix
           // We combine rotations: R_total = R_xy * R_xz * R_xw ...
           // Note: Matrix multiplication order matters. 
           // To simplify accumulation in this frame, we just rotate the original vertices 
           // by the current total angle decomposed into specific planes.
           // A more robust way is to maintain a matrix state, but for visualization 
           // accumulating angles into a combined transform is cleaner code-wise.
           
           // Actually, let's just rotate vertices sequentially for simplicity and visual effect
           // It creates the "tumbling" look.
           
           let rotatedVertices = vertices4D.map(v => [...v]); // Copy

           const rotSpeed = state.angle;
           
           if (state.planes.xy) rotatedVertices = rotatedVertices.map(v => multiplyMatrixVector(getRotationMatrix4D(rotSpeed, 0, 1), v));
           if (state.planes.xz) rotatedVertices = rotatedVertices.map(v => multiplyMatrixVector(getRotationMatrix4D(rotSpeed * 0.5, 0, 2), v));
           if (state.planes.xw) rotatedVertices = rotatedVertices.map(v => multiplyMatrixVector(getRotationMatrix4D(rotSpeed * 0.3, 0, 3), v));
           if (state.planes.yz) rotatedVertices = rotatedVertices.map(v => multiplyMatrixVector(getRotationMatrix4D(rotSpeed * 0.7, 1, 2), v));
           if (state.planes.yw) rotatedVertices = rotatedVertices.map(v => multiplyMatrixVector(getRotationMatrix4D(rotSpeed * 0.4, 1, 3), v));
           if (state.planes.zw) rotatedVertices = rotatedVertices.map(v => multiplyMatrixVector(getRotationMatrix4D(rotSpeed * 0.6, 2, 3), v));

           // 2. Project 4D -> 3D
           // We ignore the W coordinate for position effectively, or project it.
           // Standard projection: scale xyz by 1/(dist - w)
           let vertices3D = rotatedVertices.map(v => {
               let [x, y, z, w] = v;
               
               // Perspective divide based on W
               let divisor = state.dist4D - w;
               if (state.isPerspective && divisor !== 0) {
                   x /= divisor;
                   y /= divisor;
                   z /= divisor;
               }
               // If Orthographic, we just drop W implicitly by returning x,y,z
               
               return [x * CONFIG.size, y * CONFIG.size, z * CONFIG.size];
           });

           // 3. Rotate in 3D space based on mouse interaction
           // Simple Euler rotation
           let cx = Math.cos(state.mouseRotate.y);
           let sx = Math.sin(state.mouseRotate.y);
           let cy = Math.cos(state.mouseRotate.x);
           let sy = Math.sin(state.mouseRotate.x);

           vertices3D = vertices3D.map(v => {
               let [x, y, z] = v;
               
               // Rotate around X axis
               let y1 = y * cx - z * sx;
               let z1 = y * sx + z * cx;
               
               // Rotate around Y axis
               let x2 = x * cy + z1 * sy;
               let z2 = -x * sy + z1 * cy;
               
               return [x2, y1, z2];
           });

           // 4. Project 3D -> 2D
           let vertices2D = vertices3D.map(v => {
               let [x, y, z] = v;
               let scale = CONFIG.perspective3D / (CONFIG.perspective3D - z);
               if (!state.isPerspective) scale = 1;
               return { x: x * scale, y: y * scale, z: z }; // Keep Z for depth sorting if needed
           });

           // --- Rendering ---

           // Glow effect
           drawingContext.shadowBlur = 15;
           drawingContext.shadowColor = 'rgba(0, 255, 255, 0.5)';
           
           strokeWeight(1.5);

           // Draw Edges
           for (let edge of edges) {
               let i = edge[0];
               let j = edge[1];
               
               let v1 = vertices2D[i];
               let v2 = vertices2D[j];
               
               // Color logic: 
               // If both Z are positive (behind camera in this coord system?), fade? 
               // Actually z is just depth.
               
               // Determine if edge connects "inner" cube to "outer" cube
               // In 4D, inner cube has w = -1, outer has w = 1 (or vice versa)
               let w1 = rotatedVertices[i][3];
               let w2 = rotatedVertices[j][3];
               
               if (w1 > 0 && w2 > 0) {
                   // Outer cube edges
                   stroke(0, 255, 255); // Cyan
               } else if (w1 < 0 && w2 < 0) {
                   // Inner cube edges
                   stroke(255, 0, 128); // Pink
               } else {
                   // Connecting edges
                   stroke(200, 200, 255); // White-ish
               }
               
               line(v1.x, v1.y, v2.x, v2.y);
           }
           
           drawingContext.shadowBlur = 0;

           // Draw Vertices
           noStroke();
           for (let i = 0; i < vertices2D.length; i++) {
               let v = vertices2D[i];
               let w = rotatedVertices[i][3];
               
               if (w > 0) fill(0, 255, 255);
               else fill(255, 0, 128);
               
               ellipse(v.x, v.y, 4, 4);
           }
       }

       function mouseDragged() {
           // Update target rotation based on drag delta
           state.targetMouseRotate.x += (mouseX - pmouseX) * 0.01;
           state.targetMouseRotate.y += (mouseY - pmouseY) * 0.01;
       }
       
       function mouseWheel(event) {
           // Zoom
           state.zoom -= event.delta * CONFIG.zoomSensitivity;
           state.zoom = constrain(state.zoom, 0.1, 5);
           return false;
       }

       // --- UI Handlers ---

       function togglePause() {
           state.isRunning = !state.isRunning;
           const btn = document.getElementById('btn-pause');
           btn.innerText = state.isRunning ? "Pause" : "Resume";
           btn.classList.toggle('text-yellow-400');
       }

       function resetView() {
           state.targetMouseRotate = { x: 0, y: 0 };
           state.mouseRotate = { x: 0, y: 0 };
           state.zoom = 1;
           state.angle = 0;
       }

       function toggleProjection() {
           state.isPerspective = !state.isPerspective;
           const btn = document.getElementById('btn-proj');
           btn.innerText = state.isPerspective ? "Perspective" : "Orthographic";
       }

   </script>
</body>
</html>