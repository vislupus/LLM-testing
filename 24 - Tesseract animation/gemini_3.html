<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 4D Tesseract</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #eee;
        }
        canvas {
            display: block;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            width: 280px;
            pointer-events: auto;
            user-select: none;
        }
        h2 { margin: 0 0 10px 0; font-size: 18px; color: #00d2ff; }
        .control-group { margin-bottom: 10px; }
        label { display: inline-block; width: 140px; font-size: 13px; }
        input[type=range] { width: 120px; vertical-align: middle; }
        .checkbox-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            font-size: 12px;
            margin-top: 5px;
        }
        .checkbox-item { display: flex; align-items: center; }
        .checkbox-item input { margin-right: 5px; }
        .info { font-size: 11px; color: #aaa; margin-top: 10px; border-top: 1px solid #555; padding-top: 5px; }
        button {
            background: #00d2ff; border: none; padding: 5px 10px; 
            color: #000; font-weight: bold; cursor: pointer; border-radius: 3px;
            width: 100%; margin-top: 5px;
        }
        button:hover { background: #66e0ff; }
    </style>
</head>
<body>

<div id="controls">
    <h2>Tesseract Control</h2>
    
    <div class="control-group">
        <button id="btnPause">Pause Rotation (Space)</button>
    </div>

    <div class="control-group">
        <label>Rotation Speed</label>
        <input type="range" id="sliderSpeed" min="0" max="0.05" step="0.001" value="0.015">
    </div>

    <div class="control-group">
        <label>4D Camera Dist</label>
        <input type="range" id="sliderDist" min="1.1" max="5" step="0.1" value="2.5">
        <br><span style="font-size:10px; color:#888;">(Closer = Perspective, Far = Ortho)</span>
    </div>

    <div class="control-group">
        <div style="font-size: 13px; margin-bottom: 4px;">Active Rotation Planes:</div>
        <div class="checkbox-group">
            <div class="checkbox-item"><input type="checkbox" id="chkXY"> XY</div>
            <div class="checkbox-item"><input type="checkbox" id="chkZW" checked> ZW</div>
            <div class="checkbox-item"><input type="checkbox" id="chkXZ"> XZ</div>
            <div class="checkbox-item"><input type="checkbox" id="chkYW"> YW</div>
            <div class="checkbox-item"><input type="checkbox" id="chkYZ"> YZ</div>
            <div class="checkbox-item"><input type="checkbox" id="chkXW" checked> XW</div>
        </div>
    </div>

    <div class="info">
        Drag mouse to rotate view.<br>
        W coordinates color mapped (Cyan to Magenta).
    </div>
</div>

<script>
/**
 * 4D Tesseract Visualization
 * 
 * Mathematical Concept:
 * 1. Define 16 vertices of a hypercube in 4D space (x, y, z, w).
 * 2. Apply 4D rotation matrices based on 6 possible planes.
 * 3. Project 4D -> 3D using a perspective projection based on 'w'.
 *    x3d = x / (distance - w)
 * 4. Use P5.js WEBGL mode to handle the final 3D -> 2D projection.
 */

let angle = 0;
let points = [];
let isPaused = false;

// Configuration
const TESSERACT_SIZE = 100; // Base scale of the shape

// P5.js Elements
let speedSlider, distSlider;
let chkXY, chkZW, chkXZ, chkYW, chkYZ, chkXW;

class P4Vector {
    constructor(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
}

function setup() {
    createCanvas(windowWidth, windowHeight, WEBGL);
    
    // Initialize UI references
    speedSlider = select('#sliderSpeed');
    distSlider = select('#sliderDist');
    
    chkXY = select('#chkXY');
    chkZW = select('#chkZW');
    chkXZ = select('#chkXZ');
    chkYW = select('#chkYW');
    chkYZ = select('#chkYZ');
    chkXW = select('#chkXW');
    
    const btnPause = select('#btnPause');
    btnPause.mousePressed(togglePause);

    // Generate the 16 vertices of a tesseract
    // A hypercube coordinates are all combinations of -1 and 1
    for (let i = 0; i < 16; i++) {
        let x = (i & 1) ? -1 : 1;
        let y = (i & 2) ? -1 : 1;
        let z = (i & 4) ? -1 : 1;
        let w = (i & 8) ? -1 : 1;
        points.push(new P4Vector(x, y, z, w));
    }
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
}

function togglePause() {
    isPaused = !isPaused;
    let btn = select('#btnPause');
    btn.html(isPaused ? "Resume Rotation" : "Pause Rotation (Space)");
}

function keyPressed() {
    if (key === ' ') {
        togglePause();
    }
}

function draw() {
    background(20);
    
    // User Interaction: Orbit Control for 3D view
    orbitControl();

    // Get current parameter values
    let speed = parseFloat(speedSlider.value());
    let dist4d = parseFloat(distSlider.value()); // Distance of "camera" in 4th dimension

    // Update rotation angle
    if (!isPaused) {
        angle += speed;
    }

    // Calculate rotated and projected points
    let projected3D = [];

    for (let i = 0; i < points.length; i++) {
        let p = points[i];
        
        // Copy original point
        let v = new P4Vector(p.x, p.y, p.z, p.w);

        // Apply Rotations based on checkboxes
        // 4D Rotations involve keeping 2 axes constant and rotating the other 2
        
        if (chkXY.checked()) v = rotateXY(v, angle);
        if (chkZW.checked()) v = rotateZW(v, angle);
        if (chkXZ.checked()) v = rotateXZ(v, angle);
        if (chkYW.checked()) v = rotateYW(v, angle);
        if (chkYZ.checked()) v = rotateYZ(v, angle);
        if (chkXW.checked()) v = rotateXW(v, angle);

        // 4D to 3D Projection
        // Formula: P_3d = P_4d * (1 / (distance - w))
        // The 'w' here determines the size of the "inner" vs "outer" cube in projection
        let w = v.w;
        let projectionFactor = 1 / (dist4d - w);
        
        let x3 = v.x * projectionFactor * TESSERACT_SIZE * 2; // Scale up for visibility
        let y3 = v.y * projectionFactor * TESSERACT_SIZE * 2;
        let z3 = v.z * projectionFactor * TESSERACT_SIZE * 2;

        // Store projection + original w for styling
        projected3D[i] = { x: x3, y: y3, z: z3, w: w };
    }

    // Drawing settings
    strokeWeight(2);
    noFill();

    // Draw Vertices (optional visuals)
    for (let i = 0; i < projected3D.length; i++) {
        let v = projected3D[i];
        push();
        translate(v.x, v.y, v.z);
        
        // Color based on 4th dimension depth (W)
        // W ranges roughly from -1.5 to 1.5 after rotation
        let hue = map(v.w, -1, 1, 180, 320); // Cyan to Magenta
        colorMode(HSB);
        stroke(hue, 100, 100);
        strokeWeight(8);
        point(0, 0, 0);
        pop();
    }

    // Draw Edges
    // Connect vertices that differ by exactly 1 coordinate in the original 4D space.
    // Since we generated points in binary order (0 to 15), we can use bit manipulation.
    // Two points connect if (i ^ j) is a power of 2 (1, 2, 4, 8).
    
    colorMode(RGB); // Reset for edge gradients if needed, though we'll use HSB logic
    
    for (let i = 0; i < 16; i++) {
        for (let j = i + 1; j < 16; j++) {
            // Check if connected
            let diff = i ^ j;
            // If diff is a power of 2, they are connected
            if (diff === 1 || diff === 2 || diff === 4 || diff === 8) {
                connect(i, j, projected3D);
            }
        }
    }
}

function connect(i, j, verts) {
    let v1 = verts[i];
    let v2 = verts[j];
    
    // Create a gradient look by mapping W coordinate to color
    // We can't do true gradients on LINES in p5 easy without shaders,
    // so we pick a color based on the average W of the edge.
    colorMode(HSB);
    let avgW = (v1.w + v2.w) / 2;
    let hue = map(avgW, -1, 1, 180, 320); 
    let bright = map(avgW, -1, 1, 50, 100); // Inner (further) edges slightly dimmer
    let alpha = map(avgW, -1, 1, 0.4, 1.0); // Depth cue: further items transparent
    
    stroke(hue, 80, bright, alpha);
    strokeWeight(2);

    beginShape(LINES);
    vertex(v1.x, v1.y, v1.z);
    vertex(v2.x, v2.y, v2.z);
    endShape();
}

/* --- 4D Rotation Matrices --- */

// Rotate around XY plane (Z and W constant)
function rotateXY(v, theta) {
    let x = v.x * Math.cos(theta) - v.y * Math.sin(theta);
    let y = v.x * Math.sin(theta) + v.y * Math.cos(theta);
    return new P4Vector(x, y, v.z, v.w);
}

// Rotate around ZW plane (X and Y constant)
function rotateZW(v, theta) {
    let z = v.z * Math.cos(theta) - v.w * Math.sin(theta);
    let w = v.z * Math.sin(theta) + v.w * Math.cos(theta);
    return new P4Vector(v.x, v.y, z, w);
}

// Rotate around XZ plane (Y and W constant)
function rotateXZ(v, theta) {
    let x = v.x * Math.cos(theta) - v.z * Math.sin(theta);
    let z = v.x * Math.sin(theta) + v.z * Math.cos(theta);
    return new P4Vector(x, v.y, z, v.w);
}

// Rotate around YW plane (X and Z constant)
function rotateYW(v, theta) {
    let y = v.y * Math.cos(theta) - v.w * Math.sin(theta);
    let w = v.y * Math.sin(theta) + v.w * Math.cos(theta);
    return new P4Vector(v.x, y, v.z, w);
}

// Rotate around YZ plane (X and W constant)
function rotateYZ(v, theta) {
    let y = v.y * Math.cos(theta) - v.z * Math.sin(theta);
    let z = v.y * Math.sin(theta) + v.z * Math.cos(theta);
    return new P4Vector(v.x, y, z, v.w);
}

// Rotate around XW plane (Y and Z constant)
function rotateXW(v, theta) {
    let x = v.x * Math.cos(theta) - v.w * Math.sin(theta);
    let w = v.x * Math.sin(theta) + v.w * Math.cos(theta);
    return new P4Vector(x, v.y, v.z, w);
}

</script>
</body>
</html>