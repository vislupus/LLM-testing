<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D Tesseract Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            color: #fff;
            overflow: hidden;
        }
        
        #container {
            position: relative;
        }
        
        #canvas-wrapper {
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 0 60px rgba(100, 150, 255, 0.2);
        }
        
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 30, 0.9);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 16px;
            border: 1px solid rgba(100, 150, 255, 0.2);
            min-width: 280px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        #controls h2 {
            color: #64b5f6;
            font-size: 18px;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 0 0 20px rgba(100, 181, 246, 0.5);
        }
        
        .section {
            margin-bottom: 18px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .section h3 {
            color: #ce93d8;
            font-size: 12px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }
        
        .rotation-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 10px;
        }
        
        .rotation-row label {
            width: 35px;
            font-size: 12px;
            color: #aaa;
            font-family: 'Consolas', monospace;
        }
        
        .checkbox-wrapper {
            position: relative;
            width: 20px;
            height: 20px;
        }
        
        .checkbox-wrapper input {
            opacity: 0;
            width: 20px;
            height: 20px;
            cursor: pointer;
            position: absolute;
        }
        
        .checkbox-wrapper .checkmark {
            position: absolute;
            top: 0;
            left: 0;
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            pointer-events: none;
        }
        
        .checkbox-wrapper input:checked + .checkmark {
            background: linear-gradient(135deg, #64b5f6, #42a5f5);
            border-color: transparent;
        }
        
        .checkbox-wrapper input:checked + .checkmark::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #000;
            font-size: 12px;
            font-weight: bold;
        }
        
        input[type="range"] {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ce93d8, #ab47bc);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(206, 147, 216, 0.4);
        }
        
        .control-row {
            margin-bottom: 12px;
        }
        
        .control-row label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 11px;
            color: #aaa;
        }
        
        .control-row label span {
            color: #64b5f6;
            font-family: 'Consolas', monospace;
        }
        
        .button-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        button {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-blue {
            background: linear-gradient(135deg, #64b5f6, #42a5f5);
            color: #000;
        }
        
        .btn-purple {
            background: linear-gradient(135deg, #ce93d8, #ab47bc);
            color: #fff;
        }
        
        .btn-cyan {
            background: linear-gradient(135deg, #4dd0e1, #26c6da);
            color: #000;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .toggle-row span {
            font-size: 12px;
            color: #aaa;
        }
        
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            position: absolute;
            z-index: 1;
        }
        
        .toggle-switch .slider {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            transition: 0.3s;
            pointer-events: none;
        }
        
        .toggle-switch .slider::before {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            left: 3px;
            bottom: 3px;
            background: #888;
            border-radius: 50%;
            transition: 0.3s;
        }
        
        .toggle-switch input:checked + .slider {
            background: linear-gradient(135deg, #64b5f6, #42a5f5);
        }
        
        .toggle-switch input:checked + .slider::before {
            transform: translateX(26px);
            background: #fff;
        }
        
        .info-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            font-size: 10px;
            color: #888;
            line-height: 1.6;
        }
        
        .info-box kbd {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #stats {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 10, 30, 0.9);
            padding: 15px;
            border-radius: 12px;
            font-size: 11px;
            font-family: 'Consolas', monospace;
            border: 1px solid rgba(100, 150, 255, 0.2);
        }
        
        #stats div {
            margin-bottom: 4px;
            color: #aaa;
        }
        
        #stats span {
            color: #64b5f6;
        }
        
        #title {
            position: fixed;
            top: 20px;
            right: 20px;
            text-align: right;
        }
        
        #title h1 {
            color: #64b5f6;
            font-size: 24px;
            font-weight: 300;
            text-shadow: 0 0 30px rgba(100, 181, 246, 0.5);
            margin-bottom: 5px;
        }
        
        #title p {
            color: #888;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-wrapper"></div>
    </div>
    
    <div id="controls">
        <h2>⬡ 4D Tesseract</h2>
        
        <div class="section">
            <h3>Rotation Planes</h3>
            <div class="rotation-row">
                <label>XY</label>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="rotXY" checked>
                    <div class="checkmark"></div>
                </div>
                <input type="range" id="speedXY" min="0" max="0.05" step="0.001" value="0.015">
            </div>
            <div class="rotation-row">
                <label>XZ</label>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="rotXZ">
                    <div class="checkmark"></div>
                </div>
                <input type="range" id="speedXZ" min="0" max="0.05" step="0.001" value="0.008">
            </div>
            <div class="rotation-row">
                <label>XW</label>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="rotXW" checked>
                    <div class="checkmark"></div>
                </div>
                <input type="range" id="speedXW" min="0" max="0.05" step="0.001" value="0.012">
            </div>
            <div class="rotation-row">
                <label>YZ</label>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="rotYZ">
                    <div class="checkmark"></div>
                </div>
                <input type="range" id="speedYZ" min="0" max="0.05" step="0.001" value="0.01">
            </div>
            <div class="rotation-row">
                <label>YW</label>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="rotYW">
                    <div class="checkmark"></div>
                </div>
                <input type="range" id="speedYW" min="0" max="0.05" step="0.001" value="0.009">
            </div>
            <div class="rotation-row">
                <label>ZW</label>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="rotZW" checked>
                    <div class="checkmark"></div>
                </div>
                <input type="range" id="speedZW" min="0" max="0.05" step="0.001" value="0.011">
            </div>
        </div>
        
        <div class="section">
            <h3>Projection</h3>
            <div class="toggle-row">
                <span>Perspective Mode</span>
                <div class="toggle-switch">
                    <input type="checkbox" id="perspective" checked>
                    <div class="slider"></div>
                </div>
            </div>
            <div class="control-row">
                <label>4D Distance: <span id="dist4DVal">2.5</span></label>
                <input type="range" id="dist4D" min="1.5" max="5" step="0.1" value="2.5">
            </div>
            <div class="control-row">
                <label>3D Distance: <span id="dist3DVal">4</span></label>
                <input type="range" id="dist3D" min="2" max="8" step="0.1" value="4">
            </div>
            <div class="control-row">
                <label>Scale: <span id="scaleVal">180</span></label>
                <input type="range" id="scale" min="50" max="300" step="10" value="180">
            </div>
        </div>
        
        <div class="section">
            <h3>Appearance</h3>
            <div class="toggle-row">
                <span>Show Vertices</span>
                <div class="toggle-switch">
                    <input type="checkbox" id="showVertices" checked>
                    <div class="slider"></div>
                </div>
            </div>
            <div class="toggle-row">
                <span>Color by Depth</span>
                <div class="toggle-switch">
                    <input type="checkbox" id="colorDepth" checked>
                    <div class="slider"></div>
                </div>
            </div>
            <div class="toggle-row">
                <span>Glow Effect</span>
                <div class="toggle-switch">
                    <input type="checkbox" id="glowEffect" checked>
                    <div class="slider"></div>
                </div>
            </div>
            <div class="control-row">
                <label>Line Width: <span id="lineWidthVal">2</span></label>
                <input type="range" id="lineWidth" min="0.5" max="5" step="0.5" value="2">
            </div>
        </div>
        
        <div class="section">
            <h3>Controls</h3>
            <div class="button-row">
                <button class="btn-blue" onclick="togglePause()">Pause</button>
                <button class="btn-purple" onclick="resetAngles()">Reset</button>
            </div>
            <div class="button-row" style="margin-top: 8px;">
                <button class="btn-cyan" onclick="presetCubeInCube()">Cube in Cube</button>
                <button class="btn-cyan" onclick="presetDouble()">Double Rotate</button>
            </div>
        </div>
        
        <div class="section">
            <div class="info-box">
                <kbd>Space</kbd> Pause/Resume<br>
                <kbd>R</kbd> Reset rotation<br>
                <kbd>1-6</kbd> Toggle rotation planes<br>
                <kbd>P</kbd> Toggle perspective<br>
                <kbd>Mouse drag</kbd> Manual rotation
            </div>
        </div>
    </div>
    
    <div id="stats">
        <div>FPS: <span id="fps">60</span></div>
        <div>Vertices: <span>16</span></div>
        <div>Edges: <span>32</span></div>
    </div>
    
    <div id="title">
        <h1>Tesseract</h1>
        <p>4-Dimensional Hypercube</p>
    </div>

    <script>
        // 4D Tesseract vertices and edges
        let vertices4D = [];
        let edges = [];
        
        // Rotation angles for each plane (6 planes in 4D)
        let angles = {
            XY: 0, XZ: 0, XW: 0,
            YZ: 0, YW: 0, ZW: 0
        };
        
        // Rotation settings
        let rotations = {
            XY: { enabled: true, speed: 0.015 },
            XZ: { enabled: false, speed: 0.008 },
            XW: { enabled: true, speed: 0.012 },
            YZ: { enabled: false, speed: 0.01 },
            YW: { enabled: false, speed: 0.009 },
            ZW: { enabled: true, speed: 0.011 }
        };
        
        // Projection parameters
        let distance4D = 2.5;
        let distance3D = 4;
        let perspectiveMode = true;
        let displayScale = 180;
        
        // Appearance
        let showVertices = true;
        let colorByDepth = true;
        let glowEffect = true;
        let lineWidth = 2;
        
        // Animation state
        let paused = false;
        let manualRotation = { x: 0, y: 0 };
        let isDragging = false;
        let lastMouse = { x: 0, y: 0 };
        
        // Canvas
        let canvasSize;
        
        function setup() {
            canvasSize = min(700, windowWidth - 350, windowHeight - 60);
            canvasSize = max(400, canvasSize);
            
            const canvas = createCanvas(canvasSize, canvasSize);
            canvas.parent('canvas-wrapper');
            
            // Generate 16 vertices of tesseract (all combinations of ±1 in 4D)
            for (let i = 0; i < 16; i++) {
                vertices4D.push([
                    (i & 1) ? 1 : -1,
                    (i & 2) ? 1 : -1,
                    (i & 4) ? 1 : -1,
                    (i & 8) ? 1 : -1
                ]);
            }
            
            // Generate 32 edges (connect vertices differing in exactly one coordinate)
            for (let i = 0; i < 16; i++) {
                for (let j = i + 1; j < 16; j++) {
                    let diff = 0;
                    for (let k = 0; k < 4; k++) {
                        if (vertices4D[i][k] !== vertices4D[j][k]) diff++;
                    }
                    if (diff === 1) {
                        edges.push([i, j]);
                    }
                }
            }
            
            setupControls();
        }
        
        function setupControls() {
            // Rotation plane toggles and speeds
            const planes = ['XY', 'XZ', 'XW', 'YZ', 'YW', 'ZW'];
            planes.forEach(plane => {
                document.getElementById('rot' + plane).addEventListener('change', function() {
                    rotations[plane].enabled = this.checked;
                });
                document.getElementById('speed' + plane).addEventListener('input', function() {
                    rotations[plane].speed = parseFloat(this.value);
                });
            });
            
            // Projection controls
            document.getElementById('perspective').addEventListener('change', function() {
                perspectiveMode = this.checked;
            });
            
            document.getElementById('dist4D').addEventListener('input', function() {
                distance4D = parseFloat(this.value);
                document.getElementById('dist4DVal').textContent = distance4D.toFixed(1);
            });
            
            document.getElementById('dist3D').addEventListener('input', function() {
                distance3D = parseFloat(this.value);
                document.getElementById('dist3DVal').textContent = distance3D.toFixed(1);
            });
            
            document.getElementById('scale').addEventListener('input', function() {
                displayScale = parseFloat(this.value);
                document.getElementById('scaleVal').textContent = displayScale;
            });
            
            // Appearance controls
            document.getElementById('showVertices').addEventListener('change', function() {
                showVertices = this.checked;
            });
            
            document.getElementById('colorDepth').addEventListener('change', function() {
                colorByDepth = this.checked;
            });
            
            document.getElementById('glowEffect').addEventListener('change', function() {
                glowEffect = this.checked;
            });
            
            document.getElementById('lineWidth').addEventListener('input', function() {
                lineWidth = parseFloat(this.value);
                document.getElementById('lineWidthVal').textContent = lineWidth;
            });
        }
        
        // 4D rotation in a specific plane
        function rotate4D(v, plane, angle) {
            let [x, y, z, w] = v;
            const c = cos(angle);
            const s = sin(angle);
            
            switch(plane) {
                case 'XY': return [x*c - y*s, x*s + y*c, z, w];
                case 'XZ': return [x*c - z*s, y, x*s + z*c, w];
                case 'XW': return [x*c - w*s, y, z, x*s + w*c];
                case 'YZ': return [x, y*c - z*s, y*s + z*c, w];
                case 'YW': return [x, y*c - w*s, z, y*s + w*c];
                case 'ZW': return [x, y, z*c - w*s, z*s + w*c];
            }
            return v;
        }
        
        // Apply all rotations to a vertex
        function applyRotations(v) {
            let result = [...v];
            
            // Apply each enabled rotation
            for (let plane in angles) {
                result = rotate4D(result, plane, angles[plane]);
            }
            
            // Apply manual rotation (3D-like rotation for mouse control)
            // XZ rotation (horizontal mouse movement)
            let [x, y, z, w] = result;
            let c = cos(manualRotation.x);
            let s = sin(manualRotation.x);
            result = [x*c - z*s, y, x*s + z*c, w];
            
            // YZ rotation (vertical mouse movement)
            [x, y, z, w] = result;
            c = cos(manualRotation.y);
            s = sin(manualRotation.y);
            result = [x, y*c - z*s, y*s + z*c, w];
            
            return result;
        }
        
        // Project 4D point to 3D
        function project4Dto3D(v) {
            const [x, y, z, w] = v;
            
            if (perspectiveMode) {
                const factor = distance4D / (distance4D - w);
                return [x * factor, y * factor, z * factor, w];
            } else {
                return [x, y, z, w];
            }
        }
        
        // Project 3D point to 2D
        function project3Dto2D(v) {
            const [x, y, z, w] = v;
            
            if (perspectiveMode) {
                const factor = distance3D / (distance3D - z);
                return { x: x * factor * displayScale, y: y * factor * displayScale, z: z, w: w };
            } else {
                return { x: x * displayScale, y: y * displayScale, z: z, w: w };
            }
        }
        
        // Get color based on 4D depth (w coordinate)
        function getDepthColor(w, alpha = 255) {
            if (!colorByDepth) {
                return color(100, 180, 255, alpha);
            }
            
            // Map w from [-1.5, 1.5] to hue
            const hue = map(w, -1.5, 1.5, 180, 320);
            colorMode(HSB, 360, 100, 100, 255);
            const c = color(hue, 70, 90, alpha);
            colorMode(RGB, 255, 255, 255, 255);
            return c;
        }
        
        function draw() {
            // Dark background with subtle gradient
            background(10, 12, 25);
            
            // Draw subtle grid
            stroke(30, 35, 50);
            strokeWeight(0.5);
            const gridStep = 50;
            for (let i = gridStep; i < width; i += gridStep) {
                line(i, 0, i, height);
                line(0, i, width, i);
            }
            
            translate(width / 2, height / 2);
            
            // Update rotation angles
            if (!paused) {
                for (let plane in rotations) {
                    if (rotations[plane].enabled) {
                        angles[plane] += rotations[plane].speed;
                    }
                }
            }
            
            // Transform and project all vertices
            let transformed = vertices4D.map(v => applyRotations(v));
            let projected = transformed.map(v => {
                const v3D = project4Dto3D(v);
                return project3Dto2D(v3D);
            });
            
            // Sort edges by average depth for proper rendering
            let sortedEdges = edges.map((edge, idx) => {
                const avgW = (transformed[edge[0]][3] + transformed[edge[1]][3]) / 2;
                const avgZ = (projected[edge[0]].z + projected[edge[1]].z) / 2;
                return { edge, depth: avgW + avgZ * 0.5, idx };
            });
            sortedEdges.sort((a, b) => a.depth - b.depth);
            
            // Draw glow layer first
            if (glowEffect) {
                for (let item of sortedEdges) {
                    const [i, j] = item.edge;
                    const p1 = projected[i];
                    const p2 = projected[j];
                    const avgW = (transformed[i][3] + transformed[j][3]) / 2;
                    
                    const glowColor = getDepthColor(avgW, 30);
                    stroke(glowColor);
                    strokeWeight(lineWidth * 4);
                    line(p1.x, p1.y, p2.x, p2.y);
                }
            }
            
            // Draw edges
            for (let item of sortedEdges) {
                const [i, j] = item.edge;
                const p1 = projected[i];
                const p2 = projected[j];
                const avgW = (transformed[i][3] + transformed[j][3]) / 2;
                
                // Edge color and alpha based on 4D depth
                const alpha = map(avgW, -1.5, 1.5, 120, 255);
                const edgeColor = getDepthColor(avgW, alpha);
                
                stroke(edgeColor);
                strokeWeight(lineWidth);
                line(p1.x, p1.y, p2.x, p2.y);
            }
            
            // Draw vertices
            if (showVertices) {
                noStroke();
                
                // Sort vertices by depth
                let sortedVertices = projected.map((p, idx) => ({
                    p, w: transformed[idx][3], idx
                }));
                sortedVertices.sort((a, b) => a.w - b.w);
                
                for (let item of sortedVertices) {
                    const p = item.p;
                    const w = item.w;
                    
                    // Size based on depth
                    const size = map(w, -1.5, 1.5, 3, 8);
                    
                    // Glow
                    if (glowEffect) {
                        const glowColor = getDepthColor(w, 50);
                        fill(glowColor);
                        ellipse(p.x, p.y, size * 3, size * 3);
                    }
                    
                    // Vertex
                    const vertexColor = getDepthColor(w, 255);
                    fill(vertexColor);
                    ellipse(p.x, p.y, size, size);
                    
                    // Highlight
                    fill(255, 255, 255, 150);
                    ellipse(p.x - size * 0.15, p.y - size * 0.15, size * 0.4, size * 0.4);
                }
            }
            
            // Update FPS display
            if (frameCount % 30 === 0) {
                document.getElementById('fps').textContent = floor(frameRate());
            }
        }
        
        // Mouse interaction for manual rotation
        function mousePressed() {
            if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {
                isDragging = true;
                lastMouse = { x: mouseX, y: mouseY };
            }
        }
        
        function mouseDragged() {
            if (isDragging) {
                const dx = mouseX - lastMouse.x;
                const dy = mouseY - lastMouse.y;
                
                manualRotation.x += dx * 0.01;
                manualRotation.y += dy * 0.01;
                
                lastMouse = { x: mouseX, y: mouseY };
            }
        }
        
        function mouseReleased() {
            isDragging = false;
        }
        
        // Keyboard controls
        function keyPressed() {
            switch(key) {
                case ' ':
                    togglePause();
                    return false;
                case 'r':
                case 'R':
                    resetAngles();
                    break;
                case 'p':
                case 'P':
                    perspectiveMode = !perspectiveMode;
                    document.getElementById('perspective').checked = perspectiveMode;
                    break;
                case '1':
                    toggleRotation('XY');
                    break;
                case '2':
                    toggleRotation('XZ');
                    break;
                case '3':
                    toggleRotation('XW');
                    break;
                case '4':
                    toggleRotation('YZ');
                    break;
                case '5':
                    toggleRotation('YW');
                    break;
                case '6':
                    toggleRotation('ZW');
                    break;
            }
        }
        
        function toggleRotation(plane) {
            rotations[plane].enabled = !rotations[plane].enabled;
            document.getElementById('rot' + plane).checked = rotations[plane].enabled;
        }
        
        function togglePause() {
            paused = !paused;
            document.querySelector('.btn-blue').textContent = paused ? 'Resume' : 'Pause';
        }
        
        function resetAngles() {
            for (let plane in angles) {
                angles[plane] = 0;
            }
            manualRotation = { x: 0, y: 0 };
        }
        
        // Preset configurations
        function presetCubeInCube() {
            // Only rotate in XW plane for classic cube-within-cube view
            for (let plane in rotations) {
                rotations[plane].enabled = false;
                document.getElementById('rot' + plane).checked = false;
            }
            rotations.XW.enabled = true;
            rotations.XW.speed = 0.02;
            document.getElementById('rotXW').checked = true;
            document.getElementById('speedXW').value = 0.02;
            resetAngles();
        }
        
        function presetDouble() {
            // Double rotation - most interesting patterns
            for (let plane in rotations) {
                rotations[plane].enabled = false;
                document.getElementById('rot' + plane).checked = false;
            }
            rotations.XY.enabled = true;
            rotations.ZW.enabled = true;
            rotations.XY.speed = 0.015;
            rotations.ZW.speed = 0.012;
            document.getElementById('rotXY').checked = true;
            document.getElementById('rotZW').checked = true;
            resetAngles();
        }
        
        function windowResized() {
            // Keep canvas size fixed
        }
    </script>
</body>
</html>