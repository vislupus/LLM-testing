<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 4D Tesseract Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #container {
            position: relative;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.5);
            border-radius: 16px;
            overflow: hidden;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            color: #e0e0ff;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            max-width: 320px;
            transition: transform 0.3s ease;
            z-index: 100;
        }

        .controls.hidden {
            transform: translateX(-350px);
        }

        .controls h3 {
            margin: 0 0 15px 0;
            color: #64b5f6;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(100, 180, 255, 0.5);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 13px;
            color: #b0c4ff;
        }

        .slider {
            width: 100%;
            height: 5px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #64b5f6;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 180, 255, 0.6);
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #64b5f6;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 180, 255, 0.6);
        }

        .rotation-planes {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .plane-btn {
            padding: 8px;
            background: #333;
            color: #b0c4ff;
            border: 2px solid #555;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
        }

        .plane-btn:hover {
            background: #444;
            border-color: #64b5f6;
        }

        .plane-btn.active {
            background: #64b5f6;
            color: #000;
            border-color: #64b5f6;
            box-shadow: 0 0 15px rgba(100, 180, 255, 0.5);
        }

        .projection-modes {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .proj-btn {
            flex: 1;
            padding: 8px;
            background: #333;
            color: #b0c4ff;
            border: 2px solid #555;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
        }

        .proj-btn:hover {
            background: #444;
            border-color: #64b5f6;
        }

        .proj-btn.active {
            background: #4fc3f7;
            color: #000;
            border-color: #4fc3f7;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            flex: 1;
            padding: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .toggle-btn {
            position: absolute;
            top: 20px;
            left: 350px;
            background: rgba(20, 20, 35, 0.95);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            z-index: 101;
        }

        .toggle-btn.shifted {
            left: 20px;
        }

        .info-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(20, 20, 35, 0.95);
            padding: 15px;
            border-radius: 12px;
            color: #e0e0ff;
            font-size: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            max-width: 250px;
            z-index: 100;
        }

        .info-panel h4 {
            margin: 0 0 10px 0;
            color: #64b5f6;
            font-size: 14px;
        }

        .info-panel div {
            margin: 5px 0;
        }

        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 35, 0.95);
            padding: 12px 18px;
            border-radius: 8px;
            color: #4fc3f7;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(79, 195, 247, 0.5);
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="controls" id="controls">
            <h3>ðŸ”® Tesseract Controls</h3>
            
            <div class="control-group">
                <label>Rotation Speed: <span id="speedValue">1.0</span></label>
                <input type="range" class="slider" id="rotationSpeed" min="0" max="3" step="0.1" value="1">
            </div>
            
            <div class="control-group">
                <label>Projection Distance: <span id="distanceValue">3.0</span></label>
                <input type="range" class="slider" id="projectionDistance" min="1" max="10" step="0.1" value="3">
            </div>
            
            <div class="control-group">
                <label>Line Thickness: <span id="thicknessValue">2</span></label>
                <input type="range" class="slider" id="lineThickness" min="1" max="5" step="0.5" value="2">
            </div>
            
            <div class="control-group">
                <label>Rotation Planes</label>
                <div class="rotation-planes">
                    <button class="plane-btn active" data-plane="XY">XY</button>
                    <button class="plane-btn active" data-plane="XZ">XZ</button>
                    <button class="plane-btn active" data-plane="XW">XW</button>
                    <button class="plane-btn" data-plane="YZ">YZ</button>
                    <button class="plane-btn" data-plane="YW">YW</button>
                    <button class="plane-btn" data-plane="ZW">ZW</button>
                </div>
            </div>
            
            <div class="control-group">
                <label>Projection Type</label>
                <div class="projection-modes">
                    <button class="proj-btn active" data-proj="perspective">Perspective</button>
                    <button class="proj-btn" data-proj="orthographic">Orthographic</button>
                </div>
            </div>
            
            <div class="action-buttons">
                <button class="btn" onclick="tesseract.togglePause()">Pause</button>
                <button class="btn" onclick="tesseract.reset()">Reset</button>
            </div>
        </div>
        
        <button class="toggle-btn" id="toggleBtn" onclick="toggleControls()">â—€</button>
        
        <div class="stats">
            FPS: <span id="fps">60</span> | Frame: <span id="frame">0</span>
        </div>
        
        <div class="info-panel">
            <h4>ðŸŽ® Controls</h4>
            <div>â€¢ <strong>Mouse Drag</strong> â†’ Manual rotation</div>
            <div>â€¢ <strong>Scroll</strong> â†’ Zoom in/out</div>
            <div>â€¢ <strong>Space</strong> â†’ Pause/Resume</div>
            <div>â€¢ <strong>R</strong> â†’ Reset view</div>
            <div>â€¢ <strong>1-6</strong> â†’ Toggle rotation planes</div>
            <div>â€¢ <strong>P</strong> â†’ Toggle projection</div>
        </div>
    </div>

    <script>
        class Tesseract4D {
            constructor() {
                this.vertices4D = [];
                this.edges = [];
                this.vertices3D = [];
                this.vertices2D = [];
                
                this.angle = 0;
                this.rotationSpeed = 1.0;
                this.projectionDistance = 3.0;
                this.projectionMode = 'perspective';
                this.paused = false;
                this.lineThickness = 2;
                
                // Rotation angles for each plane
                this.rotations = {
                    XY: 0, XZ: 0, XW: 0,
                    YZ: 0, YW: 0, ZW: 0
                };
                
                this.activePlanes = ['XY', 'XZ', 'XW'];
                
                // Mouse interaction
                this.mouseX = 0;
                this.mouseY = 0;
                this.prevMouseX = 0;
                this.prevMouseY = 0;
                this.mouseDragging = false;
                this.manualRotation = { x: 0, y: 0 };
                
                this.frameCount = 0;
                this.fps = 60;
                this.lastTime = millis();
                
                this.init();
            }
            
            init() {
                // Define 16 vertices of a tesseract at (Â±1, Â±1, Â±1, Â±1)
                for (let i = 0; i < 16; i++) {
                    const x = (i & 1) ? 1 : -1;
                    const y = (i & 2) ? 1 : -1;
                    const z = (i & 4) ? 1 : -1;
                    const w = (i & 8) ? 1 : -1;
                    this.vertices4D.push([x, y, z, w]);
                }
                
                // Define 32 edges of the tesseract
                this.edges = [
                    // Edges of the first cube (w = -1)
                    [0, 1], [1, 3], [3, 2], [2, 0],
                    [4, 5], [5, 7], [7, 6], [6, 4],
                    [0, 4], [1, 5], [2, 6], [3, 7],
                    // Edges of the second cube (w = 1)
                    [8, 9], [9, 11], [11, 10], [10, 8],
                    [12, 13], [13, 15], [15, 14], [14, 12],
                    [8, 12], [9, 13], [10, 14], [11, 15],
                    // Edges connecting the two cubes
                    [0, 8], [1, 9], [2, 10], [3, 11],
                    [4, 12], [5, 13], [6, 14], [7, 15]
                ];
                
                // Initialize projection arrays
                for (let i = 0; i < 16; i++) {
                    this.vertices3D.push([0, 0, 0]);
                    this.vertices2D.push([0, 0]);
                }
            }
            
            rotate4D(vertex, plane, angle) {
                const [x, y, z, w] = vertex;
                let newX = x, newY = y, newZ = z, newW = w;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                
                switch(plane) {
                    case 'XY':
                        newX = x * cos - y * sin;
                        newY = x * sin + y * cos;
                        break;
                    case 'XZ':
                        newX = x * cos - z * sin;
                        newZ = x * sin + z * cos;
                        break;
                    case 'XW':
                        newX = x * cos - w * sin;
                        newW = x * sin + w * cos;
                        break;
                    case 'YZ':
                        newY = y * cos - z * sin;
                        newZ = y * sin + z * cos;
                        break;
                    case 'YW':
                        newY = y * cos - w * sin;
                        newW = y * sin + w * cos;
                        break;
                    case 'ZW':
                        newZ = z * cos - w * sin;
                        newW = z * sin + w * cos;
                        break;
                }
                
                return [newX, newY, newZ, newW];
            }
            
            project4Dto3D(vertex4D) {
                const [x, y, z, w] = vertex4D;
                const distance = this.projectionDistance;
                const wDistance = distance - w;
                
                if (this.projectionMode === 'perspective') {
                    const factor = distance / wDistance;
                    return [x * factor, y * factor, z * factor];
                } else {
                    // Orthographic projection
                    return [x, y, z];
                }
            }
            
            project3Dto2D(vertex3D) {
                const [x, y, z] = vertex3D;
                const distance = 5;
                
                if (this.projectionMode === 'perspective') {
                    const factor = distance / (distance - z);
                    return [x * factor, y * factor];
                } else {
                    return [x, y];
                }
            }
            
            update() {
                if (this.paused) return;
                
                // Update rotation angles
                for (const plane of this.activePlanes) {
                    this.rotations[plane] += 0.01 * this.rotationSpeed;
                }
                
                // Apply rotations and projections
                for (let i = 0; i < 16; i++) {
                    let vertex = [...this.vertices4D[i]];
                    
                    // Apply all active rotations
                    for (const plane of this.activePlanes) {
                        vertex = this.rotate4D(vertex, plane, this.rotations[plane]);
                    }
                    
                    // Apply manual mouse rotation
                    if (this.mouseDragging) {
                        vertex = this.rotate4D(vertex, 'XY', this.manualRotation.x);
                        vertex = this.rotate4D(vertex, 'XZ', this.manualRotation.y);
                    }
                    
                    // Project to 3D then 2D
                    this.vertices3D[i] = this.project4Dto3D(vertex);
                    this.vertices2D[i] = this.project3Dto2D(this.vertices3D[i]);
                }
                
                this.frameCount++;
            }
            
            render() {
                push();
                translate(width / 2, height / 2);
                
                // Calculate scale based on projection distance
                const scale = min(width, height) / 4;
                
                // Sort edges by depth for proper rendering
                const sortedEdges = this.edges.map(edge => {
                    const v1 = this.vertices3D[edge[0]];
                    const v2 = this.vertices3D[edge[1]];
                    const avgZ = (v1[2] + v2[2]) / 2;
                    return { edge, avgZ };
                }).sort((a, b) => a.avgZ - b.avgZ);
                
                // Draw edges
                for (const { edge } of sortedEdges) {
                    const v1 = this.vertices2D[edge[0]];
                    const v2 = this.vertices2D[edge[1]];
                    const v3D1 = this.vertices3D[edge[0]];
                    const v3D2 = this.vertices3D[edge[1]];
                    
                    // Calculate depth-based color and thickness
                    const avgZ = (v3D1[2] + v3D2[2]) / 2;
                    const depth = map(avgZ, -3, 3, 0, 1);
                    
                    // Color gradient from inner to outer edges
                    const r = lerp(100, 255, depth);
                    const g = lerp(150, 100, depth);
                    const b = lerp(255, 150, depth);
                    const alpha = lerp(255, 150, depth);
                    
                    strokeWeight(this.lineThickness * (1 - depth * 0.3));
                    stroke(r, g, b, alpha);
                    
                    // Add glow effect for outer edges
                    if (depth > 0.7) {
                        drawingContext.shadowBlur = 10;
                        drawingContext.shadowColor = `rgba(${r}, ${g}, ${b}, 0.5)`;
                    } else {
                        drawingContext.shadowBlur = 0;
                    }
                    
                    line(v1[0] * scale, v1[1] * scale, v2[0] * scale, v2[1] * scale);
                }
                
                // Draw vertices as points
                noStroke();
                for (let i = 0; i < 16; i++) {
                    const v = this.vertices2D[i];
                    const v3D = this.vertices3D[i];
                    const depth = map(v3D[2], -3, 3, 0, 1);
                    
                    fill(255, 255, 255, 200 - depth * 100);
                    ellipse(v[0] * scale, v[1] * scale, 4 - depth * 2);
                }
                
                pop();
                
                // Update FPS
                const currentTime = millis();
                const deltaTime = currentTime - this.lastTime;
                this.fps = Math.round(1000 / deltaTime);
                this.lastTime = currentTime;
                
                // Update stats display
                document.getElementById('fps').textContent = this.fps;
                document.getElementById('frame').textContent = this.frameCount;
            }
            
            togglePause() {
                this.paused = !this.paused;
            }
            
            reset() {
                this.angle = 0;
                for (const plane in this.rotations) {
                    this.rotations[plane] = 0;
                }
                this.manualRotation = { x: 0, y: 0 };
                this.frameCount = 0;
            }
            
            togglePlane(plane) {
                const index = this.activePlanes.indexOf(plane);
                if (index > -1) {
                    this.activePlanes.splice(index, 1);
                } else {
                    this.activePlanes.push(plane);
                }
            }
            
            setProjectionMode(mode) {
                this.projectionMode = mode;
            }
        }
        
        let tesseract;
        
        function setup() {
            const canvas = createCanvas(800, 800);
            canvas.parent('container');
            
            tesseract = new Tesseract4D();
            
            setupControls();
        }
        
        function draw() {
            // Dark gradient background
            for (let i = 0; i <= height; i++) {
                const inter = map(i, 0, height, 0, 1);
                const c = lerpColor(color(15, 12, 41), color(36, 43, 62), inter);
                stroke(c);
                line(0, i, width, i);
            }
            
            tesseract.update();
            tesseract.render();
        }
        
        function mousePressed() {
            tesseract.mouseDragging = true;
            tesseract.prevMouseX = mouseX;
            tesseract.prevMouseY = mouseY;
        }
        
        function mouseDragged() {
            if (tesseract.mouseDragging) {
                const deltaX = mouseX - tesseract.prevMouseX;
                const deltaY = mouseY - tesseract.prevMouseY;
                
                tesseract.manualRotation.x += deltaX * 0.01;
                tesseract.manualRotation.y += deltaY * 0.01;
                
                tesseract.prevMouseX = mouseX;
                tesseract.prevMouseY = mouseY;
            }
        }
        
        function mouseReleased() {
            tesseract.mouseDragging = false;
        }
        
        function mouseWheel(event) {
            const delta = event.delta;
            tesseract.projectionDistance = constrain(
                tesseract.projectionDistance - delta * 0.01,
                1, 10
            );
            document.getElementById('projectionDistance').value = tesseract.projectionDistance;
            document.getElementById('distanceValue').textContent = tesseract.projectionDistance.toFixed(1);
            return false;
        }
        
        function keyPressed() {
            if (key === ' ') {
                tesseract.togglePause();
            } else if (key === 'r' || key === 'R') {
                tesseract.reset();
            } else if (key === 'p' || key === 'P') {
                const mode = tesseract.projectionMode === 'perspective' ? 'orthographic' : 'perspective';
                tesseract.setProjectionMode(mode);
                updateProjectionButtons(mode);
            } else if (key >= '1' && key <= '6') {
                const planes = ['XY', 'XZ', 'XW', 'YZ', 'YW', 'ZW'];
                const planeIndex = parseInt(key) - 1;
                tesseract.togglePlane(planes[planeIndex]);
                updatePlaneButtons();
            }
        }
        
        function setupControls() {
            // Rotation speed
            document.getElementById('rotationSpeed').addEventListener('input', (e) => {
                tesseract.rotationSpeed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = e.target.value;
            });
            
            // Projection distance
            document.getElementById('projectionDistance').addEventListener('input', (e) => {
                tesseract.projectionDistance = parseFloat(e.target.value);
                document.getElementById('distanceValue').textContent = e.target.value;
            });
            
            // Line thickness
            document.getElementById('lineThickness').addEventListener('input', (e) => {
                tesseract.lineThickness = parseFloat(e.target.value);
                document.getElementById('thicknessValue').textContent = e.target.value;
            });
            
            // Rotation plane buttons
            document.querySelectorAll('.plane-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const plane = btn.dataset.plane;
                    tesseract.togglePlane(plane);
                    btn.classList.toggle('active');
                });
            });
            
            // Projection mode buttons
            document.querySelectorAll('.proj-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const mode = btn.dataset.proj;
                    tesseract.setProjectionMode(mode);
                    updateProjectionButtons(mode);
                });
            });
        }
        
        function updatePlaneButtons() {
            document.querySelectorAll('.plane-btn').forEach(btn => {
                const plane = btn.dataset.plane;
                if (tesseract.activePlanes.includes(plane)) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }
        
        function updateProjectionButtons(mode) {
            document.querySelectorAll('.proj-btn').forEach(btn => {
                if (btn.dataset.proj === mode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }
        
        function toggleControls() {
            const controls = document.getElementById('controls');
            const toggleBtn = document.getElementById('toggleBtn');
            controls.classList.toggle('hidden');
            toggleBtn.classList.toggle('shifted');
            toggleBtn.textContent = controls.classList.contains('hidden') ? 'â–¶' : 'â—€';
        }
    </script>
</body>
</html>