<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>p5.js 4D Tesseract (4D→3D→2D) Interactive</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b0f14; color: #eaf2ff; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; overflow: hidden; }
    #hud {
      position: fixed; left: 12px; top: 12px;
      width: min(420px, calc(100% - 24px));
      background: rgba(10, 14, 20, 0.78);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
      user-select: none;
    }
    #hud h1 { margin: 0 0 8px; font-size: 14px; letter-spacing: .2px; }
    .line { font-size: 12px; opacity: 0.92; line-height: 1.35; }
    .pill {
      display: inline-block; padding: 2px 6px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      font-size: 11px; margin-right: 6px;
      font-variant-numeric: tabular-nums;
    }
    .grid { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; margin-top: 8px; }
    input[type="range"] { width: 100%; }
    button {
      padding: 7px 10px; border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08);
      color: #eaf2ff; cursor: pointer; font-size: 12px;
    }
    button:hover { background: rgba(255,255,255,0.12); }
    .rowBtns { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 11px; opacity: 0.95; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="hud">
    <h1>4D Tesseract — rotating in multiple 4D planes (4D→3D→2D)</h1>

    <div class="grid">
      <div class="line">Rotation speed <span class="pill" id="spdVal">1.00×</span></div>
      <input id="spd" type="range" min="0" max="3" step="0.01" value="1.00" />
    </div>

    <div class="grid">
      <div class="line">4D→3D distance <span class="pill" id="d4Val">2.60</span></div>
      <input id="d4" type="range" min="1.2" max="6.0" step="0.01" value="2.60" />
    </div>

    <div class="grid">
      <div class="line">3D→2D distance <span class="pill" id="d3Val">3.20</span></div>
      <input id="d3" type="range" min="1.5" max="8.0" step="0.01" value="3.20" />
    </div>

    <div class="rowBtns">
      <button id="pauseBtn">Pause</button>
      <button id="projBtn">Projection: Perspective</button>
      <button id="shadeBtn">Shading: On</button>
      <button id="resetBtn">Reset</button>
    </div>

    <div class="line" style="margin-top:8px">
      Active 4D planes (toggle):<br/>
      <span class="pill kbd">1</span>XY <span class="pill kbd">2</span>XZ <span class="pill kbd">3</span>XW
      <span class="pill kbd">4</span>YZ <span class="pill kbd">5</span>YW <span class="pill kbd">6</span>ZW
    </div>

    <div class="line" style="margin-top:8px">
      Controls: <span class="pill kbd">Space</span> pause/resume,
      <span class="pill kbd">O</span> ortho/persp,
      <span class="pill kbd">[ ]</span> speed,
      <span class="pill kbd">- +</span> 4D distance,
      <span class="pill kbd">, .</span> 3D distance,
      <span class="pill kbd">S</span> shading,
      <span class="pill kbd">R</span> reset.
      Drag mouse to “nudge” extra rotation.
    </div>

    <div class="line" style="margin-top:8px">
      Planes on: <span class="pill" id="planesReadout">XY XW ZW</span>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <script>
  // ============================================================
  // 4D Tesseract in p5.js (single file)
  // - Builds 16 vertices of a tesseract (±1 in x,y,z,w)
  // - Rotates in 4D via multiple plane rotations
  // - Projects 4D→3D (perspective w) then 3D→2D (perspective z)
  // - Interactive toggles, speed, distances, ortho/persp
  // ============================================================

  // --- UI elements
  const ui = {};
  const PLANES = ["XY","XZ","XW","YZ","YW","ZW"];
  const planeIdx = { XY:0, XZ:1, XW:2, YZ:3, YW:4, ZW:5 };

  // --- sim parameters
  let running = true;
  let persp2D = true;     // 3D→2D perspective
  let shading = true;     // subtle depth/inner-outer cue
  let speedMul = 1.0;
  let d4 = 2.60;          // 4D perspective distance (w)
  let d3 = 3.20;          // 3D perspective distance (z)

  // active rotations (default: classic morphs)
  let active = new Set(["XY","XW","ZW"]);

  // time & extra mouse-driven rotation
  let t = 0;
  let extra = { x:0, y:0 };   // nudges add to some planes

  // tesseract geometry
  let V4 = [];    // 16 vertices [x,y,z,w]
  let edges = []; // pairs of vertex indices

  function setupGeometry() {
    V4 = [];
    for (let i = 0; i < 16; i++) {
      const x = (i & 1) ? 1 : -1;
      const y = (i & 2) ? 1 : -1;
      const z = (i & 4) ? 1 : -1;
      const w = (i & 8) ? 1 : -1;
      V4.push([x,y,z,w]);
    }
    edges = [];
    for (let i = 0; i < 16; i++) {
      for (let bit = 0; bit < 4; bit++) {
        const j = i ^ (1<<bit);
        if (i < j) edges.push([i,j]);
      }
    }
  }

  // --- 4D rotation in a coordinate plane (a,b are indices 0..3)
  function rotatePlane(v, a, b, ang) {
    const c = Math.cos(ang), s = Math.sin(ang);
    const va = v[a], vb = v[b];
    v[a] = va*c - vb*s;
    v[b] = va*s + vb*c;
    return v;
  }

  function applyRotations(v, angs) {
    // angs: map plane->angle
    // Order matters; pick a stable, consistent order:
    const order = ["XY","XZ","XW","YZ","YW","ZW"];
    for (const pl of order) {
      const ang = angs[pl] || 0;
      if (ang === 0) continue;
      if (pl === "XY") rotatePlane(v,0,1,ang);
      if (pl === "XZ") rotatePlane(v,0,2,ang);
      if (pl === "XW") rotatePlane(v,0,3,ang);
      if (pl === "YZ") rotatePlane(v,1,2,ang);
      if (pl === "YW") rotatePlane(v,1,3,ang);
      if (pl === "ZW") rotatePlane(v,2,3,ang);
    }
    return v;
  }

  // 4D→3D projection (perspective from w, or orthographic)
  function project4to3(v) {
    const x=v[0], y=v[1], z=v[2], w=v[3];
    // Perspective: scale by (d4 / (d4 - w)) with d4 > |w|
    const denom = (d4 - w);
    const k = (denom !== 0) ? (d4 / denom) : 1e6;
    return [x*k, y*k, z*k];
  }

  // 3D→2D projection (perspective from z, or orthographic)
  function project3to2(p3) {
    const x=p3[0], y=p3[1], z=p3[2];
    if (!persp2D) return [x,y, z];
    const denom = (d3 - z);
    const k = (denom !== 0) ? (d3 / denom) : 1e6;
    return [x*k, y*k, z];
  }

  // estimate "inner vs outer" factor from w after rotation (for coloring)
  function innerFactorFromW(wVal) {
    // Map w in roughly [-something, +something] into [0..1]
    // When w is negative => further "inside"; positive => more "outside"
    return constrain((wVal + 2.0) / 4.0, 0, 1);
  }

  function setupUI() {
    ui.spd = document.getElementById("spd");
    ui.d4 = document.getElementById("d4");
    ui.d3 = document.getElementById("d3");
    ui.spdVal = document.getElementById("spdVal");
    ui.d4Val = document.getElementById("d4Val");
    ui.d3Val = document.getElementById("d3Val");
    ui.pauseBtn = document.getElementById("pauseBtn");
    ui.projBtn = document.getElementById("projBtn");
    ui.shadeBtn = document.getElementById("shadeBtn");
    ui.resetBtn = document.getElementById("resetBtn");
    ui.planesReadout = document.getElementById("planesReadout");

    ui.spd.addEventListener("input", () => {
      speedMul = parseFloat(ui.spd.value);
      ui.spdVal.textContent = speedMul.toFixed(2) + "×";
    });

    ui.d4.addEventListener("input", () => {
      d4 = parseFloat(ui.d4.value);
      ui.d4Val.textContent = d4.toFixed(2);
    });

    ui.d3.addEventListener("input", () => {
      d3 = parseFloat(ui.d3.value);
      ui.d3Val.textContent = d3.toFixed(2);
    });

    ui.pauseBtn.addEventListener("click", () => togglePause());
    ui.projBtn.addEventListener("click", () => toggleProjection());
    ui.shadeBtn.addEventListener("click", () => toggleShading());
    ui.resetBtn.addEventListener("click", () => resetAll());

    refreshPlaneReadout();
    ui.spdVal.textContent = speedMul.toFixed(2) + "×";
    ui.d4Val.textContent = d4.toFixed(2);
    ui.d3Val.textContent = d3.toFixed(2);
  }

  function refreshPlaneReadout() {
    ui.planesReadout.textContent = Array.from(active).join(" ") || "(none)";
  }

  function togglePlane(pl) {
    if (active.has(pl)) active.delete(pl);
    else active.add(pl);
    refreshPlaneReadout();
  }

  function togglePause() {
    running = !running;
    ui.pauseBtn.textContent = running ? "Pause" : "Resume";
  }

  function toggleProjection() {
    persp2D = !persp2D;
    ui.projBtn.textContent = "Projection: " + (persp2D ? "Perspective" : "Orthographic");
  }

  function toggleShading() {
    shading = !shading;
    ui.shadeBtn.textContent = "Shading: " + (shading ? "On" : "Off");
  }

  function resetAll() {
    running = true;
    persp2D = true;
    shading = true;
    speedMul = 1.0;
    d4 = 2.60;
    d3 = 3.20;
    active = new Set(["XY","XW","ZW"]);
    t = 0;
    extra.x = 0; extra.y = 0;

    ui.pauseBtn.textContent = "Pause";
    ui.projBtn.textContent = "Projection: Perspective";
    ui.shadeBtn.textContent = "Shading: On";
    ui.spd.value = speedMul;
    ui.d4.value = d4;
    ui.d3.value = d3;
    ui.spdVal.textContent = speedMul.toFixed(2) + "×";
    ui.d4Val.textContent = d4.toFixed(2);
    ui.d3Val.textContent = d3.toFixed(2);
    refreshPlaneReadout();
  }

  function setup() {
    createCanvas(window.innerWidth, window.innerHeight);
    pixelDensity(1);
    setupGeometry();
    setupUI();
  }

  function windowResized() {
    resizeCanvas(window.innerWidth, window.innerHeight);
  }

  function keyPressed() {
    if (key === ' ') togglePause();
    else if (key === 'O' || key === 'o') toggleProjection();
    else if (key === 'S' || key === 's') toggleShading();
    else if (key === 'R' || key === 'r') resetAll();
    else if (key === '[') { speedMul = max(0, speedMul - 0.05); ui.spd.value = speedMul; ui.spdVal.textContent = speedMul.toFixed(2) + "×"; }
    else if (key === ']') { speedMul = min(3, speedMul + 0.05); ui.spd.value = speedMul; ui.spdVal.textContent = speedMul.toFixed(2) + "×"; }
    else if (key === '-' || key === '_') { d4 = max(1.2, d4 - 0.05); ui.d4.value = d4; ui.d4Val.textContent = d4.toFixed(2); }
    else if (key === '+' || key === '=') { d4 = min(6.0, d4 + 0.05); ui.d4.value = d4; ui.d4Val.textContent = d4.toFixed(2); }
    else if (key === ',' ) { d3 = max(1.5, d3 - 0.05); ui.d3.value = d3; ui.d3Val.textContent = d3.toFixed(2); }
    else if (key === '.' ) { d3 = min(8.0, d3 + 0.05); ui.d3.value = d3; ui.d3Val.textContent = d3.toFixed(2); }
    else if (key === '1') togglePlane("XY");
    else if (key === '2') togglePlane("XZ");
    else if (key === '3') togglePlane("XW");
    else if (key === '4') togglePlane("YZ");
    else if (key === '5') togglePlane("YW");
    else if (key === '6') togglePlane("ZW");
  }

  function mouseDragged() {
    // add a subtle "manual" influence: horizontal affects XW, vertical affects YW
    const k = 0.0025;
    extra.x += movedX * k;
    extra.y += movedY * k;
    extra.x *= 0.98;
    extra.y *= 0.98;
  }

  function draw() {
    background(11, 15, 20);

    // time step
    const dt = deltaTime / 1000;
    if (running) t += dt * speedMul;

    // angles for each plane (mix in a couple of incommensurate rates)
    const angs = {
      XY: 0,
      XZ: 0,
      XW: 0,
      YZ: 0,
      YW: 0,
      ZW: 0
    };

    // base rates (radians/sec)
    const rates = {
      XY: 0.70,
      XZ: 0.53,
      XW: 0.93,
      YZ: 0.61,
      YW: 0.77,
      ZW: 0.89
    };

    for (const pl of active) {
      // smooth “always morphing” feel via slight modulation
      const mod = 1.0 + 0.18 * Math.sin(t * 0.7 + planeIdx[pl] * 1.3);
      angs[pl] = t * rates[pl] * mod;
    }

    // include mouse nudges
    if (active.has("XW")) angs.XW += extra.x;
    if (active.has("YW")) angs.YW += extra.y;

    // Project all vertices
    const verts2 = new Array(16);
    const verts3 = new Array(16);
    const wVals  = new Array(16);

    for (let i = 0; i < 16; i++) {
      const v = V4[i].slice();             // copy
      applyRotations(v, angs);
      wVals[i] = v[3];

      const p3 = project4to3(v);
      const p2 = project3to2(p3);
      verts3[i] = p3;
      verts2[i] = p2; // [x,y,z] where z is kept for depth cue
    }

    // Fit to screen: scale based on projected extents
    let minX=1e9, maxX=-1e9, minY=1e9, maxY=-1e9;
    for (const p of verts2) {
      minX = min(minX, p[0]); maxX = max(maxX, p[0]);
      minY = min(minY, p[1]); maxY = max(maxY, p[1]);
    }
    const spanX = max(1e-6, maxX - minX);
    const spanY = max(1e-6, maxY - minY);
    const scale = 0.42 * min(width / spanX, height / spanY);

    const cx = (minX + maxX) * 0.5;
    const cy = (minY + maxY) * 0.5;

    translate(width/2, height/2);
    // a little gentle breathing scale
    const breathe = 1.0 + 0.01 * Math.sin(t*0.8);
    scaleCanvas(scale * breathe);

    // Draw edges
    strokeCap(ROUND);
    noFill();

    // Determine depth range for shading
    let minZ=1e9, maxZ=-1e9;
    for (const p of verts2) { minZ = min(minZ, p[2]); maxZ = max(maxZ, p[2]); }
    const spanZ = max(1e-6, maxZ - minZ);

    // Subtle gradient: inner/outer by w and depth by z
    for (const [a,b] of edges) {
      const pa = verts2[a], pb = verts2[b];

      const za = (pa[2] - minZ) / spanZ;
      const zb = (pb[2] - minZ) / spanZ;
      const zMid = (za + zb) * 0.5;

      const wa = innerFactorFromW(wVals[a]);
      const wb = innerFactorFromW(wVals[b]);
      const wMid = (wa + wb) * 0.5;

      let alpha = 180;
      let sw = 1.35;

      if (shading) {
        // nearer edges brighter; also differentiate inner vs outer (w)
        alpha = 90 + 140 * (1.0 - zMid);
        sw = 0.85 + 1.55 * (0.35 + 0.65 * (1.0 - zMid));
      }

      // Color: outer edges slightly warmer, inner edges slightly cooler
      // (Still subtle to keep it "clean lines")
      const outerWarm = wMid; // 0..1
      const r = lerp(120, 245, outerWarm);
      const g = lerp(190, 235, 1.0 - 0.35*outerWarm);
      const bcol = lerp(255, 190, outerWarm);

      stroke(r, g, bcol, alpha);
      strokeWeight(sw);

      line(pa[0] - cx, pa[1] - cy, pb[0] - cx, pb[1] - cy);
    }

    // Optional: draw vertices faintly
    if (shading) {
      noStroke();
      for (let i = 0; i < 16; i++) {
        const p = verts2[i];
        const zNorm = (p[2] - minZ) / spanZ;
        const wNorm = innerFactorFromW(wVals[i]);
        const a = 40 + 80 * (1.0 - zNorm);
        const rr = lerp(120, 255, wNorm);
        const gg = lerp(210, 235, 1.0 - 0.25*wNorm);
        const bb = lerp(255, 200, wNorm);
        fill(rr, gg, bb, a);
        circle(p[0] - cx, p[1] - cy, 0.06);
      }
    }

    // Small caption bottom-right (kept minimal)
    resetMatrix();
    fill(220, 235, 255, 120);
    noStroke();
    textSize(12);
    textAlign(RIGHT, BOTTOM);
    text(`planes: ${Array.from(active).join(" ")}   |   ${persp2D ? "persp" : "ortho"}   |   d4=${d4.toFixed(2)} d3=${d3.toFixed(2)}`, width - 12, height - 12);
  }

  // p5.js has a function named scale(); but we used scaleCanvas to avoid confusion.
  function scaleCanvas(s) { scale(s); }

  </script>
</body>
</html>
