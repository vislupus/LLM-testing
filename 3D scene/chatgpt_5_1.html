<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>High-Poly Floating Island Castle Diorama - Babylon.js</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #b8f2ff 0%, #182848 65%, #0b1020 100%);
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            font-size: 18px;
            font-weight: 600;
            text-shadow: 0 2px 6px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 10;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
<div id="loading">Building floating islandâ€¦</div>
<canvas id="renderCanvas"></canvas>

<script>
window.addEventListener("DOMContentLoaded", function () {
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

    const createScene = function () {
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0, 0, 0, 0); // Transparent, shows CSS background

        // Short aliases
        const Vector3 = BABYLON.Vector3;
        const MeshBuilder = BABYLON.MeshBuilder;

        // Camera
        const camera = new BABYLON.ArcRotateCamera(
            "camera",
            -Math.PI / 3,
            Math.PI / 2.8,
            90,
            new Vector3(0, 8, 0),
            scene
        );
        camera.attachControl(canvas, true);
        camera.lowerRadiusLimit = 40;
        camera.upperRadiusLimit = 140;
        camera.wheelPrecision = 40;
        camera.panningSensibility = 0;
        camera.inertia = 0.85;

        camera.useAutoRotationBehavior = true;
        camera.autoRotationBehavior.idleRotationSpeed = 0.1;

        // Lights
        const hemi = new BABYLON.HemisphericLight("hemi", new Vector3(0, 1, 0), scene);
        hemi.intensity = 0.7;
        hemi.groundColor = new BABYLON.Color3(0.25, 0.2, 0.25);

        const sun = new BABYLON.DirectionalLight("sun", new Vector3(-0.5, -1, -0.6), scene);
        sun.position = new Vector3(50, 80, 40);
        sun.intensity = 1.2;

        // Shadows
        const shadowGen = new BABYLON.ShadowGenerator(2048, sun);
        shadowGen.useBlurExponentialShadowMap = true;
        shadowGen.blurKernel = 32;
        shadowGen.bias = 0.00015;

        // Post-process pipeline (soft, vibrant miniature look)
        const pipeline = new BABYLON.DefaultRenderingPipeline("default", true, scene, [camera]);
        pipeline.samples = 4; // MSAA
        pipeline.fxaaEnabled = true;
        pipeline.imageProcessing.toneMappingEnabled = true;
        pipeline.imageProcessing.exposure = 1.15;
        pipeline.imageProcessing.contrast = 1.2;
        pipeline.bloomEnabled = true;
        pipeline.bloomThreshold = 0.9;
        pipeline.bloomWeight = 0.35;
        pipeline.bloomKernel = 32;
        pipeline.bloomScale = 0.5;

        // Root for island (so we can float/rotate it)
        const islandRoot = new BABYLON.TransformNode("islandRoot", scene);

        // Materials
        const createMat = (name, color, spec) => {
            const m = new BABYLON.StandardMaterial(name, scene);
            m.diffuseColor = color;
            m.specularColor = spec || new BABYLON.Color3(0.12, 0.12, 0.12);
            return m;
        };

        const matGrass     = createMat("grass", new BABYLON.Color3(0.30, 0.75, 0.33));
        const matGrassDark = createMat("grassDark", new BABYLON.Color3(0.23, 0.63, 0.27));
        const matCliff     = createMat("cliff", new BABYLON.Color3(0.42, 0.38, 0.34));
        const matWater     = createMat("water", new BABYLON.Color3(0.0, 0.85, 0.9), new BABYLON.Color3(0.8, 0.8, 0.9));
        matWater.alpha = 0.88;

        const matSea       = createMat("sea", new BABYLON.Color3(0.05, 0.45, 0.75), new BABYLON.Color3(0.2, 0.25, 0.3));
        matSea.alpha = 0.99;

        const matWood      = createMat("wood", new BABYLON.Color3(0.45, 0.29, 0.18));
        const matLightWood = createMat("lightWood", new BABYLON.Color3(0.72, 0.52, 0.32));
        const matStone     = createMat("stone", new BABYLON.Color3(0.68, 0.68, 0.74));
        const matStoneDark = createMat("stoneDark", new BABYLON.Color3(0.5, 0.52, 0.58));
        const matRoofRed   = createMat("roofRed", new BABYLON.Color3(0.80, 0.2, 0.2));
        const matRoofBrown = createMat("roofBrown", new BABYLON.Color3(0.55, 0.32, 0.18));
        const matRoofGray  = createMat("roofGray", new BABYLON.Color3(0.7, 0.7, 0.75));
        const matFoliage   = createMat("foliage", new BABYLON.Color3(0.18, 0.52, 0.30));
        const matCanopy1   = createMat("canopy1", new BABYLON.Color3(0.9, 0.7, 0.3));
        const matCanopy2   = createMat("canopy2", new BABYLON.Color3(0.6, 0.4, 0.9));

        // Sea below
        const sea = MeshBuilder.CreateGround("sea", { width: 300, height: 300, subdivisions: 1 }, scene);
        sea.position.y = -14;
        sea.material = matSea;
        sea.receiveShadows = true;

        // River path
        const riverY = 2.8;
        const riverPath = [];
        const riverSteps = 80;
        const riverLength = 44;
        const startZ = -riverLength / 2;
        const amplitudeX = 10;

        for (let i = 0; i < riverSteps; i++) {
            const t = i / (riverSteps - 1);
            const z = startZ + t * riverLength;
            const x = Math.sin(z * 0.23) * amplitudeX;
            riverPath.push(new Vector3(x, riverY, z));
        }

        // Island body via CSG
        const islandRadius = 26;
        const groundThickness = 3;
        const cliffHeight = 14;
        const groundTopY = 4; // walking surface

        const groundBase = MeshBuilder.CreateCylinder("groundBase", {
            diameter: islandRadius * 2,
            height: groundThickness,
            tessellation: 64
        }, scene);
        groundBase.position.y = groundTopY - groundThickness / 2;

        const cliffBase = MeshBuilder.CreateCylinder("cliffBase", {
            height: cliffHeight,
            diameterTop: islandRadius * 2,
            diameterBottom: islandRadius * 1.4 * 2,
            tessellation: 64
        }, scene);
        cliffBase.position.y = groundBase.position.y - groundThickness / 2 - cliffHeight / 2 + 0.2;

        const riverCutter = MeshBuilder.CreateTube("riverCutter", {
            path: riverPath,
            radius: 3.2,
            tessellation: 24,
            sideOrientation: BABYLON.Mesh.DOUBLESIDE,
            cap: BABYLON.Mesh.CAP_ALL
        }, scene);

        // Perform CSG operations
        const groundCSG = BABYLON.CSG.FromMesh(groundBase);
        const cliffCSG = BABYLON.CSG.FromMesh(cliffBase);
        const cutterCSG = BABYLON.CSG.FromMesh(riverCutter);

        const grassCSG = groundCSG.subtract(cutterCSG);
        const cliffResultCSG = cliffCSG.subtract(cutterCSG);

        const grassMesh = grassCSG.toMesh("islandGrass", matGrass, scene);
        const cliffMesh = cliffResultCSG.toMesh("islandCliff", matCliff, scene);

        grassMesh.parent = islandRoot;
        cliffMesh.parent = islandRoot;

        grassMesh.receiveShadows = true;
        cliffMesh.receiveShadows = true;
        shadowGen.addShadowCaster(grassMesh);
        shadowGen.addShadowCaster(cliffMesh);

        // Add some jaggedness to cliffs for realism
        (function jiggleCliffs(mesh) {
            mesh.convertToFlatShadedMesh();
            const positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            const centerY = cliffBase.position.y;
            for (let i = 0; i < positions.length; i += 3) {
                const y = positions[i + 1];
                if (y < groundTopY - 0.5) {
                    const x = positions[i];
                    const z = positions[i + 2];
                    const radius = Math.sqrt(x * x + z * z) || 1;
                    const noise = (Math.random() - 0.5) * 0.4;
                    const factor = 1 + noise * ((groundTopY - y) / cliffHeight + 0.3);
                    positions[i] = (x / radius) * radius * factor;
                    positions[i + 2] = (z / radius) * radius * factor;
                }
            }
            mesh.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
            mesh.refreshBoundingInfo();
        })(cliffMesh);

        grassMesh.convertToFlatShadedMesh();

        groundBase.dispose();
        cliffBase.dispose();
        riverCutter.dispose();

        // River water (tube)
        const waterMesh = MeshBuilder.CreateTube("riverWater", {
            path: riverPath,
            radius: 2.3,
            tessellation: 24,
            sideOrientation: BABYLON.Mesh.DOUBLESIDE,
            cap: BABYLON.Mesh.CAP_ALL
        }, scene);
        waterMesh.material = matWater;
        waterMesh.parent = islandRoot;
        waterMesh.position.y = 0; // path already has Y
        waterMesh.scaling.y = 0.3; // flatter
        waterMesh.receiveShadows = false;

        // Plateau for castle, centered
        const plateauRoot = new BABYLON.TransformNode("plateauRoot", scene);
        plateauRoot.parent = islandRoot;
        plateauRoot.position = new Vector3(0, groundTopY, 0);

        const plateauHeight = 1.3;
        const plateau = MeshBuilder.CreateCylinder("plateau", {
            height: plateauHeight,
            diameter: 18,
            tessellation: 48
        }, scene);
        plateau.material = matGrassDark;
        plateau.parent = plateauRoot;
        plateau.position.y = plateauHeight / 2;
        plateau.convertToFlatShadedMesh();
        plateau.receiveShadows = true;
        shadowGen.addShadowCaster(plateau);

        const plateauTopYLocal = plateauHeight; // local inside plateauRoot

        // Large medieval stone castle at center
        function createCastle(root) {
            const castleRoot = new BABYLON.TransformNode("castleRoot", scene);
            castleRoot.parent = root;
            castleRoot.position = new Vector3(0, plateauTopYLocal, 0);

            // Central keep
            const keepHeight = 9;
            const keep = MeshBuilder.CreateBox("keep", {
                width: 6.5, depth: 6.5, height: keepHeight
            }, scene);
            keep.parent = castleRoot;
            keep.position.y = keepHeight / 2;
            keep.material = matStone;
            keep.convertToFlatShadedMesh();
            keep.receiveShadows = true;
            shadowGen.addShadowCaster(keep);

            // Keep battlements (simple crenellations ring)
            const merlonCount = 12;
            const merlonRadius = 3.6;
            for (let i = 0; i < merlonCount; i++) {
                const angle = (i / merlonCount) * Math.PI * 2;
                const mx = Math.cos(angle) * merlonRadius;
                const mz = Math.sin(angle) * merlonRadius;
                const merlon = MeshBuilder.CreateBox("merlon", {
                    width: 0.7, depth: 0.7, height: 0.6
                }, scene);
                merlon.parent = castleRoot;
                merlon.position = new Vector3(mx, keepHeight + 0.3, mz);
                merlon.material = matStoneDark;
                merlon.convertToFlatShadedMesh();
                shadowGen.addShadowCaster(merlon);
            }

            // Tall central round tower with conical roof
            const tallTowerHeight = 7;
            const tallTower = MeshBuilder.CreateCylinder("tallTower", {
                height: tallTowerHeight,
                diameter: 3,
                tessellation: 32
            }, scene);
            tallTower.parent = castleRoot;
            tallTower.position.y = keepHeight + tallTowerHeight / 2 - 0.5;
            tallTower.material = matStoneDark;
            tallTower.convertToFlatShadedMesh();
            shadowGen.addShadowCaster(tallTower);

            const tallRoof = MeshBuilder.CreateCylinder("tallRoof", {
                height: 3,
                diameterTop: 0,
                diameterBottom: 4,
                tessellation: 32
            }, scene);
            tallRoof.parent = castleRoot;
            tallRoof.position.y = keepHeight + tallTowerHeight + 1.5;
            tallRoof.material = matRoofGray;
            tallRoof.convertToFlatShadedMesh();
            shadowGen.addShadowCaster(tallRoof);

            // Four corner towers with conical roofs
            const cornerOffset = 5;
            const cornerTowerHeight = 4.5;
            function createCornerTower(dx, dz) {
                const tower = MeshBuilder.CreateCylinder("cornerTower", {
                    height: cornerTowerHeight,
                    diameter: 2.2,
                    tessellation: 24
                }, scene);
                tower.parent = castleRoot;
                tower.position = new Vector3(dx, cornerTowerHeight / 2 + 1, dz);
                tower.material = matStone;
                tower.convertToFlatShadedMesh();
                shadowGen.addShadowCaster(tower);

                const roof = MeshBuilder.CreateCylinder("cornerRoof", {
                    height: 2.3,
                    diameterTop: 0,
                    diameterBottom: 2.8,
                    tessellation: 24
                }, scene);
                roof.parent = castleRoot;
                roof.position = new Vector3(dx, cornerTowerHeight + 1 + 1.15, dz);
                roof.material = matRoofBrown;
                roof.convertToFlatShadedMesh();
                shadowGen.addShadowCaster(roof);
            }
            createCornerTower( cornerOffset,  cornerOffset);
            createCornerTower(-cornerOffset,  cornerOffset);
            createCornerTower( cornerOffset, -cornerOffset);
            createCornerTower(-cornerOffset, -cornerOffset);

            // Square curtain walls connecting towers
            const wallHeight = 4;
            const wallThickness = 1;
            const wallLength = cornerOffset * 2 + 1;
            function createWall(position, rotationY) {
                const wall = MeshBuilder.CreateBox("castleWall", {
                    width: wallLength,
                    height: wallHeight,
                    depth: wallThickness
                }, scene);
                wall.parent = castleRoot;
                wall.position = position;
                wall.rotation.y = rotationY;
                wall.material = matStoneDark;
                wall.convertToFlatShadedMesh();
                shadowGen.addShadowCaster(wall);
            }
            createWall(new Vector3(0, wallHeight / 2 + 1, -cornerOffset), 0);
            createWall(new Vector3(0, wallHeight / 2 + 1,  cornerOffset), 0);
            createWall(new Vector3(-cornerOffset, wallHeight / 2 + 1, 0), Math.PI / 2);
            createWall(new Vector3( cornerOffset, wallHeight / 2 + 1, 0), Math.PI / 2);

            // Gatehouse facing roughly towards negative Z
            const gate = MeshBuilder.CreateBox("gatehouse", {
                width: 4,
                height: 4.2,
                depth: 2
            }, scene);
            gate.parent = castleRoot;
            gate.position = new Vector3(0, 2.1 + 1, -cornerOffset - 1.2);
            gate.material = matStoneDark;
            gate.convertToFlatShadedMesh();
            shadowGen.addShadowCaster(gate);

            return castleRoot;
        }
        createCastle(plateauRoot);

        // Village helpers
        const buildingCenters = []; // store ground-level x,z to keep trees away

        function addBuildingCenter(x, z) {
            buildingCenters.push(new Vector3(x, 0, z));
        }

        function createHouse(position, roofMat, scale) {
            const root = new BABYLON.TransformNode("houseRoot", scene);
            root.parent = islandRoot;
            root.position = new Vector3(position.x, groundTopY, position.z);
            root.scaling.scaleInPlace(scale || 1);

            const body = MeshBuilder.CreateBox("houseBody", {
                width: 3,
                height: 1.8,
                depth: 2.3
            }, scene);
            body.parent = root;
            body.position.y = 0.9;
            body.material = matWood;
            body.convertToFlatShadedMesh();
            body.receiveShadows = true;
            shadowGen.addShadowCaster(body);

            const roof = MeshBuilder.CreateCylinder("houseRoof", {
                height: 3.2,
                diameterTop: 0,
                diameterBottom: 3.2,
                tessellation: 4
            }, scene);
            roof.parent = root;
            roof.position.y = 2.3;
            roof.rotation.z = Math.PI / 2;
            roof.material = roofMat;
            roof.convertToFlatShadedMesh();
            shadowGen.addShadowCaster(roof);

            addBuildingCenter(position.x, position.z);
            return root;
        }

        function createTavern(position) {
            const root = new BABYLON.TransformNode("tavernRoot", scene);
            root.parent = islandRoot;
            root.position = new Vector3(position.x, groundTopY, position.z);

            const body = MeshBuilder.CreateBox("tavernBody", {
                width: 5,
                height: 2.3,
                depth: 3.5
            }, scene);
            body.parent = root;
            body.position.y = 1.15;
            body.material = matWood;
            body.convertToFlatShadedMesh();
            body.receiveShadows = true;
            shadowGen.addShadowCaster(body);

            const roof = MeshBuilder.CreateCylinder("tavernRoof", {
                height: 5.2,
                diameterTop: 3.8,
                diameterBottom: 3.8,
                tessellation: 4
            }, scene);
            roof.parent = root;
            roof.rotation.z = Math.PI / 2;
            roof.position.y = 3.0;
            roof.material = matRoofRed;
            roof.convertToFlatShadedMesh();
            shadowGen.addShadowCaster(roof);

            // Simple sign
            const signPost = MeshBuilder.CreateBox("tavernSignPost", {
                width: 0.1, height: 1.3, depth: 0.1
            }, scene);
            signPost.parent = root;
            signPost.position = new Vector3(2.6, 1.0, 1.8);
            signPost.material = matLightWood;
            shadowGen.addShadowCaster(signPost);

            const sign = MeshBuilder.CreatePlane("tavernSign", {
                width: 1.4,
                height: 0.9
            }, scene);
            sign.parent = root;
            sign.position = new Vector3(3.0, 1.4, 1.8);
            sign.rotation.y = Math.PI / 2;
            sign.material = matWood;
            shadowGen.addShadowCaster(sign);

            addBuildingCenter(position.x, position.z);
            return root;
        }

        function createMarketStall(position, rotationY, canopyMat) {
            const root = new BABYLON.TransformNode("stallRoot", scene);
            root.parent = islandRoot;
            root.position = new Vector3(position.x, groundTopY, position.z);
            root.rotation.y = rotationY || 0;

            const table = MeshBuilder.CreateBox("stallTable", {
                width: 2.5,
                height: 0.25,
                depth: 1.2
            }, scene);
            table.parent = root;
            table.position.y = 0.7;
            table.material = matLightWood;
            table.receiveShadows = true;
            shadowGen.addShadowCaster(table);

            const roof = MeshBuilder.CreateBox("stallRoof", {
                width: 2.6,
                height: 0.1,
                depth: 1.4
            }, scene);
            roof.parent = root;
            roof.position.y = 1.6;
            roof.material = canopyMat;
            roof.receiveShadows = true;
            shadowGen.addShadowCaster(roof);

            // Side posts
            for (let sx of [-1.1, 1.1]) {
                const postFront = MeshBuilder.CreateCylinder("stallPostF", {
                    height: 1.6,
                    diameter: 0.08,
                    tessellation: 8
                }, scene);
                postFront.parent = root;
                postFront.position = new Vector3(sx, 0.8, 0.5);
                postFront.material = matWood;
                shadowGen.addShadowCaster(postFront);

                const postBack = postFront.clone("stallPostB");
                postBack.position.z = -0.5;
            }

            // Crates
            const crate = MeshBuilder.CreateBox("crate", {
                size: 0.6
            }, scene);
            crate.parent = root;
            crate.position = new Vector3(0.3, 0.3, -0.7);
            crate.material = matWood;
            shadowGen.addShadowCaster(crate);

            const crate2 = crate.clone("crate2");
            crate2.position = new Vector3(-0.5, 0.3, 0.7);

            addBuildingCenter(position.x, position.z);
            return root;
        }

        // Riverside watermill
        function createMillAlongRiver(index) {
            const pathIndex = Math.max(2, Math.min(riverPath.length - 3, index));
            const centerPoint = riverPath[pathIndex];
            const prev = riverPath[pathIndex - 1];
            const next = riverPath[pathIndex + 1];
            const tangent = next.subtract(prev).normalize();
            const normal = new Vector3(-tangent.z, 0, tangent.x); // perpendicular

            const millRoot = new BABYLON.TransformNode("millRoot", scene);
            millRoot.parent = islandRoot;

            const buildingOffset = normal.scale(5);
            const buildingPos = centerPoint.add(buildingOffset);
            millRoot.position = new Vector3(buildingPos.x, groundTopY, buildingPos.z);

            // Mill building
            const body = MeshBuilder.CreateBox("millBody", {
                width: 3.2,
                height: 2.2,
                depth: 2.8
            }, scene);
            body.parent = millRoot;
            body.position.y = 1.1;
            body.material = matWood;
            body.convertToFlatShadedMesh();
            body.receiveShadows = true;
            shadowGen.addShadowCaster(body);

            const roof = MeshBuilder.CreateCylinder("millRoof", {
                height: 4,
                diameterTop: 0,
                diameterBottom: 3.4,
                tessellation: 4
            }, scene);
            roof.parent = millRoot;
            roof.rotation.z = Math.PI / 2;
            roof.position.y = 2.6;
            roof.material = matRoofBrown;
            roof.convertToFlatShadedMesh();
            shadowGen.addShadowCaster(roof);

            // Waterwheel
            const wheelRoot = new BABYLON.TransformNode("wheelRoot", scene);
            wheelRoot.parent = islandRoot;

            const wheelPos = centerPoint.add(normal.scale(2.3));
            wheelRoot.position = new Vector3(wheelPos.x, riverY + 1.0, wheelPos.z);

            const wheel = MeshBuilder.CreateTorus("millWheel", {
                diameter: 3,
                thickness: 0.25,
                tessellation: 32
            }, scene);
            wheel.parent = wheelRoot;
            wheel.rotation.z = Math.PI / 2;
            wheel.material = matWood;
            wheel.convertToFlatShadedMesh();
            shadowGen.addShadowCaster(wheel);

            // Paddles
            const paddleCount = 12;
            for (let i = 0; i < paddleCount; i++) {
                const angle = (i / paddleCount) * Math.PI * 2;
                const px = Math.cos(angle) * 1.3;
                const py = Math.sin(angle) * 1.3;

                const paddle = MeshBuilder.CreateBox("millPaddle", {
                    width: 0.15,
                    height: 1.0,
                    depth: 0.4
                }, scene);
                paddle.parent = wheelRoot;
                paddle.position = new Vector3(px, py, 0);
                paddle.rotation.z = angle;
                paddle.material = matLightWood;
                shadowGen.addShadowCaster(paddle);
            }

            // Rotate wheel slowly
            scene.onBeforeRenderObservable.add(() => {
                const dt = scene.getEngine().getDeltaTime() * 0.001;
                wheelRoot.rotation.x += dt * 0.7;
            });

            addBuildingCenter(buildingPos.x, buildingPos.z);
        }

        // Ruined stone watchtower at cliff edge
        function createRuinedWatchtower(position) {
            const baseHeight = 5;
            const base = MeshBuilder.CreateCylinder("ruinBase", {
                height: baseHeight,
                diameter: 3,
                tessellation: 32
            }, scene);
            base.position = new Vector3(position.x, groundTopY + baseHeight / 2, position.z);
            base.parent = islandRoot;

            const breaker = MeshBuilder.CreateBox("ruinBreaker", {
                width: 4,
                height: 3,
                depth: 4
            }, scene);
            breaker.position = new Vector3(position.x + 1.5, groundTopY + baseHeight, position.z + 0.5);
            breaker.rotation = new BABYLON.Vector3(Math.PI / 5, Math.PI / 5, 0);
            breaker.parent = islandRoot;

            const ruinCSG = BABYLON.CSG.FromMesh(base).subtract(BABYLON.CSG.FromMesh(breaker));
            const ruin = ruinCSG.toMesh("ruinedTower", matStone, scene);
            ruin.parent = islandRoot;
            ruin.convertToFlatShadedMesh();
            ruin.receiveShadows = true;
            shadowGen.addShadowCaster(ruin);

            base.dispose();
            breaker.dispose();

            // Rubble around
            for (let i = 0; i < 6; i++) {
                const rock = MeshBuilder.CreatePolyhedron("rubble", {
                    type: 1,
                    size: 0.5
                }, scene);
                const rx = position.x + (Math.random() - 0.5) * 3;
                const rz = position.z + (Math.random() - 0.5) * 3;
                rock.position = new Vector3(rx, groundTopY + 0.25, rz);
                rock.parent = islandRoot;
                rock.material = matStoneDark;
                rock.receiveShadows = true;
                shadowGen.addShadowCaster(rock);
            }

            addBuildingCenter(position.x, position.z);
        }

        // Wooden bridges over river
        function createBridgeAtSegment(segIndex) {
            const i = Math.max(0, Math.min(riverPath.length - 2, segIndex));
            const p0 = riverPath[i];
            const p1 = riverPath[i + 1];
            const mid = p0.add(p1).scale(0.5);
            const dir = p1.subtract(p0);
            const angle = Math.atan2(dir.z, dir.x) + Math.PI / 2;

            const root = new BABYLON.TransformNode("bridgeRoot", scene);
            root.parent = islandRoot;
            root.position = new Vector3(mid.x, riverY + 0.8, mid.z);
            root.rotation.y = angle;

            const deck = MeshBuilder.CreateBox("bridgeDeck", {
                width: 5,
                height: 0.25,
                depth: 1.6
            }, scene);
            deck.parent = root;
            deck.position.y = 0;
            deck.material = matLightWood;
            deck.convertToFlatShadedMesh();
            deck.receiveShadows = true;
            shadowGen.addShadowCaster(deck);

            // Posts
            const postHeight = 1.0;
            const createPost = (x, z) => {
                const post = MeshBuilder.CreateCylinder("bridgePost", {
                    height: postHeight,
                    diameter: 0.15,
                    tessellation: 8
                }, scene);
                post.parent = root;
                post.position = new Vector3(x, postHeight / 2 + 0.125, z);
                post.material = matWood;
                post.receiveShadows = true;
                shadowGen.addShadowCaster(post);
            };
            createPost(-2.2,  0.6);
            createPost( 2.2,  0.6);
            createPost(-2.2, -0.6);
            createPost( 2.2, -0.6);
        }

        // Pine trees
        function createPineTree(pos, scale) {
            const root = new BABYLON.TransformNode("pineRoot", scene);
            root.parent = islandRoot;
            root.position = new Vector3(pos.x, groundTopY, pos.z);
            root.scaling.scaleInPlace(scale || 1);

            const trunkHeight = 1.6;
            const trunk = MeshBuilder.CreateCylinder("trunk", {
                height: trunkHeight,
                diameter: 0.45,
                tessellation: 12
            }, scene);
            trunk.parent = root;
            trunk.position.y = trunkHeight / 2;
            trunk.material = matWood;
            trunk.convertToFlatShadedMesh();
            trunk.receiveShadows = true;
            shadowGen.addShadowCaster(trunk);

            const levels = 4;
            for (let i = 0; i < levels; i++) {
                const h = 1.4;
                const r = 1.5 - i * 0.3;
                const cone = MeshBuilder.CreateCylinder("foliage", {
                    height: h,
                    diameterTop: 0,
                    diameterBottom: r,
                    tessellation: 20
                }, scene);
                cone.parent = root;
                cone.position.y = trunkHeight + h / 2 + i * 0.7;
                cone.material = matFoliage;
                cone.convertToFlatShadedMesh();
                cone.receiveShadows = true;
                shadowGen.addShadowCaster(cone);
            }
        }

        // Waterfalls
        function createWaterfallAt(pathIndex) {
            const p = riverPath[pathIndex];
            const emitterNode = new BABYLON.TransformNode("waterfallEmitter", scene);
            emitterNode.parent = islandRoot;
            emitterNode.position = new Vector3(p.x, p.y, p.z);

            const ps = new BABYLON.ParticleSystem("waterfallPS", 1500, scene);
            ps.particleTexture = new BABYLON.Texture("https://cdn.babylonjs.com/assets/flare.png", scene);
            ps.emitter = emitterNode;

            ps.minEmitBox = new Vector3(-1.2, 0, -0.6);
            ps.maxEmitBox = new Vector3( 1.2, 0,  0.6);

            ps.color1 = new BABYLON.Color4(0.9, 0.97, 1.0, 1.0);
            ps.color2 = new BABYLON.Color4(0.3, 0.7, 1.0, 1.0);
            ps.colorDead = new BABYLON.Color4(0, 0.2, 0.5, 0);

            ps.minSize = 0.25;
            ps.maxSize = 0.8;
            ps.minLifeTime = 1.1;
            ps.maxLifeTime = 1.6;
            ps.emitRate = 400;

            ps.gravity = new Vector3(0, -9.81, 0);
            ps.direction1 = new Vector3(0, -1.4, 0);
            ps.direction2 = new Vector3(0, -1.0, 0);

            ps.minAngularSpeed = 0;
            ps.maxAngularSpeed = 0.5;
            ps.minEmitPower = 5;
            ps.maxEmitPower = 8;
            ps.updateSpeed = 0.02;

            ps.start();
        }

        // Place waterfalls at river ends
        createWaterfallAt(2);
        createWaterfallAt(riverPath.length - 3);

        // Bridges
        createBridgeAtSegment(Math.floor(riverPath.length * 0.30));
        createBridgeAtSegment(Math.floor(riverPath.length * 0.62));

        // Riverside mill (roughly first third of river)
        createMillAlongRiver(Math.floor(riverPath.length * 0.25));

        // Ruined watchtower on outer cliff edge
        createRuinedWatchtower(new Vector3(18, 0, -16));

        // Cozy medieval village around castle
        // Houses
        createHouse(new Vector3(-15, 0,  4), matRoofRed,   1.05);
        createHouse(new Vector3(-14, 0, -6), matRoofBrown, 1.0);
        createHouse(new Vector3(-10, 0, 11), matRoofRed,   0.95);
        createHouse(new Vector3( -4, 0, 13), matRoofBrown, 1.1);
        createHouse(new Vector3(  5, 0, 13), matRoofRed,   1.0);
        createHouse(new Vector3( 11, 0,  9), matRoofBrown, 1.05);

        // Tavern near center of village
        createTavern(new Vector3(-11, 0, 1));

        // Market stalls in small plaza
        createMarketStall(new Vector3(-8, 0, 4),  Math.PI / 6, matCanopy1);
        createMarketStall(new Vector3(-7, 0, -1), -Math.PI / 4, matCanopy2);
        createMarketStall(new Vector3(-10,0, -4), Math.PI / 3, matCanopy1);

        // Tree scattering (avoid river, plateau, buildings)
        function isPositionFree(x, z) {
            const r = Math.sqrt(x * x + z * z);
            if (r < 9) return false; // keep castle plateau clear

            // Avoid buildings
            for (const c of buildingCenters) {
                const dx = x - c.x;
                const dz = z - c.z;
                if (Math.sqrt(dx * dx + dz * dz) < 4) return false;
            }

            // Avoid river
            for (let i = 0; i < riverPath.length; i += 4) {
                const p = riverPath[i];
                const dx = x - p.x;
                const dz = z - p.z;
                if (Math.sqrt(dx * dx + dz * dz) < 4) return false;
            }
            return true;
        }

        for (let i = 0; i < 60; i++) {
            const radius = 8 + Math.random() * (islandRadius - 4 - 8);
            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            if (!isPositionFree(x, z)) continue;
            const scale = 0.8 + Math.random() * 0.6;
            createPineTree(new Vector3(x, 0, z), scale);
        }

        // Gentle island floating animation
        let t = 0;
        scene.onBeforeRenderObservable.add(() => {
            const dt = scene.getEngine().getDeltaTime() * 0.001;
            t += dt;
            islandRoot.rotation.y = t * 0.12;
            islandRoot.position.y = Math.sin(t * 0.6) * 0.5;
        });

        document.getElementById("loading").style.display = "none";
        return scene;
    };

    const scene = createScene();

    engine.runRenderLoop(function () {
        scene.render();
    });

    window.addEventListener("resize", function () {
        engine.resize();
    });
});
</script>
</body>
</html>