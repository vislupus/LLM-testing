<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Floating Island Medieval Diorama - Babylon.js Standalone</title>
    <style>
        html, body { overflow: hidden; width: 100%; height: 100%; margin: 0; padding: 0; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
</script>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

    const createScene = function () {
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0.75, 0.85, 0.95, 1.0);

        // Soft vibrant lighting
        const hemiLight = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
        hemiLight.intensity = 0.85;
        hemiLight.diffuse = new BABYLON.Color3(0.9, 0.95, 1);

        const dirLight = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-1, -1.5, -1), scene);
        dirLight.intensity = 0.6;

        const shadowGenerator = new BABYLON.ShadowGenerator(2048, dirLight);
        shadowGenerator.bias = 0.0001;
        shadowGenerator.normalBias = 0.02;
        shadowGenerator.useBlurExponentialShadowMap = true;
        shadowGenerator.blurScale = 2;

        // Camera
        const camera = new BABYLON.ArcRotateCamera("cam", -Math.PI / 2, Math.PI / 3.2, 140, new BABYLON.Vector3(0, 15, 0), scene);
        camera.lowerRadiusLimit = 30;
        camera.upperRadiusLimit = 260;
        camera.wheelPrecision = 10;
        camera.attachControl(canvas, true);

        // Materials - vibrant stylized colors, matte/miniature look
        const grassMat = new BABYLON.StandardMaterial("grass", scene);
        grassMat.diffuseColor = new BABYLON.Color3(0.35, 0.9, 0.35);
        grassMat.specularColor = BABYLON.Color3.Black();

        const rockMat = new BABYLON.StandardMaterial("rock", scene);
        rockMat.diffuseColor = new BABYLON.Color3(0.55, 0.52, 0.48);
        rockMat.specularColor = BABYLON.Color3.Black();

        const stoneMat = new BABYLON.StandardMaterial("stone", scene);
        stoneMat.diffuseColor = new BABYLON.Color3(0.68, 0.68, 0.75);
        stoneMat.specularColor = BABYLON.Color3.Black();

        const woodMat = new BABYLON.StandardMaterial("wood", scene);
        woodMat.diffuseColor = new BABYLON.Color3(0.75, 0.55, 0.35);
        woodMat.specularColor = BABYLON.Color3.Black();

        const roofMat = new BABYLON.StandardMaterial("roof", scene);
        roofMat.diffuseColor = new BABYLON.Color3(0.85, 0.25, 0.25); // vibrant red
        roofMat.specularColor = BABYLON.Color3.Black();

        const waterMat = new BABYLON.StandardMaterial("water", scene);
        waterMat.diffuseColor = new BABYLON.Color3(0.15, 0.85, 0.9);
        waterMat.alpha = 0.65;
        waterMat.specularColor = new BABYLON.Color3(1, 1, 1);
        waterMat.specularPower = 64;

        // ───── Floating Island Terrain ─────
        const islandSize = 120;
        const maxRadius = islandSize / 2;
        const islandTop = BABYLON.MeshBuilder.CreateGround("islandTop", { width: islandSize, height: islandSize, subdivisions: 200, updatable: true }, scene);

        const positions = islandTop.getVerticesData(BABYLON.VertexBuffer.PositionKind);
        for (let i = 0; i < positions.length; i += 3) {
            const x = positions[i];
            const z = positions[i + 2];
            const dist = Math.hypot(x, z);
            const normalized = dist / maxRadius;

            if (normalized > 1.0) {
                positions[i + 1] = -100; // sink far vertices
            } else {
                let h = 18 * Math.pow(1 - normalized, 1.8); // higher center, softer drop
                h += 6 * Math.sin(x * 0.09 + 3.7) * Math.cos(z * 0.09);
                h += 4 * Math.sin(x * 0.18) * Math.cos(z * 0.18 + 1.3);
                h += 2 * Math.sin(x * 0.35) * Math.cos(z * 0.35 + 7.1);
                positions[i + 1] = h;
            }
        }
        islandTop.setVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
        islandTop.material = grassMat;
        islandTop.receiveShadows = true;

        // Bottom rocky part (inverted copy)
        const islandBottom = islandTop.clone("islandBottom");
        islandBottom.material = rockMat;
        islandBottom.scaling.y = -1.1; // slightly larger for rocky overhang
        islandBottom.position.y = -8;
        islandBottom.flipFaces(true);
        islandBottom.receiveShadows = true;

        function getTerrainHeight(x, z) {
            const dist = Math.hypot(x, z);
            const normalized = dist / maxRadius;
            if (normalized > 1.0) return -100;
            let h = 18 * Math.pow(1 - normalized, 1.8);
            h += 6 * Math.sin(x * 0.09 + 3.7) * Math.cos(z * 0.09);
            h += 4 * Math.sin(x * 0.18) * Math.cos(z * 0.18 + 1.3);
            h += 2 * Math.sin(x * 0.35) * Math.cos(z * 0.35 + 7.1);
            return h;
        }

        // ───── Castle at center ─────
        const castleBaseY = getTerrainHeight(0, 0) + 2;
        const keep = BABYLON.MeshBuilder.CreateCylinder("keep", { height: 34, diameter: 22, tessellation: 24 }, scene);
        keep.position = new BABYLON.Vector3(0, castleBaseY + 17, 0);
        keep.material = stoneMat;
        shadowGenerator.addShadowCaster(keep);

        const keepRoof = BABYLON.MeshBuilder.CreateCylinder("keepRoof", { height: 12, diameterTop: 0, diameterBottom: 28, tessellation: 24 }, scene);
        keepRoof.position.y = castleBaseY + 34 + 6;
        keepRoof.material = roofMat;
        shadowGenerator.addShadowCaster(keepRoof);

        // Four corner towers
        const towerPositions = [[-24, -24], [24, -24], [-24, 24], [24, 24]];
        towerPositions.forEach((pos, i) => {
            const y = getTerrainHeight(pos[0], pos[1]) + 2;
            const tower = BABYLON.MeshBuilder.CreateCylinder(`tower${i}`, { height: 28, diameter: 14, tessellation: 20 }, scene);
            tower.position = new BABYLON.Vector3(pos[0], y + 14, pos[1]);
            tower.material = stoneMat;
            shadowGenerator.addShadowCaster(tower);

            const tRoof = BABYLON.MeshBuilder.CreateCylinder(`tRoof${i}`, { height: 9, diameterTop: 0, diameterBottom: 18, tessellation: 20 }, scene);
            tRoof.position = new BABYLON.Vector3(pos[0], y + 32.5, pos[1]);
            tRoof.material = roofMat;
            shadowGenerator.addShadowCaster(tRoof);
        });

        // Walls
        const wallHeight = 16;
        const wallY = castleBaseY + wallHeight / 2;
        const wall1 = BABYLON.MeshBuilder.CreateBox("wall", { width: 48, height: wallHeight, depth: 6 }, scene);
        wall1.position = new BABYLON.Vector3(0, wallY, -27);
        wall1.material = stoneMat;
        shadowGenerator.addShadowCaster(wall1);
        const wall2 = wall1.clone(); wall2.position.z = 27;
        const wall3 = wall1.clone(); wall3.rotation.y = Math.PI / 2; wall3.position = new BABYLON.Vector3(-27, wallY, 0);
        const wall4 = wall3.clone(); wall4.position.x = 27;

        // ───── Village ─────
        function createHouse(x, z, scale = 1, roofColor = roofMat) {
            const baseY = getTerrainHeight(x, z) + scale * 4;
            const walls = BABYLON.MeshBuilder.CreateBox("house", { height: 8 * scale, width: 10 * scale, depth: 12 * scale }, scene);
            walls.position = new BABYLON.Vector3(x, baseY, z);
            walls.material = woodMat;
            shadowGenerator.addShadowCaster(walls);

            const roof = BABYLON.MeshBuilder.CreateCylinder("roof", { height: 7 * scale, diameterTop: 0, diameterBottom: 16 * scale, tessellation: 4 }, scene);
            roof.position = new BABYLON.Vector3(x, baseY + 8 * scale + 3.5 * scale, z);
            roof.material = roofColor;
            shadowGenerator.addShadowCaster(roof);
        }

        // Village houses
        createHouse(-32, -8, 1.1, roofMat);
        createHouse(-38, 8, 0.9);
        createHouse(-25, 18, 1.3, roofMat);
        createHouse(28, -12, 1.0);
        createHouse(35, 10, 1.2);
        createHouse(20, 25, 0.8);

        // Tavern (larger + blue roof)
        const tavernRoofMat = roofMat.clone();
        tavernRoofMat.diffuseColor = new BABYLON.Color3(0.2, 0.5, 1); // vibrant blue roof
        createHouse(-38, -22, 1.6, tavernRoofMat);

        // Market stalls
        function createStall(x, z) {
            const y = getTerrainHeight(x, z) + 3;
            const posts = BABYLON.MeshBuilder.CreateCylinder("posts", { height: 3, diameter: 0.6, tessellation: 8 }, scene);
            posts.position = new BABYLON.Vector3(x, y, z);
            posts.material = woodMat;
            shadowGenerator.addShadowCaster(posts);
            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 2) {
                const p = posts.clone();
                p.position.x += Math.cos(angle) * 4;
                p.position.z += Math.sin(angle) * 4;
                shadowGenerator.addShadowCaster(p);
            }
            const canopy = BABYLON.MeshBuilder.CreatePlane("canopy", { size: 10 }, scene);
            canopy.position = new BABYLON.Vector3(x, y + 3.2, z);
            canopy.rotation.x = Math.PI / 8;
            canopy.material = new BABYLON.StandardMaterial("", scene);
            canopy.material.diffuseColor = new BABYLON.Color3(1, 0.8, 0.3);
            canopy.material.specularColor = BABYLON.Color3.Black();
            shadowGenerator.addShadowCaster(canopy);
        }

        createStall(-20, -18);
        createStall(-15, -15);
        createStall(-25, -15);

        // ───── Riverside Mill ─────
        const millX = 15;
        const millZ = -38;
        const millY = getTerrainHeight(millX, millZ) + 5;
        createHouse(millX, millZ, 1.7, roofMat);

        const waterWheel = BABYLON.MeshBuilder.CreateCylinder("wheel", { height: 3, diameter: 16, tessellation: 16 }, scene);
        waterWheel.rotation.x = Math.PI / 2;
        waterWheel.position = new BABYLON.Vector3(millX + 12, millY - 3, millZ);
        waterWheel.material = woodMat;
        shadowGenerator.addShadowCaster(waterWheel);

        // Animate water wheel
        scene.registerBeforeRender(() => {
            waterWheel.rotation.z += 0.02;
        });

        // ───── Turquoise River with bridges & waterfalls ─────
        const riverPath = [];
        for (let i = 0; i <= 100; i++) {
            const t = i / 100;
            const x = -50 + t * 100;
            const z = 20 * Math.sin(t * Math.PI * 1.8);
            const y = getTerrainHeight(x, z) - 4.5; // river cuts into terrain
            riverPath.push(new BABYLON.Vector3(x, y, z));
        }

        const river = BABYLON.MeshBuilder.CreateRibbon("river", {
            pathArray: [
                riverPath.map(p => p.clone().addInPlace(new BABYLON.Vector3(-8, 0, 0))),
                riverPath.map(p => p.clone().addInPlace(new BABYLON.Vector3(8, 0, 0)))
            ],
            sideOrientation: BABYLON.Mesh.DOUBLESIDE
        }, scene);
        river.material = waterMat;

        // Simple wooden bridges
        for (let bx of [-20, 15, 40]) {
            const bridgeY = getTerrainHeight(bx, 20 * Math.sin(bx / 100 * Math.PI * 1.8)) + 2;
            const bridge = BABYLON.MeshBuilder.CreateBox("bridge", { width: 18, height: 1.2, depth: 12 }, scene);
            bridge.position = new BABYLON.Vector3(bx, bridgeY, 20 * Math.sin(bx / 100 * Math.PI * 1.8));
            bridge.material = woodMat;
            shadowGenerator.addShadowCaster(bridge);
        }

        // Waterfalls at edges
        const falls = [-48, 48];
        falls.forEach(fx => {
            const fy = getTerrainHeight(fx, 20 * Math.sin(fx / 100 * Math.PI * 1.8)) - 4;
            const fall = BABYLON.MeshBuilder.CreateTube("fall", {
                path: [new BABYLON.Vector3(fx, fy, 20 * Math.sin(fx / 100 * Math.PI * 1.8)), new BABYLON.Vector3(fx, fy - 40, 20 * Math.sin(fx / 100 * Math.PI * 1.8))],
                radius: 6,
                tessellation: 16,
                sideOrientation: BABYLON.Mesh.DOUBLESIDE
            }, scene);
            fall.material = waterMat;
        });

        // ───── Pine Trees ─────
        const treeMat = new BABYLON.StandardMaterial("tree", scene);
        treeMat.diffuseColor = new BABYLON.Color3(0.05, 0.55, 0.15);
        treeMat.specularColor = BABYLON.Color3.Black();

        for (let i = 0; i < 80; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * 48;
            const x = Math.cos(angle) * dist;
            const z = Math.sin(angle) * dist;
            if (dist < 15) continue; // keep center clear for castle

            const trunkH = 6 + Math.random() * 8;
            const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk", { height: trunkH, diameterTop: 1.2, diameterBottom: 2, tessellation: 12 }, scene);
            trunk.position = new BABYLON.Vector3(x, getTerrainHeight(x, z) + trunkH / 2, z);
            trunk.material = woodMat;
            shadowGenerator.addShadowCaster(trunk);

            for (let l = 0; l < 4; l++) {
                const cone = BABYLON.MeshBuilder.CreateSphere("foliage", { diameter: 10 - l * 2.2, segments: 8 }, scene);
                cone.scaling.y = 1.6;
                cone.position.y = getTerrainHeight(x, z) + trunkH + l * 4;
                cone.position.x = x;
                cone.position.z = z;
                cone.material = treeMat;
                shadowGenerator.addShadowCaster(cone);
            }
        }

        // ───── Ruined Watchtower at edge ─────
        const towerX = 48;
        const towerZ = 12;
        const towerY = getTerrainHeight(towerX, towerZ);
        const ruinedTower = BABYLON.MeshBuilder.CreateCylinder("ruined", { height: 22, diameter: 10, tessellation: 14 }, scene);
        ruinedTower.position = new BABYLON.Vector3(towerX, towerY + 11, towerZ);
        ruinedTower.rotation = new BABYLON.Vector3(0.25, 0.1, 0.15); // leaning / ruined
        ruinedTower.material = stoneMat;
        shadowGenerator.addShadowCaster(ruinedTower);

        return scene;
    };

    const scene = createScene();

    engine.runRenderLoop(() => {
        scene.render();
    });

    window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>