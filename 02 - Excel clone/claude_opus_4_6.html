<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SpreadSheet Pro</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #f0f2f5;
  --surface: #ffffff;
  --toolbar-bg: #f8f9fa;
  --border: #e1e3e6;
  --border-light: #ecedef;
  --accent: #217346;
  --accent-light: #e8f5ee;
  --accent-hover: #1a5c38;
  --text: #1d1d1f;
  --text2: #6e6e73;
  --text3: #aeaeb2;
  --select: rgba(33,115,70,0.12);
  --select-border: #217346;
  --header-bg: #f3f4f6;
  --header-active: #e2e4e7;
  --cell-edit: #fff;
  --danger: #d32f2f;
  --blue: #1a73e8;
  --row-h: 24px;
  --col-w: 100px;
  --header-h: 26px;
  --rn-w: 46px;
  --formula-h: 30px;
  --toolbar-h: 40px;
  --tabs-h: 32px;
}
* { margin:0; padding:0; box-sizing:border-box; }
body {
  font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
  background: var(--bg);
  color: var(--text);
  overflow: hidden;
  height: 100vh;
  display: flex;
  flex-direction: column;
}

/* ===== TOOLBAR ===== */
#toolbar {
  height: var(--toolbar-h);
  background: var(--toolbar-bg);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 8px;
  gap: 2px;
  flex-shrink: 0;
  z-index: 100;
}
.tb-btn {
  height: 30px;
  min-width: 30px;
  padding: 0 6px;
  border: none;
  background: none;
  border-radius: 4px;
  cursor: pointer;
  font-family: inherit;
  font-size: 13px;
  color: var(--text);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
  transition: background 0.12s;
  position: relative;
  white-space: nowrap;
}
.tb-btn:hover { background: rgba(0,0,0,0.06); }
.tb-btn:active { background: rgba(0,0,0,0.1); }
.tb-btn.active { background: var(--accent-light); color: var(--accent); }
.tb-btn svg { width: 16px; height: 16px; flex-shrink: 0; }
.tb-sep { width: 1px; height: 22px; background: var(--border); margin: 0 4px; flex-shrink: 0; }
.tb-color-input {
  width: 0; height: 0; opacity: 0; position: absolute; pointer-events: none;
}
.tb-color-swatch {
  width: 14px; height: 14px; border-radius: 2px; border: 1px solid rgba(0,0,0,0.15);
  display: inline-block; vertical-align: middle;
}
.tb-select {
  height: 28px; border: 1px solid var(--border); border-radius: 4px;
  background: var(--surface); font-family: inherit; font-size: 12px;
  padding: 0 4px; color: var(--text); cursor: pointer; outline: none;
}

/* ===== FORMULA BAR ===== */
#formula-bar {
  height: var(--formula-h);
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  flex-shrink: 0;
  z-index: 99;
}
#cell-address {
  width: 72px;
  height: 100%;
  border: none;
  border-right: 1px solid var(--border);
  text-align: center;
  font-family: 'DM Sans', monospace;
  font-size: 12px;
  font-weight: 600;
  color: var(--text);
  background: var(--header-bg);
  outline: none;
  padding: 0 4px;
}
#fx-label {
  padding: 0 8px;
  font-size: 12px;
  font-style: italic;
  color: var(--text2);
  border-right: 1px solid var(--border);
  height: 100%;
  display: flex;
  align-items: center;
  user-select: none;
}
#formula-input {
  flex: 1;
  height: 100%;
  border: none;
  padding: 0 8px;
  font-family: 'DM Sans', monospace;
  font-size: 13px;
  color: var(--text);
  outline: none;
  background: var(--surface);
}
#formula-input:focus {
  background: #fffde7;
}

/* ===== GRID CONTAINER ===== */
#grid-container {
  flex: 1;
  position: relative;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}
#grid-wrapper {
  flex: 1;
  position: relative;
  overflow: auto;
  will-change: scroll-position;
}
#grid-wrapper::-webkit-scrollbar { width: 14px; height: 14px; }
#grid-wrapper::-webkit-scrollbar-track { background: var(--bg); }
#grid-wrapper::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 7px; border: 3px solid var(--bg); }
#grid-wrapper::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
#grid-wrapper::-webkit-scrollbar-corner { background: var(--bg); }

/* ===== GRID TABLE ===== */
#grid {
  border-collapse: collapse;
  table-layout: fixed;
  position: relative;
}
#grid th, #grid td {
  border: 1px solid var(--border-light);
  padding: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Column headers */
#grid thead th {
  height: var(--header-h);
  background: var(--header-bg);
  font-size: 11.5px;
  font-weight: 500;
  color: var(--text2);
  text-align: center;
  position: sticky;
  top: 0;
  z-index: 20;
  user-select: none;
  cursor: default;
}
#grid thead th:first-child {
  width: var(--rn-w);
  min-width: var(--rn-w);
  position: sticky;
  left: 0;
  z-index: 30;
  background: var(--header-bg);
  cursor: pointer;
}
#grid thead th.col-selected {
  background: var(--accent);
  color: #fff;
}
#grid thead th .col-resize {
  position: absolute;
  right: -2px;
  top: 0;
  width: 5px;
  height: 100%;
  cursor: col-resize;
  z-index: 5;
}
#grid thead th .col-resize:hover,
#grid thead th .col-resize.resizing {
  background: var(--accent);
}

/* Row number cells */
#grid tbody td:first-child {
  width: var(--rn-w);
  min-width: var(--rn-w);
  background: var(--header-bg);
  text-align: center;
  font-size: 11px;
  font-weight: 500;
  color: var(--text2);
  position: sticky;
  left: 0;
  z-index: 10;
  user-select: none;
  cursor: pointer;
}
#grid tbody td:first-child.row-selected {
  background: var(--accent);
  color: #fff;
}

/* Data cells */
#grid tbody td.cell {
  height: var(--row-h);
  font-size: 13px;
  padding: 0 4px;
  cursor: cell;
  position: relative;
  line-height: var(--row-h);
}
#grid tbody td.cell.selected {
  outline: 2px solid var(--select-border);
  outline-offset: -1px;
  z-index: 5;
}
#grid tbody td.cell.in-range {
  background: var(--select);
}
#grid tbody td.cell.editing {
  outline: 2px solid var(--blue);
  outline-offset: -1px;
  z-index: 6;
  padding: 0;
}
#grid tbody td.cell.editing input {
  width: 100%;
  height: 100%;
  border: none;
  outline: none;
  font-family: inherit;
  font-size: 13px;
  padding: 0 4px;
  background: var(--cell-edit);
}
#grid tbody td.cell.formula-ref-highlight {
  outline: 2px dashed var(--blue);
  outline-offset: -1px;
}
#grid tbody td.cell.error {
  color: var(--danger);
  font-size: 11px;
}
#grid tbody td.cell.bold { font-weight: 700; }
#grid tbody td.cell.italic { font-style: italic; }
#grid tbody td.cell.align-left { text-align: left; }
#grid tbody td.cell.align-center { text-align: center; }
#grid tbody td.cell.align-right { text-align: right; }

/* ===== SHEET TABS ===== */
#sheet-bar {
  height: var(--tabs-h);
  background: var(--toolbar-bg);
  border-top: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 4px;
  gap: 2px;
  flex-shrink: 0;
  z-index: 100;
  overflow-x: auto;
}
#sheet-bar::-webkit-scrollbar { height: 0; }
.sheet-tab {
  height: 26px;
  padding: 0 14px;
  border: 1px solid transparent;
  border-bottom: none;
  background: none;
  border-radius: 4px 4px 0 0;
  font-family: inherit;
  font-size: 12px;
  color: var(--text2);
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 4px;
  white-space: nowrap;
  transition: background 0.1s;
  position: relative;
}
.sheet-tab:hover { background: rgba(0,0,0,0.04); }
.sheet-tab.active {
  background: var(--surface);
  color: var(--accent);
  font-weight: 600;
  border-color: var(--border);
  border-bottom: 1px solid var(--surface);
  margin-bottom: -1px;
}
.sheet-tab .tab-close {
  width: 16px; height: 16px;
  border-radius: 50%;
  display: none;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  line-height: 1;
  color: var(--text3);
  cursor: pointer;
}
.sheet-tab:hover .tab-close { display: flex; }
.sheet-tab .tab-close:hover { background: rgba(0,0,0,0.1); color: var(--danger); }
#add-sheet-btn {
  width: 26px;
  height: 26px;
  border: 1px dashed var(--border);
  background: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  color: var(--text2);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  transition: all 0.12s;
}
#add-sheet-btn:hover { background: var(--accent-light); color: var(--accent); border-color: var(--accent); }

/* ===== STATUS BAR ===== */
#status-bar {
  height: 22px;
  background: var(--accent);
  display: flex;
  align-items: center;
  padding: 0 12px;
  font-size: 11px;
  color: rgba(255,255,255,0.9);
  gap: 16px;
  flex-shrink: 0;
}
#status-bar .stat { opacity: 0.8; }
#status-bar .stat b { font-weight: 600; opacity: 1; }

/* ===== CONTEXT MENU ===== */
.ctx-menu {
  position: fixed;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.15);
  padding: 4px;
  z-index: 9999;
  min-width: 180px;
  display: none;
}
.ctx-menu.show { display: block; }
.ctx-item {
  padding: 6px 12px;
  font-size: 12px;
  cursor: pointer;
  border-radius: 4px;
  display: flex;
  align-items: center;
  gap: 8px;
  color: var(--text);
}
.ctx-item:hover { background: var(--accent-light); }
.ctx-sep { height: 1px; background: var(--border); margin: 3px 8px; }

/* ===== RENAME INPUT ===== */
.tab-rename-input {
  border: 1px solid var(--accent);
  border-radius: 3px;
  font-size: 12px;
  font-family: inherit;
  padding: 1px 4px;
  outline: none;
  width: 80px;
  background: #fff;
}

/* ===== RANGE HIGHLIGHT BOX ===== */
.range-highlight {
  position: absolute;
  border: 2px dashed;
  pointer-events: none;
  z-index: 4;
  background: rgba(26,115,232,0.06);
}

/* ===== UPLOAD HIDDEN ===== */
#csv-upload { display: none; }

/* ===== RESPONSIVE ===== */
@media (max-width: 768px) {
  :root { --col-w: 80px; --rn-w: 36px; }
  .tb-btn span { display: none; }
  #cell-address { width: 56px; }
}
</style>
</head>
<body>

<!-- TOOLBAR -->
<div id="toolbar">
  <button class="tb-btn" id="btn-bold" title="Bold (Ctrl+B)">
    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z"/></svg>
  </button>
  <button class="tb-btn" id="btn-italic" title="Italic (Ctrl+I)">
    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z"/></svg>
  </button>
  <div class="tb-sep"></div>
  <button class="tb-btn" id="btn-align-left" title="Align Left">
    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z"/></svg>
  </button>
  <button class="tb-btn" id="btn-align-center" title="Align Center">
    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z"/></svg>
  </button>
  <button class="tb-btn" id="btn-align-right" title="Align Right">
    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zM3 3v2h18V3H3z"/></svg>
  </button>
  <div class="tb-sep"></div>
  <button class="tb-btn" id="btn-bg-color" title="Fill Color">
    <span class="tb-color-swatch" id="bg-swatch" style="background:#ffff00"></span>
    <svg viewBox="0 0 24 24" fill="currentColor" width="10" height="10" style="width:10px;height:10px"><path d="M7 10l5 5 5-5z"/></svg>
    <input type="color" class="tb-color-input" id="bg-color-picker" value="#ffff00">
  </button>
  <button class="tb-btn" id="btn-text-color" title="Text Color">
    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M11 3L5.5 17h2.25l1.12-3h6.25l1.12 3h2.25L13 3h-2zm-1.38 9L12 5.67 14.38 12H9.62z"/></svg>
    <span class="tb-color-swatch" id="text-swatch" style="background:#000000"></span>
    <input type="color" class="tb-color-input" id="text-color-picker" value="#000000">
  </button>
  <div class="tb-sep"></div>
  <button class="tb-btn" id="btn-clear" title="Clear Contents">
    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
    <span>Clear</span>
  </button>
  <div class="tb-sep"></div>
  <select class="tb-select" id="font-size-select" title="Font Size">
    <option value="11">11</option>
    <option value="12">12</option>
    <option value="13" selected>13</option>
    <option value="14">14</option>
    <option value="16">16</option>
    <option value="18">18</option>
    <option value="20">20</option>
    <option value="24">24</option>
  </select>
  <div class="tb-sep"></div>
  <button class="tb-btn" id="btn-download" title="Download CSV">
    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
    <span>CSV ‚Üì</span>
  </button>
  <button class="tb-btn" id="btn-upload" title="Upload CSV">
    <svg viewBox="0 0 24 24" fill="currentColor"><path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/></svg>
    <span>CSV ‚Üë</span>
  </button>
  <input type="file" id="csv-upload" accept=".csv,.tsv,.txt">
</div>

<!-- FORMULA BAR -->
<div id="formula-bar">
  <input id="cell-address" value="A1" readonly>
  <div id="fx-label">fx</div>
  <input id="formula-input" placeholder="Enter value or formula (e.g. =SUM(A1:A10))">
</div>

<!-- GRID -->
<div id="grid-container">
  <div id="grid-wrapper">
    <table id="grid"></table>
  </div>
</div>

<!-- SHEET TABS -->
<div id="sheet-bar">
  <button id="add-sheet-btn" title="Add Sheet">+</button>
</div>

<!-- STATUS BAR -->
<div id="status-bar">
  <span class="stat" id="stat-sum"></span>
  <span class="stat" id="stat-avg"></span>
  <span class="stat" id="stat-count"></span>
  <span class="stat" id="stat-min"></span>
  <span class="stat" id="stat-max"></span>
  <span style="flex:1"></span>
  <span class="stat" id="stat-info">Ready</span>
</div>

<!-- CONTEXT MENU -->
<div class="ctx-menu" id="ctx-menu">
  <div class="ctx-item" data-action="cut">‚úÇÔ∏è Cut</div>
  <div class="ctx-item" data-action="copy">üìã Copy</div>
  <div class="ctx-item" data-action="paste">üìå Paste</div>
  <div class="ctx-sep"></div>
  <div class="ctx-item" data-action="insert-row">‚ûï Insert Row Above</div>
  <div class="ctx-item" data-action="insert-col">‚ûï Insert Column Left</div>
  <div class="ctx-sep"></div>
  <div class="ctx-item" data-action="delete-row">üóë Delete Row</div>
  <div class="ctx-item" data-action="delete-col">üóë Delete Column</div>
  <div class="ctx-sep"></div>
  <div class="ctx-item" data-action="clear">üßπ Clear Contents</div>
</div>

<script>
// =====================================================================
// SPREADSHEET ENGINE
// =====================================================================

const NUM_ROWS = 200;
const NUM_COLS = 26;
const COL_LETTERS = [];
for (let i = 0; i < NUM_COLS; i++) {
  if (i < 26) COL_LETTERS.push(String.fromCharCode(65 + i));
  else COL_LETTERS.push(String.fromCharCode(64 + Math.floor(i/26)) + String.fromCharCode(65 + i%26));
}

// ===== DATA MODEL =====
class Sheet {
  constructor(name) {
    this.name = name;
    this.cells = {};       // key "A1" -> { raw, value, formula, error, deps, bold, italic, align, bgColor, textColor, fontSize }
    this.colWidths = {};   // col index -> width
  }
  getCell(key) {
    if (!this.cells[key]) {
      this.cells[key] = { raw: '', value: '', formula: null, error: null, deps: new Set(), rdeps: new Set(), bold: false, italic: false, align: '', bgColor: '', textColor: '', fontSize: '' };
    }
    return this.cells[key];
  }
}

class Workbook {
  constructor() {
    this.sheets = [new Sheet('Sheet1')];
    this.activeSheetIdx = 0;
  }
  get sheet() { return this.sheets[this.activeSheetIdx]; }
  addSheet(name) {
    this.sheets.push(new Sheet(name || `Sheet${this.sheets.length + 1}`));
    return this.sheets.length - 1;
  }
  deleteSheet(idx) {
    if (this.sheets.length <= 1) return false;
    this.sheets.splice(idx, 1);
    if (this.activeSheetIdx >= this.sheets.length) this.activeSheetIdx = this.sheets.length - 1;
    return true;
  }
}

// ===== FORMULA PARSER =====
function parseCellRef(ref) {
  const m = ref.match(/^([A-Z]+)(\d+)$/);
  if (!m) return null;
  let col = 0;
  for (let i = 0; i < m[1].length; i++) col = col * 26 + (m[1].charCodeAt(i) - 64);
  return { col: col - 1, row: parseInt(m[2]) - 1 };
}

function cellKey(col, row) {
  return COL_LETTERS[col] + (row + 1);
}

function expandRange(range) {
  const parts = range.split(':');
  if (parts.length !== 2) return [range];
  const start = parseCellRef(parts[0]);
  const end = parseCellRef(parts[1]);
  if (!start || !end) return [range];
  const cells = [];
  const r1 = Math.min(start.row, end.row), r2 = Math.max(start.row, end.row);
  const c1 = Math.min(start.col, end.col), c2 = Math.max(start.col, end.col);
  for (let r = r1; r <= r2; r++)
    for (let c = c1; c <= c2; c++)
      cells.push(cellKey(c, r));
  return cells;
}

function tokenize(expr) {
  const tokens = [];
  let i = 0;
  while (i < expr.length) {
    if (expr[i] === ' ') { i++; continue; }
    // Function names
    if (/[A-Z]/i.test(expr[i])) {
      let name = '';
      while (i < expr.length && /[A-Z0-9:]/i.test(expr[i])) { name += expr[i].toUpperCase(); i++; }
      tokens.push({ type: 'ref', value: name });
      continue;
    }
    if (/[0-9.]/.test(expr[i])) {
      let num = '';
      while (i < expr.length && /[0-9.eE]/.test(expr[i])) { num += expr[i]; i++; }
      tokens.push({ type: 'num', value: parseFloat(num) });
      continue;
    }
    if ('"\''.includes(expr[i])) {
      const q = expr[i]; i++;
      let s = '';
      while (i < expr.length && expr[i] !== q) { s += expr[i]; i++; }
      i++;
      tokens.push({ type: 'str', value: s });
      continue;
    }
    if ('+-*/^%'.includes(expr[i])) {
      tokens.push({ type: 'op', value: expr[i] }); i++; continue;
    }
    if ('(),'.includes(expr[i])) {
      tokens.push({ type: expr[i], value: expr[i] }); i++; continue;
    }
    if ('<>=!'.includes(expr[i])) {
      let op = expr[i]; i++;
      if (i < expr.length && '='.includes(expr[i])) { op += expr[i]; i++; }
      tokens.push({ type: 'op', value: op }); continue;
    }
    i++;
  }
  return tokens;
}

function evaluateFormula(expr, sheet, visited = new Set()) {
  const deps = new Set();
  const FUNCS = {
    SUM: args => args.flat().reduce((a, v) => a + (parseFloat(v) || 0), 0),
    AVERAGE: args => { const flat = args.flat().filter(v => v !== '' && !isNaN(v)); return flat.length ? flat.reduce((a,v)=>a+parseFloat(v),0)/flat.length : 0; },
    MIN: args => Math.min(...args.flat().filter(v=>v!==''&&!isNaN(v)).map(Number)),
    MAX: args => Math.max(...args.flat().filter(v=>v!==''&&!isNaN(v)).map(Number)),
    COUNT: args => args.flat().filter(v => v !== '' && !isNaN(v)).length,
    COUNTA: args => args.flat().filter(v => v !== '').length,
    ABS: args => Math.abs(parseFloat(args.flat()[0]) || 0),
    ROUND: args => { const flat = args.flat(); return parseFloat((parseFloat(flat[0])||0).toFixed(parseInt(flat[1])||0)); },
    IF: args => { /* special handling */ },
    CONCAT: args => args.flat().join(''),
    LEN: args => String(args.flat()[0] || '').length,
    UPPER: args => String(args.flat()[0] || '').toUpperCase(),
    LOWER: args => String(args.flat()[0] || '').toLowerCase(),
    TRIM: args => String(args.flat()[0] || '').trim(),
    INT: args => Math.floor(parseFloat(args.flat()[0]) || 0),
    MOD: args => { const flat = args.flat(); return (parseFloat(flat[0])||0) % (parseFloat(flat[1])||1); },
    POWER: args => { const flat = args.flat(); return Math.pow(parseFloat(flat[0])||0, parseFloat(flat[1])||1); },
    SQRT: args => Math.sqrt(parseFloat(args.flat()[0]) || 0),
    PI: () => Math.PI,
    NOW: () => new Date().toLocaleString(),
    TODAY: () => new Date().toLocaleDateString(),
  };

  function resolveRef(name) {
    if (name.includes(':')) {
      const cellKeys = expandRange(name);
      const values = [];
      for (const k of cellKeys) {
        deps.add(k);
        if (visited.has(k)) throw new Error('CIRCULAR');
        const c = sheet.getCell(k);
        values.push(c.value);
      }
      return values;
    }
    const ref = parseCellRef(name);
    if (ref) {
      const k = cellKey(ref.col, ref.row);
      deps.add(k);
      if (visited.has(k)) throw new Error('CIRCULAR');
      const c = sheet.getCell(k);
      return c.value;
    }
    return name;
  }

  function parse(tokens, pos) {
    return parseComparison(tokens, pos);
  }

  function parseComparison(tokens, pos) {
    let [left, p] = parseAddSub(tokens, pos);
    while (p < tokens.length && tokens[p].type === 'op' && ['<','>','<=','>=','==','!=','<>','='].includes(tokens[p].value)) {
      const op = tokens[p].value; p++;
      let [right, p2] = parseAddSub(tokens, p); p = p2;
      const a = parseFloat(left), b = parseFloat(right);
      const la = isNaN(a) ? left : a, lb = isNaN(b) ? right : b;
      if (op === '<') left = la < lb;
      else if (op === '>') left = la > lb;
      else if (op === '<=') left = la <= lb;
      else if (op === '>=') left = la >= lb;
      else if (op === '==' || op === '=') left = la == lb;
      else if (op === '!=' || op === '<>') left = la != lb;
    }
    return [left, p];
  }

  function parseAddSub(tokens, pos) {
    let [left, p] = parseMulDiv(tokens, pos);
    while (p < tokens.length && tokens[p].type === 'op' && '+-'.includes(tokens[p].value)) {
      const op = tokens[p].value; p++;
      let [right, p2] = parseMulDiv(tokens, p); p = p2;
      if (op === '+') {
        const a = parseFloat(left), b = parseFloat(right);
        left = (!isNaN(a) && !isNaN(b)) ? a + b : String(left) + String(right);
      } else {
        left = (parseFloat(left) || 0) - (parseFloat(right) || 0);
      }
    }
    return [left, p];
  }

  function parseMulDiv(tokens, pos) {
    let [left, p] = parsePower(tokens, pos);
    while (p < tokens.length && tokens[p].type === 'op' && '*/'.includes(tokens[p].value)) {
      const op = tokens[p].value; p++;
      let [right, p2] = parsePower(tokens, p); p = p2;
      if (op === '*') left = (parseFloat(left)||0) * (parseFloat(right)||0);
      else { const d = parseFloat(right)||0; if(d===0) throw new Error('#DIV/0!'); left = (parseFloat(left)||0)/d; }
    }
    return [left, p];
  }

  function parsePower(tokens, pos) {
    let [left, p] = parseUnary(tokens, pos);
    while (p < tokens.length && tokens[p].type === 'op' && tokens[p].value === '^') {
      p++;
      let [right, p2] = parseUnary(tokens, p); p = p2;
      left = Math.pow(parseFloat(left)||0, parseFloat(right)||0);
    }
    return [left, p];
  }

  function parseUnary(tokens, pos) {
    if (pos < tokens.length && tokens[pos].type === 'op' && tokens[pos].value === '-') {
      pos++;
      let [val, p] = parseAtom(tokens, pos);
      return [-(parseFloat(val)||0), p];
    }
    if (pos < tokens.length && tokens[pos].type === 'op' && tokens[pos].value === '+') {
      pos++;
    }
    return parseAtom(tokens, pos);
  }

  function parseAtom(tokens, pos) {
    if (pos >= tokens.length) return ['', pos];
    const t = tokens[pos];
    if (t.type === 'num') return [t.value, pos+1];
    if (t.type === 'str') return [t.value, pos+1];
    if (t.type === '(') {
      pos++;
      let [val, p] = parse(tokens, pos);
      if (p < tokens.length && tokens[p].type === ')') p++;
      return [val, p];
    }
    if (t.type === 'ref') {
      // Check if it's a function call
      if (pos+1 < tokens.length && tokens[pos+1].type === '(') {
        const fname = t.value;
        pos += 2; // skip name and (
        const args = [];
        while (pos < tokens.length && tokens[pos].type !== ')') {
          if (tokens[pos].type === ',') { pos++; continue; }
          // Check for range ref
          if (tokens[pos].type === 'ref' && tokens[pos].value.includes(':')) {
            args.push(resolveRef(tokens[pos].value));
            pos++;
          } else {
            let [val, p] = parse(tokens, pos);
            args.push([val]);
            pos = p;
          }
        }
        if (pos < tokens.length) pos++; // skip )
        
        // Special IF handling
        if (fname === 'IF') {
          const cond = args[0] ? args[0].flat()[0] : false;
          const truthy = (cond && cond !== 0 && cond !== false && cond !== 'false' && cond !== '');
          return [truthy ? (args[1]?args[1].flat()[0]:'') : (args[2]?args[2].flat()[0]:''), pos];
        }
        
        if (FUNCS[fname]) return [FUNCS[fname](args), pos];
        throw new Error('#NAME?');
      }
      // Cell reference or range
      const val = resolveRef(t.value);
      return [Array.isArray(val) ? val : val, pos+1];
    }
    return ['', pos+1];
  }

  const tokens = tokenize(expr);
  const [result, _] = parse(tokens, 0);
  return { value: result, deps };
}

// ===== WORKBOOK INSTANCE =====
const workbook = new Workbook();
let sel = { row: 0, col: 0 };        // active cell
let rangeStart = null;                 // range selection start
let rangeEnd = null;                   // range selection end
let isEditing = false;
let editingFormulaMode = false;        // true when editing formula in formula bar and clicking cells to insert refs
let clipboard = null;
let colWidths = {};

// ===== CALCULATE CELL =====
function calcCell(key, sheet, visited = new Set()) {
  const cell = sheet.getCell(key);
  if (visited.has(key)) { cell.value = '#CIRCULAR!'; cell.error = 'Circular reference'; return; }
  visited.add(key);
  
  if (!cell.raw || !cell.formula) {
    cell.value = cell.raw;
    cell.error = null;
    // Try to parse as number
    if (cell.raw !== '' && !isNaN(cell.raw)) cell.value = parseFloat(cell.raw);
    return;
  }
  
  try {
    const oldDeps = cell.deps;
    const result = evaluateFormula(cell.formula, sheet, new Set([key]));
    cell.value = result.value;
    cell.error = null;
    // Update deps
    cell.deps = result.deps;
    // Format result
    if (typeof cell.value === 'number') {
      if (!isFinite(cell.value)) { cell.value = '#NUM!'; cell.error = 'Invalid number'; }
    } else if (typeof cell.value === 'boolean') {
      cell.value = cell.value ? 'TRUE' : 'FALSE';
    }
  } catch (e) {
    cell.value = e.message.startsWith('#') ? e.message : '#ERROR!';
    cell.error = e.message;
  }
}

function recalcAll() {
  const sheet = workbook.sheet;
  // Build dependency graph and calculate
  const calculated = new Set();
  function calcWithDeps(key) {
    if (calculated.has(key)) return;
    calculated.add(key);
    const cell = sheet.getCell(key);
    if (cell.formula) {
      // First ensure dependencies are calculated
      const tempResult = evaluateFormula(cell.formula, sheet, new Set());
      for (const dep of tempResult.deps) {
        if (!calculated.has(dep)) calcWithDeps(dep);
      }
    }
    calcCell(key, sheet);
  }
  for (const key in sheet.cells) {
    calcWithDeps(key);
  }
}

function setCellValue(key, raw) {
  const sheet = workbook.sheet;
  const cell = sheet.getCell(key);
  cell.raw = raw;
  if (typeof raw === 'string' && raw.startsWith('=')) {
    cell.formula = raw.substring(1);
  } else {
    cell.formula = null;
  }
  recalcAll();
}

// ===== RENDERING =====
function getColWidth(ci) {
  return workbook.sheet.colWidths[ci] || 100;
}

function buildGrid() {
  const grid = document.getElementById('grid');
  grid.innerHTML = '';
  
  // THEAD
  const thead = document.createElement('thead');
  const hr = document.createElement('tr');
  const corner = document.createElement('th');
  corner.textContent = '';
  corner.onclick = () => { selectAll(); };
  hr.appendChild(corner);
  
  for (let c = 0; c < NUM_COLS; c++) {
    const th = document.createElement('th');
    th.textContent = COL_LETTERS[c];
    th.style.width = getColWidth(c) + 'px';
    th.dataset.col = c;
    th.setAttribute('data-col-header', c);
    
    // Column resize handle
    const handle = document.createElement('div');
    handle.className = 'col-resize';
    handle.addEventListener('mousedown', (e) => startColResize(e, c, th));
    th.appendChild(handle);
    
    // Click to select column
    th.addEventListener('mousedown', (e) => {
      if (e.target === handle) return;
      selectColumn(c);
    });
    
    hr.appendChild(th);
  }
  thead.appendChild(hr);
  grid.appendChild(thead);
  
  // TBODY
  const tbody = document.createElement('tbody');
  const sheet = workbook.sheet;
  
  for (let r = 0; r < NUM_ROWS; r++) {
    const tr = document.createElement('tr');
    // Row number
    const rn = document.createElement('td');
    rn.textContent = r + 1;
    rn.dataset.row = r;
    rn.addEventListener('mousedown', () => selectRow(r));
    tr.appendChild(rn);
    
    for (let c = 0; c < NUM_COLS; c++) {
      const td = document.createElement('td');
      td.className = 'cell';
      td.dataset.row = r;
      td.dataset.col = c;
      td.style.width = getColWidth(c) + 'px';
      
      const key = cellKey(c, r);
      const cell = sheet.getCell(key);
      updateCellElement(td, cell);
      
      td.addEventListener('mousedown', (e) => onCellMouseDown(e, r, c));
      td.addEventListener('mouseover', (e) => onCellMouseOver(e, r, c));
      td.addEventListener('dblclick', () => startEditingCell(r, c));
      
      tr.appendChild(td);
    }
    tbody.appendChild(tr);
  }
  grid.appendChild(tbody);
  
  refreshSelection();
}

function updateCellElement(td, cell) {
  if (cell.error) {
    td.textContent = cell.value;
    td.classList.add('error');
  } else {
    td.classList.remove('error');
    const val = cell.value;
    if (typeof val === 'number') {
      td.textContent = formatNumber(val);
    } else {
      td.textContent = val || '';
    }
  }
  // Apply formatting
  td.classList.toggle('bold', !!cell.bold);
  td.classList.toggle('italic', !!cell.italic);
  td.classList.remove('align-left', 'align-center', 'align-right');
  if (cell.align) td.classList.add('align-' + cell.align);
  td.style.backgroundColor = cell.bgColor || '';
  td.style.color = cell.textColor || '';
  if (cell.fontSize) td.style.fontSize = cell.fontSize + 'px';
}

function formatNumber(n) {
  if (Number.isInteger(n) && Math.abs(n) < 1e15) return n.toLocaleString();
  if (Math.abs(n) < 0.0001 && n !== 0) return n.toExponential(4);
  const s = n.toString();
  if (s.includes('.') && s.split('.')[1].length > 8) return parseFloat(n.toFixed(8)).toString();
  return s;
}

function getCellTd(row, col) {
  const grid = document.getElementById('grid');
  const tbody = grid.querySelector('tbody');
  if (!tbody || !tbody.children[row]) return null;
  return tbody.children[row].children[col + 1] || null;
}

function refreshCellDisplay(key) {
  const ref = parseCellRef(key);
  if (!ref) return;
  const td = getCellTd(ref.row, ref.col);
  if (td) updateCellElement(td, workbook.sheet.getCell(key));
}

// ===== SELECTION =====
let mouseDown = false;

function setSelection(row, col) {
  sel = { row, col };
  rangeStart = { row, col };
  rangeEnd = { row, col };
  refreshSelection();
  updateFormulaBar();
  updateToolbarState();
}

function refreshSelection() {
  const grid = document.getElementById('grid');
  // Clear old
  grid.querySelectorAll('.selected, .in-range, .col-selected, .row-selected').forEach(el => {
    el.classList.remove('selected', 'in-range', 'col-selected', 'row-selected');
  });
  
  // Active cell
  const activeTd = getCellTd(sel.row, sel.col);
  if (activeTd) activeTd.classList.add('selected');
  
  // Range
  if (rangeStart && rangeEnd) {
    const r1 = Math.min(rangeStart.row, rangeEnd.row);
    const r2 = Math.max(rangeStart.row, rangeEnd.row);
    const c1 = Math.min(rangeStart.col, rangeEnd.col);
    const c2 = Math.max(rangeStart.col, rangeEnd.col);
    for (let r = r1; r <= r2; r++) {
      for (let c = c1; c <= c2; c++) {
        const td = getCellTd(r, c);
        if (td && !(r === sel.row && c === sel.col)) td.classList.add('in-range');
      }
    }
    // Column headers
    const ths = grid.querySelectorAll('thead th');
    for (let c = c1; c <= c2; c++) {
      if (ths[c+1]) ths[c+1].classList.add('col-selected');
    }
    // Row numbers
    const tbody = grid.querySelector('tbody');
    for (let r = r1; r <= r2; r++) {
      if (tbody.children[r]) tbody.children[r].children[0].classList.add('row-selected');
    }
  }
  
  updateStatusBar();
}

function selectRow(r) {
  sel = { row: r, col: 0 };
  rangeStart = { row: r, col: 0 };
  rangeEnd = { row: r, col: NUM_COLS - 1 };
  refreshSelection();
  updateFormulaBar();
}

function selectColumn(c) {
  sel = { row: 0, col: c };
  rangeStart = { row: 0, col: c };
  rangeEnd = { row: NUM_ROWS - 1, col: c };
  refreshSelection();
  updateFormulaBar();
}

function selectAll() {
  sel = { row: 0, col: 0 };
  rangeStart = { row: 0, col: 0 };
  rangeEnd = { row: NUM_ROWS - 1, col: NUM_COLS - 1 };
  refreshSelection();
}

function onCellMouseDown(e, r, c) {
  if (e.button === 2) return; // right click handled elsewhere
  
  // If editing formula and clicking a cell, insert reference
  if (editingFormulaMode) {
    e.preventDefault();
    const fi = document.getElementById('formula-input');
    const ref = cellKey(c, r);
    // Insert at cursor position
    const start = fi.selectionStart;
    const end = fi.selectionEnd;
    const val = fi.value;
    fi.value = val.substring(0, start) + ref + val.substring(end);
    fi.focus();
    fi.setSelectionRange(start + ref.length, start + ref.length);
    formulaDragStart = { row: r, col: c };
    formulaDragMode = true;
    return;
  }
  
  if (isEditing) finishEditing();
  
  mouseDown = true;
  if (e.shiftKey) {
    rangeEnd = { row: r, col: c };
  } else {
    sel = { row: r, col: c };
    rangeStart = { row: r, col: c };
    rangeEnd = { row: r, col: c };
  }
  refreshSelection();
  updateFormulaBar();
  updateToolbarState();
}

let formulaDragStart = null;
let formulaDragMode = false;

function onCellMouseOver(e, r, c) {
  if (formulaDragMode && editingFormulaMode) {
    e.preventDefault();
    const fi = document.getElementById('formula-input');
    const startRef = cellKey(formulaDragStart.col, formulaDragStart.row);
    const endRef = cellKey(c, r);
    const rangeStr = (startRef === endRef) ? startRef : startRef + ':' + endRef;
    
    // Replace the last inserted reference
    const val = fi.value;
    // Find last ref/range
    const lastRefMatch = val.match(/([A-Z]+\d+(?::[A-Z]+\d+)?)$/);
    if (lastRefMatch) {
      fi.value = val.substring(0, val.length - lastRefMatch[0].length) + rangeStr;
    }
    return;
  }
  
  if (!mouseDown) return;
  rangeEnd = { row: r, col: c };
  refreshSelection();
}

document.addEventListener('mouseup', () => {
  mouseDown = false;
  formulaDragMode = false;
});

// ===== CELL EDITING =====
function startEditingCell(row, col) {
  if (isEditing) finishEditing();
  isEditing = true;
  sel = { row, col };
  
  const td = getCellTd(row, col);
  if (!td) return;
  td.classList.add('editing');
  
  const key = cellKey(col, row);
  const cell = workbook.sheet.getCell(key);
  
  const input = document.createElement('input');
  input.value = cell.raw || '';
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { finishEditing(); moveSel(1, 0); e.preventDefault(); }
    else if (e.key === 'Tab') { finishEditing(); moveSel(0, e.shiftKey ? -1 : 1); e.preventDefault(); }
    else if (e.key === 'Escape') { cancelEditing(); e.preventDefault(); }
  });
  input.addEventListener('input', () => {
    document.getElementById('formula-input').value = input.value;
  });
  
  td.textContent = '';
  td.appendChild(input);
  input.focus();
  
  // Update formula bar
  const fi = document.getElementById('formula-input');
  fi.value = cell.raw || '';
}

function finishEditing(fromFormulaBar = false) {
  if (!isEditing && !editingFormulaMode) return;
  
  const key = cellKey(sel.col, sel.row);
  let newVal;
  
  if (fromFormulaBar || editingFormulaMode) {
    newVal = document.getElementById('formula-input').value;
    editingFormulaMode = false;
  } else {
    const td = getCellTd(sel.row, sel.col);
    const input = td?.querySelector('input');
    newVal = input ? input.value : '';
  }
  
  setCellValue(key, newVal);
  
  isEditing = false;
  
  // Re-render edited cell
  const td = getCellTd(sel.row, sel.col);
  if (td) {
    td.classList.remove('editing');
    const cellInput = td.querySelector('input');
    if (cellInput) cellInput.remove();
    updateCellElement(td, workbook.sheet.getCell(key));
  }
  
  // Update all cells that might depend on this
  refreshAllCells();
  updateFormulaBar();
  updateStatusBar();
}

function cancelEditing() {
  isEditing = false;
  editingFormulaMode = false;
  const td = getCellTd(sel.row, sel.col);
  if (td) {
    td.classList.remove('editing');
    const input = td.querySelector('input');
    if (input) input.remove();
    updateCellElement(td, workbook.sheet.getCell(cellKey(sel.col, sel.row)));
  }
  updateFormulaBar();
}

function refreshAllCells() {
  const sheet = workbook.sheet;
  for (const key in sheet.cells) {
    refreshCellDisplay(key);
  }
}

// ===== FORMULA BAR =====
function updateFormulaBar() {
  const key = cellKey(sel.col, sel.row);
  document.getElementById('cell-address').value = key;
  const cell = workbook.sheet.getCell(key);
  document.getElementById('formula-input').value = cell.raw || '';
}

const formulaInput = document.getElementById('formula-input');
formulaInput.addEventListener('focus', () => {
  const cell = workbook.sheet.getCell(cellKey(sel.col, sel.row));
  if (cell.raw && cell.raw.startsWith('=')) {
    editingFormulaMode = true;
  }
});
formulaInput.addEventListener('input', () => {
  if (formulaInput.value.startsWith('=')) {
    editingFormulaMode = true;
  }
  // Sync to cell input if editing
  if (isEditing) {
    const td = getCellTd(sel.row, sel.col);
    const input = td?.querySelector('input');
    if (input) input.value = formulaInput.value;
  }
});
formulaInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    finishEditing(true);
    document.getElementById('grid-wrapper').focus();
  } else if (e.key === 'Escape') {
    e.preventDefault();
    editingFormulaMode = false;
    cancelEditing();
    updateFormulaBar();
  }
});

// ===== KEYBOARD NAVIGATION =====
document.addEventListener('keydown', (e) => {
  if (e.target === formulaInput || e.target.tagName === 'INPUT' && e.target.parentElement?.classList?.contains('editing')) return;
  if (e.target.classList?.contains('tab-rename-input')) return;
  
  // Don't interfere with toolbar inputs
  if (e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT') return;
  
  const { row, col } = sel;
  
  if (e.key === 'ArrowDown') { e.preventDefault(); moveSel(1, 0, e.shiftKey); }
  else if (e.key === 'ArrowUp') { e.preventDefault(); moveSel(-1, 0, e.shiftKey); }
  else if (e.key === 'ArrowRight') { e.preventDefault(); moveSel(0, 1, e.shiftKey); }
  else if (e.key === 'ArrowLeft') { e.preventDefault(); moveSel(0, -1, e.shiftKey); }
  else if (e.key === 'Tab') { e.preventDefault(); moveSel(0, e.shiftKey ? -1 : 1); }
  else if (e.key === 'Enter') { e.preventDefault(); moveSel(1, 0); }
  else if (e.key === 'Delete' || e.key === 'Backspace') {
    e.preventDefault();
    clearSelection();
  }
  else if (e.key === 'F2') {
    e.preventDefault();
    startEditingCell(row, col);
  }
  else if (e.ctrlKey && e.key === 'c') { copySelection(); }
  else if (e.ctrlKey && e.key === 'x') { cutSelection(); }
  else if (e.ctrlKey && e.key === 'v') { pasteSelection(); }
  else if (e.ctrlKey && e.key === 'b') { e.preventDefault(); toggleBold(); }
  else if (e.ctrlKey && e.key === 'i') { e.preventDefault(); toggleItalic(); }
  else if (e.ctrlKey && e.key === 'a') { e.preventDefault(); selectAll(); }
  else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
    // Start typing in cell
    startEditingCell(row, col);
    const td = getCellTd(row, col);
    const input = td?.querySelector('input');
    if (input) { input.value = e.key; formulaInput.value = e.key; }
  }
});

function moveSel(dr, dc, extend = false) {
  if (isEditing) finishEditing();
  const newR = Math.max(0, Math.min(NUM_ROWS - 1, sel.row + dr));
  const newC = Math.max(0, Math.min(NUM_COLS - 1, sel.col + dc));
  
  if (extend) {
    rangeEnd = { row: newR, col: newC };
    sel = { row: newR, col: newC };
  } else {
    sel = { row: newR, col: newC };
    rangeStart = { row: newR, col: newC };
    rangeEnd = { row: newR, col: newC };
  }
  refreshSelection();
  updateFormulaBar();
  updateToolbarState();
  scrollToCell(newR, newC);
}

function scrollToCell(r, c) {
  const td = getCellTd(r, c);
  if (td) td.scrollIntoView({ block: 'nearest', inline: 'nearest' });
}

// ===== CLIPBOARD =====
function getSelectionRange() {
  if (!rangeStart || !rangeEnd) return { r1: sel.row, c1: sel.col, r2: sel.row, c2: sel.col };
  return {
    r1: Math.min(rangeStart.row, rangeEnd.row),
    r2: Math.max(rangeStart.row, rangeEnd.row),
    c1: Math.min(rangeStart.col, rangeEnd.col),
    c2: Math.max(rangeStart.col, rangeEnd.col)
  };
}

function copySelection() {
  const { r1, r2, c1, c2 } = getSelectionRange();
  clipboard = { data: [], cut: false };
  for (let r = r1; r <= r2; r++) {
    const row = [];
    for (let c = c1; c <= c2; c++) {
      const cell = workbook.sheet.getCell(cellKey(c, r));
      row.push({ ...cell, deps: new Set(cell.deps), rdeps: new Set(cell.rdeps) });
    }
    clipboard.data.push(row);
  }
  // Also copy to system clipboard as text
  const text = clipboard.data.map(row => row.map(c => c.raw || '').join('\t')).join('\n');
  navigator.clipboard?.writeText(text).catch(()=>{});
}

function cutSelection() {
  copySelection();
  clipboard.cut = true;
  clearSelection();
}

function pasteSelection() {
  if (!clipboard) return;
  const sheet = workbook.sheet;
  for (let r = 0; r < clipboard.data.length; r++) {
    for (let c = 0; c < clipboard.data[r].length; c++) {
      const tr = sel.row + r;
      const tc = sel.col + c;
      if (tr >= NUM_ROWS || tc >= NUM_COLS) continue;
      const key = cellKey(tc, tr);
      const src = clipboard.data[r][c];
      const cell = sheet.getCell(key);
      cell.raw = src.raw;
      cell.formula = src.formula;
      cell.bold = src.bold;
      cell.italic = src.italic;
      cell.align = src.align;
      cell.bgColor = src.bgColor;
      cell.textColor = src.textColor;
      cell.fontSize = src.fontSize;
    }
  }
  recalcAll();
  refreshAllCells();
  refreshSelection();
}

function clearSelection() {
  const { r1, r2, c1, c2 } = getSelectionRange();
  const sheet = workbook.sheet;
  for (let r = r1; r <= r2; r++) {
    for (let c = c1; c <= c2; c++) {
      const key = cellKey(c, r);
      const cell = sheet.getCell(key);
      cell.raw = '';
      cell.formula = null;
      cell.value = '';
      cell.error = null;
    }
  }
  recalcAll();
  refreshAllCells();
  updateFormulaBar();
  updateStatusBar();
}

// ===== COLUMN RESIZE =====
function startColResize(e, colIdx, th) {
  e.preventDefault();
  e.stopPropagation();
  const startX = e.clientX;
  const startW = getColWidth(colIdx);
  const handle = th.querySelector('.col-resize');
  handle.classList.add('resizing');
  
  const onMove = (e2) => {
    const newW = Math.max(30, startW + e2.clientX - startX);
    workbook.sheet.colWidths[colIdx] = newW;
    th.style.width = newW + 'px';
    // Update all cells in this column
    const tbody = document.querySelector('#grid tbody');
    for (let r = 0; r < tbody.children.length; r++) {
      const td = tbody.children[r].children[colIdx + 1];
      if (td) td.style.width = newW + 'px';
    }
  };
  const onUp = () => {
    handle.classList.remove('resizing');
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);
  };
  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
}

// ===== TOOLBAR ACTIONS =====
function toggleBold() {
  const { r1, r2, c1, c2 } = getSelectionRange();
  const cell = workbook.sheet.getCell(cellKey(sel.col, sel.row));
  const newVal = !cell.bold;
  for (let r = r1; r <= r2; r++)
    for (let c = c1; c <= c2; c++) {
      workbook.sheet.getCell(cellKey(c, r)).bold = newVal;
      refreshCellDisplay(cellKey(c, r));
    }
  updateToolbarState();
}

function toggleItalic() {
  const { r1, r2, c1, c2 } = getSelectionRange();
  const cell = workbook.sheet.getCell(cellKey(sel.col, sel.row));
  const newVal = !cell.italic;
  for (let r = r1; r <= r2; r++)
    for (let c = c1; c <= c2; c++) {
      workbook.sheet.getCell(cellKey(c, r)).italic = newVal;
      refreshCellDisplay(cellKey(c, r));
    }
  updateToolbarState();
}

function setAlign(align) {
  const { r1, r2, c1, c2 } = getSelectionRange();
  for (let r = r1; r <= r2; r++)
    for (let c = c1; c <= c2; c++) {
      workbook.sheet.getCell(cellKey(c, r)).align = align;
      refreshCellDisplay(cellKey(c, r));
    }
}

function setBgColor(color) {
  const { r1, r2, c1, c2 } = getSelectionRange();
  for (let r = r1; r <= r2; r++)
    for (let c = c1; c <= c2; c++) {
      workbook.sheet.getCell(cellKey(c, r)).bgColor = color;
      refreshCellDisplay(cellKey(c, r));
    }
}

function setTextColor(color) {
  const { r1, r2, c1, c2 } = getSelectionRange();
  for (let r = r1; r <= r2; r++)
    for (let c = c1; c <= c2; c++) {
      workbook.sheet.getCell(cellKey(c, r)).textColor = color;
      refreshCellDisplay(cellKey(c, r));
    }
}

function setFontSize(size) {
  const { r1, r2, c1, c2 } = getSelectionRange();
  for (let r = r1; r <= r2; r++)
    for (let c = c1; c <= c2; c++) {
      workbook.sheet.getCell(cellKey(c, r)).fontSize = size;
      refreshCellDisplay(cellKey(c, r));
    }
}

function updateToolbarState() {
  const cell = workbook.sheet.getCell(cellKey(sel.col, sel.row));
  document.getElementById('btn-bold').classList.toggle('active', !!cell.bold);
  document.getElementById('btn-italic').classList.toggle('active', !!cell.italic);
  document.getElementById('btn-align-left').classList.toggle('active', cell.align === 'left');
  document.getElementById('btn-align-center').classList.toggle('active', cell.align === 'center');
  document.getElementById('btn-align-right').classList.toggle('active', cell.align === 'right');
  if (cell.fontSize) document.getElementById('font-size-select').value = cell.fontSize;
}

// Wire toolbar buttons
document.getElementById('btn-bold').onclick = toggleBold;
document.getElementById('btn-italic').onclick = toggleItalic;
document.getElementById('btn-align-left').onclick = () => setAlign('left');
document.getElementById('btn-align-center').onclick = () => setAlign('center');
document.getElementById('btn-align-right').onclick = () => setAlign('right');
document.getElementById('btn-clear').onclick = clearSelection;

document.getElementById('btn-bg-color').onclick = () => document.getElementById('bg-color-picker').click();
document.getElementById('bg-color-picker').addEventListener('input', (e) => {
  document.getElementById('bg-swatch').style.background = e.target.value;
  setBgColor(e.target.value);
});

document.getElementById('btn-text-color').onclick = () => document.getElementById('text-color-picker').click();
document.getElementById('text-color-picker').addEventListener('input', (e) => {
  document.getElementById('text-swatch').style.background = e.target.value;
  setTextColor(e.target.value);
});

document.getElementById('font-size-select').onchange = (e) => setFontSize(e.target.value);

// ===== CSV =====
document.getElementById('btn-download').onclick = () => {
  const sheet = workbook.sheet;
  let maxR = 0, maxC = 0;
  for (const key in sheet.cells) {
    const cell = sheet.cells[key];
    if (cell.raw) {
      const ref = parseCellRef(key);
      if (ref) { maxR = Math.max(maxR, ref.row); maxC = Math.max(maxC, ref.col); }
    }
  }
  const rows = [];
  for (let r = 0; r <= maxR; r++) {
    const row = [];
    for (let c = 0; c <= maxC; c++) {
      const cell = sheet.getCell(cellKey(c, r));
      let v = String(cell.value ?? '');
      if (v.includes(',') || v.includes('"') || v.includes('\n')) v = '"' + v.replace(/"/g, '""') + '"';
      row.push(v);
    }
    rows.push(row.join(','));
  }
  const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = sheet.name + '.csv';
  a.click();
  URL.revokeObjectURL(a.href);
};

document.getElementById('btn-upload').onclick = () => document.getElementById('csv-upload').click();
document.getElementById('csv-upload').onchange = (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    const text = ev.target.result;
    const lines = text.split(/\r?\n/);
    const sheet = workbook.sheet;
    // Clear
    sheet.cells = {};
    for (let r = 0; r < lines.length; r++) {
      // Parse CSV properly
      const cols = parseCSVLine(lines[r]);
      for (let c = 0; c < cols.length && c < NUM_COLS; c++) {
        if (cols[c]) setCellValue(cellKey(c, r), cols[c]);
      }
    }
    recalcAll();
    buildGrid();
    setSelection(0, 0);
  };
  reader.readAsText(file);
  e.target.value = '';
};

function parseCSVLine(line) {
  const result = [];
  let i = 0, field = '', inQuotes = false;
  while (i <= line.length) {
    if (i === line.length || (line[i] === ',' && !inQuotes)) {
      result.push(field); field = ''; i++; continue;
    }
    if (line[i] === '"') {
      if (inQuotes && i+1 < line.length && line[i+1] === '"') { field += '"'; i += 2; }
      else { inQuotes = !inQuotes; i++; }
      continue;
    }
    field += line[i]; i++;
  }
  return result;
}

// ===== STATUS BAR =====
function updateStatusBar() {
  const { r1, r2, c1, c2 } = getSelectionRange();
  const values = [];
  for (let r = r1; r <= r2; r++)
    for (let c = c1; c <= c2; c++) {
      const v = workbook.sheet.getCell(cellKey(c, r)).value;
      if (v !== '' && !isNaN(v)) values.push(parseFloat(v));
    }
  
  if (values.length > 0) {
    const sum = values.reduce((a,b)=>a+b, 0);
    document.getElementById('stat-sum').innerHTML = `<b>Sum:</b> ${formatNumber(sum)}`;
    document.getElementById('stat-avg').innerHTML = `<b>Avg:</b> ${formatNumber(sum/values.length)}`;
    document.getElementById('stat-count').innerHTML = `<b>Count:</b> ${values.length}`;
    document.getElementById('stat-min').innerHTML = `<b>Min:</b> ${formatNumber(Math.min(...values))}`;
    document.getElementById('stat-max').innerHTML = `<b>Max:</b> ${formatNumber(Math.max(...values))}`;
  } else {
    document.getElementById('stat-sum').textContent = '';
    document.getElementById('stat-avg').textContent = '';
    document.getElementById('stat-count').textContent = '';
    document.getElementById('stat-min').textContent = '';
    document.getElementById('stat-max').textContent = '';
  }
}

// ===== SHEET TABS =====
function renderSheetTabs() {
  const bar = document.getElementById('sheet-bar');
  // Remove existing tabs (keep add button)
  bar.querySelectorAll('.sheet-tab').forEach(t => t.remove());
  const addBtn = document.getElementById('add-sheet-btn');
  
  workbook.sheets.forEach((sheet, idx) => {
    const tab = document.createElement('div');
    tab.className = 'sheet-tab' + (idx === workbook.activeSheetIdx ? ' active' : '');
    tab.dataset.idx = idx;
    
    const nameSpan = document.createElement('span');
    nameSpan.textContent = sheet.name;
    tab.appendChild(nameSpan);
    
    if (workbook.sheets.length > 1) {
      const closeBtn = document.createElement('span');
      closeBtn.className = 'tab-close';
      closeBtn.textContent = '√ó';
      closeBtn.onclick = (e) => { e.stopPropagation(); deleteSheet(idx); };
      tab.appendChild(closeBtn);
    }
    
    tab.onclick = () => switchSheet(idx);
    tab.ondblclick = (e) => { e.stopPropagation(); startRenameSheet(idx, nameSpan); };
    tab.oncontextmenu = (e) => {
      e.preventDefault();
      showSheetContextMenu(e, idx);
    };
    
    bar.insertBefore(tab, addBtn);
  });
}

function switchSheet(idx) {
  if (isEditing) finishEditing();
  workbook.activeSheetIdx = idx;
  buildGrid();
  setSelection(0, 0);
  renderSheetTabs();
}

function addSheet() {
  const idx = workbook.addSheet();
  switchSheet(idx);
}

function deleteSheet(idx) {
  if (workbook.deleteSheet(idx)) {
    buildGrid();
    setSelection(0, 0);
    renderSheetTabs();
  }
}

function startRenameSheet(idx, span) {
  const input = document.createElement('input');
  input.className = 'tab-rename-input';
  input.value = workbook.sheets[idx].name;
  span.textContent = '';
  span.appendChild(input);
  input.focus();
  input.select();
  
  const finish = () => {
    const newName = input.value.trim() || workbook.sheets[idx].name;
    workbook.sheets[idx].name = newName;
    renderSheetTabs();
  };
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); finish(); }
    if (e.key === 'Escape') { e.preventDefault(); renderSheetTabs(); }
    e.stopPropagation();
  });
  input.addEventListener('blur', finish);
}

document.getElementById('add-sheet-btn').onclick = addSheet;

// ===== CONTEXT MENU =====
const ctxMenu = document.getElementById('ctx-menu');

document.getElementById('grid').addEventListener('contextmenu', (e) => {
  e.preventDefault();
  ctxMenu.style.left = Math.min(e.clientX, innerWidth - 200) + 'px';
  ctxMenu.style.top = Math.min(e.clientY, innerHeight - 250) + 'px';
  ctxMenu.classList.add('show');
});

document.addEventListener('click', (e) => {
  if (!e.target.closest('.ctx-menu')) ctxMenu.classList.remove('show');
});

ctxMenu.querySelectorAll('.ctx-item').forEach(item => {
  item.onclick = () => {
    const action = item.dataset.action;
    ctxMenu.classList.remove('show');
    if (action === 'copy') copySelection();
    else if (action === 'cut') cutSelection();
    else if (action === 'paste') pasteSelection();
    else if (action === 'clear') clearSelection();
    else if (action === 'insert-row') insertRow();
    else if (action === 'insert-col') insertColumn();
    else if (action === 'delete-row') deleteRow();
    else if (action === 'delete-col') deleteColumn();
  };
});

function insertRow() {
  const sheet = workbook.sheet;
  // Shift all rows down from sel.row
  for (let r = NUM_ROWS - 1; r > sel.row; r--) {
    for (let c = 0; c < NUM_COLS; c++) {
      const fromKey = cellKey(c, r - 1);
      const toKey = cellKey(c, r);
      if (sheet.cells[fromKey]) {
        sheet.cells[toKey] = { ...sheet.cells[fromKey] };
      } else {
        delete sheet.cells[toKey];
      }
    }
  }
  // Clear the inserted row
  for (let c = 0; c < NUM_COLS; c++) {
    delete sheet.cells[cellKey(c, sel.row)];
  }
  recalcAll();
  buildGrid();
  refreshSelection();
}

function insertColumn() {
  const sheet = workbook.sheet;
  for (let c = NUM_COLS - 1; c > sel.col; c--) {
    for (let r = 0; r < NUM_ROWS; r++) {
      const fromKey = cellKey(c - 1, r);
      const toKey = cellKey(c, r);
      if (sheet.cells[fromKey]) {
        sheet.cells[toKey] = { ...sheet.cells[fromKey] };
      } else {
        delete sheet.cells[toKey];
      }
    }
  }
  for (let r = 0; r < NUM_ROWS; r++) {
    delete sheet.cells[cellKey(sel.col, r)];
  }
  recalcAll();
  buildGrid();
  refreshSelection();
}

function deleteRow() {
  const sheet = workbook.sheet;
  for (let r = sel.row; r < NUM_ROWS - 1; r++) {
    for (let c = 0; c < NUM_COLS; c++) {
      const fromKey = cellKey(c, r + 1);
      const toKey = cellKey(c, r);
      if (sheet.cells[fromKey]) {
        sheet.cells[toKey] = { ...sheet.cells[fromKey] };
      } else {
        delete sheet.cells[toKey];
      }
    }
  }
  recalcAll();
  buildGrid();
  refreshSelection();
}

function deleteColumn() {
  const sheet = workbook.sheet;
  for (let c = sel.col; c < NUM_COLS - 1; c++) {
    for (let r = 0; r < NUM_ROWS; r++) {
      const fromKey = cellKey(c, r);
      const nextKey = cellKey(c + 1, r);
      if (sheet.cells[nextKey]) {
        sheet.cells[fromKey] = { ...sheet.cells[nextKey] };
      } else {
        delete sheet.cells[fromKey];
      }
    }
  }
  recalcAll();
  buildGrid();
  refreshSelection();
}

function showSheetContextMenu(e, idx) {
  // Simple inline menu
  const existing = document.querySelector('.sheet-ctx');
  if (existing) existing.remove();
  
  const menu = document.createElement('div');
  menu.className = 'ctx-menu sheet-ctx show';
  menu.style.left = e.clientX + 'px';
  menu.style.top = (e.clientY - 100) + 'px';
  menu.innerHTML = `
    <div class="ctx-item" data-action="rename">‚úèÔ∏è Rename</div>
    <div class="ctx-item" data-action="duplicate">üìã Duplicate</div>
    ${workbook.sheets.length > 1 ? '<div class="ctx-sep"></div><div class="ctx-item" data-action="delete" style="color:var(--danger)">üóë Delete</div>' : ''}
  `;
  document.body.appendChild(menu);
  
  menu.querySelectorAll('.ctx-item').forEach(item => {
    item.onclick = () => {
      const a = item.dataset.action;
      menu.remove();
      if (a === 'rename') {
        switchSheet(idx);
        setTimeout(() => {
          const tab = document.querySelector(`.sheet-tab[data-idx="${idx}"]`);
          if (tab) startRenameSheet(idx, tab.querySelector('span'));
        }, 50);
      }
      else if (a === 'duplicate') {
        const newIdx = workbook.addSheet(workbook.sheets[idx].name + ' Copy');
        const src = workbook.sheets[idx];
        const dst = workbook.sheets[newIdx];
        for (const k in src.cells) {
          dst.cells[k] = { ...src.cells[k], deps: new Set(src.cells[k].deps), rdeps: new Set(src.cells[k].rdeps) };
        }
        dst.colWidths = { ...src.colWidths };
        switchSheet(newIdx);
      }
      else if (a === 'delete') deleteSheet(idx);
    };
  });
  
  setTimeout(() => {
    document.addEventListener('click', function handler() {
      menu.remove();
      document.removeEventListener('click', handler);
    }, { once: true });
  }, 10);
}

// ===== INITIALIZE =====
buildGrid();
renderSheetTabs();
setSelection(0, 0);

// Populate some demo data
const demoData = [
  ['A1', 'Item'], ['B1', 'Q1'], ['C1', 'Q2'], ['D1', 'Q3'], ['E1', 'Q4'], ['F1', 'Total'],
  ['A2', 'Revenue'], ['B2', '12500'], ['C2', '15200'], ['D2', '18900'], ['E2', '22100'], ['F2', '=SUM(B2:E2)'],
  ['A3', 'Costs'], ['B3', '8200'], ['C3', '9100'], ['D3', '10500'], ['E3', '11800'], ['F3', '=SUM(B3:E3)'],
  ['A4', 'Profit'], ['B4', '=B2-B3'], ['C4', '=C2-C3'], ['D4', '=D2-D3'], ['E4', '=E2-E3'], ['F4', '=SUM(B4:E4)'],
  ['A6', 'Average'], ['B6', '=AVERAGE(B2:E2)'],
  ['A7', 'Max Revenue'], ['B7', '=MAX(B2:E2)'],
  ['A8', 'Min Cost'], ['B8', '=MIN(B3:E3)'],
];

demoData.forEach(([key, val]) => {
  setCellValue(key, val);
  const cell = workbook.sheet.getCell(key);
  // Bold headers
  if (key.endsWith('1')) cell.bold = true;
  if (key.startsWith('A') && !key.endsWith('5') && !key.endsWith('9')) cell.bold = true;
});

// Add header bg color
for (let c = 0; c < 6; c++) {
  workbook.sheet.getCell(cellKey(c, 0)).bgColor = '#e8f5ee';
}

recalcAll();
buildGrid();
setSelection(0, 0);
renderSheetTabs();
document.getElementById('stat-info').textContent = 'Ready';
</script>
</body>
</html>
