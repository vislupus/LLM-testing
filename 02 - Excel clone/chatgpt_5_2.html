<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Browser Spreadsheet (Excel-like) — Single-file</title>
  <style>
    :root{
      --bg:#0c1118;
      --panel:#0f1622;
      --panel2:#101a28;
      --line:rgba(255,255,255,.12);
      --line2:rgba(255,255,255,.08);
      --text:#e8f0ff;
      --muted:rgba(232,240,255,.7);
      --accent:#3aa0ff;
      --accent2:#72d1ff;
      --cell:#0b1018;
      --cellAlt:#0a0f16;
      --sel:rgba(58,160,255,.18);
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }

    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family:var(--font); overflow:hidden;}
    .app{height:100%; display:flex; flex-direction:column;}

    /* Toolbar */
    .toolbar{
      display:flex; align-items:center; gap:8px;
      padding:10px 12px;
      background:linear-gradient(180deg, rgba(16,26,40,.95), rgba(10,14,20,.95));
      border-bottom:1px solid var(--line);
      box-shadow: var(--shadow);
      z-index:5;
    }
    .toolgroup{display:flex; gap:6px; align-items:center; padding-right:10px; border-right:1px solid var(--line2);}
    .toolgroup:last-child{border-right:none; padding-right:0;}
    .btn{
      border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:7px 10px;
      border-radius:10px;
      cursor:pointer;
      font-size:12px;
      line-height:1;
      user-select:none;
    }
    .btn:hover{background:rgba(255,255,255,.1);}
    .btn.toggled{border-color:rgba(58,160,255,.6); background:rgba(58,160,255,.18);}
    .btn.small{padding:7px 8px;}
    .btn.primary{border-color:rgba(58,160,255,.55); background:rgba(58,160,255,.16);}
    .btn.danger{border-color:rgba(255,120,120,.45); background:rgba(255,120,120,.14);}
    .sep{width:1px; height:28px; background:var(--line2); margin:0 4px;}
    .label{font-size:12px; color:var(--muted); padding:0 6px;}
    input[type="color"]{
      width:34px; height:30px; padding:0; border:none; background:none; cursor:pointer;
      border-radius:10px; overflow:hidden;
      filter: drop-shadow(0 0 0 rgba(0,0,0,0));
    }

    /* Formula bar */
    .formula{
      display:grid;
      grid-template-columns: 110px 1fr;
      gap:8px;
      padding:8px 12px;
      background:rgba(12,17,24,.9);
      border-bottom:1px solid var(--line);
      z-index:4;
    }
    .namebox{
      display:flex; align-items:center; gap:8px;
      border:1px solid var(--line);
      border-radius:10px;
      background:rgba(255,255,255,.05);
      padding:0 10px;
      height:34px;
      font-variant-numeric: tabular-nums;
    }
    .namebox .addr{font-family:var(--mono); font-size:12px;}
    .namebox .hint{font-size:11px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .fxbox{
      display:flex; align-items:center; gap:8px;
      border:1px solid var(--line);
      border-radius:10px;
      background:rgba(255,255,255,.05);
      padding:0 10px;
      height:34px;
    }
    .fx{
      font-family:var(--mono);
      color:var(--muted);
      font-size:12px;
      user-select:none;
    }
    #formulaInput{
      border:none; outline:none; background:transparent; color:var(--text);
      width:100%; font-size:13px;
      font-family:var(--mono);
    }

    /* Grid area */
    .gridWrap{
      position:relative;
      flex:1;
      overflow:auto;
      background:linear-gradient(180deg, rgba(8,12,18,.96), rgba(10,14,20,.96));
    }

    table.grid{
      border-collapse:separate;
      border-spacing:0;
      table-layout:fixed;
      width:max-content;
      background:transparent;
      font-size:13px;
      color:var(--text);
    }
    col.rowhdr{width:54px;}
    th, td{
      border-right:1px solid var(--line2);
      border-bottom:1px solid var(--line2);
      height:26px;
      padding:0;
      user-select:none;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    th{
      position:sticky;
      top:0;
      background:rgba(18,28,44,.95);
      z-index:3;
      font-weight:600;
      color:rgba(232,240,255,.88);
      text-align:center;
    }
    th.corner{
      left:0;
      z-index:4;
      background:rgba(18,28,44,.98);
      border-right:1px solid var(--line);
    }
    th.colhdr{min-width:80px;}
    th.rowhdr{
      position:sticky;
      left:0;
      z-index:2;
      background:rgba(16,24,36,.96);
      font-weight:600;
      color:rgba(232,240,255,.78);
    }
    td{
      background:rgba(255,255,255,.02);
      position:relative;
    }
    td .cell{
      padding:0 8px;
      display:flex;
      align-items:center;
      height:26px;
      width:100%;
      box-sizing:border-box;
    }
    td .cell.mono{font-family:var(--mono);}
    td .cell.right{justify-content:flex-end;}
    td .cell.center{justify-content:center;}

    /* Column resizer handle */
    .resizer{
      position:absolute;
      top:0; right:-3px;
      width:8px;
      height:100%;
      cursor:col-resize;
      z-index:6;
    }
    th.colhdr{position:sticky;}
    th.colhdr .resizer{background:transparent;}
    th.colhdr:hover .resizer{background:rgba(255,255,255,.04);}

    /* Selection overlays */
    .selectionBox, .activeBox{
      position:absolute;
      pointer-events:none;
      border:2px solid rgba(58,160,255,.9);
      box-shadow: 0 0 0 9999px rgba(58,160,255,.08);
      border-radius:2px;
      z-index:10;
      display:none;
    }
    .activeBox{
      border-color: rgba(114,209,255,.95);
      box-shadow:none;
    }

    /* Editor overlay */
    #cellEditor{
      position:absolute;
      z-index:20;
      display:none;
      border:2px solid rgba(114,209,255,.9);
      background:rgba(10,14,20,.98);
      color:var(--text);
      outline:none;
      padding:0 8px;
      font-size:13px;
      font-family:var(--mono);
      box-sizing:border-box;
      height:26px;
      border-radius:2px;
    }

    /* Sheets tabs */
    .sheets{
      display:flex; align-items:center; gap:6px;
      padding:8px 12px;
      border-top:1px solid var(--line);
      background:rgba(12,17,24,.92);
      z-index:5;
    }
    .tab{
      display:flex; align-items:center; gap:8px;
      padding:7px 10px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.05);
      border-radius:999px;
      cursor:pointer;
      font-size:12px;
      max-width:160px;
    }
    .tab.active{
      border-color:rgba(58,160,255,.55);
      background:rgba(58,160,255,.16);
    }
    .tab .name{
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .tab .x{
      opacity:.7;
      font-weight:700;
      padding:0 2px;
      border-radius:8px;
    }
    .tab:hover .x{opacity:1}
    .tab .x:hover{background:rgba(255,255,255,.08)}
    .spacer{flex:1;}
    .status{
      font-size:12px;
      color:var(--muted);
      font-variant-numeric: tabular-nums;
    }

    /* Responsive: hide some toolbar text on narrow screens */
    @media (max-width: 820px){
      .label{display:none;}
    }
  </style>
</head>
<body>
<div class="app">
  <!-- Toolbar -->
  <div class="toolbar">
    <div class="toolgroup">
      <button class="btn small" id="boldBtn"><b>B</b></button>
      <button class="btn small" id="italicBtn"><i>I</i></button>
      <span class="label">Fill</span>
      <input type="color" id="fillColor" value="#2a2f3a" title="Cell background color" />
      <button class="btn" id="clearBtn">Clear</button>
    </div>

    <div class="toolgroup">
      <button class="btn" id="csvDownBtn">Download CSV</button>
      <button class="btn" id="csvUpBtn">Upload CSV</button>
      <input type="file" id="csvFile" accept=".csv,text/csv" style="display:none;" />
    </div>

    <div class="toolgroup">
      <button class="btn danger" id="clearSheetBtn" title="Clear all data in current sheet">Clear Sheet</button>
    </div>

    <div class="spacer"></div>
    <div class="status" id="status">Ready</div>
  </div>

  <!-- Formula bar -->
  <div class="formula">
    <div class="namebox">
      <div class="addr" id="addrBox">A1</div>
      <div class="hint" id="nameHint">Selected</div>
    </div>
    <div class="fxbox">
      <div class="fx">fx</div>
      <input id="formulaInput" spellcheck="false" autocomplete="off" />
    </div>
  </div>

  <!-- Grid -->
  <div class="gridWrap" id="gridWrap">
    <div class="selectionBox" id="selectionBox"></div>
    <div class="activeBox" id="activeBox"></div>
    <input id="cellEditor" spellcheck="false" autocomplete="off" />
    <table class="grid" id="grid"></table>
  </div>

  <!-- Sheets -->
  <div class="sheets" id="sheetsBar">
    <!-- tabs injected -->
    <button class="btn primary" id="addSheetBtn">+ Sheet</button>
    <div class="spacer"></div>
    <div class="status" id="sheetStatus"></div>
  </div>
</div>

<script>
(() => {
  "use strict";

  // ===========================
  // Helpers: address conversions
  // ===========================
  const GRID_ROWS = 200;     // change if you want more
  const GRID_COLS = 52;      // A..AZ (52 columns)

  function colToName(n){
    // 0 -> A, 25 -> Z, 26 -> AA ...
    let s = "";
    n = n + 1;
    while (n > 0){
      const r = (n - 1) % 26;
      s = String.fromCharCode(65 + r) + s;
      n = Math.floor((n - 1) / 26);
    }
    return s;
  }
  function nameToCol(name){
    let n = 0;
    for (let i=0;i<name.length;i++){
      const c = name.charCodeAt(i);
      if (c < 65 || c > 90) return NaN;
      n = n * 26 + (c - 64);
    }
    return n - 1;
  }
  function rcToAddr(r,c){ return colToName(c) + String(r+1); }
  function addrToRC(addr){
    const m = /^([A-Z]+)(\d+)$/.exec(addr);
    if (!m) return null;
    const c = nameToCol(m[1]);
    const r = parseInt(m[2],10)-1;
    if (!Number.isFinite(c) || !Number.isFinite(r)) return null;
    return {r,c};
  }
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

  function rectUnion(a,b){
    return {
      r1: Math.min(a.r1, b.r1),
      c1: Math.min(a.c1, b.c1),
      r2: Math.max(a.r2, b.r2),
      c2: Math.max(a.c2, b.c2),
    };
  }
  function normRange(r1,c1,r2,c2){
    return { r1: Math.min(r1,r2), c1: Math.min(c1,c2), r2: Math.max(r1,r2), c2: Math.max(c1,c2) };
  }

  // ===========================
  // Workbook / Sheet model
  // ===========================
  class Cell {
    constructor(){
      this.raw = "";                 // user entered string (including leading '=' for formulas)
      this.formula = null;           // raw without '=' (string) or null
      this.ast = null;               // parsed AST for formula
      this.value = "";               // computed value for display (string/number or error string)
      this.deps = new Set();         // addresses referenced
      this.dependents = new Set();   // addresses that reference this
      this.style = { bold:false, italic:false, bg:"" };
      this.dirty = true;
    }
  }

  class Sheet {
    constructor(name){
      this.name = name;
      this.cells = new Map();          // addr -> Cell
      this.colWidths = Array.from({length: GRID_COLS}, () => 96);
      this.rowHeights = Array.from({length: GRID_ROWS}, () => 26);
      this.dirtySet = new Set();
    }
    getCell(addr, create=true){
      let c = this.cells.get(addr);
      if (!c && create){
        c = new Cell();
        this.cells.set(addr, c);
      }
      return c;
    }
    markDirty(addr){
      const cell = this.getCell(addr, true);
      if (!cell.dirty){
        cell.dirty = true;
      }
      this.dirtySet.add(addr);
    }
    markDirtyCascade(addr){
      // mark addr + all dependents dirty (DFS)
      const stack = [addr];
      const seen = new Set();
      while (stack.length){
        const a = stack.pop();
        if (seen.has(a)) continue;
        seen.add(a);
        this.markDirty(a);
        const cell = this.getCell(a, false);
        if (cell){
          for (const dep of cell.dependents) stack.push(dep);
        }
      }
    }
  }

  const workbook = {
    sheets: [],
    active: 0
  };

  function makeDefaultWorkbook(){
    workbook.sheets = [new Sheet("Sheet1")];
    workbook.active = 0;
  }

  function activeSheet(){ return workbook.sheets[workbook.active]; }

  // ===========================
  // Formula parsing (safe, no eval)
  // Supports:
  //  - arithmetic + - * / ( )
  //  - cell refs A1
  //  - functions SUM/AVERAGE/MIN/MAX with args and ranges A1:B10
  // ===========================
  function tokenize(expr){
    const s = expr.trim();
    const tokens = [];
    let i = 0;
    while (i < s.length){
      const ch = s[i];
      if (/\s/.test(ch)){ i++; continue; }

      // number
      if (/[0-9.]/.test(ch)){
        let j = i+1;
        while (j < s.length && /[0-9.]/.test(s[j])) j++;
        const text = s.slice(i,j);
        const n = Number(text);
        if (!Number.isFinite(n)) throw new Error("Bad number");
        tokens.push({t:"num", v:n});
        i = j; continue;
      }

      // identifier (function or cell)
      if (/[A-Za-z_]/.test(ch)){
        let j = i+1;
        while (j < s.length && /[A-Za-z0-9_]/.test(s[j])) j++;
        const text = s.slice(i,j).toUpperCase();
        tokens.push({t:"id", v:text});
        i = j; continue;
      }

      // operators / punctuation
      if ("+-*/(),:".includes(ch)){
        tokens.push({t:ch, v:ch});
        i++; continue;
      }

      throw new Error("Unexpected character: " + ch);
    }
    return tokens;
  }

  function isCellId(id){
    return /^[A-Z]+[0-9]+$/.test(id);
  }

  function parseFormula(expr){
    // returns AST
    const tokens = tokenize(expr);
    let p = 0;

    const peek = () => tokens[p] || null;
    const next = () => tokens[p++] || null;
    const expect = (t) => {
      const tok = next();
      if (!tok || tok.t !== t) throw new Error("Expected " + t);
      return tok;
    };

    function parseExpression(){
      let node = parseTerm();
      while (true){
        const tok = peek();
        if (!tok || (tok.t !== "+" && tok.t !== "-")) break;
        next();
        const right = parseTerm();
        node = { type:"bin", op: tok.t, left: node, right };
      }
      return node;
    }

    function parseTerm(){
      let node = parseFactor();
      while (true){
        const tok = peek();
        if (!tok || (tok.t !== "*" && tok.t !== "/")) break;
        next();
        const right = parseFactor();
        node = { type:"bin", op: tok.t, left: node, right };
      }
      return node;
    }

    function parseFactor(){
      const tok = peek();
      if (!tok) throw new Error("Unexpected end");

      // unary
      if (tok.t === "+" || tok.t === "-"){
        next();
        const expr = parseFactor();
        return { type:"unary", op: tok.t, expr };
      }

      // parenthesis
      if (tok.t === "("){
        next();
        const node = parseExpression();
        expect(")");
        return node;
      }

      // number
      if (tok.t === "num"){
        next();
        return { type:"num", value: tok.v };
      }

      // id: function or cell
      if (tok.t === "id"){
        next();
        const id = tok.v;

        // function call
        if (peek() && peek().t === "("){
          next(); // "("
          const args = [];
          if (peek() && peek().t !== ")"){
            while (true){
              args.push(parseArg());
              if (peek() && peek().t === ","){ next(); continue; }
              break;
            }
          }
          expect(")");
          return { type:"call", name: id, args };
        }

        // cell reference
        if (isCellId(id)){
          return { type:"cell", addr: id };
        }

        throw new Error("Unknown identifier: " + id);
      }

      throw new Error("Unexpected token: " + tok.t);
    }

    function parseArg(){
      // recognize range: CELL ":" CELL
      const t1 = peek();
      const t2 = tokens[p+1];
      const t3 = tokens[p+2];

      if (t1 && t1.t==="id" && isCellId(t1.v) && t2 && t2.t===":" && t3 && t3.t==="id" && isCellId(t3.v)){
        const a = next().v;
        next(); // :
        const b = next().v;
        return { type:"range", start:a, end:b };
      }
      return parseExpression();
    }

    const ast = parseExpression();
    if (p !== tokens.length) throw new Error("Unexpected trailing tokens");
    return ast;
  }

  function expandRange(a1, a2){
    const r1 = addrToRC(a1), r2 = addrToRC(a2);
    if (!r1 || !r2) return [];
    const rr = normRange(r1.r, r1.c, r2.r, r2.c);
    const out = [];
    for (let r = rr.r1; r <= rr.r2; r++){
      for (let c = rr.c1; c <= rr.c2; c++){
        if (r>=0 && r<GRID_ROWS && c>=0 && c<GRID_COLS) out.push(rcToAddr(r,c));
        else out.push(rcToAddr(clamp(r,0,GRID_ROWS-1), clamp(c,0,GRID_COLS-1)));
      }
    }
    return out;
  }

  function collectDeps(ast, deps){
    if (!ast) return;
    switch (ast.type){
      case "cell": deps.add(ast.addr); break;
      case "range":
        for (const a of expandRange(ast.start, ast.end)) deps.add(a);
        break;
      case "num": break;
      case "unary": collectDeps(ast.expr, deps); break;
      case "bin": collectDeps(ast.left, deps); collectDeps(ast.right, deps); break;
      case "call": for (const arg of ast.args) collectDeps(arg, deps); break;
    }
  }

  function toNumber(v){
    if (v === "" || v == null) return 0;
    if (typeof v === "number" && Number.isFinite(v)) return v;
    if (typeof v === "string"){
      if (v.startsWith("#")) return NaN; // error
      const n = Number(v);
      return Number.isFinite(n) ? n : NaN;
    }
    return NaN;
  }

  function evalAST(ast, sheet, stack){
    // returns number|string (or "#ERR")
    function getCellComputed(addr){
      const c = sheet.getCell(addr, false);
      if (!c || c.raw === "") return "";
      // ensure evaluated
      evaluateCell(addr, sheet, stack);
      return sheet.getCell(addr, false)?.value ?? "";
    }
    function rangeValues(start,end){
      const addrs = expandRange(start,end);
      return addrs.map(a => getCellComputed(a));
    }
    function flattenArgs(args){
      const flat = [];
      for (const a of args){
        if (Array.isArray(a)) flat.push(...a);
        else flat.push(a);
      }
      return flat;
    }
    function numOnly(vals){
      const out = [];
      for (const v of vals){
        const n = toNumber(v);
        if (Number.isFinite(n)) out.push(n);
      }
      return out;
    }

    switch(ast.type){
      case "num": return ast.value;
      case "cell": return getCellComputed(ast.addr);
      case "range": return rangeValues(ast.start, ast.end);
      case "unary":{
        const v = evalAST(ast.expr, sheet, stack);
        if (typeof v === "string" && v.startsWith("#")) return v;
        const n = toNumber(v);
        if (!Number.isFinite(n)) return "#VALUE!";
        return ast.op === "-" ? -n : n;
      }
      case "bin":{
        const a = evalAST(ast.left, sheet, stack);
        if (typeof a === "string" && a.startsWith("#")) return a;
        const b = evalAST(ast.right, sheet, stack);
        if (typeof b === "string" && b.startsWith("#")) return b;
        const x = toNumber(a), y = toNumber(b);
        if (!Number.isFinite(x) || !Number.isFinite(y)) return "#VALUE!";
        if (ast.op === "+") return x + y;
        if (ast.op === "-") return x - y;
        if (ast.op === "*") return x * y;
        if (ast.op === "/") return y === 0 ? "#DIV/0!" : (x / y);
        return "#VALUE!";
      }
      case "call":{
        const name = ast.name.toUpperCase();
        const evalArgs = ast.args.map(arg => evalAST(arg, sheet, stack));
        const flat = flattenArgs(evalArgs);

        if (name === "SUM"){
          const nums = numOnly(flat);
          return nums.reduce((s,n)=>s+n, 0);
        }
        if (name === "AVERAGE"){
          const nums = numOnly(flat);
          if (nums.length === 0) return 0;
          return nums.reduce((s,n)=>s+n, 0) / nums.length;
        }
        if (name === "MIN"){
          const nums = numOnly(flat);
          if (nums.length === 0) return 0;
          return Math.min(...nums);
        }
        if (name === "MAX"){
          const nums = numOnly(flat);
          if (nums.length === 0) return 0;
          return Math.max(...nums);
        }
        return "#NAME?";
      }
      default: return "#VALUE!";
    }
  }

  function evaluateCell(addr, sheet, stack){
    const cell = sheet.getCell(addr, false);
    if (!cell) return;

    if (!cell.dirty) return;

    if (stack.has(addr)){
      cell.value = "#CYCLE!";
      cell.dirty = false;
      sheet.dirtySet.delete(addr);
      return;
    }

    stack.add(addr);

    if (!cell.formula){
      // raw value
      cell.value = cell.raw;
    } else {
      try{
        if (!cell.ast) cell.ast = parseFormula(cell.formula);
        const v = evalAST(cell.ast, sheet, stack);
        cell.value = v;
      } catch(e){
        cell.value = "#ERROR!";
      }
    }

    stack.delete(addr);
    cell.dirty = false;
    sheet.dirtySet.delete(addr);
  }

  function recalcSheet(sheet){
    // Evaluate all dirty cells; evaluation is recursive and handles dependencies
    const stack = new Set();
    // Copy set to array to avoid mutation during evaluation
    const list = Array.from(sheet.dirtySet);
    for (const addr of list){
      evaluateCell(addr, sheet, stack);
    }
  }

  // ===========================
  // UI / DOM
  // ===========================
  const gridWrap = document.getElementById("gridWrap");
  const gridEl = document.getElementById("grid");
  const selectionBox = document.getElementById("selectionBox");
  const activeBox = document.getElementById("activeBox");
  const cellEditor = document.getElementById("cellEditor");

  const addrBox = document.getElementById("addrBox");
  const formulaInput = document.getElementById("formulaInput");
  const status = document.getElementById("status");
  const sheetStatus = document.getElementById("sheetStatus");

  const boldBtn = document.getElementById("boldBtn");
  const italicBtn = document.getElementById("italicBtn");
  const fillColor = document.getElementById("fillColor");
  const clearBtn = document.getElementById("clearBtn");
  const clearSheetBtn = document.getElementById("clearSheetBtn");
  const csvDownBtn = document.getElementById("csvDownBtn");
  const csvUpBtn = document.getElementById("csvUpBtn");
  const csvFile = document.getElementById("csvFile");

  const sheetsBar = document.getElementById("sheetsBar");
  const addSheetBtn = document.getElementById("addSheetBtn");

  // Current selection state
  let activeRC = {r:0,c:0};
  let sel = {r1:0,c1:0,r2:0,c2:0};
  let dragging = false;
  let dragAnchor = null;
  let formulaInsertMode = false;
  let suppressFormulaCommit = false;

  function setStatus(msg){ status.textContent = msg; }

  function currentAddr(){ return rcToAddr(activeRC.r, activeRC.c); }
  function currentRangeAddr(){
    const rr = normRange(sel.r1,sel.c1,sel.r2,sel.c2);
    const a = rcToAddr(rr.r1, rr.c1);
    const b = rcToAddr(rr.r2, rr.c2);
    return (a === b) ? a : (a + ":" + b);
  }

  // Build table grid once
  function buildGrid(){
    gridEl.innerHTML = "";
    const sheet = activeSheet();

    // colgroup
    const colgroup = document.createElement("colgroup");
    const colRowHdr = document.createElement("col");
    colRowHdr.className = "rowhdr";
    colgroup.appendChild(colRowHdr);

    for (let c=0;c<GRID_COLS;c++){
      const col = document.createElement("col");
      col.style.width = (sheet.colWidths[c] || 96) + "px";
      col.dataset.c = String(c);
      colgroup.appendChild(col);
    }
    gridEl.appendChild(colgroup);

    // header
    const thead = document.createElement("thead");
    const trh = document.createElement("tr");

    const corner = document.createElement("th");
    corner.className = "corner";
    corner.textContent = "";
    trh.appendChild(corner);

    for (let c=0;c<GRID_COLS;c++){
      const th = document.createElement("th");
      th.className = "colhdr";
      th.dataset.c = String(c);
      th.textContent = colToName(c);

      const res = document.createElement("div");
      res.className = "resizer";
      res.dataset.c = String(c);
      th.appendChild(res);

      trh.appendChild(th);
    }
    thead.appendChild(trh);
    gridEl.appendChild(thead);

    // body
    const tbody = document.createElement("tbody");
    for (let r=0;r<GRID_ROWS;r++){
      const tr = document.createElement("tr");

      const rh = document.createElement("th");
      rh.className = "rowhdr";
      rh.dataset.r = String(r);
      rh.textContent = String(r+1);
      tr.appendChild(rh);

      for (let c=0;c<GRID_COLS;c++){
        const td = document.createElement("td");
        td.dataset.r = String(r);
        td.dataset.c = String(c);

        const div = document.createElement("div");
        div.className = "cell";
        div.dataset.addr = rcToAddr(r,c);
        td.appendChild(div);

        tr.appendChild(td);
      }

      tbody.appendChild(tr);
    }
    gridEl.appendChild(tbody);
  }

  function getCellEl(r,c){
    // td -> div.cell
    const row = gridEl.tBodies[0].rows[r];
    if (!row) return null;
    const td = row.cells[c+1]; // +1 because row header th
    if (!td) return null;
    return td.firstElementChild;
  }
  function getTdEl(r,c){
    const row = gridEl.tBodies[0].rows[r];
    if (!row) return null;
    return row.cells[c+1] || null;
  }

  function updateCellDOM(r,c){
    const sheet = activeSheet();
    const addr = rcToAddr(r,c);
    const cell = sheet.getCell(addr, false);
    const el = getCellEl(r,c);
    if (!el) return;

    let display = "";
    let style = null;

    if (cell){
      if (cell.dirty) recalcSheet(sheet);
      const v = cell.value;
      display = (typeof v === "number")
        ? (Number.isFinite(v) ? String(+v.toFixed(12)).replace(/\.?0+$/,"") : "#VALUE!")
        : (v ?? "");
      style = cell.style;
    }

    el.textContent = display;

    // styling
    el.style.fontWeight = style?.bold ? "700" : "400";
    el.style.fontStyle  = style?.italic ? "italic" : "normal";
    el.parentElement.style.background = style?.bg ? style.bg : "rgba(255,255,255,.02)";
  }

  function renderAll(){
    const sheet = activeSheet();
    recalcSheet(sheet);
    for (let r=0;r<GRID_ROWS;r++){
      for (let c=0;c<GRID_COLS;c++){
        updateCellDOM(r,c);
      }
    }
    updateFormulaBarFromSelection();
    updateToolbarToggles();
    updateSelectionOverlays();
    updateSheetTabs();
  }

  // ===========================
  // Selection overlays
  // ===========================
  function cellRectInWrap(r,c){
    const td = getTdEl(r,c);
    if (!td) return null;
    const tdRect = td.getBoundingClientRect();
    const wrapRect = gridWrap.getBoundingClientRect();
    return {
      left: tdRect.left - wrapRect.left + gridWrap.scrollLeft,
      top: tdRect.top - wrapRect.top + gridWrap.scrollTop,
      width: tdRect.width,
      height: tdRect.height,
    };
  }

  function updateSelectionOverlays(){
    // active box
    const a = cellRectInWrap(activeRC.r, activeRC.c);
    if (a){
      activeBox.style.display = "block";
      activeBox.style.left = a.left + "px";
      activeBox.style.top = a.top + "px";
      activeBox.style.width = a.width + "px";
      activeBox.style.height = a.height + "px";
    }

    // selection box
    const rr = normRange(sel.r1,sel.c1,sel.r2,sel.c2);
    const r1 = cellRectInWrap(rr.r1, rr.c1);
    const r2 = cellRectInWrap(rr.r2, rr.c2);
    if (r1 && r2){
      selectionBox.style.display = "block";
      const left = Math.min(r1.left, r2.left);
      const top  = Math.min(r1.top,  r2.top);
      const right = Math.max(r1.left + r1.width, r2.left + r2.width);
      const bottom= Math.max(r1.top + r1.height, r2.top + r2.height);

      selectionBox.style.left = left + "px";
      selectionBox.style.top  = top + "px";
      selectionBox.style.width = (right - left) + "px";
      selectionBox.style.height= (bottom - top) + "px";
    }
  }

  gridWrap.addEventListener("scroll", () => {
    updateSelectionOverlays();
    if (cellEditor.style.display === "block") positionEditorToActive();
  });

  // ===========================
  // Formula bar + editor
  // ===========================
  function updateFormulaBarFromSelection(){
    const sheet = activeSheet();
    const addr = currentAddr();
    addrBox.textContent = addr;

    const cell = sheet.getCell(addr, false);
    const raw = cell?.raw ?? "";
    formulaInput.value = raw;
    sheetStatus.textContent = `${sheet.name} • ${sheet.cells.size} cells`;
  }

  function positionEditorToActive(){
    const rr = cellRectInWrap(activeRC.r, activeRC.c);
    if (!rr) return;
    cellEditor.style.left = rr.left + "px";
    cellEditor.style.top  = rr.top + "px";
    cellEditor.style.width = rr.width + "px";
    cellEditor.style.height= rr.height + "px";
  }

  function beginEditInGrid(){
    const sheet = activeSheet();
    const addr = currentAddr();
    const cell = sheet.getCell(addr, false);
    const raw = cell?.raw ?? "";

    positionEditorToActive();
    cellEditor.value = raw;
    cellEditor.style.display = "block";
    cellEditor.focus();
    cellEditor.setSelectionRange(cellEditor.value.length, cellEditor.value.length);
  }

  function commitEdit(raw){
    const sheet = activeSheet();
    const addr = currentAddr();
    setCellRaw(sheet, addr, raw);
    cellEditor.style.display = "none";
    renderAll(); // update display
  }

  function commitFormulaBar(){
    if (suppressFormulaCommit) return;
    const sheet = activeSheet();
    const addr = currentAddr();
    setCellRaw(sheet, addr, formulaInput.value);
    renderAll();
  }

  function insertIntoFormula(text){
    const input = formulaInput;
    const start = input.selectionStart ?? input.value.length;
    const end = input.selectionEnd ?? input.value.length;
    input.setRangeText(text, start, end, "end");
    input.focus();
  }

  // Prevent formula bar blur-commit when clicking grid to insert refs
  gridWrap.addEventListener("mousedown", (e) => {
    // capture-ish behavior: set flag before input blurs
    formulaInsertMode = (document.activeElement === formulaInput) && (formulaInput.value.trim().startsWith("="));
    if (formulaInsertMode){
      suppressFormulaCommit = true;
      // clear after event loop
      setTimeout(() => { suppressFormulaCommit = false; }, 0);
    }
  }, true);

  formulaInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter"){
      e.preventDefault();
      commitFormulaBar();
      // Excel-ish: move down
      moveActive(1,0,false);
    } else if (e.key === "Escape"){
      updateFormulaBarFromSelection();
      formulaInput.blur();
    }
  });
  formulaInput.addEventListener("blur", () => {
    // commit on blur unless we are in ref insertion flow
    commitFormulaBar();
  });

  cellEditor.addEventListener("keydown", (e) => {
    if (e.key === "Enter"){
      e.preventDefault();
      commitEdit(cellEditor.value);
      moveActive(1,0,false);
    } else if (e.key === "Escape"){
      cellEditor.style.display = "none";
    } else if (e.key === "Tab"){
      e.preventDefault();
      commitEdit(cellEditor.value);
      moveActive(0, e.shiftKey ? -1 : 1, false);
    }
  });
  cellEditor.addEventListener("blur", () => {
    if (cellEditor.style.display === "block"){
      commitEdit(cellEditor.value);
    }
  });

  // ===========================
  // Set cell raw + dependency tracking + dirty propagation
  // ===========================
  function setCellRaw(sheet, addr, raw){
    raw = (raw ?? "").toString();
    const cell = sheet.getCell(addr, true);

    // remove old dependencies
    for (const d of cell.deps){
      const depCell = sheet.getCell(d, false);
      if (depCell) depCell.dependents.delete(addr);
    }
    cell.deps.clear();

    cell.raw = raw;

    if (raw.trim().startsWith("=")){
      cell.formula = raw.trim().slice(1);
      cell.ast = null;
      try{
        cell.ast = parseFormula(cell.formula);
        const deps = new Set();
        collectDeps(cell.ast, deps);
        cell.deps = deps;
        for (const d of deps){
          const depCell = sheet.getCell(d, true);
          depCell.dependents.add(addr);
        }
      } catch {
        // keep formula, but will show error
        cell.ast = null;
      }
    } else {
      cell.formula = null;
      cell.ast = null;
    }

    sheet.markDirtyCascade(addr);
  }

  // ===========================
  // Mouse selection + drag range selection
  // ===========================
  function setSelection(r,c, extend=false){
    if (!extend){
      activeRC = {r, c};
      sel = {r1:r, c1:c, r2:r, c2:c};
      dragAnchor = {r, c};
    } else {
      const a = dragAnchor ?? activeRC;
      sel = {r1:a.r, c1:a.c, r2:r, c2:c};
    }
    updateSelectionOverlays();
    updateFormulaBarFromSelection();
    updateToolbarToggles();
  }

  function scrollCellIntoView(r,c){
    const td = getTdEl(r,c);
    if (!td) return;
    const wrapRect = gridWrap.getBoundingClientRect();
    const tdRect = td.getBoundingClientRect();

    const pad = 30;

    // if out of view, adjust scroll
    if (tdRect.left < wrapRect.left + 54) gridWrap.scrollLeft -= (wrapRect.left + 54 - tdRect.left) + pad;
    if (tdRect.right > wrapRect.right) gridWrap.scrollLeft += (tdRect.right - wrapRect.right) + pad;
    if (tdRect.top < wrapRect.top + 26) gridWrap.scrollTop -= (wrapRect.top + 26 - tdRect.top) + pad;
    if (tdRect.bottom > wrapRect.bottom) gridWrap.scrollTop += (tdRect.bottom - wrapRect.bottom) + pad;
  }

  function moveActive(dr, dc, extend){
    const nr = clamp(activeRC.r + dr, 0, GRID_ROWS-1);
    const nc = clamp(activeRC.c + dc, 0, GRID_COLS-1);
    if (!extend){
      activeRC = {r:nr,c:nc};
      sel = {r1:nr,c1:nc,r2:nr,c2:nc};
      dragAnchor = {r:nr,c:nc};
    } else {
      sel = {r1:dragAnchor?.r ?? activeRC.r, c1:dragAnchor?.c ?? activeRC.c, r2:nr, c2:nc};
      activeRC = {r:nr,c:nc};
    }
    updateSelectionOverlays();
    updateFormulaBarFromSelection();
    updateToolbarToggles();
    scrollCellIntoView(nr,nc);
  }

  function handleGridPointerDown(e){
    const td = e.target.closest("td");
    if (!td) return;

    const r = parseInt(td.dataset.r,10);
    const c = parseInt(td.dataset.c,10);

    // If currently editing in-grid, commit it first
    if (cellEditor.style.display === "block"){
      commitEdit(cellEditor.value);
    }

    dragging = true;
    dragAnchor = {r,c};
    activeRC = {r,c};
    sel = {r1:r,c1:c,r2:r,c2:c};
    updateSelectionOverlays();
    updateFormulaBarFromSelection();
    updateToolbarToggles();

    // If formula bar focused and starts with '=', we keep selection but will insert ref on mouseup/click
  }

  function handleGridPointerMove(e){
    if (!dragging) return;
    const td = e.target.closest("td");
    if (!td) return;
    const r = parseInt(td.dataset.r,10);
    const c = parseInt(td.dataset.c,10);
    sel = {r1:dragAnchor.r, c1:dragAnchor.c, r2:r, c2:c};
    activeRC = {r,c};
    updateSelectionOverlays();
    // do not change formula bar during drag (Excel keeps showing)
  }

  function handleGridPointerUp(e){
    if (!dragging) return;
    dragging = false;

    // Insertion into formula (click or drag range) if formula bar is in edit mode
    const formulaMode = (document.activeElement === formulaInput) && formulaInput.value.trim().startsWith("=");
    if (formulaMode){
      insertIntoFormula(currentRangeAddr());
    } else {
      updateFormulaBarFromSelection();
    }
  }

  gridEl.addEventListener("mousedown", handleGridPointerDown);
  gridEl.addEventListener("mousemove", handleGridPointerMove);
  window.addEventListener("mouseup", handleGridPointerUp);

  gridEl.addEventListener("dblclick", (e) => {
    const td = e.target.closest("td");
    if (!td) return;
    const r = parseInt(td.dataset.r,10);
    const c = parseInt(td.dataset.c,10);
    setSelection(r,c,false);
    beginEditInGrid();
  });

  // Click formula bar should keep selection overlays updated
  formulaInput.addEventListener("focus", () => updateSelectionOverlays());

  // ===========================
  // Keyboard navigation + edit
  // ===========================
  window.addEventListener("keydown", (e) => {
    // If typing in formula input/editor, let it handle
    if (document.activeElement === formulaInput || document.activeElement === cellEditor) return;

    const key = e.key;

    // formatting shortcuts
    if (e.ctrlKey && (key === "b" || key === "B")){
      e.preventDefault();
      toggleBold();
      return;
    }
    if (e.ctrlKey && (key === "i" || key === "I")){
      e.preventDefault();
      toggleItalic();
      return;
    }

    if (key === "ArrowUp"){ e.preventDefault(); moveActive(-1,0,e.shiftKey); }
    else if (key === "ArrowDown"){ e.preventDefault(); moveActive(1,0,e.shiftKey); }
    else if (key === "ArrowLeft"){ e.preventDefault(); moveActive(0,-1,e.shiftKey); }
    else if (key === "ArrowRight"){ e.preventDefault(); moveActive(0,1,e.shiftKey); }
    else if (key === "Enter"){ e.preventDefault(); moveActive(1,0,false); }
    else if (key === "Tab"){ e.preventDefault(); moveActive(0, e.shiftKey ? -1 : 1, false); }
    else if (key === "Backspace" || key === "Delete"){ e.preventDefault(); clearSelectionContents(); }
    else if (key === "F2"){ e.preventDefault(); beginEditInGrid(); }
    else if (key.length === 1){
      // start editing and replace content
      beginEditInGrid();
      cellEditor.value = key;
      cellEditor.setSelectionRange(cellEditor.value.length, cellEditor.value.length);
    }
  });

  // ===========================
  // Formatting & toolbar actions
  // ===========================
  function eachCellInSelection(fn){
    const rr = normRange(sel.r1,sel.c1,sel.r2,sel.c2);
    for (let r=rr.r1; r<=rr.r2; r++){
      for (let c=rr.c1; c<=rr.c2; c++){
        fn(r,c, rcToAddr(r,c));
      }
    }
  }

  function updateToolbarToggles(){
    const sheet = activeSheet();
    const cell = sheet.getCell(currentAddr(), false);
    const bold = !!cell?.style?.bold;
    const ital = !!cell?.style?.italic;

    boldBtn.classList.toggle("toggled", bold);
    italicBtn.classList.toggle("toggled", ital);

    // fill picker: show current cell bg if any
    if (cell?.style?.bg){
      // try to set input if it's hex; otherwise leave
      // (we store as rgba or hex; here we store hex only from picker)
      fillColor.value = cell.style.bg;
    }
  }

  function toggleBold(){
    const sheet = activeSheet();
    const rr = normRange(sel.r1,sel.c1,sel.r2,sel.c2);
    const addr = currentAddr();
    const base = sheet.getCell(addr, true);
    const newVal = !base.style.bold;

    eachCellInSelection((r,c,a)=>{
      const cell = sheet.getCell(a, true);
      cell.style.bold = newVal;
      updateCellDOM(r,c);
    });
    updateToolbarToggles();
  }

  function toggleItalic(){
    const sheet = activeSheet();
    const addr = currentAddr();
    const base = sheet.getCell(addr, true);
    const newVal = !base.style.italic;

    eachCellInSelection((r,c,a)=>{
      const cell = sheet.getCell(a, true);
      cell.style.italic = newVal;
      updateCellDOM(r,c);
    });
    updateToolbarToggles();
  }

  function setFillColor(color){
    const sheet = activeSheet();
    eachCellInSelection((r,c,a)=>{
      const cell = sheet.getCell(a, true);
      cell.style.bg = color;
      updateCellDOM(r,c);
    });
    updateToolbarToggles();
  }

  function clearSelectionContents(){
    const sheet = activeSheet();
    eachCellInSelection((r,c,a)=>{
      setCellRaw(sheet, a, "");
      updateCellDOM(r,c);
    });
    renderAll();
  }

  boldBtn.addEventListener("click", toggleBold);
  italicBtn.addEventListener("click", toggleItalic);
  fillColor.addEventListener("input", (e) => setFillColor(e.target.value));
  clearBtn.addEventListener("click", clearSelectionContents);

  clearSheetBtn.addEventListener("click", () => {
    const sheet = activeSheet();
    if (!confirm(`Clear all cells in "${sheet.name}"?`)) return;
    sheet.cells.clear();
    sheet.dirtySet.clear();
    renderAll();
    setStatus("Sheet cleared");
  });

  // ===========================
  // Column resizing
  // ===========================
  let resizing = null; // {c, startX, startW}
  gridEl.addEventListener("mousedown", (e) => {
    const handle = e.target.closest(".resizer");
    if (!handle) return;
    const c = parseInt(handle.dataset.c,10);
    const sheet = activeSheet();
    resizing = { c, startX: e.clientX, startW: sheet.colWidths[c] || 96 };
    e.preventDefault();
    e.stopPropagation();
  });
  window.addEventListener("mousemove", (e) => {
    if (!resizing) return;
    const sheet = activeSheet();
    const dx = e.clientX - resizing.startX;
    const w = clamp(resizing.startW + dx, 44, 420);
    sheet.colWidths[resizing.c] = w;
    // apply to colgroup
    const col = gridEl.querySelector(`col[data-c="${resizing.c}"]`);
    if (col) col.style.width = w + "px";
    updateSelectionOverlays();
    if (cellEditor.style.display === "block") positionEditorToActive();
  });
  window.addEventListener("mouseup", () => {
    if (resizing) setStatus("Column resized");
    resizing = null;
  });

  // ===========================
  // Sheets (tabs): add / rename / delete
  // ===========================
  function updateSheetTabs(){
    // remove existing tabs except add button + status area
    // tabs live before addSheetBtn
    const existing = Array.from(sheetsBar.querySelectorAll(".tab"));
    existing.forEach(t => t.remove());

    workbook.sheets.forEach((s, idx) => {
      const tab = document.createElement("div");
      tab.className = "tab" + (idx === workbook.active ? " active" : "");
      tab.dataset.idx = String(idx);

      const name = document.createElement("div");
      name.className = "name";
      name.textContent = s.name;

      const x = document.createElement("div");
      x.className = "x";
      x.textContent = "×";
      x.title = "Delete sheet";

      tab.appendChild(name);
      tab.appendChild(x);

      tab.addEventListener("click", (e) => {
        const i = parseInt(tab.dataset.idx,10);
        if (e.target === x){
          // delete
          if (workbook.sheets.length <= 1) return alert("You must keep at least one sheet.");
          if (!confirm(`Delete sheet "${workbook.sheets[i].name}"?`)) return;
          workbook.sheets.splice(i,1);
          workbook.active = clamp(workbook.active, 0, workbook.sheets.length-1);
          buildGrid();
          renderAll();
          setStatus("Sheet deleted");
          return;
        }
        workbook.active = i;
        buildGrid();
        renderAll();
      });

      tab.addEventListener("dblclick", () => {
        const i = parseInt(tab.dataset.idx,10);
        const s = workbook.sheets[i];
        const nn = prompt("Rename sheet:", s.name);
        if (!nn) return;
        s.name = nn.slice(0, 40);
        updateSheetTabs();
        setStatus("Sheet renamed");
      });

      sheetsBar.insertBefore(tab, addSheetBtn);
    });
  }

  addSheetBtn.addEventListener("click", () => {
    const base = "Sheet";
    let n = workbook.sheets.length + 1;
    let name = base + n;
    const existing = new Set(workbook.sheets.map(s => s.name));
    while (existing.has(name)){ n++; name = base + n; }
    workbook.sheets.push(new Sheet(name));
    workbook.active = workbook.sheets.length - 1;
    buildGrid();
    renderAll();
    setStatus("Sheet added");
  });

  // ===========================
  // CSV import/export (active sheet)
  // ===========================
  function escapeCSVCell(s){
    s = (s ?? "").toString();
    if (/[",\n]/.test(s)){
      return `"${s.replace(/"/g,'""')}"`;
    }
    return s;
  }

  function usedBounds(sheet){
    let maxR = -1, maxC = -1;
    for (const [addr, cell] of sheet.cells){
      if (!cell || cell.raw === "") continue;
      const rc = addrToRC(addr);
      if (!rc) continue;
      maxR = Math.max(maxR, rc.r);
      maxC = Math.max(maxC, rc.c);
    }
    if (maxR < 0 || maxC < 0) return {r:0,c:0, empty:true};
    return {r:maxR, c:maxC, empty:false};
  }

  function downloadCSV(){
    const sheet = activeSheet();
    const b = usedBounds(sheet);
    const rows = b.empty ? 1 : (b.r + 1);
    const cols = b.empty ? 1 : (b.c + 1);

    const lines = [];
    for (let r=0;r<rows;r++){
      const parts = [];
      for (let c=0;c<cols;c++){
        const addr = rcToAddr(r,c);
        const cell = sheet.getCell(addr, false);
        parts.push(escapeCSVCell(cell?.raw ?? ""));
      }
      lines.push(parts.join(","));
    }

    const csv = lines.join("\n");
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = `${sheet.name}.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);

    setStatus("CSV downloaded");
  }

  function parseCSV(text){
    // basic RFC4180-ish parser
    const rows = [];
    let row = [];
    let i=0, field="", inQuotes=false;

    function pushField(){
      row.push(field);
      field = "";
    }
    function pushRow(){
      rows.push(row);
      row = [];
    }

    while (i < text.length){
      const ch = text[i];

      if (inQuotes){
        if (ch === '"'){
          const next = text[i+1];
          if (next === '"'){ field += '"'; i += 2; continue; }
          inQuotes = false; i++; continue;
        }
        field += ch; i++; continue;
      } else {
        if (ch === '"'){ inQuotes = true; i++; continue; }
        if (ch === ","){ pushField(); i++; continue; }
        if (ch === "\r"){
          if (text[i+1] === "\n"){ pushField(); pushRow(); i += 2; continue; }
          pushField(); pushRow(); i++; continue;
        }
        if (ch === "\n"){ pushField(); pushRow(); i++; continue; }
        field += ch; i++; continue;
      }
    }
    pushField();
    pushRow();

    // trim possible trailing empty last row from file ending newline
    if (rows.length && rows[rows.length-1].length === 1 && rows[rows.length-1][0] === "" && text.endsWith("\n")){
      // keep it simple; no removal
    }
    return rows;
  }

  function uploadCSV(file){
    const reader = new FileReader();
    reader.onload = () => {
      const text = String(reader.result ?? "");
      const data = parseCSV(text);

      const sheet = activeSheet();
      // clear current sheet? Use confirm
      if (!confirm(`Import will overwrite cells starting at A1 in "${sheet.name}". Continue?`)) return;

      // write values
      for (let r=0;r<Math.min(GRID_ROWS, data.length);r++){
        const row = data[r];
        for (let c=0;c<Math.min(GRID_COLS, row.length);c++){
          const addr = rcToAddr(r,c);
          setCellRaw(sheet, addr, row[c] ?? "");
        }
      }

      renderAll();
      setStatus("CSV imported");
    };
    reader.readAsText(file);
  }

  csvDownBtn.addEventListener("click", downloadCSV);
  csvUpBtn.addEventListener("click", () => csvFile.click());
  csvFile.addEventListener("change", () => {
    const f = csvFile.files?.[0];
    if (f) uploadCSV(f);
    csvFile.value = "";
  });

  // ===========================
  // Formula bar: clicking cells inserts refs/ranges
  // Also allow drag range insert (handled on mouseup).
  // ===========================
  gridEl.addEventListener("click", (e) => {
    const td = e.target.closest("td");
    if (!td) return;

    const r = parseInt(td.dataset.r,10);
    const c = parseInt(td.dataset.c,10);
    setSelection(r,c,false);

    const formulaMode = (document.activeElement === formulaInput) && formulaInput.value.trim().startsWith("=");
    if (formulaMode){
      insertIntoFormula(rcToAddr(r,c));
    }
  });

  // ===========================
  // Init
  // ===========================
  makeDefaultWorkbook();
  buildGrid();
  updateSheetTabs();
  renderAll();

  // initial focus behavior: click grid to focus selection, or click formula bar to edit.
  setStatus("Ready");

})();
</script>
</body>
</html>
