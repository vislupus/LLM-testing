<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSpreadsheet</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Toolbar */
        .toolbar {
            background: #fff;
            border-bottom: 1px solid #d1d1d1;
            padding: 8px 12px;
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }

        .tool-group {
            display: flex;
            gap: 4px;
            padding-right: 8px;
            border-right: 1px solid #e0e0e0;
        }

        .tool-group:last-child { border-right: none; }

        button {
            padding: 6px 12px;
            border: 1px solid transparent;
            background: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
        }

        button:hover {
            background: #f3f3f3;
            border-color: #c6c6c6;
        }

        button.active {
            background: #e6e6e6;
            border-color: #b0b0b0;
        }

        .icon-btn {
            padding: 6px 8px;
            font-weight: bold;
        }

        .bold { font-weight: 900; }
        .italic { font-style: italic; }
        
        input[type="color"] {
            width: 30px;
            height: 28px;
            border: none;
            cursor: pointer;
            background: none;
        }

        input[type="file"] { display: none; }

        /* Formula Bar Area */
        .formula-container {
            background: #fff;
            border-bottom: 1px solid #d1d1d1;
            padding: 4px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .cell-reference-box {
            min-width: 80px;
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
            text-align: center;
            background: #f9f9f9;
        }

        .formula-bar {
            flex: 1;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 13px;
            outline: none;
            min-height: 28px;
            background: #fff;
        }

        .formula-bar:focus {
            border-color: #1976d2;
            box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.1);
        }

        /* Grid Layout */
        .grid-wrapper {
            flex: 1;
            overflow: auto;
            position: relative;
            background: #fff;
        }

        .grid-container {
            display: grid;
            grid-template-columns: 50px repeat(26, 100px);
            grid-template-rows: 25px repeat(100, 24px);
            min-width: fit-content;
        }

        /* Headers */
        .corner-header {
            position: sticky;
            top: 0;
            left: 0;
            background: #f3f3f3;
            border-right: 1px solid #d1d1d1;
            border-bottom: 1px solid #d1d1d1;
            z-index: 3;
            cursor: pointer;
        }

        .col-header {
            position: sticky;
            top: 0;
            background: #f3f3f3;
            border-right: 1px solid #d1d1d1;
            border-bottom: 1px solid #d1d1d1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: #444;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            z-index: 2;
        }

        .col-header:hover { background: #e6e6e6; }
        .col-header.selected { background: #d1d1d1; }

        .row-header {
            position: sticky;
            left: 0;
            background: #f3f3f3;
            border-right: 1px solid #d1d1d1;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: #444;
            cursor: pointer;
            user-select: none;
            z-index: 2;
        }

        .row-header:hover { background: #e6e6e6; }
        .row-header.selected { background: #d1d1d1; }

        /* Cells */
        .cell {
            border-right: 1px solid #e0e0e0;
            border-bottom: 1px solid #e0e0e0;
            padding: 2px 6px;
            font-size: 12px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            cursor: cell;
            background: #fff;
            outline: none;
            position: relative;
        }

        .cell:hover { background: #f9f9f9; }
        
        .cell.selected {
            outline: 2px solid #1976d2;
            outline-offset: -2px;
            z-index: 1;
        }

        .cell.editing {
            padding: 0;
            border: 2px solid #1976d2;
            background: #fff;
        }

        .cell input {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            padding: 2px 6px;
            font-size: 12px;
            font-family: inherit;
        }

        .cell .cell-content {
            width: 100%;
            height: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Range Selection */
        .cell.range-selected {
            background: rgba(25, 118, 210, 0.1);
        }

        /* Sheet Tabs */
        .sheet-tabs-container {
            background: #f3f3f3;
            border-top: 1px solid #d1d1d1;
            padding: 4px 12px;
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .sheet-tab {
            padding: 6px 16px;
            background: #fff;
            border: 1px solid #d1d1d1;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            font-size: 12px;
            position: relative;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .sheet-tab:hover { background: #f9f9f9; }
        .sheet-tab.active {
            border-bottom: 1px solid #fff;
            background: #fff;
            font-weight: 600;
        }

        .sheet-tab input {
            border: none;
            outline: none;
            font-size: 12px;
            width: 80px;
            background: transparent;
        }

        .add-sheet-btn {
            padding: 4px 8px;
            font-size: 16px;
            line-height: 1;
        }

        /* Context Menu */
        .context-menu {
            position: absolute;
            background: #fff;
            border: 1px solid #ccc;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            border-radius: 4px;
            padding: 4px 0;
            z-index: 1000;
            display: none;
            min-width: 150px;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
        }

        .context-menu-item:hover { background: #f3f3f3; }

        /* Resize Handle */
        .col-resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            width: 4px;
            height: 100%;
            cursor: col-resize;
            z-index: 4;
        }

        .col-resize-handle:hover { background: #1976d2; }

        /* Scrollbar Styling */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #a1a1a1; }

        /* Status Bar */
        .status-bar {
            background: #f3f3f3;
            border-top: 1px solid #d1d1d1;
            padding: 4px 12px;
            font-size: 11px;
            color: #666;
            display: flex;
            justify-content: space-between;
        }
    </style>
</head>
<body>

<div class="toolbar">
    <div class="tool-group">
        <button onclick="app.insertRow()">+ Row</button>
        <button onclick="app.insertCol()">+ Col</button>
    </div>
    <div class="tool-group">
        <button class="icon-btn bold" onclick="app.toggleBold()">B</button>
        <button class="icon-btn italic" onclick="app.toggleItalic()">I</button>
    </div>
    <div class="tool-group">
        <input type="color" id="bgColor" onchange="app.setBgColor(this.value)" title="Background Color">
    </div>
    <div class="tool-group">
        <button onclick="app.clearCell()">Clear</button>
        <button onclick="app.deleteSheet()">Delete Sheet</button>
    </div>
    <div class="tool-group">
        <button onclick="app.downloadCSV()">Download CSV</button>
        <button onclick="document.getElementById('csvInput').click()">Upload CSV</button>
        <input type="file" id="csvInput" accept=".csv" onchange="app.uploadCSV(this)">
    </div>
</div>

<div class="formula-container">
    <div class="cell-reference-box" id="cellRef">A1</div>
    <div class="formula-bar" id="formulaBar" contenteditable="true"></div>
</div>

<div class="grid-wrapper" id="gridWrapper">
    <div class="grid-container" id="grid"></div>
</div>

<div class="sheet-tabs-container" id="sheetTabs">
    <button class="add-sheet-btn" onclick="app.addSheet()">+</button>
</div>

<div class="status-bar">
    <span id="statusLeft">Ready</span>
    <span id="statusRight">WebSpreadsheet</span>
</div>

<div class="context-menu" id="contextMenu">
    <div class="context-menu-item" onclick="app.renameSheet()">Rename</div>
    <div class="context-menu-item" onclick="app.deleteSheet()">Delete</div>
</div>

<script>
class SpreadsheetApp {
    constructor() {
        this.sheets = [this.createSheet('Sheet1')];
        this.activeSheetIndex = 0;
        this.selectedCell = 'A1';
        this.selectionRange = null; // {start: 'A1', end: 'B2'}
        this.editing = false;
        this.formulaBarFocused = false;
        this.dragStart = null;
        this.colWidths = new Array(26).fill(100);
        this.rowHeights = new Array(100).fill(24);
        
        this.init();
    }

    createSheet(name) {
        return {
            name,
            cells: new Map(), // key: 'A1', value: {formula, value, style: {}, deps: Set(), dependents: Set()}
            rowCount: 100,
            colCount: 26
        };
    }

    init() {
        this.grid = document.getElementById('grid');
        this.formulaBar = document.getElementById('formulaBar');
        this.cellRef = document.getElementById('cellRef');
        this.gridWrapper = document.getElementById('gridWrapper');
        
        this.renderGrid();
        this.renderSheetTabs();
        this.setupEvents();
        this.selectCell('A1');
    }

    renderGrid() {
        this.grid.innerHTML = '';
        
        // Corner header
        const corner = document.createElement('div');
        corner.className = 'corner-header';
        corner.onclick = () => this.selectAll();
        this.grid.appendChild(corner);
        
        // Column headers
        for (let col = 0; col < this.getActiveSheet().colCount; col++) {
            const header = document.createElement('div');
            header.className = 'col-header';
            header.textContent = this.colToLetter(col);
            header.style.width = this.colWidths[col] + 'px';
            header.dataset.col = col;
            
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'col-resize-handle';
            resizeHandle.addEventListener('mousedown', (e) => this.startColResize(e, col));
            header.appendChild(resizeHandle);
            
            header.addEventListener('click', () => this.selectCol(col));
            this.grid.appendChild(header);
        }
        
        // Rows and cells
        for (let row = 0; row < this.getActiveSheet().rowCount; row++) {
            // Row header
            const rowHeader = document.createElement('div');
            rowHeader.className = 'row-header';
            rowHeader.textContent = row + 1;
            rowHeader.dataset.row = row;
            rowHeader.addEventListener('click', () => this.selectRow(row));
            this.grid.appendChild(rowHeader);
            
            // Cells
            for (let col = 0; col < this.getActiveSheet().colCount; col++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.row = row;
                cell.dataset.col = col;
                cell.dataset.address = this.indicesToCell(row, col);
                cell.style.width = this.colWidths[col] + 'px';
                
                const content = document.createElement('div');
                content.className = 'cell-content';
                cell.appendChild(content);
                
                this.updateCellDisplay(cell);
                this.grid.appendChild(cell);
            }
        }
        
        this.updateSelection();
    }

    updateCellDisplay(cellElement) {
        const address = cellElement.dataset.address;
        const cellData = this.getCellData(address);
        const content = cellElement.querySelector('.cell-content');
        
        if (cellData) {
            content.textContent = cellData.value || '';
            cellElement.style.fontWeight = cellData.style?.bold ? 'bold' : 'normal';
            cellElement.style.fontStyle = cellData.style?.italic ? 'italic' : 'normal';
            cellElement.style.backgroundColor = cellData.style?.bgColor || '#fff';
        } else {
            content.textContent = '';
            cellElement.style.fontWeight = 'normal';
            cellElement.style.fontStyle = 'normal';
            cellElement.style.backgroundColor = '#fff';
        }
    }

    setupEvents() {
        // Grid clicks
        this.grid.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('cell') || e.target.closest('.cell')) {
                const cell = e.target.classList.contains('cell') ? e.target : e.target.closest('.cell');
                if (this.editing && this.formulaBarFocused) {
                    // Insert reference
                    this.insertReference(cell.dataset.address);
                } else {
                    // Start selection
                    this.dragStart = cell.dataset.address;
                    this.selectCell(cell.dataset.address);
                    
                    const mouseMove = (ev) => {
                        if (ev.target.classList.contains('cell') || ev.target.closest('.cell')) {
                            const endCell = ev.target.classList.contains('cell') ? ev.target : ev.target.closest('.cell');
                            this.selectionRange = {
                                start: this.dragStart,
                                end: endCell.dataset.address
                            };
                            this.updateSelection();
                        }
                    };
                    
                    const mouseUp = () => {
                        document.removeEventListener('mousemove', mouseMove);
                        document.removeEventListener('mouseup', mouseUp);
                    };
                    
                    document.addEventListener('mousemove', mouseMove);
                    document.addEventListener('mouseup', mouseUp);
                }
            }
        });

        // Double click to edit
        this.grid.addEventListener('dblclick', (e) => {
            if (e.target.classList.contains('cell') || e.target.closest('.cell')) {
                const cell = e.target.classList.contains('cell') ? e.target : e.target.closest('.cell');
                this.startEditing(cell.dataset.address);
            }
        });

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (this.editing) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    this.commitEdit();
                    this.moveSelection(1, 0); // Down
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    this.commitEdit();
                    this.moveSelection(0, e.shiftKey ? -1 : 1); // Left/Right
                } else if (e.key === 'Escape') {
                    this.cancelEdit();
                }
            } else {
                switch(e.key) {
                    case 'ArrowUp': e.preventDefault(); this.moveSelection(-1, 0); break;
                    case 'ArrowDown': e.preventDefault(); this.moveSelection(1, 0); break;
                    case 'ArrowLeft': e.preventDefault(); this.moveSelection(0, -1); break;
                    case 'ArrowRight': e.preventDefault(); this.moveSelection(0, 1); break;
                    case 'Enter': this.startEditing(this.selectedCell); break;
                    case 'Delete': this.clearCell(); break;
                    default:
                        if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
                            this.startEditing(this.selectedCell, e.key);
                            e.preventDefault();
                        }
                }
            }
        });

        // Formula bar
        this.formulaBar.addEventListener('focus', () => {
            this.formulaBarFocused = true;
            if (!this.editing) this.startEditing(this.selectedCell);
        });

        this.formulaBar.addEventListener('blur', () => {
            setTimeout(() => { this.formulaBarFocused = false; }, 200);
        });

        this.formulaBar.addEventListener('input', () => {
            if (this.editing) {
                const cell = document.querySelector(`[data-address="${this.selectedCell}"]`);
                cell.querySelector('.cell-content').textContent = this.formulaBar.textContent;
            }
        });
    }

    startEditing(address, initialChar = null) {
        this.editing = true;
        this.selectCell(address);
        const cellData = this.getCellData(address);
        this.formulaBar.textContent = cellData?.formula || cellData?.value || '';
        if (initialChar) this.formulaBar.textContent = initialChar;
        this.formulaBar.focus();
        
        const cell = document.querySelector(`[data-address="${address}"]`);
        cell.classList.add('editing');
        
        // Place cursor at end
        const range = document.createRange();
        const sel = window.getSelection();
        range.selectNodeContents(this.formulaBar);
        range.collapse(false);
        sel.removeAllRanges();
        sel.addRange(range);
    }

    commitEdit() {
        if (!this.editing) return;
        
        const address = this.selectedCell;
        const formula = this.formulaBar.textContent.trim();
        
        this.setCellValue(address, formula);
        this.editing = false;
        this.formulaBarFocused = false;
        
        const cell = document.querySelector(`[data-address="${address}"]`);
        cell.classList.remove('editing');
        
        this.selectCell(address); // Refresh display
    }

    cancelEdit() {
        this.editing = false;
        const cellData = this.getCellData(this.selectedCell);
        this.formulaBar.textContent = cellData?.formula || cellData?.value || '';
        const cell = document.querySelector(`[data-address="${this.selectedCell}"]`);
        cell.classList.remove('editing');
        this.updateCellDisplay(cell);
    }

    insertReference(ref) {
        const sel = window.getSelection();
        const text = this.formulaBar.textContent;
        const range = sel.getRangeAt(0);
        
        // Insert at cursor
        range.deleteContents();
        range.insertNode(document.createTextNode(ref));
        
        // Move cursor after
        range.collapse(false);
        sel.removeAllRanges();
        sel.addRange(range);
    }

    selectCell(address) {
        this.selectedCell = address;
        this.selectionRange = null;
        this.cellRef.textContent = address;
        
        const cellData = this.getCellData(address);
        this.formulaBar.textContent = cellData?.formula || cellData?.value || '';
        
        this.updateSelection();
        this.scrollToCell(address);
    }

    updateSelection() {
        document.querySelectorAll('.cell').forEach(c => {
            c.classList.remove('selected', 'range-selected');
        });
        document.querySelectorAll('.col-header, .row-header').forEach(h => h.classList.remove('selected'));
        
        if (this.selectionRange) {
            const {start, end} = this.selectionRange;
            const [startRow, startCol] = this.cellToIndices(start);
            const [endRow, endCol] = this.cellToIndices(end);
            
            const minRow = Math.min(startRow, endRow);
            const maxRow = Math.max(startRow, endRow);
            const minCol = Math.min(startCol, endCol);
            const maxCol = Math.max(startCol, endCol);
            
            for (let row = minRow; row <= maxRow; row++) {
                for (let col = minCol; col <= maxCol; col++) {
                    const addr = this.indicesToCell(row, col);
                    const cell = document.querySelector(`[data-address="${addr}"]`);
                    if (cell) cell.classList.add('range-selected');
                }
                document.querySelector(`[data-row="${row}"]`).classList.add('selected');
            }
            for (let col = minCol; col <= maxCol; col++) {
                document.querySelector(`[data-col="${col}"]`).classList.add('selected');
            }
        } else {
            const cell = document.querySelector(`[data-address="${this.selectedCell}"]`);
            if (cell) cell.classList.add('selected');
        }
    }

    moveSelection(dRow, dCol) {
        const [row, col] = this.cellToIndices(this.selectedCell);
        const newRow = Math.max(0, Math.min(this.getActiveSheet().rowCount - 1, row + dRow));
        const newCol = Math.max(0, Math.min(this.getActiveSheet().colCount - 1, col + dCol));
        this.selectCell(this.indicesToCell(newRow, newCol));
    }

    scrollToCell(address) {
        const cell = document.querySelector(`[data-address="${address}"]`);
        if (cell) cell.scrollIntoView({behavior: 'smooth', block: 'nearest'});
    }

    // Formula Engine
    setCellValue(address, value) {
        const sheet = this.getActiveSheet();
        let cellData = sheet.cells.get(address);
        
        if (!cellData) {
            cellData = { formula: null, value: '', style: {}, deps: new Set(), dependents: new Set() };
            sheet.cells.set(address, cellData);
        }
        
        // Clear old dependencies
        cellData.deps.forEach(dep => {
            const depCell = sheet.cells.get(dep);
            if (depCell) depCell.dependents.delete(address);
        });
        cellData.deps.clear();
        
        if (value.startsWith('=')) {
            cellData.formula = value;
            cellData.value = this.evaluateFormula(value, address);
        } else {
            cellData.formula = null;
            cellData.value = value;
        }
        
        // Update dependent cells
        this.recalculateDependents(address);
        
        // Update display
        const cell = document.querySelector(`[data-address="${address}"]`);
        if (cell) this.updateCellDisplay(cell);
    }

    evaluateFormula(formula, contextAddress) {
        try {
            let expr = formula.substring(1);
            
            // Handle functions (SUM, AVERAGE, MIN, MAX)
            expr = expr.replace(/(SUM|AVERAGE|MIN|MAX)\(([A-Z]+\d+):([A-Z]+\d+)\)/gi, (match, func, start, end) => {
                const values = this.getRangeValues(start, end);
                switch(func.toUpperCase()) {
                    case 'SUM': return values.reduce((a,b) => a + (parseFloat(b) || 0), 0);
                    case 'AVERAGE': return values.reduce((a,b) => a + (parseFloat(b) || 0), 0) / values.length;
                    case 'MIN': return Math.min(...values.map(v => parseFloat(v) || Infinity));
                    case 'MAX': return Math.max(...values.map(v => parseFloat(v) || -Infinity));
                    default: return 0;
                }
            });
            
            // Replace cell references with values
            const deps = new Set();
            expr = expr.replace(/([A-Z]+\d+)/g, (match) => {
                if (match.match(/^(SUM|AVERAGE|MIN|MAX)$/i)) return match;
                deps.add(match);
                const val = parseFloat(this.getCellValue(match));
                return isNaN(val) ? 0 : val;
            });
            
            // Store dependencies
            const sheet = this.getActiveSheet();
            const cellData = sheet.cells.get(contextAddress);
            if (cellData) {
                deps.forEach(dep => {
                    cellData.deps.add(dep);
                    let depCell = sheet.cells.get(dep);
                    if (!depCell) {
                        depCell = { formula: null, value: '', style: {}, deps: new Set(), dependents: new Set() };
                        sheet.cells.set(dep, depCell);
                    }
                    depCell.dependents.add(contextAddress);
                });
            }
            
            // Safe evaluation
            return Function('"use strict"; return (' + expr + ')')();
        } catch (e) {
            return '#ERROR';
        }
    }

    recalculateDependents(address) {
        const sheet = this.getActiveSheet();
        const cellData = sheet.cells.get(address);
        if (!cellData) return;
        
        const visited = new Set();
        const stack = [...cellData.dependents];
        
        while (stack.length > 0) {
            const dep = stack.pop();
            if (visited.has(dep)) continue;
            visited.add(dep);
            
            const depCell = sheet.cells.get(dep);
            if (depCell && depCell.formula) {
                depCell.value = this.evaluateFormula(depCell.formula, dep);
                const cell = document.querySelector(`[data-address="${dep}"]`);
                if (cell) this.updateCellDisplay(cell);
                stack.push(...depCell.dependents);
            }
        }
    }

    getRangeValues(start, end) {
        const [startRow, startCol] = this.cellToIndices(start);
        const [endRow, endCol] = this.cellToIndices(end);
        const values = [];
        
        const minRow = Math.min(startRow, endRow);
        const maxRow = Math.max(startRow, endRow);
        const minCol = Math.min(startCol, endCol);
        const maxCol = Math.max(startCol, endCol);
        
        for (let row = minRow; row <= maxRow; row++) {
            for (let col = minCol; col <= maxCol; col++) {
                values.push(this.getCellValue(this.indicesToCell(row, col)));
            }
        }
        return values;
    }

    getCellValue(address) {
        const cell = this.getActiveSheet().cells.get(address);
        return cell ? cell.value : '';
    }

    getCellData(address) {
        return this.getActiveSheet().cells.get(address);
    }

    // Utility functions
    cellToIndices(cell) {
        const match = cell.match(/([A-Z]+)(\d+)/);
        const col = match[1].split('').reduce((a, b) => a * 26 + b.charCodeAt(0) - 64, 0) - 1;
        const row = parseInt(match[2]) - 1;
        return [row, col];
    }

    indicesToCell(row, col) {
        let colStr = '';
        let n = col + 1;
        while (n > 0) {
            n--;
            colStr = String.fromCharCode(65 + (n % 26)) + colStr;
            n = Math.floor(n / 26);
        }
        return colStr + (row + 1);
    }

    colToLetter(col) {
        return this.indicesToCell(0, col).replace(/\d/, '');
    }

    getActiveSheet() {
        return this.sheets[this.activeSheetIndex];
    }

    // Sheet management
    addSheet() {
        const name = `Sheet${this.sheets.length + 1}`;
        this.sheets.push(this.createSheet(name));
        this.activeSheetIndex = this.sheets.length - 1;
        this.renderSheetTabs();
        this.renderGrid();
        this.selectCell('A1');
    }

    deleteSheet() {
        if (this.sheets.length <= 1) {
            alert('Cannot delete the only sheet');
            return;
        }
        this.sheets.splice(this.activeSheetIndex, 1);
        this.activeSheetIndex = Math.max(0, this.activeSheetIndex - 1);
        this.renderSheetTabs();
        this.renderGrid();
        this.selectCell('A1');
    }

    renameSheet() {
        const sheet = this.getActiveSheet();
        const newName = prompt('Enter new name:', sheet.name);
        if (newName) {
            sheet.name = newName;
            this.renderSheetTabs();
        }
    }

    renderSheetTabs() {
        const container = document.getElementById('sheetTabs');
        // Clear existing tabs (keep add button)
        const addBtn = container.querySelector('.add-sheet-btn');
        container.innerHTML = '';
        container.appendChild(addBtn);
        
        this.sheets.forEach((sheet, index) => {
            const tab = document.createElement('div');
            tab.className = 'sheet-tab' + (index === this.activeSheetIndex ? ' active' : '');
            tab.textContent = sheet.name;
            tab.onclick = () => {
                this.activeSheetIndex = index;
                this.renderSheetTabs();
                this.renderGrid();
                this.selectCell('A1');
            };
            tab.oncontextmenu = (e) => {
                e.preventDefault();
                this.activeSheetIndex = index;
                this.renderSheetTabs();
                const menu = document.getElementById('contextMenu');
                menu.style.display = 'block';
                menu.style.left = e.pageX + 'px';
                menu.style.top = e.pageY + 'px';
            };
            container.insertBefore(tab, addBtn);
        });
    }

    // Formatting
    toggleBold() {
        this.applyStyle('bold', !(this.getCellData(this.selectedCell)?.style?.bold));
    }

    toggleItalic() {
        this.applyStyle('italic', !(this.getCellData(this.selectedCell)?.style?.italic));
    }

    setBgColor(color) {
        this.applyStyle('bgColor', color);
    }

    applyStyle(prop, value) {
        if (this.selectionRange) {
            // Apply to range
            const {start, end} = this.selectionRange;
            const [r1, c1] = this.cellToIndices(start);
            const [r2, c2] = this.cellToIndices(end);
            for (let r = Math.min(r1, r2); r <= Math.max(r1, r2); r++) {
                for (let c = Math.min(c1, c2); c <= Math.max(c1, c2); c++) {
                    this.applyStyleToCell(this.indicesToCell(r, c), prop, value);
                }
            }
        } else {
            this.applyStyleToCell(this.selectedCell, prop, value);
        }
        this.renderGrid();
    }

    applyStyleToCell(address, prop, value) {
        const sheet = this.getActiveSheet();
        let cell = sheet.cells.get(address);
        if (!cell) {
            cell = { formula: null, value: '', style: {}, deps: new Set(), dependents: new Set() };
            sheet.cells.set(address, cell);
        }
        cell.style[prop] = value;
    }

    clearCell() {
        if (this.selectionRange) {
            const {start, end} = this.selectionRange;
            const [r1, c1] = this.cellToIndices(start);
            const [r2, c2] = this.cellToIndices(end);
            for (let r = Math.min(r1, r2); r <= Math.max(r1, r2); r++) {
                for (let c = Math.min(c1, c2); c <= Math.max(c1, c2); c++) {
                    this.setCellValue(this.indicesToCell(r, c), '');
                }
            }
        } else {
            this.setCellValue(this.selectedCell, '');
        }
    }

    // Import/Export
    downloadCSV() {
        const sheet = this.getActiveSheet();
        let csv = '';
        
        // Find used range
        let maxRow = 0, maxCol = 0;
        sheet.cells.forEach((data, addr) => {
            if (data.value) {
                const [r, c] = this.cellToIndices(addr);
                maxRow = Math.max(maxRow, r);
                maxCol = Math.max(maxCol, c);
            }
        });
        
        for (let row = 0; row <= maxRow; row++) {
            const rowData = [];
            for (let col = 0; col <= maxCol; col++) {
                const addr = this.indicesToCell(row, col);
                const cell = sheet.cells.get(addr);
                let val = cell?.value || '';
                if (val.includes(',') || val.includes('"')) {
                    val = '"' + val.replace(/"/g, '""') + '"';
                }
                rowData.push(val);
            }
            csv += rowData.join(',') + '\n';
        }
        
        const blob = new Blob([csv], {type: 'text/csv'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = sheet.name + '.csv';
        a.click();
        URL.revokeObjectURL(url);
    }

    uploadCSV(input) {
        const file = input.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            const text = e.target.result;
            const rows = text.split('\n');
            const sheet = this.getActiveSheet();
            sheet.cells.clear();
            
            rows.forEach((row, rowIdx) => {
                if (!row.trim()) return;
                const cells = this.parseCSV(row);
                cells.forEach((val, colIdx) => {
                    if (val.trim()) {
                        const addr = this.indicesToCell(rowIdx, colIdx);
                        this.setCellValue(addr, val.trim());
                    }
                });
            });
            
            this.renderGrid();
            this.selectCell('A1');
        };
        reader.readAsText(file);
        input.value = '';
    }

    parseCSV(line) {
        const result = [];
        let inQuotes = false;
        let cell = '';
        
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            const next = line[i + 1];
            
            if (char === '"') {
                if (inQuotes && next === '"') {
                    cell += '"';
                    i++;
                } else {
                    inQuotes = !inQuotes;
                }
            } else if (char === ',' && !inQuotes) {
                result.push(cell);
                cell = '';
            } else {
                cell += char;
            }
        }
        result.push(cell);
        return result;
    }

    // Column/Row operations
    insertRow() {
        // Simplified: just expand grid
        this.getActiveSheet().rowCount++;
        this.renderGrid();
    }

    insertCol() {
        this.getActiveSheet().colCount++;
        this.colWidths.push(100);
        this.renderGrid();
    }

    startColResize(e, col) {
        const startX = e.pageX;
        const startWidth = this.colWidths[col];
        
        const onMove = (ev) => {
            const diff = ev.pageX - startX;
            this.colWidths[col] = Math.max(50, startWidth + diff);
            document.querySelectorAll(`[data-col="${col}"]`).forEach(el => {
                el.style.width = this.colWidths[col] + 'px';
            });
            document.querySelectorAll(`[data-address]`).forEach(el => {
                const c = parseInt(el.dataset.col);
                if (c === col) el.style.width = this.colWidths[col] + 'px';
            });
        };
        
        const onUp = () => {
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
        };
        
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
    }

    selectCol(col) {
        const sheet = this.getActiveSheet();
        this.selectionRange = {
            start: this.indicesToCell(0, col),
            end: this.indicesToCell(sheet.rowCount - 1, col)
        };
        this.selectedCell = this.indicesToCell(0, col);
        this.updateSelection();
    }

    selectRow(row) {
        const sheet = this.getActiveSheet();
        this.selectionRange = {
            start: this.indicesToCell(row, 0),
            end: this.indicesToCell(row, sheet.colCount - 1)
        };
        this.selectedCell = this.indicesToCell(row, 0);
        this.updateSelection();
    }

    selectAll() {
        const sheet = this.getActiveSheet();
        this.selectionRange = {
            start: 'A1',
            end: this.indicesToCell(sheet.rowCount - 1, sheet.colCount - 1)
        };
        this.selectedCell = 'A1';
        this.updateSelection();
    }
}

// Hide context menu on click elsewhere
document.addEventListener('click', (e) => {
    const menu = document.getElementById('contextMenu');
    if (!e.target.closest('.sheet-tab')) {
        menu.style.display = 'none';
    }
});

const app = new SpreadsheetApp();
</script>

</body>
</html>