<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel Clone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow: hidden;
            background: #f3f2f1;
        }

        .spreadsheet-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Toolbar */
        .toolbar {
            background: #fff;
            border-bottom: 1px solid #d1d1d1;
            padding: 8px;
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toolbar-group {
            display: flex;
            gap: 4px;
            padding-right: 8px;
            border-right: 1px solid #e1e1e1;
        }

        .toolbar button {
            padding: 6px 12px;
            border: 1px solid #d1d1d1;
            background: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .toolbar button:hover {
            background: #f3f2f1;
        }

        .toolbar button.active {
            background: #e1e1e1;
            border-color: #0078d4;
        }

        .toolbar input[type="color"] {
            width: 40px;
            height: 32px;
            border: 1px solid #d1d1d1;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Formula Bar */
        .formula-bar {
            background: #fff;
            border-bottom: 1px solid #d1d1d1;
            padding: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .cell-address {
            background: #f3f2f1;
            padding: 6px 12px;
            border: 1px solid #d1d1d1;
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
            min-width: 80px;
            text-align: center;
        }

        .formula-input {
            flex: 1;
            padding: 6px 12px;
            border: 1px solid #d1d1d1;
            border-radius: 4px;
            font-size: 14px;
            font-family: monospace;
        }

        .formula-input:focus {
            outline: none;
            border-color: #0078d4;
        }

        /* Sheet Area */
        .sheet-area {
            flex: 1;
            overflow: auto;
            position: relative;
            background: #fff;
        }

        .sheet-grid {
            position: relative;
            min-width: 100%;
            min-height: 100%;
        }

        /* Column Headers */
        .column-headers {
            position: sticky;
            top: 0;
            left: 60px;
            display: flex;
            z-index: 10;
            background: #f3f2f1;
            border-bottom: 2px solid #0078d4;
        }

        .column-header {
            min-width: 100px;
            width: 100px;
            padding: 8px;
            text-align: center;
            border-right: 1px solid #d1d1d1;
            border-bottom: 1px solid #d1d1d1;
            font-weight: 600;
            font-size: 12px;
            cursor: pointer;
            position: relative;
            user-select: none;
        }

        .column-header:hover {
            background: #e1e1e1;
        }

        .column-resizer {
            position: absolute;
            right: 0;
            top: 0;
            width: 4px;
            height: 100%;
            cursor: col-resize;
            z-index: 5;
        }

        .column-resizer:hover {
            background: #0078d4;
        }

        /* Row Headers */
        .row-headers {
            position: sticky;
            left: 0;
            top: 33px;
            z-index: 10;
            background: #f3f2f1;
        }

        .row-header {
            height: 32px;
            width: 60px;
            padding: 8px;
            text-align: center;
            border-right: 1px solid #d1d1d1;
            border-bottom: 1px solid #d1d1d1;
            font-size: 12px;
            cursor: pointer;
            user-select: none;
        }

        .row-header:hover {
            background: #e1e1e1;
        }

        /* Cells Container */
        .cells-container {
            position: absolute;
            left: 60px;
            top: 33px;
        }

        .cell-row {
            display: flex;
        }

        .cell {
            width: 100px;
            min-width: 100px;
            height: 32px;
            border-right: 1px solid #e1e1e1;
            border-bottom: 1px solid #e1e1e1;
            padding: 6px;
            font-size: 14px;
            outline: none;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            background: #fff;
            cursor: cell;
            position: relative;
        }

        .cell.selected {
            border: 2px solid #0078d4;
            padding: 5px;
        }

        .cell.range-selected {
            background: #e8f4ff;
        }

        .cell.editing {
            border: 2px solid #0078d4;
            background: #fff;
            overflow: visible;
            white-space: normal;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        /* Sheet Tabs */
        .sheet-tabs {
            background: #fff;
            border-top: 1px solid #d1d1d1;
            padding: 8px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .sheet-tab {
            padding: 8px 16px;
            background: #f3f2f1;
            border: 1px solid #d1d1d1;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
        }

        .sheet-tab.active {
            background: #fff;
            border-bottom: 1px solid #fff;
            margin-bottom: -1px;
        }

        .sheet-tab:hover {
            background: #e1e1e1;
        }

        .sheet-tab input {
            border: none;
            background: transparent;
            font-size: 14px;
            width: 60px;
            outline: none;
        }

        .sheet-tab button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px;
            border-radius: 2px;
            opacity: 0.5;
        }

        .sheet-tab button:hover {
            background: #d1d1d1;
            opacity: 1;
        }

        .add-sheet-btn {
            padding: 8px 12px;
            background: #f3f2f1;
            border: 1px solid #d1d1d1;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .add-sheet-btn:hover {
            background: #e1e1e1;
        }

        /* Selection Box */
        .selection-box {
            position: absolute;
            border: 2px solid #0078d4;
            background: rgba(0, 120, 212, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* Formula Selector */
        .formula-selector {
            position: absolute;
            border: 2px dashed #0078d4;
            background: rgba(0, 120, 212, 0.1);
            pointer-events: none;
            z-index: 60;
            display: none;
        }

        /* Scrollbars */
        .sheet-area::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        .sheet-area::-webkit-scrollbar-track {
            background: #f3f2f1;
        }

        .sheet-area::-webkit-scrollbar-thumb {
            background: #d1d1d1;
            border-radius: 6px;
        }

        .sheet-area::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }

        /* Status Bar */
        .status-bar {
            background: #f3f2f1;
            border-top: 1px solid #d1d1d1;
            padding: 4px 8px;
            font-size: 12px;
            color: #666;
            display: flex;
            justify-content: space-between;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .toolbar {
                padding: 4px;
            }
            
            .toolbar button {
                padding: 4px 8px;
                font-size: 12px;
            }
            
            .column-header, .cell {
                min-width: 80px;
                width: 80px;
            }
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #0078d4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="spreadsheet-container">
        <!-- Toolbar -->
        <div class="toolbar">
            <div class="toolbar-group">
                <button onclick="spreadsheet.undo()" title="Undo">‚Ü∂</button>
                <button onclick="spreadsheet.redo()" title="Redo">‚Ü∑</button>
            </div>
            <div class="toolbar-group">
                <button onclick="spreadsheet.cut()" title="Cut">‚úÇÔ∏è</button>
                <button onclick="spreadsheet.copy()" title="Copy">üìã</button>
                <button onclick="spreadsheet.paste()" title="Paste">üìÑ</button>
            </div>
            <div class="toolbar-group">
                <button id="boldBtn" onclick="spreadsheet.toggleBold()" title="Bold"><b>B</b></button>
                <button id="italicBtn" onclick="spreadsheet.toggleItalic()" title="Italic"><i>I</i></button>
            </div>
            <div class="toolbar-group">
                <input type="color" id="bgColorPicker" onchange="spreadsheet.setBackgroundColor(this.value)" title="Background Color">
                <button onclick="spreadsheet.clearFormatting()" title="Clear Formatting">üßπ</button>
            </div>
            <div class="toolbar-group">
                <button onclick="spreadsheet.clearContents()" title="Clear Contents">‚ùå</button>
                <button onclick="spreadsheet.deleteSheet()" title="Delete Sheet">üóëÔ∏è</button>
            </div>
            <div class="toolbar-group">
                <button onclick="spreadsheet.downloadCSV()" title="Download CSV">‚¨áÔ∏è CSV</button>
                <button onclick="spreadsheet.uploadCSV()" title="Upload CSV">‚¨ÜÔ∏è CSV</button>
                <input type="file" id="csvFileInput" accept=".csv" style="display: none;" onchange="spreadsheet.handleCSVUpload(event)">
            </div>
        </div>

        <!-- Formula Bar -->
        <div class="formula-bar">
            <div class="cell-address" id="cellAddress">A1</div>
            <input type="text" class="formula-input" id="formulaInput" placeholder="Enter formula or value">
        </div>

        <!-- Sheet Area -->
        <div class="sheet-area" id="sheetArea">
            <div class="sheet-grid" id="sheetGrid">
                <!-- Column Headers -->
                <div class="column-headers" id="columnHeaders"></div>
                
                <!-- Row Headers -->
                <div class="row-headers" id="rowHeaders"></div>
                
                <!-- Cells Container -->
                <div class="cells-container" id="cellsContainer"></div>
                
                <!-- Selection Box -->
                <div class="selection-box" id="selectionBox"></div>
                
                <!-- Formula Selector -->
                <div class="formula-selector" id="formulaSelector"></div>
            </div>
        </div>

        <!-- Sheet Tabs -->
        <div class="sheet-tabs" id="sheetTabs">
            <button class="add-sheet-btn" onclick="spreadsheet.addSheet()">+ Add Sheet</button>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <span id="statusText">Ready</span>
            <span id="cellCount">0 cells selected</span>
        </div>
    </div>

    <script>
        class Spreadsheet {
            constructor() {
                this.sheets = [];
                this.activeSheet = null;
                this.activeCell = { row: 0, col: 0 };
                this.selection = { start: { row: 0, col: 0 }, end: { row: 0, col: 0 } };
                this.isSelecting = false;
                this.isEditing = false;
                this.isResizing = false;
                this.formulaMode = false;
                this.history = [];
                this.historyIndex = -1;
                this.clipboard = null;
                
                this.formulas = {
                    'SUM': (args) => args.reduce((sum, val) => sum + val, 0),
                    'AVERAGE': (args) => args.reduce((sum, val) => sum + val, 0) / args.length,
                    'MIN': (args) => Math.min(...args),
                    'MAX': (args) => Math.max(...args),
                    'COUNT': (args) => args.length,
                    'IF': (args) => args[0] ? args[1] : args[2]
                };
                
                this.init();
            }

            init() {
                this.addSheet('Sheet1');
                this.render();
                this.attachEventListeners();
                this.updateCellAddress();
            }

            addSheet(name = null) {
                if (!name) {
                    let i = 2;
                    while (this.sheets.find(s => s.name === `Sheet${i}`)) i++;
                    name = `Sheet${i}`;
                }

                const sheet = {
                    id: Date.now(),
                    name: name,
                    cells: new Map(),
                    columnWidths: {},
                    rowHeights: {},
                    formulas: new Map()
                };

                this.sheets.push(sheet);
                this.activeSheet = sheet;
                this.renderSheetTabs();
                this.render();
                this.saveState();
            }

            deleteSheet() {
                if (this.sheets.length <= 1) {
                    alert('Cannot delete the last sheet');
                    return;
                }

                const index = this.sheets.indexOf(this.activeSheet);
                this.sheets.splice(index, 1);
                this.activeSheet = this.sheets[Math.max(0, index - 1)];
                this.renderSheetTabs();
                this.render();
                this.saveState();
            }

            renameSheet(sheetId, newName) {
                const sheet = this.sheets.find(s => s.id === sheetId);
                if (sheet) {
                    sheet.name = newName || 'Sheet';
                    this.renderSheetTabs();
                    this.saveState();
                }
            }

            renderSheetTabs() {
                const container = document.getElementById('sheetTabs');
                const addBtn = container.querySelector('.add-sheet-btn');
                
                // Clear existing tabs
                container.querySelectorAll('.sheet-tab').forEach(tab => tab.remove());
                
                // Add tabs
                this.sheets.forEach(sheet => {
                    const tab = document.createElement('div');
                    tab.className = `sheet-tab ${sheet === this.activeSheet ? 'active' : ''}`;
                    tab.innerHTML = `
                        <input type="text" value="${sheet.name}" onblur="spreadsheet.renameSheet(${sheet.id}, this.value)" 
                               onkeydown="if(event.key==='Enter') { this.blur(); event.stopPropagation(); }">
                        <button onclick="event.stopPropagation(); spreadsheet.deleteSheet();">√ó</button>
                    `;
                    tab.onclick = (e) => {
                        if (e.target.type !== 'text') {
                            this.activeSheet = sheet;
                            this.renderSheetTabs();
                            this.render();
                        }
                    };
                    container.insertBefore(tab, addBtn);
                });
            }

            render() {
                this.renderColumnHeaders();
                this.renderRowHeaders();
                this.renderCells();
                this.updateStatus();
            }

            renderColumnHeaders() {
                const container = document.getElementById('columnHeaders');
                container.innerHTML = '';
                
                for (let col = 0; col < 26; col++) {
                    const header = document.createElement('div');
                    header.className = 'column-header';
                    header.textContent = this.getColumnLetter(col);
                    header.style.width = (this.activeSheet.columnWidths[col] || 100) + 'px';
                    
                    // Column resizer
                    const resizer = document.createElement('div');
                    resizer.className = 'column-resizer';
                    resizer.onmousedown = (e) => this.startColumnResize(e, col);
                    header.appendChild(resizer);
                    
                    container.appendChild(header);
                }
            }

            renderRowHeaders() {
                const container = document.getElementById('rowHeaders');
                container.innerHTML = '';
                
                for (let row = 0; row < 100; row++) {
                    const header = document.createElement('div');
                    header.className = 'row-header';
                    header.textContent = row + 1;
                    header.style.height = (this.activeSheet.rowHeights[row] || 32) + 'px';
                    container.appendChild(header);
                }
            }

            renderCells() {
                const container = document.getElementById('cellsContainer');
                container.innerHTML = '';
                
                for (let row = 0; row < 100; row++) {
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'cell-row';
                    
                    for (let col = 0; col < 26; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.style.width = (this.activeSheet.columnWidths[col] || 100) + 'px';
                        cell.style.height = (this.activeSheet.rowHeights[row] || 32) + 'px';
                        
                        const cellKey = `${row},${col}`;
                        const value = this.activeSheet.cells.get(cellKey);
                        if (value !== undefined) {
                            cell.textContent = value;
                        }
                        
                        cell.ondblclick = () => this.editCell(row, col);
                        cell.onmousedown = (e) => this.startSelection(e, row, col);
                        cell.onmousemove = (e) => this.updateSelection(e, row, col);
                        cell.onmouseup = () => this.endSelection();
                        
                        rowDiv.appendChild(cell);
                    }
                    
                    container.appendChild(rowDiv);
                }
                
                this.updateSelectionDisplay();
            }

            getColumnLetter(col) {
                let letter = '';
                while (col >= 0) {
                    letter = String.fromCharCode(65 + (col % 26)) + letter;
                    col = Math.floor(col / 26) - 1;
                }
                return letter || 'A';
            }

            getCellAddress(row, col) {
                return `${this.getColumnLetter(col)}${row + 1}`;
            }

            parseCellAddress(address) {
                const match = address.match(/^([A-Z]+)(\d+)$/);
                if (!match) return null;
                
                const colLetters = match[1];
                const row = parseInt(match[2]) - 1;
                
                let col = 0;
                for (let i = 0; i < colLetters.length; i++) {
                    col = col * 26 + colLetters.charCodeAt(i) - 64;
                }
                
                return { row, col: col - 1 };
            }

            editCell(row, col) {
                this.isEditing = true;
                this.activeCell = { row, col };
                this.updateCellAddress();
                
                const cellKey = `${row},${col}`;
                const formula = this.activeSheet.formulas.get(cellKey);
                const value = this.activeSheet.cells.get(cellKey);
                
                const formulaInput = document.getElementById('formulaInput');
                formulaInput.value = formula || (value || '');
                formulaInput.focus();
                formulaInput.select();
                
                const cell = this.getCellElement(row, col);
                if (cell) {
                    cell.classList.add('editing');
                }
            }

            startSelection(e, row, col) {
                if (this.isEditing) return;
                
                this.isSelecting = true;
                this.activeCell = { row, col };
                this.selection = { start: { row, col }, end: { row, col } };
                this.updateCellAddress();
                
                const formulaInput = document.getElementById('formulaInput');
                if (document.activeElement === formulaInput && formulaInput.value.startsWith('=')) {
                    this.formulaMode = true;
                    this.formulaStart = formulaInput.selectionStart;
                }
                
                e.preventDefault();
            }

            updateSelection(e, row, col) {
                if (!this.isSelecting) return;
                
                this.selection.end = { row, col };
                this.updateSelectionDisplay();
                
                if (this.formulaMode) {
                    this.updateFormulaSelection();
                }
            }

            endSelection() {
                this.isSelecting = false;
                this.formulaMode = false;
            }

            updateSelectionDisplay() {
                const cells = document.querySelectorAll('.cell');
                cells.forEach(cell => {
                    cell.classList.remove('selected', 'range-selected');
                });
                
                const { start, end } = this.selection;
                const minRow = Math.min(start.row, end.row);
                const maxRow = Math.max(start.row, end.row);
                const minCol = Math.min(start.col, end.col);
                const maxCol = Math.max(start.col, end.col);
                
                for (let row = minRow; row <= maxRow; row++) {
                    for (let col = minCol; col <= maxCol; col++) {
                        const cell = this.getCellElement(row, col);
                        if (cell) {
                            if (row === this.activeCell.row && col === this.activeCell.col) {
                                cell.classList.add('selected');
                            } else {
                                cell.classList.add('range-selected');
                            }
                        }
                    }
                }
                
                this.updateStatus();
            }

            updateFormulaSelection() {
                const { start, end } = this.selection;
                const minRow = Math.min(start.row, end.row);
                const maxRow = Math.max(start.row, end.row);
                const minCol = Math.min(start.col, end.col);
                const maxCol = Math.max(start.col, end.col);
                
                let range;
                if (minRow === maxRow && minCol === maxCol) {
                    range = this.getCellAddress(minRow, minCol);
                } else {
                    range = `${this.getCellAddress(minRow, minCol)}:${this.getCellAddress(maxRow, maxCol)}`;
                }
                
                const formulaInput = document.getElementById('formulaInput');
                const value = formulaInput.value;
                const before = value.substring(0, this.formulaStart);
                const after = value.substring(this.formulaStart);
                formulaInput.value = before + range + after;
                formulaInput.focus();
                formulaInput.setSelectionRange(before.length + range.length, before.length + range.length);
            }

            getCellElement(row, col) {
                return document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            }

            updateCellAddress() {
                const address = this.getCellAddress(this.activeCell.row, this.activeCell.col);
                document.getElementById('cellAddress').textContent = address;
                
                const cellKey = `${this.activeCell.row},${this.activeCell.col}`;
                const formula = this.activeSheet.formulas.get(cellKey);
                const value = this.activeSheet.cells.get(cellKey);
                
                const formulaInput = document.getElementById('formulaInput');
                if (!this.isEditing) {
                    formulaInput.value = formula || (value || '');
                }
            }

            attachEventListeners() {
                const formulaInput = document.getElementById('formulaInput');
                formulaInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        this.commitEdit();
                    } else if (e.key === 'Escape') {
                        this.cancelEdit();
                    }
                });
                
                formulaInput.addEventListener('input', () => {
                    if (this.isEditing) {
                        const value = formulaInput.value;
                        if (value.startsWith('=')) {
                            this.activeSheet.formulas.set(`${this.activeCell.row},${this.activeCell.col}`, value);
                        } else {
                            this.activeSheet.formulas.delete(`${this.activeCell.row},${this.activeCell.col}`);
                        }
                    }
                });
                
                formulaInput.addEventListener('focus', () => {
                    if (!this.isEditing) {
                        this.editCell(this.activeCell.row, this.activeCell.col);
                    }
                });
                
                // Keyboard navigation
                document.addEventListener('keydown', (e) => {
                    if (this.isEditing && e.target === formulaInput) return;
                    
                    let newRow = this.activeCell.row;
                    let newCol = this.activeCell.col;
                    
                    switch(e.key) {
                        case 'ArrowUp':
                            newRow = Math.max(0, newRow - 1);
                            break;
                        case 'ArrowDown':
                            newRow = Math.min(99, newRow + 1);
                            break;
                        case 'ArrowLeft':
                            newCol = Math.max(0, newCol - 1);
                            break;
                        case 'ArrowRight':
                            newCol = Math.min(25, newCol + 1);
                            break;
                        case 'Enter':
                            this.editCell(newRow, newCol);
                            return;
                        case 'Tab':
                            e.preventDefault();
                            newCol = Math.min(25, newCol + 1);
                            break;
                        case 'Delete':
                            this.clearContents();
                            return;
                        default:
                            if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
                                this.editCell(newRow, newCol);
                                formulaInput.value = e.key;
                                formulaInput.focus();
                                formulaInput.setSelectionRange(1, 1);
                            }
                            return;
                    }
                    
                    this.activeCell = { row: newRow, col: newCol };
                    this.selection = { start: { row: newRow, col: newCol }, end: { row: newRow, col: newCol } };
                    this.updateCellAddress();
                    this.updateSelectionDisplay();
                });
                
                // Click outside to commit edit
                document.addEventListener('click', (e) => {
                    if (this.isEditing && !e.target.classList.contains('cell') && e.target !== formulaInput) {
                        this.commitEdit();
                    }
                });
                
                // Global mouseup to end selection
                document.addEventListener('mouseup', () => {
                    if (this.isSelecting) {
                        this.endSelection();
                    }
                });
            }

            commitEdit() {
                if (!this.isEditing) return;
                
                const formulaInput = document.getElementById('formulaInput');
                const value = formulaInput.value;
                const cellKey = `${this.activeCell.row},${this.activeCell.col}`;
                
                if (value.startsWith('=')) {
                    this.activeSheet.formulas.set(cellKey, value);
                    this.evaluateFormula(cellKey, value);
                } else {
                    this.activeSheet.formulas.delete(cellKey);
                    this.activeSheet.cells.set(cellKey, value);
                    this.updateCellDisplay(this.activeCell.row, this.activeCell.col);
                    this.recalculateDependents(cellKey);
                }
                
                const cell = this.getCellElement(this.activeCell.row, this.activeCell.col);
                if (cell) {
                    cell.classList.remove('editing');
                }
                
                this.isEditing = false;
                this.saveState();
            }

            cancelEdit() {
                if (!this.isEditing) return;
                
                const cell = this.getCellElement(this.activeCell.row, this.activeCell.col);
                if (cell) {
                    cell.classList.remove('editing');
                }
                
                this.isEditing = false;
                this.updateCellAddress();
            }

            evaluateFormula(cellKey, formula) {
                try {
                    const result = this.parseAndEvaluate(formula.substring(1));
                    this.activeSheet.cells.set(cellKey, result);
                    this.updateCellDisplay(...cellKey.split(',').map(Number));
                } catch (error) {
                    this.activeSheet.cells.set(cellKey, '#ERROR');
                    this.updateCellDisplay(...cellKey.split(',').map(Number));
                }
            }

            parseAndEvaluate(expression) {
                // Handle ranges (e.g., A1:A10)
                const rangeMatch = expression.match(/^([A-Z]+\d+):([A-Z]+\d+)$/);
                if (rangeMatch) {
                    const start = this.parseCellAddress(rangeMatch[1]);
                    const end = this.parseCellAddress(rangeMatch[2]);
                    const values = [];
                    
                    for (let row = start.row; row <= end.row; row++) {
                        for (let col = start.col; col <= end.col; col++) {
                            const value = this.getCellValue(row, col);
                            if (typeof value === 'number') {
                                values.push(value);
                            }
                        }
                    }
                    
                    return values;
                }
                
                // Handle functions (e.g., SUM(A1:A10))
                const funcMatch = expression.match(/^([A-Z]+)\((.*)\)$/);
                if (funcMatch) {
                    const funcName = funcMatch[1];
                    const args = this.parseArguments(funcMatch[2]);
                    
                    if (this.formulas[funcName]) {
                        const evaluatedArgs = args.map(arg => {
                            if (arg.match(/^[A-Z]+\d+$/)) {
                                const addr = this.parseCellAddress(arg);
                                return this.getCellValue(addr.row, addr.col);
                            } else if (arg.match(/^[A-Z]+\d+:[A-Z]+\d+$/)) {
                                return this.parseAndEvaluate(arg);
                            } else if (!isNaN(parseFloat(arg))) {
                                return parseFloat(arg);
                            }
                            return arg;
                        });
                        
                        // Flatten array arguments for functions like SUM
                        const flatArgs = evaluatedArgs.flat();
                        const numericArgs = flatArgs.filter(v => typeof v === 'number');
                        
                        return this.formulas[funcName](numericArgs);
                    }
                }
                
                // Handle cell references (e.g., A1 + B2)
                return this.evaluateExpression(expression);
            }

            parseArguments(argString) {
                const args = [];
                let currentArg = '';
                let depth = 0;
                
                for (let i = 0; i < argString.length; i++) {
                    const char = argString[i];
                    
                    if (char === '(') {
                        depth++;
                        currentArg += char;
                    } else if (char === ')') {
                        depth--;
                        currentArg += char;
                    } else if (char === ',' && depth === 0) {
                        args.push(currentArg.trim());
                        currentArg = '';
                    } else {
                        currentArg += char;
                    }
                }
                
                if (currentArg) {
                    args.push(currentArg.trim());
                }
                
                return args;
            }

            evaluateExpression(expression) {
                // Replace cell references with their values
                expression = expression.replace(/[A-Z]+\d+/g, (match) => {
                    const addr = this.parseCellAddress(match);
                    return this.getCellValue(addr.row, addr.col);
                });
                
                // Evaluate the expression
                try {
                    // eslint-disable-next-line no-eval
                    return eval(expression);
                } catch (error) {
                    return '#ERROR';
                }
            }

            getCellValue(row, col) {
                const cellKey = `${row},${col}`;
                const value = this.activeSheet.cells.get(cellKey);
                const formula = this.activeSheet.formulas.get(cellKey);
                
                if (formula) {
                    return this.parseAndEvaluate(formula.substring(1));
                }
                
                return value || 0;
            }

            recalculateDependents(changedCellKey) {
                // Simple recalculation - in a real implementation, this would be more efficient
                this.activeSheet.formulas.forEach((formula, cellKey) => {
                    if (formula.includes(changedCellKey.split(',').join('')) || 
                        this.isCellInRange(formula, changedCellKey)) {
                        this.evaluateFormula(cellKey, formula);
                    }
                });
            }

            isCellInRange(formula, cellKey) {
                const [changedRow, changedCol] = cellKey.split(',').map(Number);
                const rangeMatch = formula.match(/[A-Z]+\d+:[A-Z]+\d+/);
                
                if (rangeMatch) {
                    const range = rangeMatch[0];
                    const [start, end] = range.split(':');
                    const startAddr = this.parseCellAddress(start);
                    const endAddr = this.parseCellAddress(end);
                    
                    return changedRow >= startAddr.row && changedRow <= endAddr.row &&
                           changedCol >= startAddr.col && changedCol <= endAddr.col;
                }
                
                return false;
            }

            updateCellDisplay(row, col) {
                const cell = this.getCellElement(row, col);
                if (cell) {
                    const cellKey = `${row},${col}`;
                    const value = this.activeSheet.cells.get(cellKey);
                    cell.textContent = value !== undefined ? value : '';
                }
            }

            clearContents() {
                const { start, end } = this.selection;
                const minRow = Math.min(start.row, end.row);
                const maxRow = Math.max(start.row, end.row);
                const minCol = Math.min(start.col, end.col);
                const maxCol = Math.max(start.col, end.col);
                
                for (let row = minRow; row <= maxRow; row++) {
                    for (let col = minCol; col <= maxCol; col++) {
                        const cellKey = `${row},${col}`;
                        this.activeSheet.cells.delete(cellKey);
                        this.activeSheet.formulas.delete(cellKey);
                        this.updateCellDisplay(row, col);
                    }
                }
                
                this.saveState();
            }

            clearFormatting() {
                const { start, end } = this.selection;
                const minRow = Math.min(start.row, end.row);
                const maxRow = Math.max(start.row, end.row);
                const minCol = Math.min(start.col, end.col);
                const maxCol = Math.max(start.col, end.col);
                
                for (let row = minRow; row <= maxRow; row++) {
                    for (let col = minCol; col <= maxCol; col++) {
                        const cell = this.getCellElement(row, col);
                        if (cell) {
                            cell.style.fontWeight = '';
                            cell.style.fontStyle = '';
                            cell.style.backgroundColor = '';
                        }
                    }
                }
                
                this.saveState();
            }

            toggleBold() {
                const { start, end } = this.selection;
                const minRow = Math.min(start.row, end.row);
                const maxRow = Math.max(start.row, end.row);
                const minCol = Math.min(start.col, end.col);
                const maxCol = Math.max(start.col, end.col);
                
                const cell = this.getCellElement(minRow, minCol);
                const isBold = cell.style.fontWeight === 'bold';
                
                for (let row = minRow; row <= maxRow; row++) {
                    for (let col = minCol; col <= maxCol; col++) {
                        const cell = this.getCellElement(row, col);
                        if (cell) {
                            cell.style.fontWeight = isBold ? '' : 'bold';
                        }
                    }
                }
                
                document.getElementById('boldBtn').classList.toggle('active', !isBold);
                this.saveState();
            }

            toggleItalic() {
                const { start, end } = this.selection;
                const minRow = Math.min(start.row, end.row);
                const maxRow = Math.max(start.row, end.row);
                const minCol = Math.min(start.col, end.col);
                const maxCol = Math.max(start.col, end.col);
                
                const cell = this.getCellElement(minRow, minCol);
                const isItalic = cell.style.fontStyle === 'italic';
                
                for (let row = minRow; row <= maxRow; row++) {
                    for (let col = minCol; col <= maxCol; col++) {
                        const cell = this.getCellElement(row, col);
                        if (cell) {
                            cell.style.fontStyle = isItalic ? '' : 'italic';
                        }
                    }
                }
                
                document.getElementById('italicBtn').classList.toggle('active', !isItalic);
                this.saveState();
            }

            setBackgroundColor(color) {
                const { start, end } = this.selection;
                const minRow = Math.min(start.row, end.row);
                const maxRow = Math.max(start.row, end.row);
                const minCol = Math.min(start.col, end.col);
                const maxCol = Math.max(start.col, end.col);
                
                for (let row = minRow; row <= maxRow; row++) {
                    for (let col = minCol; col <= maxCol; col++) {
                        const cell = this.getCellElement(row, col);
                        if (cell) {
                            cell.style.backgroundColor = color;
                        }
                    }
                }
                
                this.saveState();
            }

            startColumnResize(e, col) {
                this.isResizing = true;
                const startX = e.clientX;
                const startWidth = this.activeSheet.columnWidths[col] || 100;
                
                const onMouseMove = (e) => {
                    const newWidth = Math.max(20, startWidth + e.clientX - startX);
                    this.activeSheet.columnWidths[col] = newWidth;
                    this.render();
                };
                
                const onMouseUp = () => {
                    this.isResizing = false;
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    this.saveState();
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }

            downloadCSV() {
                const { start, end } = this.selection;
                const minRow = Math.min(start.row, end.row);
                const maxRow = Math.max(start.row, end.row);
                const minCol = Math.min(start.col, end.col);
                const maxCol = Math.max(start.col, end.col);
                
                let csv = '';
                for (let row = minRow; row <= maxRow; row++) {
                    const rowData = [];
                    for (let col = minCol; col <= maxCol; col++) {
                        const cellKey = `${row},${col}`;
                        const value = this.activeSheet.cells.get(cellKey) || '';
                        rowData.push(`"${value}"`);
                    }
                    csv += rowData.join(',') + '\n';
                }
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${this.activeSheet.name}.csv`;
                a.click();
                URL.revokeObjectURL(url);
            }

            uploadCSV() {
                document.getElementById('csvFileInput').click();
            }

            handleCSVUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const csv = e.target.result;
                    const rows = csv.split('\n').filter(row => row.trim());
                    
                    rows.forEach((row, rowIndex) => {
                        const values = row.split(',').map(v => v.replace(/^"|"$/g, ''));
                        values.forEach((value, colIndex) => {
                            if (value) {
                                const cellKey = `${rowIndex},${colIndex}`;
                                this.activeSheet.cells.set(cellKey, value);
                            }
                        });
                    });
                    
                    this.render();
                    this.saveState();
                    event.target.value = '';
                };
                
                reader.readAsText(file);
            }

            cut() {
                this.copy();
                this.clearContents();
            }

            copy() {
                const { start, end } = this.selection;
                const minRow = Math.min(start.row, end.row);
                const maxRow = Math.max(start.row, end.row);
                const minCol = Math.min(start.col, end.col);
                const maxCol = Math.max(start.col, end.col);
                
                const data = [];
                for (let row = minRow; row <= maxRow; row++) {
                    const rowData = [];
                    for (let col = minCol; col <= maxCol; col++) {
                        const cellKey = `${row},${col}`;
                        rowData.push(this.activeSheet.cells.get(cellKey) || '');
                    }
                    data.push(rowData);
                }
                
                this.clipboard = data;
            }

            paste() {
                if (!this.clipboard) return;
                
                const { start } = this.selection;
                const startRow = start.row;
                const startCol = start.col;
                
                this.clipboard.forEach((rowData, rowOffset) => {
                    rowData.forEach((value, colOffset) => {
                        const row = startRow + rowOffset;
                        const col = startCol + colOffset;
                        if (row < 100 && col < 26) {
                            const cellKey = `${row},${col}`;
                            this.activeSheet.cells.set(cellKey, value);
                            this.updateCellDisplay(row, col);
                        }
                    });
                });
                
                this.render();
                this.saveState();
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    const state = this.history[this.historyIndex];
                    this.restoreState(state);
                }
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    const state = this.history[this.historyIndex];
                    this.restoreState(state);
                }
            }

            saveState() {
                const state = JSON.stringify({
                    sheets: this.sheets.map(sheet => ({
                        ...sheet,
                        cells: Array.from(sheet.cells.entries()),
                        formulas: Array.from(sheet.formulas.entries())
                    }))
                });
                
                this.history = this.history.slice(0, this.historyIndex + 1);
                this.history.push(state);
                this.historyIndex++;
                
                // Limit history size
                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyIndex--;
                }
            }

            restoreState(stateString) {
                const state = JSON.parse(stateString);
                this.sheets = state.sheets.map(sheet => ({
                    ...sheet,
                    cells: new Map(sheet.cells),
                    formulas: new Map(sheet.formulas)
                }));
                
                if (!this.activeSheet || !this.sheets.includes(this.activeSheet)) {
                    this.activeSheet = this.sheets[0];
                }
                
                this.render();
            }

            updateStatus() {
                const { start, end } = this.selection;
                const rows = Math.abs(end.row - start.row) + 1;
                const cols = Math.abs(end.col - start.col) + 1;
                document.getElementById('cellCount').textContent = `${rows * cols} cells selected`;
            }
        }

        // Initialize spreadsheet
        const spreadsheet = new Spreadsheet();
    </script>
</body>
</html>