<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Heat Diffusion Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #canvas-container {
            position: relative;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            overflow: hidden;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 320px;
            transition: transform 0.3s ease;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        .controls.hidden {
            transform: translateX(-340px);
        }

        .controls h3 {
            margin-top: 0;
            color: #ff6b6b;
            font-size: 18px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group {
            margin-bottom: 18px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            color: #b3e5fc;
            font-weight: 500;
        }

        .slider {
            width: 100%;
            height: 5px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ff6b6b;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            background: #ff5252;
            transform: scale(1.2);
        }

        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ff6b6b;
            cursor: pointer;
            border: none;
        }

        .value-display {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-left: 8px;
        }

        .material-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .material-btn {
            padding: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .material-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .material-btn.active {
            background: linear-gradient(135deg, #ff6b6b, #ff8e53);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
        }

        .boundary-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .boundary-btn {
            flex: 1;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .boundary-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .boundary-btn.active {
            background: rgba(255, 107, 107, 0.3);
            border-color: #ff6b6b;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 12px;
            background: linear-gradient(135deg, #ff6b6b, #ff8e53);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .btn.secondary {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        .info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 18px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            font-size: 13px;
            max-width: 280px;
        }

        .info h4 {
            margin-top: 0;
            color: #ff6b6b;
            margin-bottom: 12px;
            font-size: 15px;
        }

        .info div {
            margin: 8px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info .key {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
        }

        .toggle-btn {
            position: absolute;
            top: 20px;
            left: 360px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 0 10px 10px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
        }

        .toggle-btn.shifted {
            left: 20px;
        }

        .toggle-btn:hover {
            background: rgba(0, 0, 0, 0.95);
        }

        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            font-size: 12px;
            min-width: 150px;
        }

        .stats div {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }

        .stats .label {
            color: #b3e5fc;
        }

        .stats .value {
            color: #ff6b6b;
            font-weight: bold;
        }

        .color-scale {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background: linear-gradient(to right, #0000ff, #00ffff, #00ff00, #ffff00, #ff0000);
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .color-labels {
            position: absolute;
            bottom: 45px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            display: flex;
            justify-content: space-between;
            color: white;
            font-size: 11px;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div class="controls" id="controls">
            <h3>üî• Heat Diffusion Controls</h3>
            
            <div class="control-group">
                <label>Thermal Conductivity <span class="value-display" id="conductivityValue">0.25</span></label>
                <input type="range" class="slider" id="conductivity" min="0.01" max="1" step="0.01" value="0.25">
            </div>
            
            <div class="control-group">
                <label>Diffusion Speed <span class="value-display" id="diffusionValue">0.15</span></label>
                <input type="range" class="slider" id="diffusion" min="0.01" max="0.5" step="0.01" value="0.15">
            </div>
            
            <div class="control-group">
                <label>Grid Resolution <span class="value-display" id="resolutionValue">128</span></label>
                <input type="range" class="slider" id="resolution" min="64" max="256" step="32" value="128">
            </div>
            
            <div class="control-group">
                <label>Convection Strength <span class="value-display" id="convectionValue">0</span></label>
                <input type="range" class="slider" id="convection" min="0" max="0.5" step="0.01" value="0">
            </div>
            
            <div class="control-group">
                <label>Ambient Temperature <span class="value-display" id="ambientValue">20¬∞C</span></label>
                <input type="range" class="slider" id="ambient" min="0" max="100" step="1" value="20">
            </div>
            
            <div class="control-group">
                <label>Material Presets</label>
                <div class="material-buttons">
                    <button class="material-btn active" onclick="heatSim.setMaterial('air')">Air</button>
                    <button class="material-btn" onclick="heatSim.setMaterial('water')">Water</button>
                    <button class="material-btn" onclick="heatSim.setMaterial('metal')">Metal</button>
                    <button class="material-btn" onclick="heatSim.setMaterial('insulator')">Insulator</button>
                </div>
            </div>
            
            <div class="control-group">
                <label>Boundary Conditions</label>
                <div class="boundary-buttons">
                    <button class="boundary-btn active" onclick="heatSim.setBoundary('insulated')">Insulated</button>
                    <button class="boundary-btn" onclick="heatSim.setBoundary('constant')">Constant</button>
                    <button class="boundary-btn" onclick="heatSim.setBoundary('periodic')">Periodic</button>
                </div>
            </div>
            
            <div class="action-buttons">
                <button class="btn" onclick="heatSim.reset()">üîÑ Reset</button>
                <button class="btn secondary" onclick="heatSim.randomHeat()">üé≤ Random</button>
            </div>
        </div>
        
        <button class="toggle-btn" id="toggleBtn" onclick="toggleControls()">‚ò∞</button>
        
        <div class="stats">
            <div><span class="label">Max Temp:</span> <span class="value" id="maxTemp">20¬∞C</span></div>
            <div><span class="label">Min Temp:</span> <span class="value" id="minTemp">20¬∞C</span></div>
            <div><span class="label">Avg Temp:</span> <span class="value" id="avgTemp">20¬∞C</span></div>
            <div><span class="label">FPS:</span> <span class="value" id="fps">60</span></div>
        </div>
        
        <div class="info">
            <h4>üéÆ Instructions</h4>
            <div>üñ±Ô∏è <strong>Click & Drag:</strong> Add heat</div>
            <div>‚å®Ô∏è <strong>Shift + Click:</strong> Cool area</div>
            <div>‚å®Ô∏è <strong>C:</strong> Clear all heat</div>
            <div>‚å®Ô∏è <strong>G:</strong> Toggle GPU mode</div>
            <div>‚å®Ô∏è <strong>Space:</strong> Pause/Resume</div>
            <div>‚å®Ô∏è <strong>1-5:</strong> Heat patterns</div>
        </div>
        
        <div class="color-labels">
            <span>Cold (0¬∞C)</span>
            <span>25¬∞C</span>
            <span>50¬∞C</span>
            <span>75¬∞C</span>
            <span>Hot (100¬∞C)</span>
        </div>
        <div class="color-scale"></div>
    </div>

    <script>
        class HeatSimulation {
            constructor() {
                this.gridSize = 128;
                this.temperature = [];
                this.temperaturePrev = [];
                this.conductivity = 0.25;
                this.diffusionRate = 0.15;
                this.convection = 0;
                this.ambientTemp = 20;
                this.boundaryType = 'insulated';
                this.materialType = 'air';
                this.useGPU = false;
                this.paused = false;
                
                this.mouseX = 0;
                this.mouseY = 0;
                this.mouseDown = false;
                this.shiftPressed = false;
                
                this.materials = {
                    air: { conductivity: 0.25, diffusion: 0.15 },
                    water: { conductivity: 0.6, diffusion: 0.143 },
                    metal: { conductivity: 0.95, diffusion: 0.8 },
                    insulator: { conductivity: 0.05, diffusion: 0.01 }
                };
                
                this.init();
            }
            
            init() {
                const N = this.gridSize * this.gridSize;
                this.temperature = new Float32Array(N);
                this.temperaturePrev = new Float32Array(N);
                
                // Initialize with ambient temperature
                for (let i = 0; i < N; i++) {
                    this.temperature[i] = this.ambientTemp;
                    this.temperaturePrev[i] = this.ambientTemp;
                }
            }
            
            setMaterial(material) {
                this.materialType = material;
                const props = this.materials[material];
                this.conductivity = props.conductivity;
                this.diffusionRate = props.diffusion;
                
                // Update UI
                document.getElementById('conductivity').value = this.conductivity;
                document.getElementById('diffusion').value = this.diffusionRate;
                document.getElementById('conductivityValue').textContent = this.conductivity.toFixed(2);
                document.getElementById('diffusionValue').textContent = this.diffusionRate.toFixed(2);
                
                // Update button states
                document.querySelectorAll('.material-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');
            }
            
            setBoundary(type) {
                this.boundaryType = type;
                
                // Update button states
                document.querySelectorAll('.boundary-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');
            }
            
            addHeat(x, y, amount) {
                const gridX = Math.floor(x * this.gridSize / width);
                const gridY = Math.floor(y * this.gridSize / height);
                const radius = 5;
                
                for (let i = -radius; i <= radius; i++) {
                    for (let j = -radius; j <= radius; j++) {
                        const gx = gridX + i;
                        const gy = gridY + j;
                        
                        if (gx >= 0 && gx < this.gridSize && gy >= 0 && gy < this.gridSize) {
                            const dist = Math.sqrt(i * i + j * j);
                            const idx = gy * this.gridSize + gx;
                            const influence = Math.exp(-(dist * dist) / (radius * radius));
                            this.temperature[idx] += amount * influence;
                        }
                    }
                }
            }
            
            update() {
                if (this.paused) return;
                
                const N = this.gridSize;
                const dt = this.diffusionRate;
                const alpha = this.conductivity;
                const dx = 1.0 / N;
                const dx2 = dx * dx;
                
                // Swap buffers
                const temp = this.temperaturePrev;
                this.temperaturePrev = this.temperature;
                this.temperature = temp;
                
                // Apply finite difference method
                for (let y = 1; y < N - 1; y++) {
                    for (let x = 1; x < N - 1; x++) {
                        const idx = y * N + x;
                        
                        // Calculate Laplacian using central differences
                        const laplacian = (
                            this.temperaturePrev[idx + 1] +      // Right
                            this.temperaturePrev[idx - 1] +      // Left
                            this.temperaturePrev[idx + N] +      // Bottom
                            this.temperaturePrev[idx - N] -      // Top
                            4 * this.temperaturePrev[idx]        // Center
                        ) / dx2;
                        
                        // Add convection (simplified buoyancy)
                        let convectionTerm = 0;
                        if (this.convection > 0) {
                            const tempDiff = this.temperaturePrev[idx] - this.ambientTemp;
                            convectionTerm = -this.convection * tempDiff * 0.01;
                        }
                        
                        // Update temperature using explicit Euler method
                        this.temperature[idx] = this.temperaturePrev[idx] + 
                                              dt * alpha * laplacian + 
                                              convectionTerm;
                        
                        // Clamp to reasonable range
                        this.temperature[idx] = constrain(this.temperature[idx], -50, 150);
                    }
                }
                
                // Apply boundary conditions
                this.applyBoundaryConditions();
                
                // Apply ambient cooling/heating
                for (let i = 0; i < N * N; i++) {
                    this.temperature[i] += (this.ambientTemp - this.temperature[i]) * 0.001;
                }
            }
            
            applyBoundaryConditions() {
                const N = this.gridSize;
                
                switch (this.boundaryType) {
                    case 'insulated':
                        // Neumann boundary conditions (zero gradient)
                        for (let i = 0; i < N; i++) {
                            this.temperature[i] = this.temperature[i + N];                    // Top
                            this.temperature[(N - 1) * N + i] = this.temperature[(N - 2) * N + i]; // Bottom
                            this.temperature[i * N] = this.temperature[i * N + 1];              // Left
                            this.temperature[i * N + N - 1] = this.temperature[i * N + N - 2];   // Right
                        }
                        break;
                        
                    case 'constant':
                        // Dirichlet boundary conditions (fixed temperature)
                        for (let i = 0; i < N; i++) {
                            this.temperature[i] = this.ambientTemp;                           // Top
                            this.temperature[(N - 1) * N + i] = this.ambientTemp;              // Bottom
                            this.temperature[i * N] = this.ambientTemp;                        // Left
                            this.temperature[i * N + N - 1] = this.ambientTemp;                // Right
                        }
                        break;
                        
                    case 'periodic':
                        // Periodic boundary conditions
                        for (let i = 0; i < N; i++) {
                            this.temperature[i] = this.temperature[(N - 2) * N + i];           // Top
                            this.temperature[(N - 1) * N + i] = this.temperature[N + i];        // Bottom
                            this.temperature[i * N] = this.temperature[i * N + N - 2];        // Left
                            this.temperature[i * N + N - 1] = this.temperature[i * N + 1];     // Right
                        }
                        break;
                }
            }
            
            render() {
                const cellSize = width / this.gridSize;
                
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        const idx = y * this.gridSize + x;
                        const temp = this.temperature[idx];
                        const color = this.temperatureToColor(temp);
                        
                        fill(color.r, color.g, color.b);
                        noStroke();
                        rect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
            
            temperatureToColor(temp) {
                // Map temperature to color gradient
                const normalizedTemp = constrain((temp + 50) / 200, 0, 1);
                
                let r, g, b;
                
                if (normalizedTemp < 0.25) {
                    // Blue to Cyan
                    const t = normalizedTemp * 4;
                    r = 0;
                    g = Math.floor(255 * t);
                    b = 255;
                } else if (normalizedTemp < 0.5) {
                    // Cyan to Green
                    const t = (normalizedTemp - 0.25) * 4;
                    r = 0;
                    g = 255;
                    b = Math.floor(255 * (1 - t));
                } else if (normalizedTemp < 0.75) {
                    // Green to Yellow
                    const t = (normalizedTemp - 0.5) * 4;
                    r = Math.floor(255 * t);
                    g = 255;
                    b = 0;
                } else {
                    // Yellow to Red
                    const t = (normalizedTemp - 0.75) * 4;
                    r = 255;
                    g = Math.floor(255 * (1 - t));
                    b = 0;
                }
                
                return { r, g, b };
            }
            
            reset() {
                const N = this.gridSize * this.gridSize;
                for (let i = 0; i < N; i++) {
                    this.temperature[i] = this.ambientTemp;
                    this.temperaturePrev[i] = this.ambientTemp;
                }
            }
            
            randomHeat() {
                for (let i = 0; i < 5; i++) {
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    const amount = random(30, 80);
                    this.addHeat(x, y, amount);
                }
            }
            
            getStats() {
                let min = Infinity, max = -Infinity, sum = 0;
                const N = this.gridSize * this.gridSize;
                
                for (let i = 0; i < N; i++) {
                    const temp = this.temperature[i];
                    min = Math.min(min, temp);
                    max = Math.max(max, temp);
                    sum += temp;
                }
                
                return {
                    min: min.toFixed(1),
                    max: max.toFixed(1),
                    avg: (sum / N).toFixed(1)
                };
            }
            
            resize(newSize) {
                this.gridSize = newSize;
                this.init();
            }
            
            createPattern(type) {
                const cx = this.gridSize / 2;
                const cy = this.gridSize / 2;
                
                switch (type) {
                    case 1: // Hot center
                        for (let y = 0; y < this.gridSize; y++) {
                            for (let x = 0; x < this.gridSize; x++) {
                                const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                                const idx = y * this.gridSize + x;
                                this.temperature[idx] = 100 * Math.exp(-dist * dist / 1000);
                            }
                        }
                        break;
                        
                    case 2: // Checkerboard
                        for (let y = 0; y < this.gridSize; y++) {
                            for (let x = 0; x < this.gridSize; x++) {
                                const idx = y * this.gridSize + x;
                                this.temperature[idx] = ((x + y) % 2 === 0) ? 80 : 20;
                            }
                        }
                        break;
                        
                    case 3: // Gradient
                        for (let y = 0; y < this.gridSize; y++) {
                            for (let x = 0; x < this.gridSize; x++) {
                                const idx = y * this.gridSize + x;
                                this.temperature[idx] = (x / this.gridSize) * 100;
                            }
                        }
                        break;
                        
                    case 4: // Multiple sources
                        const sources = [
                            { x: cx - 30, y: cy - 30 },
                            { x: cx + 30, y: cy - 30 },
                            { x: cx, y: cy + 30 }
                        ];
                        
                        for (let y = 0; y < this.gridSize; y++) {
                            for (let x = 0; x < this.gridSize; x++) {
                                let temp = this.ambientTemp;
                                for (const source of sources) {
                                    const dist = Math.sqrt((x - source.x) ** 2 + (y - source.y) ** 2);
                                    temp += 50 * Math.exp(-dist * dist / 500);
                                }
                                const idx = y * this.gridSize + x;
                                this.temperature[idx] = temp;
                            }
                        }
                        break;
                        
                    case 5: // Wave pattern
                        for (let y = 0; y < this.gridSize; y++) {
                            for (let x = 0; x < this.gridSize; x++) {
                                const idx = y * this.gridSize + x;
                                this.temperature[idx] = 60 + 40 * Math.sin(x * 0.1) * Math.cos(y * 0.1);
                            }
                        }
                        break;
                }
            }
        }
        
        let heatSim;
        let frameCount = 0;
        let lastFrameTime = 0;
        let fps = 60;
        
        function setup() {
            const canvas = createCanvas(800, 800);
            canvas.parent('canvas-container');
            
            heatSim = new HeatSimulation();
            
            // Setup UI controls
            setupControls();
        }
        
        function draw() {
            background(0);
            
            // Handle mouse input
            if (heatSim.mouseDown) {
                const amount = heatSim.shiftPressed ? -30 : 30;
                heatSim.addHeat(mouseX, mouseY, amount);
            }
            
            // Update simulation
            for (let i = 0; i < 2; i++) {
                heatSim.update();
            }
            
            // Render
            heatSim.render();
            
            // Update stats
            if (frameCount % 10 === 0) {
                updateStats();
            }
            
            frameCount++;
        }
        
        function mousePressed() {
            heatSim.mouseDown = true;
        }
        
        function mouseReleased() {
            heatSim.mouseDown = false;
        }
        
        function mouseDragged() {
            if (heatSim.mouseDown) {
                const amount = heatSim.shiftPressed ? -20 : 20;
                heatSim.addHeat(mouseX, mouseY, amount);
            }
        }
        
        function keyPressed() {
            if (key === ' ') {
                heatSim.paused = !heatSim.paused;
            } else if (key === 'c' || key === 'C') {
                heatSim.reset();
            } else if (key === 'r' || key === 'R') {
                heatSim.randomHeat();
            } else if (key === 'g' || key === 'G') {
                heatSim.useGPU = !heatSim.useGPU;
                console.log('GPU mode:', heatSim.useGPU ? 'ON' : 'OFF');
            } else if (key === 'Shift') {
                heatSim.shiftPressed = true;
            } else if (key >= '1' && key <= '5') {
                heatSim.createPattern(parseInt(key));
            }
        }
        
        function keyReleased() {
            if (key === 'Shift') {
                heatSim.shiftPressed = false;
            }
        }
        
        function setupControls() {
            // Conductivity slider
            const condSlider = document.getElementById('conductivity');
            condSlider.addEventListener('input', (e) => {
                heatSim.conductivity = parseFloat(e.target.value);
                document.getElementById('conductivityValue').textContent = e.target.value;
            });
            
            // Diffusion slider
            const diffSlider = document.getElementById('diffusion');
            diffSlider.addEventListener('input', (e) => {
                heatSim.diffusionRate = parseFloat(e.target.value);
                document.getElementById('diffusionValue').textContent = e.target.value;
            });
            
            // Resolution slider
            const resSlider = document.getElementById('resolution');
            resSlider.addEventListener('input', (e) => {
                const newSize = parseInt(e.target.value);
                document.getElementById('resolutionValue').textContent = newSize;
                heatSim.resize(newSize);
            });
            
            // Convection slider
            const convSlider = document.getElementById('convection');
            convSlider.addEventListener('input', (e) => {
                heatSim.convection = parseFloat(e.target.value);
                document.getElementById('convectionValue').textContent = e.target.value;
            });
            
            // Ambient temperature slider
            const ambSlider = document.getElementById('ambient');
            ambSlider.addEventListener('input', (e) => {
                heatSim.ambientTemp = parseFloat(e.target.value);
                document.getElementById('ambientValue').textContent = e.target.value + '¬∞C';
            });
        }
        
        function updateStats() {
            const stats = heatSim.getStats();
            document.getElementById('maxTemp').textContent = stats.max + '¬∞C';
            document.getElementById('minTemp').textContent = stats.min + '¬∞C';
            document.getElementById('avgTemp').textContent = stats.avg + '¬∞C';
            
            // Calculate FPS
            const now = millis();
            if (lastFrameTime > 0) {
                fps = Math.round(1000 / (now - lastFrameTime));
                document.getElementById('fps').textContent = fps;
            }
            lastFrameTime = now;
        }
        
        function toggleControls() {
            const controls = document.getElementById('controls');
            const toggleBtn = document.getElementById('toggleBtn');
            controls.classList.toggle('hidden');
            toggleBtn.classList.toggle('shifted');
        }
    </script>
</body>
</html>