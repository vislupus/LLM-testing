<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DLA Cluster Simulation</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, sans-serif;
    }
    #info {
      position: absolute;
      left: 10px;
      top: 10px;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #fff;
      font-size: 12px;
      border-radius: 4px;
      z-index: 10;
      pointer-events: none;
    }
  </style>
</head>
<body>
<div id="info">
  2D DLA Simulation<br>
  Active walkers: 100 (respawn on stick)<br>
  Growth stops when cluster is 50px from canvas edge.
</div>
<canvas id="dla"></canvas>

<script>
(function () {
  const canvas = document.getElementById('dla');
  const ctx = canvas.getContext('2d');

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // --------- PARAMETERS ---------
  const ACTIVE_WALKERS = 100;       // number of moving particles
  const STEP_SIZE = 1.3;           // movement per frame
  const BIAS_STRENGTH = 0.25;      // bias toward center (0..1-ish)
  const PARTICLE_RADIUS = 2;       // draw radius
  const BORDER_THRESHOLD = 50;     // stop when cluster is this close to edge
  const GRID_CELL_SIZE = 5;        // spatial hash cell size for collision

  const center = { x: canvas.width / 2, y: canvas.height / 2 };

  // Fixed cluster particles
  const cluster = [];
  let maxRadius = 0;

  // Spatial hash grid for cluster particles
  const grid = new Map(); // key: "ix,iy" -> array of particle indices

  function gridKey(ix, iy) {
    return ix + ',' + iy;
  }

  function addToGrid(pIndex) {
    const p = cluster[pIndex];
    const ix = Math.floor(p.x / GRID_CELL_SIZE);
    const iy = Math.floor(p.y / GRID_CELL_SIZE);
    const key = gridKey(ix, iy);
    if (!grid.has(key)) grid.set(key, []);
    grid.get(key).push(pIndex);
  }

  // Seed: one particle in the center
  cluster.push({ x: center.x, y: center.y });
  addToGrid(0);

  // Active walkers
  const walkers = [];

  function spawnWalker() {
    // spawn around cluster at a radius slightly larger than current maxRadius
    const minDim = Math.min(canvas.width, canvas.height);
    const baseRadius = Math.max(maxRadius + 20, 40);
    const spawnRadius = Math.min(baseRadius, minDim * 0.45);
    const angle = Math.random() * Math.PI * 2;
    const x = center.x + spawnRadius * Math.cos(angle);
    const y = center.y + spawnRadius * Math.sin(angle);
    return { x, y };
  }

  function ensureWalkers() {
    while (walkers.length < ACTIVE_WALKERS) {
      walkers.push(spawnWalker());
    }
  }

  ensureWalkers();

  function randomStepTowardCenter(px, py) {
    // random direction
    let rx = Math.random() * 2 - 1;
    let ry = Math.random() * 2 - 1;
    const rLen = Math.hypot(rx, ry) || 1;
    rx /= rLen;
    ry /= rLen;

    // bias toward center
    let bx = center.x - px;
    let by = center.y - py;
    const bLen = Math.hypot(bx, by) || 1;
    bx /= bLen;
    by /= bLen;

    let dx = rx * (1 - BIAS_STRENGTH) + bx * BIAS_STRENGTH;
    let dy = ry * (1 - BIAS_STRENGTH) + by * BIAS_STRENGTH;
    const len = Math.hypot(dx, dy) || 1;
    dx = (dx / len) * STEP_SIZE;
    dy = (dy / len) * STEP_SIZE;
    return { dx, dy };
  }

  function isStuck(walker) {
    // Check nearby cells in grid
    const ix = Math.floor(walker.x / GRID_CELL_SIZE);
    const iy = Math.floor(walker.y / GRID_CELL_SIZE);
    const r2 = (PARTICLE_RADIUS * 2) ** 2;

    for (let gx = ix - 1; gx <= ix + 1; gx++) {
      for (let gy = iy - 1; gy <= iy + 1; gy++) {
        const key = gridKey(gx, gy);
        const bucket = grid.get(key);
        if (!bucket) continue;
        for (const idx of bucket) {
          const p = cluster[idx];
          const dx = walker.x - p.x;
          const dy = walker.y - p.y;
          if (dx * dx + dy * dy <= r2) {
            return true;
          }
        }
      }
    }
    return false;
  }

  function addWalkerToCluster(walker) {
    const p = { x: walker.x, y: walker.y };
    const idx = cluster.length;
    cluster.push(p);
    addToGrid(idx);

    const dx = p.x - center.x;
    const dy = p.y - center.y;
    const r = Math.hypot(dx, dy);
    if (r > maxRadius) maxRadius = r;
  }

  function reachedBorder() {
    const minDim = Math.min(canvas.width, canvas.height);
    const maxAllowed = minDim / 2 - BORDER_THRESHOLD;
    return maxRadius >= maxAllowed;
  }

  function update() {
    if (!reachedBorder()) {
      // Move walkers
      for (let i = walkers.length - 1; i >= 0; i--) {
        const w = walkers[i];

        // random biased step
        const step = randomStepTowardCenter(w.x, w.y);
        w.x += step.dx;
        w.y += step.dy;

        // if too far away (escaped), respawn
        const dxC = w.x - center.x;
        const dyC = w.y - center.y;
        const distC = Math.hypot(dxC, dyC);
        const maxSpawnRadius = Math.min(canvas.width, canvas.height) * 0.5 + 60;
        if (distC > maxSpawnRadius) {
          walkers[i] = spawnWalker();
          continue;
        }

        // test for sticking
        if (isStuck(w)) {
          addWalkerToCluster(w);
          walkers.splice(i, 1); // remove walker
        }
      }

      // replenish walkers
      ensureWalkers();
    }

    // Draw
    draw();
    requestAnimationFrame(update);
  }

  function draw() {
    // subtle background so particles are visible
    ctx.fillStyle = 'rgb(220,220,220)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // draw cluster
    ctx.fillStyle = 'rgb(0,0,0)';
    for (const p of cluster) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, PARTICLE_RADIUS, 0, Math.PI * 2);
      ctx.fill();
    }

    // draw active walkers
    ctx.fillStyle = 'rgba(50,50,255,0.8)';
    for (const w of walkers) {
      ctx.beginPath();
      ctx.arc(w.x, w.y, PARTICLE_RADIUS * 0.8, 0, Math.PI * 2);
      ctx.fill();
    }

    // optional: draw border threshold circle
    const minDim = Math.min(canvas.width, canvas.height);
    const maxAllowed = minDim / 2 - BORDER_THRESHOLD;
    ctx.strokeStyle = 'rgba(200,0,0,0.4)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(center.x, center.y, maxAllowed, 0, Math.PI * 2);
    ctx.stroke();
  }

  // Start animation
  requestAnimationFrame(update);
})();
</script>
</body>
</html>
