<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DLA Simulation - Diffusion-Limited Aggregation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #fff;
        }
        #controls {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            padding: 25px;
            margin: 15px;
            border-radius: 12px;
            width: 90%;
            max-width: 850px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }
        h2 {
            margin: 0 0 20px 0;
            font-size: 22px;
            color: #63b3ed;
            text-align: center;
        }
        .control-group {
            margin: 12px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        label {
            min-width: 140px;
            font-size: 13px;
            color: #cbd5e0;
        }
        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 5px;
            background: #4a5568;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #63b3ed;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #63b3ed;
            cursor: pointer;
            border: none;
        }
        .value-display {
            min-width: 50px;
            text-align: right;
            font-weight: bold;
            color: #90cdf4;
            font-size: 13px;
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }
        button {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(66, 153, 225, 0.4);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(66, 153, 225, 0.6);
        }
        button:active {
            transform: translateY(0);
        }
        button.reset {
            background: linear-gradient(135deg, #fc8181 0%, #e53e3e 100%);
            box-shadow: 0 4px 12px rgba(229, 62, 62, 0.4);
        }
        button.reset:hover {
            box-shadow: 0 6px 16px rgba(229, 62, 62, 0.6);
        }
        #stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #4a5568;
        }
        .stat-item {
            text-align: center;
            font-size: 12px;
            color: #a0aec0;
        }
        .stat-value {
            display: block;
            font-size: 20px;
            font-weight: bold;
            color: #63b3ed;
            margin-top: 5px;
        }
        canvas {
            display: block;
            border: 3px solid #2d3748;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            margin: 10px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h2>üåå Diffusion-Limited Aggregation (DLA) Simulation</h2>
        
        <div class="control-group">
            <label>Particle Count:</label>
            <input type="range" id="particleCount" min="20" max="400" value="100" step="10">
            <span class="value-display" id="particleCountValue">100</span>
        </div>
        
        <div class="control-group">
            <label>Movement Speed:</label>
            <input type="range" id="moveSpeed" min="0.5" max="6" value="2" step="0.5">
            <span class="value-display" id="moveSpeedValue">2.0</span>
        </div>
        
        <div class="control-group">
            <label>Inward Bias:</label>
            <input type="range" id="bias" min="0" max="0.5" value="0.15" step="0.05">
            <span class="value-display" id="biasValue">0.15</span>
        </div>
        
        <div class="control-group">
            <label>Particle Size:</label>
            <input type="range" id="particleSize" min="2" max="8" value="4" step="1">
            <span class="value-display" id="particleSizeValue">4</span>
        </div>
        
        <div class="button-group">
            <button id="pauseBtn">‚è∏ Pause</button>
            <button id="resetBtn" class="reset">üîÑ Reset</button>
        </div>
        
        <div id="stats">
            <div class="stat-item">
                <span>Cluster Size</span>
                <span class="stat-value" id="clusterSize">1</span>
            </div>
            <div class="stat-item">
                <span>Active Particles</span>
                <span class="stat-value" id="activeParticles">0</span>
            </div>
            <div class="stat-item">
                <span>Max Radius</span>
                <span class="stat-value" id="maxRadius">0</span>
            </div>
            <div class="stat-item">
                <span>FPS</span>
                <span class="stat-value" id="fps">60</span>
            </div>
            <div class="stat-item">
                <span>Status</span>
                <span class="stat-value" id="status" style="color: #48bb78;">Running</span>
            </div>
        </div>
    </div>

    <script>
        // Simulation parameters
        let config = {
            particleCount: 100,
            moveSpeed: 2,
            bias: 0.15,
            particleSize: 4,
            edgeMargin: 50,
            stickDistance: 8,
            despawnDistance: 150
        };

        // State variables
        let cluster = [];
        let particles = [];
        let clusterGrid = new Map();
        let centerX, centerY;
        let maxClusterRadius = 0;
        let isPaused = false;
        let isComplete = false;
        let gridCellSize = 15;

        // Graphics layers for efficiency
        let clusterLayer;
        let particleLayer;

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
            }

            move() {
                // Random walk
                let angle = random(TWO_PI);
                this.vx = cos(angle) * config.moveSpeed;
                this.vy = sin(angle) * config.moveSpeed;

                // Add inward bias toward center
                let dx = centerX - this.x;
                let dy = centerY - this.y;
                let dist = sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    this.vx += (dx / dist) * config.moveSpeed * config.bias;
                    this.vy += (dy / dist) * config.moveSpeed * config.bias;
                }

                this.x += this.vx;
                this.y += this.vy;
            }

            isNearCluster() {
                // Grid-based collision detection for efficiency
                let gridX = Math.floor(this.x / gridCellSize);
                let gridY = Math.floor(this.y / gridCellSize);

                // Check surrounding cells
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        let key = `${gridX + dx},${gridY + dy}`;
                        let cellParticles = clusterGrid.get(key);
                        
                        if (cellParticles) {
                            for (let cp of cellParticles) {
                                let distSq = (this.x - cp.x) ** 2 + (this.y - cp.y) ** 2;
                                if (distSq < config.stickDistance ** 2) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }

            isTooFar() {
                let distSq = (this.x - centerX) ** 2 + (this.y - centerY) ** 2;
                let threshold = maxClusterRadius + config.despawnDistance;
                return distSq > threshold ** 2;
            }

            display() {
                // Particle with glow effect
                particleLayer.noStroke();
                
                // Outer glow
                particleLayer.fill(100, 200, 255, 60);
                particleLayer.circle(this.x, this.y, config.particleSize * 2.5);
                
                // Main particle
                particleLayer.fill(150, 220, 255, 220);
                particleLayer.circle(this.x, this.y, config.particleSize);
            }
        }

        function setup() {
            createCanvas(900, 900);
            centerX = width / 2;
            centerY = height / 2;

            // Create graphics layers
            clusterLayer = createGraphics(width, height);
            clusterLayer.background(20, 20, 25);
            
            particleLayer = createGraphics(width, height);

            // Initialize with seed particle at center
            addToCluster(centerX, centerY);

            // Spawn initial particles
            for (let i = 0; i < config.particleCount; i++) {
                spawnParticle();
            }

            setupControls();
            frameRate(60);
        }

        function draw() {
            background(20, 20, 25);

            if (isPaused || isComplete) {
                image(clusterLayer, 0, 0);
                image(particleLayer, 0, 0);
                return;
            }

            // Clear particle layer with fade effect for trails
            particleLayer.background(20, 20, 25, 40);

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                
                p.move();

                // Check if particle should stick
                if (p.isNearCluster()) {
                    addToCluster(p.x, p.y);
                    particles.splice(i, 1);
                    spawnParticle(); // Spawn replacement
                }
                // Respawn if too far
                else if (p.isTooFar()) {
                    particles.splice(i, 1);
                    spawnParticle();
                }
                else {
                    p.display();
                }
            }

            // Check completion
            if (maxClusterRadius + config.edgeMargin >= min(width, height) / 2) {
                if (!isComplete) {
                    isComplete = true;
                    document.getElementById('status').textContent = 'Complete!';
                    document.getElementById('status').style.color = '#48bb78';
                }
            }

            // Render layers
            image(clusterLayer, 0, 0);
            image(particleLayer, 0, 0);

            // Update stats periodically
            if (frameCount % 15 === 0) {
                updateStats();
            }
        }

        function addToCluster(x, y) {
            let point = { x, y };
            cluster.push(point);

            // Add to spatial grid
            let gridX = Math.floor(x / gridCellSize);
            let gridY = Math.floor(y / gridCellSize);
            let key = `${gridX},${gridY}`;
            
            if (!clusterGrid.has(key)) {
                clusterGrid.set(key, []);
            }
            clusterGrid.get(key).push(point);

            // Update max radius
            let dist = sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
            if (dist > maxClusterRadius) {
                maxClusterRadius = dist;
            }

            // Draw particle on cluster layer with color based on distance
            clusterLayer.push();
            clusterLayer.colorMode(HSB);
            
            let hue = map(dist, 0, 400, 200, 320) % 360;
            let brightness = map(dist, 0, maxClusterRadius, 90, 70);
            
            // Glow effect
            clusterLayer.noStroke();
            clusterLayer.fill(hue, 60, brightness, 0.4);
            clusterLayer.circle(x, y, config.particleSize * 3);
            
            // Main particle
            clusterLayer.fill(hue, 70, brightness);
            clusterLayer.circle(x, y, config.particleSize);
            
            // Highlight
            clusterLayer.fill(hue, 30, 100, 0.8);
            clusterLayer.circle(x, y, config.particleSize * 0.6);
            
            clusterLayer.pop();
        }

        function spawnParticle() {
            if (isComplete) return;

            // Spawn around cluster at random angle
            let angle = random(TWO_PI);
            let spawnRadius = maxClusterRadius + 40 + random(30);
            let x = centerX + cos(angle) * spawnRadius;
            let y = centerY + sin(angle) * spawnRadius;

            particles.push(new Particle(x, y));
        }

        function setupControls() {
            // Particle count slider
            document.getElementById('particleCount').addEventListener('input', (e) => {
                config.particleCount = parseInt(e.target.value);
                document.getElementById('particleCountValue').textContent = config.particleCount;
                
                adjustParticleCount();
            });

            // Movement speed slider
            document.getElementById('moveSpeed').addEventListener('input', (e) => {
                config.moveSpeed = parseFloat(e.target.value);
                document.getElementById('moveSpeedValue').textContent = config.moveSpeed.toFixed(1);
            });

            // Bias slider
            document.getElementById('bias').addEventListener('input', (e) => {
                config.bias = parseFloat(e.target.value);
                document.getElementById('biasValue').textContent = config.bias.toFixed(2);
            });

            // Particle size slider
            document.getElementById('particleSize').addEventListener('input', (e) => {
                config.particleSize = parseInt(e.target.value);
                document.getElementById('particleSizeValue').textContent = config.particleSize;
            });

            // Pause/Resume button
            document.getElementById('pauseBtn').addEventListener('click', () => {
                isPaused = !isPaused;
                document.getElementById('pauseBtn').textContent = isPaused ? '‚ñ∂ Resume' : '‚è∏ Pause';
                document.getElementById('status').textContent = isPaused ? 'Paused' : 'Running';
                document.getElementById('status').style.color = isPaused ? '#f6ad55' : '#48bb78';
            });

            // Reset button
            document.getElementById('resetBtn').addEventListener('click', () => {
                resetSimulation();
            });
        }

        function adjustParticleCount() {
            while (particles.length < config.particleCount && !isComplete) {
                spawnParticle();
            }
            while (particles.length > config.particleCount) {
                particles.pop();
            }
        }

        function resetSimulation() {
            cluster = [];
            particles = [];
            clusterGrid.clear();
            maxClusterRadius = 0;
            isPaused = false;
            isComplete = false;

            clusterLayer.background(20, 20, 25);
            particleLayer.clear();

            addToCluster(centerX, centerY);

            for (let i = 0; i < config.particleCount; i++) {
                spawnParticle();
            }

            document.getElementById('pauseBtn').textContent = '‚è∏ Pause';
            document.getElementById('status').textContent = 'Running';
            document.getElementById('status').style.color = '#48bb78';
        }

        function updateStats() {
            document.getElementById('clusterSize').textContent = cluster.length.toLocaleString();
            document.getElementById('activeParticles').textContent = particles.length;
            document.getElementById('maxRadius').textContent = Math.floor(maxClusterRadius);
            document.getElementById('fps').textContent = Math.floor(frameRate());
        }
    </script>
</body>
</html>