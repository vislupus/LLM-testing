<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chaotic Three-Body System with Spacecraft - p5.js</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, sans-serif;
    }
    #info {
      position: absolute;
      left: 10px;
      top: 10px;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.4);
      color: #fff;
      font-size: 12px;
      border-radius: 4px;
      z-index: 10;
    }
  </style>
</head>
<body>
<div id="info">
  Chaotic Sun–Earth–Jupiter system + spacecraft<br>
  Spacecraft: starts on Earth → loop around Sun → transfer to Jupiter
</div>

<script>
  // ----- CONFIG -----
  const G = 0.4;          // gravitational constant (tuned for aesthetics)
  const DT = 0.15;        // time step
  const MAX_SPEED = 12;   // clamp to keep things bounded

  let bodies = [];
  let ship;
  let trailLayer;
  let state = "attachedToEarth";
  let stateTimer = 0;

  function createBody(name, x, y, vx, vy, mass, radius, col) {
    return {
      name,
      x, y,
      vx, vy,
      ax: 0,
      ay: 0,
      mass,
      radius,
      col
    };
  }

  function setup() {
    createCanvas(window.innerWidth, window.innerHeight);
    background(220); // required background value
    noStroke();      // global noStroke

    trailLayer = createGraphics(width, height);
    trailLayer.background(220);
    trailLayer.noStroke();

    // ----- create main bodies -----
    const cx = width / 2;
    const cy = height / 2;

    // Sun at center
    const sun = createBody("Sun", cx, cy, 0, 0, 12000, 28, color(255, 190, 0));

    // Earth offset to the right
    const earth = createBody("Earth", cx + 210, cy, 0, 9.4, 40, 13, color(60, 130, 255));

    // Jupiter offset to the left, heavier and different speed
    const jupiter = createBody("Jupiter", cx - 310, cy, 0, -6.2, 200, 20, color(255, 180, 120));

    bodies = [sun, earth, jupiter];

    // ----- spacecraft -----
    ship = {
      x: earth.x,
      y: earth.y,
      vx: earth.vx,
      vy: earth.vy,
      mass: 1,
      radius: 6,
      col: color(255, 255, 255),
      trailCol: color(0, 0, 0, 120)
    };

    state = "attachedToEarth";
    stateTimer = 0;
  }

  function windowResized() {
    // On resize, recreate canvas & trails to avoid weird artifacts.
    resizeCanvas(window.innerWidth, window.innerHeight);
    background(220);
    trailLayer = createGraphics(width, height);
    trailLayer.background(220);
    trailLayer.noStroke();
  }

  function draw() {
    background(220); // required grayscale background every frame

    // Physics steps
    updateBodies();
    updateShip();

    // Draw trails then bodies on top
    image(trailLayer, 0, 0);
    drawBodies();
    drawShip();
  }

  // ----- PHYSICS -----

  function updateBodies() {
    // reset accelerations
    for (let b of bodies) {
      b.ax = 0;
      b.ay = 0;
    }

    // pairwise gravity for Sun, Earth, Jupiter
    for (let i = 0; i < bodies.length; i++) {
      for (let j = i + 1; j < bodies.length; j++) {
        applyGravity(bodies[i], bodies[j]);
      }
    }

    // integrate motion
    for (let b of bodies) {
      integrateBody(b);
    }
  }

  function applyGravity(a, b) {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const distSq = dx * dx + dy * dy;
    const minDist = (a.radius + b.radius) * 1.3;

    const r = sqrt(distSq);
    const safeR = max(r, minDist); // avoid huge forces in collisions

    const force = (G * a.mass * b.mass) / (safeR * safeR);
    const fx = force * (dx / safeR);
    const fy = force * (dy / safeR);

    // a feels +F, b feels -F
    a.ax += fx / a.mass;
    a.ay += fy / a.mass;
    b.ax -= fx / b.mass;
    b.ay -= fy / b.mass;

    // gentle separation if overlapping
    if (r < minDist && r > 0.1) {
      const overlap = (minDist - r) * 0.5;
      const nx = dx / r;
      const ny = dy / r;
      a.x -= nx * overlap;
      a.y -= ny * overlap;
      b.x += nx * overlap;
      b.y += ny * overlap;
    }
  }

  function integrateBody(b) {
    b.vx += b.ax * DT;
    b.vy += b.ay * DT;

    // clamp speed to keep things inside
    const speed = sqrt(b.vx * b.vx + b.vy * b.vy);
    if (speed > MAX_SPEED) {
      const s = MAX_SPEED / speed;
      b.vx *= s;
      b.vy *= s;
    }

    b.x += b.vx * DT;
    b.y += b.vy * DT;

    keepInBounds(b);
    drawTrailPoint(b.x, b.y, b.col, 80);
  }

  function keepInBounds(obj) {
    const margin = 40;
    if (obj.x < margin) {
      obj.x = margin;
      obj.vx *= -0.8;
    } else if (obj.x > width - margin) {
      obj.x = width - margin;
      obj.vx *= -0.8;
    }
    if (obj.y < margin) {
      obj.y = margin;
      obj.vy *= -0.8;
    } else if (obj.y > height - margin) {
      obj.y = height - margin;
      obj.vy *= -0.8;
    }
  }

  // ----- SPACECRAFT LOGIC -----

  function updateShip() {
    stateTimer += 1;

    const earth = bodies.find(b => b.name === "Earth");
    const jupiter = bodies.find(b => b.name === "Jupiter");
    const sun = bodies.find(b => b.name === "Sun");

    // State machine:
    // 1) attachedToEarth: follow Earth for a bit
    // 2) sunLoop: after burn, roughly one loop near Sun
    // 3) toJupiter: burn toward Jupiter and then coast

    if (state === "attachedToEarth") {
      ship.x = earth.x;
      ship.y = earth.y;
      ship.vx = earth.vx;
      ship.vy = earth.vy;

      if (stateTimer > 200) {
        // burn inward toward the Sun to get a tight, slightly chaotic orbit
        const dx = sun.x - ship.x;
        const dy = sun.y - ship.y;
        const r = sqrt(dx * dx + dy * dy) || 1;
        const inward = {x: dx / r, y: dy / r};

        // small tangential kick to destabilize orbit
        const tangent = {x: -inward.y, y: inward.x};

        const burnInward = 4.0;
        const burnTangent = 2.5;

        ship.vx += inward.x * burnInward + tangent.x * burnTangent;
        ship.vy += inward.y * burnInward + tangent.y * burnTangent;

        state = "sunLoop";
        stateTimer = 0;
      }
    } else {
      // gravitational acceleration from main bodies (ship does not affect them)
      let ax = 0;
      let ay = 0;
      for (let b of bodies) {
        const dx = b.x - ship.x;
        const dy = b.y - ship.y;
        const distSq = dx * dx + dy * dy;
        const r = sqrt(distSq) || 1;
        const minR = (b.radius + ship.radius) * 1.2;
        const safeR = max(r, minR);
        const force = (G * b.mass * ship.mass) / (safeR * safeR);
        ax += force * (dx / safeR) / ship.mass;
        ay += force * (dy / safeR) / ship.mass;
      }

      ship.vx += ax * DT;
      ship.vy += ay * DT;

      const speed = sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
      if (speed > MAX_SPEED * 1.3) {
        const s = (MAX_SPEED * 1.3) / speed;
        ship.vx *= s;
        ship.vy *= s;
      }

      ship.x += ship.vx * DT;
      ship.y += ship.vy * DT;
      keepInBounds(ship);

      // trigger transfer to Jupiter after ~one sun loop
      if (state === "sunLoop" && stateTimer > 800) {
        // burn toward current Jupiter position
        const dxJ = jupiter.x - ship.x;
        const dyJ = jupiter.y - ship.y;
        const rJ = sqrt(dxJ * dxJ + dyJ * dyJ) || 1;
        const dirJ = {x: dxJ / rJ, y: dyJ / rJ};

        const transferBurn = 5.5;
        ship.vx += dirJ.x * transferBurn;
        ship.vy += dirJ.y * transferBurn;

        state = "toJupiter";
        stateTimer = 0;
      }
    }

    drawTrailPoint(ship.x, ship.y, ship.trailCol, 50);
  }

  // ----- DRAWING -----

  function drawTrailPoint(x, y, col, alpha) {
    const c = color(red(col), green(col), blue(col), alpha);
    trailLayer.fill(c);
    trailLayer.ellipse(x, y, 3, 3);
  }

  function drawBodies() {
    for (let b of bodies) {
      fill(b.col);
      ellipse(b.x, b.y, b.radius * 2, b.radius * 2);
    }
  }

  function drawShip() {
    fill(ship.col);
    const angle = atan2(ship.vy, ship.vx);
    push();
    translate(ship.x, ship.y);
    rotate(angle);
    // small triangular ship
    beginShape();
    vertex(10, 0);
    vertex(-8, -5);
    vertex(-4, 0);
    vertex(-8, 5);
    endShape(CLOSE);
    pop();
  }
</script>
</body>
</html>
