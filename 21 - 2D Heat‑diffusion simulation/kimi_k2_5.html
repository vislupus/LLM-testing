<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heat Diffusion Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; box-shadow: 0 0 30px rgba(0,0,0,0.5); }
        .glass-panel {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        /* Custom slider */
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: #f43f5e; cursor: pointer; margin-top: -5px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #334155; border-radius: 2px;
        }
    </style>
</head>
<body>

    <!-- UI Overlay -->
    <div class="absolute top-4 left-4 w-80 glass-panel rounded-xl p-5 text-gray-200 z-10 select-none">
        <h1 class="text-xl font-bold text-rose-400 mb-1">Heat Diffusion</h1>
        <p class="text-xs text-gray-400 mb-4">2D Finite Difference Solver</p>

        <!-- Stats -->
        <div class="grid grid-cols-2 gap-2 mb-4 text-xs">
            <div class="bg-slate-800 p-2 rounded border border-slate-700">
                <div class="text-gray-500">Avg Temp</div>
                <div id="stat-avg" class="font-mono text-rose-300 text-lg">0.0</div>
            </div>
            <div class="bg-slate-800 p-2 rounded border border-slate-700">
                <div class="text-gray-500">Max Temp</div>
                <div id="stat-max" class="font-mono text-orange-300 text-lg">0.0</div>
            </div>
        </div>

        <!-- Controls -->
        <div class="space-y-4">
            
            <!-- Brush Settings -->
            <div class="bg-slate-800/50 p-3 rounded border border-slate-700">
                <div class="text-xs font-bold text-rose-400 uppercase mb-2">Interaction Mode</div>
                <div class="flex gap-2 mb-2">
                    <button id="mode-heat" class="flex-1 bg-rose-600 hover:bg-rose-500 text-white py-1 rounded text-xs font-bold transition active-mode ring-2 ring-rose-300">HEAT</button>
                    <button id="mode-cool" class="flex-1 bg-cyan-600 hover:bg-cyan-500 text-white py-1 rounded text-xs font-bold transition">COOL</button>
                    <button id="mode-wall" class="flex-1 bg-slate-600 hover:bg-slate-500 text-white py-1 rounded text-xs font-bold transition">WALL</button>
                </div>
                <div class="flex justify-between text-[10px] text-gray-400 mt-1">
                    <span>Brush Size</span>
                    <span id="val-brush">10</span>
                </div>
                <input type="range" id="slider-brush" min="1" max="50" value="10">
            </div>

            <!-- Physics Params -->
            <div>
                <div class="flex justify-between text-xs mb-1">
                    <span>Diffusivity (α)</span>
                    <span id="val-alpha" class="text-rose-400">0.25</span>
                </div>
                <input type="range" id="slider-alpha" min="0.01" max="0.5" step="0.01" value="0.25">
            </div>

            <div>
                <div class="flex justify-between text-xs mb-1">
                    <span>Convection</span>
                    <span id="val-conv" class="text-rose-400">None</span>
                </div>
                <input type="range" id="slider-conv" min="-0.5" max="0.5" step="0.1" value="0">
            </div>

            <!-- Boundary Conditions -->
            <div class="flex justify-between items-center">
                <span class="text-xs text-gray-300">Boundary Type</span>
                <select id="select-bc" class="bg-slate-800 text-xs text-white border border-slate-600 rounded px-2 py-1 outline-none focus:border-rose-500">
                    <option value="insulated">Insulated (Neumann)</option>
                    <option value="constant">Constant (Dirichlet)</option>
                    <option value="periodic">Periodic</option>
                </select>
            </div>

            <div class="flex gap-2 mt-2">
                <button id="btn-pause" class="flex-1 bg-slate-700 hover:bg-slate-600 text-white py-2 rounded text-xs font-bold transition">Pause</button>
                <button id="btn-clear" class="flex-1 bg-rose-900 hover:bg-rose-800 text-rose-100 py-2 rounded text-xs font-bold transition">Clear</button>
            </div>
        </div>
        
        <div class="mt-4 text-[10px] text-gray-500">
            Click/Drag to apply • Space to pause
        </div>
    </div>

    <script>
        // --- Configuration ---
        const CONFIG = {
            w: 150, // Grid width
            h: 100, // Grid height
            scale: 8 // Pixel size per grid cell (will be adjusted to fit)
        };

        // State
        let grid = [];
        let nextGrid = [];
        let obstacles = []; // Walls
        let mode = 'heat'; // heat, cool, wall
        let isRunning = true;
        
        // Physics Parameters
        let alpha = 0.25;
        let convectionX = 0;
        let convectionY = 0;
        let boundaryType = 'insulated'; // 'insulated', 'constant', 'periodic'
        
        // Brush
        let brushSize = 10;
        let brushTemp = 255; // Heat value

        // --- P5.js Lifecycle ---

        function setup() {
            // Calculate scale to fit window
            CONFIG.scale = Math.min(window.innerWidth / CONFIG.w, window.innerHeight / CONFIG.h);
            
            let canvasW = CONFIG.w * CONFIG.scale;
            let canvasH = CONFIG.h * CONFIG.scale;
            
            createCanvas(canvasW, canvasH);
            
            initGrids();
            
            // Initial heat source in center
            addHeat(CONFIG.w/2, CONFIG.h/2, 50, 255);
            
            setupUI();
            noStroke();
        }

        function windowResized() {
            CONFIG.scale = Math.min(window.innerWidth / CONFIG.w, window.innerHeight / CONFIG.h);
            resizeCanvas(CONFIG.w * CONFIG.scale, CONFIG.h * CONFIG.scale);
        }

        function initGrids() {
            for (let y = 0; y < CONFIG.h; y++) {
                grid[y] = [];
                nextGrid[y] = [];
                obstacles[y] = [];
                for (let x = 0; x < CONFIG.w; x++) {
                    grid[y][x] = 0;
                    nextGrid[y][x] = 0;
                    obstacles[y][x] = false;
                }
            }
        }

        // --- Solver ---

        function step() {
            // Swap grids (Ping-pong buffer logic manually)
            // Actually, we'll read from grid, write to nextGrid, then swap references
            
            for (let y = 0; y < CONFIG.h; y++) {
                for (let x = 0; x < CONFIG.w; x++) {
                    
                    if (obstacles[y][x]) {
                        nextGrid[y][x] = 0; // Walls are cold/insulated? Or just block. Let's make them 0.
                        continue;
                    }

                    // Laplacian (Discrete)
                    // 5-point stencil
                    let left = getCell(x - 1, y);
                    let right = getCell(x + 1, y);
                    let up = getCell(x, y - 1);
                    let down = getCell(x, y + 1);
                    let center = grid[y][x];

                    let laplacian = left + right + up + down - 4 * center;

                    // Convection term (Advection)
                    // Simple upwind scheme for stability
                    let conv = 0;
                    if (convectionX > 0) conv -= convectionX * (center - getCell(x-1, y));
                    else conv -= convectionX * (getCell(x+1, y) - center);
                    
                    if (convectionY > 0) conv -= convectionY * (center - getCell(x, y-1));
                    else conv -= convectionY * (getCell(x, y+1) - center);

                    // Update Equation
                    // T_new = T_old + alpha * laplacian + convection
                    nextGrid[y][x] = center + alpha * laplacian + conv;
                    
                    // Damping/Fade to prevent explosion at high alpha
                    nextGrid[y][x] *= 0.999;
                }
            }

            // Swap references
            let temp = grid;
            grid = nextGrid;
            nextGrid = temp;
        }

        function getCell(x, y) {
            if (boundaryType === 'periodic') {
                x = (x + CONFIG.w) % CONFIG.w;
                y = (y + CONFIG.h) % CONFIG.h;
                return grid[y][x];
            } else {
                // Insulated or Constant
                if (x < 0 || x >= CONFIG.w || y < 0 || y >= CONFIG.h) {
                    if (boundaryType === 'insulated') {
                        // Return neighbor (Neumann 0 derivative)
                        // Clamp to border
                        let cx = Math.max(0, Math.min(CONFIG.w - 1, x));
                        let cy = Math.max(0, Math.min(CONFIG.h - 1, y));
                        return grid[cy][cx];
                    } else {
                        // Constant (Dirichlet) - return 0 (cold) or 255 (hot)?
                        return 0;
                    }
                }
                return grid[y][x];
            }
        }

        // --- Interaction ---

        function addHeat(cx, cy, r, temp) {
            for (let y = -r; y <= r; y++) {
                for (let x = -r; x <= r; x++) {
                    if (x*x + y*y <= r*r) {
                        let px = Math.floor(cx + x);
                        let py = Math.floor(cy + y);
                        if (px >= 0 && px < CONFIG.w && py >= 0 && py < CONFIG.h) {
                            if (mode === 'wall') {
                                obstacles[py][px] = true;
                                grid[py][px] = 0;
                            } else if (mode === 'heat') {
                                obstacles[py][px] = false;
                                grid[py][px] += temp;
                                if (grid[py][px] > 255) grid[py][px] = 255;
                            } else if (mode === 'cool') {
                                obstacles[py][px] = false;
                                grid[py][px] -= temp;
                                if (grid[py][px] < 0) grid[py][px] = 0;
                            }
                        }
                    }
                }
            }
        }

        function mouseDragged() {
            let gx = Math.floor(mouseX / CONFIG.scale);
            let gy = Math.floor(mouseY / CONFIG.scale);
            addHeat(gx, gy, brushSize, brushTemp);
        }
        
        function mousePressed() {
            let gx = Math.floor(mouseX / CONFIG.scale);
            let gy = Math.floor(mouseY / CONFIG.scale);
            addHeat(gx, gy, brushSize, brushTemp);
        }

        // --- Rendering ---

        function draw() {
            if (isRunning) {
                // Run multiple steps per frame for faster simulation
                for(let i=0; i<2; i++) step();
            }

            // Draw pixels
            // Optimization: Use loadPixels/drawPixels if we were doing 1:1 mapping
            // But here we scale up. We can draw rects or use a buffer.
            // For performance at high res, we use loadPixels on a graphics buffer if needed,
            // but standard p5 rects with low grid res is fine.
            
            // Let's use loadPixels for maximum speed
            loadPixels();
            
            for (let y = 0; y < CONFIG.h; y++) {
                for (let x = 0; x < CONFIG.w; x++) {
                    let temp = grid[y][x];
                    
                    // Color Mapping (Black-Blue-White-Red-Yellow)
                    let r, g, b;
                    
                    if (obstacles[y][x]) {
                        r = 40; g = 40; b = 50; // Wall color
                    } else {
                        // Heatmap gradient
                        // 0-63: Black to Blue
                        // 64-127: Blue to White
                        // 128-191: White to Red
                        // 192-255: Red to Yellow
                        
                        if (temp < 64) {
                            r = 0; g = 0; b = temp * 4;
                        } else if (temp < 128) {
                            r = (temp - 64) * 4; g = (temp - 64) * 4; b = 255;
                        } else if (temp < 192) {
                            r = 255; g = 255 - (temp - 128) * 4; b = 255 - (temp - 128) * 4;
                        } else {
                            r = 255; g = (temp - 192) * 4; b = 0;
                        }
                    }

                    // Draw scaled pixel block
                    for (let dy = 0; dy < CONFIG.scale; dy++) {
                        for (let dx = 0; dx < CONFIG.scale; dx++) {
                            let px = x * CONFIG.scale + dx;
                            let py = y * CONFIG.scale + dy;
                            if (px < width && py < height) {
                                let idx = (px + py * width) * 4;
                                pixels[idx] = r;
                                pixels[idx+1] = g;
                                pixels[idx+2] = b;
                                pixels[idx+3] = 255;
                            }
                        }
                    }
                }
            }
            updatePixels();
            
            // Draw Brush Preview
            if (mouseX > 320 || mouseX === 0) { // Avoid UI overlap roughly
                noFill();
                stroke(255, 100);
                ellipse(mouseX, mouseY, brushSize * CONFIG.scale * 2);
                noStroke();
            }
            
            // Update Stats
            if (frameCount % 10 === 0) updateStats();
        }

        function updateStats() {
            let total = 0;
            let max = 0;
            let count = 0;
            for(let y=0; y<CONFIG.h; y++) {
                for(let x=0; x<CONFIG.w; x++) {
                    if(!obstacles[y][x]) {
                        total += grid[y][x];
                        if(grid[y][x] > max) max = grid[y][x];
                        count++;
                    }
                }
            }
            document.getElementById('stat-avg').innerText = (total/count).toFixed(1);
            document.getElementById('stat-max').innerText = max.toFixed(1);
        }

        // --- UI Logic ---

        function setupUI() {
            // Mode Buttons
            const setMode = (m, btnId) => {
                mode = m;
                document.querySelectorAll('.active-mode').forEach(b => {
                    b.classList.remove('ring-2', 'ring-rose-300', 'ring-cyan-300', 'ring-slate-300');
                });
                document.querySelectorAll('button').forEach(b => b.classList.remove('active-mode'));
                
                let btn = document.getElementById(btnId);
                btn.classList.add('active-mode');
                if(m === 'heat') btn.classList.add('ring-2', 'ring-rose-300');
                if(m === 'cool') btn.classList.add('ring-2', 'ring-cyan-300');
                if(m === 'wall') btn.classList.add('ring-2', 'ring-slate-300');
            };

            document.getElementById('mode-heat').onclick = () => setMode('heat', 'mode-heat');
            document.getElementById('mode-cool').onclick = () => setMode('cool', 'mode-cool');
            document.getElementById('mode-wall').onclick = () => setMode('wall', 'mode-wall');

            // Sliders
            document.getElementById('slider-brush').addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value);
                document.getElementById('val-brush').innerText = brushSize;
            });

            document.getElementById('slider-alpha').addEventListener('input', (e) => {
                alpha = parseFloat(e.target.value);
                document.getElementById('val-alpha').innerText = alpha;
            });

            document.getElementById('slider-conv').addEventListener('input', (e) => {
                convectionX = parseFloat(e.target.value);
                let val = Math.abs(convectionX);
                let label = "None";
                if(val > 0) label = (convectionX > 0 ? "Right" : "Left");
                document.getElementById('val-conv').innerText = label;
            });

            document.getElementById('select-bc').addEventListener('change', (e) => {
                boundaryType = e.target.value;
            });

            document.getElementById('btn-pause').addEventListener('click', () => {
                isRunning = !isRunning;
                document.getElementById('btn-pause').innerText = isRunning ? "Pause" : "Resume";
            });

            document.getElementById('btn-clear').addEventListener('click', () => {
                initGrids();
            });
            
            // Keyboard shortcut
            document.addEventListener('keydown', (e) => {
                if(e.code === 'Space') {
                    isRunning = !isRunning;
                    document.getElementById('btn-pause').innerText = isRunning ? "Pause" : "Resume";
                }
            });
        }

    </script>
</body>
</html>