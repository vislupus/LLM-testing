<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heat Diffusion Simulation - Finite Difference Method</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/addons/p5.dom.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #0c0e1a 0%, #1a1b3a 100%);
            color: #e0f0ff;
            min-height: 100vh;
            overflow-x: hidden;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        header {
            text-align: center;
            padding: 25px;
            background: rgba(10, 12, 28, 0.7);
            border-radius: 16px;
            border: 1px solid rgba(255, 100, 100, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
        }

        h1 {
            color: #ff7b00;
            margin-bottom: 15px;
            font-size: 2.8rem;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }

        .subtitle {
            color: #a8d2ff;
            font-size: 1.2rem;
            max-width: 900px;
            margin: 0 auto 15px;
            line-height: 1.6;
        }

        .equation-display {
            font-family: 'Courier New', monospace;
            background: rgba(255, 100, 100, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            font-size: 1.2rem;
            color: #ff7b00;
            border: 1px solid rgba(255, 100, 100, 0.3);
        }

        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .simulation-area {
            flex: 3;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #heat-canvas {
            width: 100%;
            height: 600px;
            border-radius: 16px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
            background: rgba(5, 8, 22, 0.9);
            border: 1px solid rgba(255, 100, 100, 0.15);
        }

        .canvas-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(15, 20, 45, 0.7);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 100, 100, 0.15);
        }

        .fps-counter {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #2ed573;
            background: rgba(46, 213, 115, 0.1);
            padding: 8px 15px;
            border-radius: 8px;
        }

        .temp-range {
            font-family: 'Courier New', monospace;
            color: #ff7b00;
            background: rgba(255, 123, 0, 0.1);
            padding: 8px 15px;
            border-radius: 8px;
        }

        .method-display {
            font-size: 1.1rem;
            color: #ff7b00;
            font-weight: 600;
        }

        .controls-panel {
            flex: 1;
            min-width: 320px;
            background: rgba(15, 20, 45, 0.7);
            border-radius: 16px;
            padding: 25px;
            border: 1px solid rgba(255, 100, 100, 0.15);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 25px;
            max-height: 800px;
            overflow-y: auto;
        }

        .panel-section {
            background: rgba(25, 30, 60, 0.6);
            border-radius: 12px;
            padding: 20px;
            border-left: 4px solid;
        }

        .material-section {
            border-left-color: #ff7b00;
        }

        .boundary-section {
            border-left-color: #409cff;
        }

        .source-section {
            border-left-color: #ff4757;
        }

        .simulation-section {
            border-left-color: #2ed573;
        }

        h2 {
            color: #7bc8ff;
            font-size: 1.5rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        h2 i {
            font-size: 1.3rem;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 10px;
            color: #a8d2ff;
            font-weight: 500;
            font-size: 1.05rem;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        input[type="range"] {
            flex: 1;
            height: 10px;
            -webkit-appearance: none;
            border-radius: 5px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 12px rgba(255, 123, 0, 0.8);
            border: 2px solid white;
        }

        .conductivity-slider {
            background: linear-gradient(to right, #1a3a5f, #ff7b00);
        }

        .conductivity-slider::-webkit-slider-thumb {
            background: #ff7b00;
        }

        .diffusion-slider {
            background: linear-gradient(to right, #1b5e20, #2ed573);
        }

        .diffusion-slider::-webkit-slider-thumb {
            background: #2ed573;
        }

        .temperature-slider {
            background: linear-gradient(to right, #b71c1c, #ff4757);
        }

        .temperature-slider::-webkit-slider-thumb {
            background: #ff4757;
        }

        .size-slider {
            background: linear-gradient(to right, #0d47a1, #409cff);
        }

        .size-slider::-webkit-slider-thumb {
            background: #409cff;
        }

        .value-display {
            min-width: 70px;
            text-align: center;
            background: rgba(10, 15, 35, 0.6);
            padding: 8px 12px;
            border-radius: 8px;
            color: #a8d2ff;
            font-weight: 600;
            font-family: 'Courier New', monospace;
            border: 1px solid rgba(255, 100, 100, 0.2);
        }

        .toggle-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(10, 15, 35, 0.4);
            border-radius: 10px;
            border: 1px solid rgba(64, 156, 255, 0.1);
            transition: all 0.3s;
        }

        .toggle-group:hover {
            background: rgba(64, 156, 255, 0.1);
        }

        .toggle-label {
            color: #a8d2ff;
            font-weight: 500;
            margin: 0;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(64, 156, 255, 0.2);
            transition: .4s;
            border-radius: 30px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #409cff;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(30px);
        }

        button {
            background: linear-gradient(to right, #ff7b00, #ff5500);
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
            font-size: 1.05rem;
        }

        button:hover {
            background: linear-gradient(to right, #ff5500, #ff3d00);
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25);
        }

        button:active {
            transform: translateY(0);
        }

        .cool-button {
            background: linear-gradient(to right, #409cff, #2a7de0);
        }

        .cool-button:hover {
            background: linear-gradient(to right, #2a7de0, #1a6bc8);
        }

        .danger-button {
            background: linear-gradient(to right, #ff4757, #ff3742);
        }

        .danger-button:hover {
            background: linear-gradient(to right, #ff3742, #ff2b36);
        }

        .material-presets {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 10px;
        }

        .material-preset {
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            background: rgba(25, 30, 60, 0.8);
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .material-preset:hover {
            transform: translateY(-3px);
        }

        .material-preset.active {
            border-color: #ff7b00;
            box-shadow: 0 0 15px rgba(255, 123, 0, 0.4);
        }

        .boundary-presets {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 10px;
        }

        .boundary-preset {
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            background: rgba(25, 30, 60, 0.8);
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .boundary-preset:hover {
            transform: translateY(-3px);
        }

        .boundary-preset.active {
            border-color: #409cff;
            box-shadow: 0 0 15px rgba(64, 156, 255, 0.4);
        }

        .source-types {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 10px;
        }

        .source-type {
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            background: rgba(25, 30, 60, 0.8);
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .source-type:hover {
            transform: translateY(-3px);
        }

        .source-type.active {
            border-color: #ff4757;
            box-shadow: 0 0 15px rgba(255, 71, 87, 0.4);
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 10px;
        }

        .preset-button {
            background: rgba(25, 30, 60, 0.8);
            padding: 12px;
            font-size: 0.95rem;
        }

        .color-legend {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            padding: 10px;
            background: rgba(10, 15, 35, 0.6);
            border-radius: 8px;
            border: 1px solid rgba(255, 100, 100, 0.2);
        }

        .legend-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 30px;
            height: 10px;
            border-radius: 3px;
        }

        .legend-label {
            font-size: 0.8rem;
            color: #a8d2ff;
        }

        .keyboard-hint {
            font-size: 0.9rem;
            color: #8ab4f8;
            margin-top: 15px;
            text-align: center;
            font-style: italic;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: #8ab4f8;
            font-size: 0.95rem;
            background: rgba(10, 12, 28, 0.7);
            border-radius: 12px;
            border: 1px solid rgba(255, 100, 100, 0.2);
            margin-top: 20px;
        }

        @media (max-width: 1200px) {
            .content {
                flex-direction: column;
            }
            
            .simulation-area, .controls-panel {
                width: 100%;
            }
        }

        @media (max-width: 600px) {
            .controls-panel {
                padding: 15px;
            }
            
            .material-presets, .boundary-presets, .source-types, .preset-buttons {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            #heat-canvas {
                height: 450px;
            }
            
            .color-legend {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Heat Diffusion Simulation</h1>
            <p class="subtitle">A numerical solution to the heat equation ‚àÇT/‚àÇt = Œ±‚àá¬≤T using finite difference methods. Watch heat diffuse through different materials with configurable boundary conditions.</p>
            <div class="equation-display">
                ‚àÇT/‚àÇt = Œ±(‚àÇ¬≤T/‚àÇx¬≤ + ‚àÇ¬≤T/‚àÇy¬≤) + Q
            </div>
        </header>
        
        <div class="content">
            <div class="simulation-area">
                <div id="heat-canvas"></div>
                <div class="canvas-info">
                    <div class="fps-counter">FPS: 60</div>
                    <div class="method-display">Explicit Finite Difference</div>
                    <div class="temp-range">T: 0.0¬∞ - 1.0¬∞</div>
                </div>
                <div class="color-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(to right, #0d47a1, #2196f3);"></div>
                        <div class="legend-label">Cold (0¬∞)</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(to right, #4caf50, #ffeb3b);"></div>
                        <div class="legend-label">Warm (0.5¬∞)</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(to right, #ff9800, #ff5722);"></div>
                        <div class="legend-label">Hot (1.0¬∞)</div>
                    </div>
                </div>
            </div>
            
            <div class="controls-panel">
                <div class="panel-section material-section">
                    <h2>Material Properties</h2>
                    
                    <div class="control-group">
                        <label>Thermal Conductivity (Œ±): <span id="conductivity-value">0.25</span></label>
                        <div class="slider-container">
                            <input type="range" id="conductivity" class="conductivity-slider" min="0.01" max="0.5" value="0.25" step="0.01">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Diffusion Speed (Œît): <span id="diffusion-speed-value">0.1</span></label>
                        <div class="slider-container">
                            <input type="range" id="diffusion-speed" class="diffusion-slider" min="0.01" max="0.5" value="0.1" step="0.01">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Material Presets</label>
                        <div class="material-presets">
                            <div class="material-preset active" id="preset-copper">
                                <div>Copper</div>
                                <div style="font-size: 0.8rem; color: #ff7b00;">Œ± = 0.40</div>
                            </div>
                            <div class="material-preset" id="preset-aluminum">
                                <div>Aluminum</div>
                                <div style="font-size: 0.8rem; color: #ff7b00;">Œ± = 0.25</div>
                            </div>
                            <div class="material-preset" id="preset-steel">
                                <div>Steel</div>
                                <div style="font-size: 0.8rem; color: #ff7b00;">Œ± = 0.12</div>
                            </div>
                            <div class="material-preset" id="preset-glass">
                                <div>Glass</div>
                                <div style="font-size: 0.8rem; color: #ff7b00;">Œ± = 0.03</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section boundary-section">
                    <h2>Boundary Conditions</h2>
                    
                    <div class="control-group">
                        <label>Boundary Temperature: <span id="boundary-temp-value">0.0</span>¬∞</label>
                        <div class="slider-container">
                            <input type="range" id="boundary-temp" class="temperature-slider" min="0" max="1" value="0.0" step="0.1">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Boundary Type</label>
                        <div class="boundary-presets">
                            <div class="boundary-preset active" id="boundary-dirichlet">
                                <div>Dirichlet</div>
                                <div style="font-size: 0.8rem; color: #409cff;">Fixed Temperature</div>
                            </div>
                            <div class="boundary-preset" id="boundary-neumann">
                                <div>Neumann</div>
                                <div style="font-size: 0.8rem; color: #409cff;">Insulated</div>
                            </div>
                            <div class="boundary-preset" id="boundary-periodic">
                                <div>Periodic</div>
                                <div style="font-size: 0.8rem; color: #409cff;">Wrapping</div>
                            </div>
                            <div class="boundary-preset" id="boundary-mixed">
                                <div>Mixed</div>
                                <div style="font-size: 0.8rem; color: #409cff;">Hot/Cold Sides</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <div class="toggle-group">
                            <span class="toggle-label">Enable Convection</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="convection-toggle">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section source-section">
                    <h2>Heat Sources</h2>
                    
                    <div class="control-group">
                        <label>Source Temperature: <span id="source-temp-value">1.0</span>¬∞</label>
                        <div class="slider-container">
                            <input type="range" id="source-temp" class="temperature-slider" min="0.1" max="2.0" value="1.0" step="0.1">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Source Size: <span id="source-size-value">3</span></label>
                        <div class="slider-container">
                            <input type="range" id="source-size" class="size-slider" min="1" max="10" value="3" step="1">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>Source Type</label>
                        <div class="source-types">
                            <div class="source-type active" id="source-instant">
                                <div>Instant</div>
                                <div style="font-size: 0.8rem; color: #ff4757;">Immediate</div>
                            </div>
                            <div class="source-type" id="source-continuous">
                                <div>Continuous</div>
                                <div style="font-size: 0.8rem; color: #ff4757;">Constant</div>
                            </div>
                            <div class="source-type" id="source-pulse">
                                <div>Pulse</div>
                                <div style="font-size: 0.8rem; color: #ff4757;">Oscillating</div>
                            </div>
                            <div class="source-type" id="source-moving">
                                <div>Moving</div>
                                <div style="font-size: 0.8rem; color: #ff4757;">Drag to Move</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="button-row" style="display: flex; gap: 12px; margin-top: 15px;">
                        <button id="add-heat-button">
                            <span>üî•</span>
                            <span>Add Heat Source</span>
                        </button>
                        <button id="cool-button" class="cool-button">
                            <span>‚ùÑÔ∏è</span>
                            <span>Cool Region</span>
                        </button>
                    </div>
                </div>
                
                <div class="panel-section simulation-section">
                    <h2>Simulation Controls</h2>
                    
                    <div class="control-group">
                        <label>Grid Resolution: <span id="resolution-value">80</span></label>
                        <div class="slider-container">
                            <input type="range" id="resolution" class="size-slider" min="20" max="200" value="80" step="10">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <div class="toggle-group">
                            <span class="toggle-label">Pause Simulation</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="pause-toggle">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        
                        <div class="toggle-group">
                            <span class="toggle-label">Show Temperature Values</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="show-values">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="preset-buttons">
                        <button class="preset-button" id="preset-single">Single Source</button>
                        <button class="preset-button" id="preset-multiple">Multiple Sources</button>
                        <button class="preset-button" id="preset-gradient">Temperature Gradient</button>
                        <button class="preset-button danger-button" id="reset-button">Reset Simulation</button>
                    </div>
                    
                    <div class="keyboard-hint">
                        Keyboard: CLICK = Add Heat, C = Cool Region, SPACE = Pause, R = Reset, 1-4 = Boundary Types
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>Finite Difference Heat Equation Simulation | Numerical Solution to ‚àÇT/‚àÇt = Œ±‚àá¬≤T | Real-time Thermal Diffusion Visualization</p>
        </footer>
    </div>

    <script>
// Heat Diffusion Simulation Class
class HeatDiffusionSimulation {
    constructor() {
        // Grid dimensions
        this.gridSize = 80;
        this.cellSize = 8;
        
        // Thermal properties
        this.alpha = 0.25; // Thermal diffusivity (conductivity)
        this.dt = 0.1; // Time step for explicit method
        
        // Stability condition: dt <= dx^2/(4*alpha) for 2D explicit method
        // With dx = 1, dt_max = 1/(4*alpha)
        this.maxDt = 1 / (4 * this.alpha);
        
        // Temperature fields (current and next)
        this.temperature = [];
        this.nextTemperature = [];
        
        // Material properties grid (different alpha per cell)
        this.materialAlpha = [];
        
        // Heat sources
        this.heatSources = [];
        this.sourceType = 'instant'; // 'instant', 'continuous', 'pulse', 'moving'
        this.sourceTemp = 1.0;
        this.sourceSize = 3;
        this.movingSource = null;
        
        // Boundary conditions
        this.boundaryType = 'dirichlet'; // 'dirichlet', 'neumann', 'periodic', 'mixed'
        this.boundaryTemp = 0.0;
        
        // Convection
        this.convectionEnabled = false;
        this.convectionStrength = 0.01;
        
        // Visualization
        this.showValues = false;
        this.isPaused = false;
        this.time = 0;
        
        // Performance
        this.fps = 60;
        this.useGPU = false; // Simple CPU method for compatibility
        
        // Initialize grids
        this.initializeGrids();
        
        // Set up UI controls
        this.setupControls();
        
        // Add initial heat sources
        this.addInitialSources();
    }
    
    // Initialize temperature and material grids
    initializeGrids() {
        const size = this.gridSize;
        
        // Initialize temperature arrays
        this.temperature = new Array(size);
        this.nextTemperature = new Array(size);
        this.materialAlpha = new Array(size);
        
        for (let i = 0; i < size; i++) {
            this.temperature[i] = new Array(size).fill(this.boundaryTemp);
            this.nextTemperature[i] = new Array(size).fill(this.boundaryTemp);
            this.materialAlpha[i] = new Array(size).fill(this.alpha);
        }
        
        // Apply boundary conditions
        this.applyBoundaryConditions();
    }
    
    // Add initial heat sources for demonstration
    addInitialSources() {
        const center = Math.floor(this.gridSize / 2);
        
        // Add a central heat source
        this.addHeatSource(center, center, this.sourceTemp, this.sourceSize);
        
        // Add a few more for interest
        const quarter = Math.floor(this.gridSize / 4);
        this.addHeatSource(quarter, quarter, this.sourceTemp * 0.8, this.sourceSize);
        this.addHeatSource(this.gridSize - quarter, quarter, this.sourceTemp * 0.6, this.sourceSize);
    }
    
    // Add a heat source at specified position
    addHeatSource(x, y, temp, size) {
        this.heatSources.push({
            x: x,
            y: y,
            temp: temp,
            size: size,
            type: this.sourceType,
            active: true,
            pulsePhase: Math.random() * Math.PI * 2
        });
    }
    
    // Apply boundary conditions to the grid
    applyBoundaryConditions() {
        const size = this.gridSize;
        
        switch (this.boundaryType) {
            case 'dirichlet':
                // Fixed temperature boundaries
                for (let i = 0; i < size; i++) {
                    this.temperature[0][i] = this.boundaryTemp; // Top
                    this.temperature[size-1][i] = this.boundaryTemp; // Bottom
                    this.temperature[i][0] = this.boundaryTemp; // Left
                    this.temperature[i][size-1] = this.boundaryTemp; // Right
                }
                break;
                
            case 'neumann':
                // Insulated boundaries (zero gradient)
                // For explicit method, we'll handle this in the update step
                // by not updating boundary cells
                break;
                
            case 'periodic':
                // Periodic boundaries (wrapping)
                // Handled in the update step by accessing wrapped indices
                break;
                
            case 'mixed':
                // Mixed boundaries (hot left, cold right)
                for (let i = 0; i < size; i++) {
                    this.temperature[i][0] = 1.0; // Hot left side
                    this.temperature[i][size-1] = 0.0; // Cold right side
                    this.temperature[0][i] = this.boundaryTemp; // Top
                    this.temperature[size-1][i] = this.boundaryTemp; // Bottom
                }
                break;
        }
    }
    
    // Update the heat equation using explicit finite difference method
    update() {
        if (this.isPaused) return;
        
        this.time += this.dt;
        
        const size = this.gridSize;
        const dx2 = 1; // dx = 1, so dx^2 = 1
        const stabilityFactor = this.dt / dx2;
        
        // Update heat sources
        this.updateHeatSources();
        
        // Apply explicit finite difference method
        for (let i = 1; i < size - 1; i++) {
            for (let j = 1; j < size - 1; j++) {
                // Get local thermal diffusivity
                const localAlpha = this.materialAlpha[i][j];
                
                // Calculate Laplacian using 5-point stencil
                const laplacian = (
                    this.temperature[i-1][j] + 
                    this.temperature[i+1][j] + 
                    this.temperature[i][j-1] + 
                    this.temperature[i][j+1] - 
                    4 * this.temperature[i][j]
                );
                
                // Update temperature using explicit method
                this.nextTemperature[i][j] = this.temperature[i][j] + 
                    localAlpha * stabilityFactor * laplacian;
                
                // Apply convection if enabled
                if (this.convectionEnabled) {
                    // Simple convection model (advection)
                    const convX = (this.temperature[i+1][j] - this.temperature[i-1][j]) * 0.5;
                    const convY = (this.temperature[i][j+1] - this.temperature[i][j-1]) * 0.5;
                    
                    this.nextTemperature[i][j] -= this.convectionStrength * (convX + convY);
                }
            }
        }
        
        // Apply boundary conditions based on type
        this.applyBoundaryUpdate();
        
        // Swap arrays for next iteration
        const temp = this.temperature;
        this.temperature = this.nextTemperature;
        this.nextTemperature = temp;
        
        // Apply heat sources to next temperature field
        this.applyHeatSources();
        
        // Find min/max temperature for visualization
        this.updateTemperatureRange();
    }
    
    // Apply boundary conditions during update
    applyBoundaryUpdate() {
        const size = this.gridSize;
        
        switch (this.boundaryType) {
            case 'dirichlet':
                // Fixed temperature boundaries already set
                for (let i = 0; i < size; i++) {
                    this.nextTemperature[0][i] = this.boundaryTemp;
                    this.nextTemperature[size-1][i] = this.boundaryTemp;
                    this.nextTemperature[i][0] = this.boundaryTemp;
                    this.nextTemperature[i][size-1] = this.boundaryTemp;
                }
                break;
                
            case 'neumann':
                // Insulated boundaries: zero gradient
                // Copy from adjacent interior cells
                for (let i = 0; i < size; i++) {
                    this.nextTemperature[0][i] = this.nextTemperature[1][i]; // Top
                    this.nextTemperature[size-1][i] = this.nextTemperature[size-2][i]; // Bottom
                    this.nextTemperature[i][0] = this.nextTemperature[i][1]; // Left
                    this.nextTemperature[i][size-1] = this.nextTemperature[i][size-2]; // Right
                }
                break;
                
            case 'periodic':
                // Periodic boundaries: wrap around
                for (let i = 0; i < size; i++) {
                    this.nextTemperature[0][i] = this.nextTemperature[size-2][i]; // Top from bottom-1
                    this.nextTemperature[size-1][i] = this.nextTemperature[1][i]; // Bottom from top+1
                    this.nextTemperature[i][0] = this.nextTemperature[i][size-2]; // Left from right-1
                    this.nextTemperature[i][size-1] = this.nextTemperature[i][1]; // Right from left+1
                }
                break;
                
            case 'mixed':
                // Mixed boundaries (already set in initialization)
                for (let i = 0; i < size; i++) {
                    this.nextTemperature[i][0] = 1.0; // Hot left
                    this.nextTemperature[i][size-1] = 0.0; // Cold right
                    this.nextTemperature[0][i] = this.boundaryTemp; // Top
                    this.nextTemperature[size-1][i] = this.boundaryTemp; // Bottom
                }
                break;
        }
        
        // Handle corners for all boundary types
        this.nextTemperature[0][0] = (this.nextTemperature[0][1] + this.nextTemperature[1][0]) / 2;
        this.nextTemperature[0][size-1] = (this.nextTemperature[0][size-2] + this.nextTemperature[1][size-1]) / 2;
        this.nextTemperature[size-1][0] = (this.nextTemperature[size-1][1] + this.nextTemperature[size-2][0]) / 2;
        this.nextTemperature[size-1][size-1] = (this.nextTemperature[size-1][size-2] + this.nextTemperature[size-2][size-1]) / 2;
    }
    
    // Update heat sources (pulse, moving, etc.)
    updateHeatSources() {
        for (const source of this.heatSources) {
            if (!source.active) continue;
            
            switch (source.type) {
                case 'pulse':
                    // Oscillating temperature
                    source.pulsePhase += 0.1;
                    const pulseTemp = source.temp * (0.5 + 0.5 * Math.sin(source.pulsePhase));
                    this.applySourceToGrid(source.x, source.y, pulseTemp, source.size);
                    break;
                    
                case 'continuous':
                    // Constant temperature source
                    this.applySourceToGrid(source.x, source.y, source.temp, source.size);
                    break;
                    
                case 'moving':
                    // Moving source (dragged by mouse)
                    if (this.movingSource === source) {
                        // Position updated by mouse
                        this.applySourceToGrid(source.x, source.y, source.temp, source.size);
                    }
                    break;
                    
                case 'instant':
                default:
                    // Instant source already applied
                    break;
            }
        }
    }
    
    // Apply heat sources to the temperature grid
    applyHeatSources() {
        for (const source of this.heatSources) {
            if (source.type === 'instant' && source.active) {
                // Instant source: apply once
                this.applySourceToGrid(source.x, source.y, source.temp, source.size);
                source.active = false; // Deactivate after applying
            } else if (source.type === 'continuous' || source.type === 'pulse' || source.type === 'moving') {
                // Continuous, pulse, or moving sources applied in updateHeatSources
                continue;
            }
        }
    }
    
    // Apply a heat source to the grid (Gaussian distribution)
    applySourceToGrid(x, y, temp, size) {
        const radius = Math.floor(size / 2);
        
        for (let dx = -radius; dx <= radius; dx++) {
            for (let dy = -radius; dy <= radius; dy++) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && nx < this.gridSize && ny >= 0 && ny < this.gridSize) {
                    // Gaussian falloff
                    const distance2 = dx * dx + dy * dy;
                    const falloff = Math.exp(-distance2 / (size * size));
                    
                    // Apply heat
                    this.temperature[nx][ny] = Math.max(this.temperature[nx][ny], temp * falloff);
                    
                    // Also update next temperature for consistency
                    this.nextTemperature[nx][ny] = Math.max(this.nextTemperature[nx][ny], temp * falloff);
                }
            }
        }
    }
    
    // Apply cooling to a region
    applyCooling(x, y, size) {
        const radius = Math.floor(size / 2);
        const coolTemp = 0.0;
        
        for (let dx = -radius; dx <= radius; dx++) {
            for (let dy = -radius; dy <= radius; dy++) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && nx < this.gridSize && ny >= 0 && ny < this.gridSize) {
                    // Gaussian falloff for cooling
                    const distance2 = dx * dx + dy * dy;
                    const influence = Math.exp(-distance2 / (size * size));
                    
                    // Cool the region
                    this.temperature[nx][ny] = Math.min(this.temperature[nx][ny], coolTemp + (1 - influence) * this.temperature[nx][ny]);
                    this.nextTemperature[nx][ny] = this.temperature[nx][ny];
                }
            }
        }
    }
    
    // Update temperature range for visualization
    updateTemperatureRange() {
        let minTemp = Infinity;
        let maxTemp = -Infinity;
        
        for (let i = 0; i < this.gridSize; i++) {
            for (let j = 0; j < this.gridSize; j++) {
                const temp = this.temperature[i][j];
                minTemp = Math.min(minTemp, temp);
                maxTemp = Math.max(maxTemp, temp);
            }
        }
        
        this.minTemperature = minTemp;
        this.maxTemperature = maxTemp;
        
        // Update UI display
        document.querySelector('.temp-range').textContent = 
            `T: ${minTemp.toFixed(1)}¬∞ - ${maxTemp.toFixed(1)}¬∞`;
    }
    
    // Draw the temperature field
    draw(canvas) {
        // Clear with gradient background
        this.drawBackground(canvas);
        
        // Draw temperature grid
        this.drawTemperatureGrid(canvas);
        
        // Draw heat sources
        this.drawHeatSources(canvas);
        
        // Draw temperature values if enabled
        if (this.showValues) {
            this.drawTemperatureValues(canvas);
        }
        
        // Draw grid lines
        this.drawGridLines(canvas);
        
        // Update UI
        this.updateUI();
    }
    
    // Draw gradient background
    drawBackground(canvas) {
        // Create gradient
        let gradient = canvas.drawingContext.createLinearGradient(0, 0, canvas.width, 0);
        gradient.addColorStop(0, 'rgba(10, 12, 28, 0.9)');
        gradient.addColorStop(0.5, 'rgba(15, 20, 45, 0.8)');
        gradient.addColorStop(1, 'rgba(10, 12, 28, 0.9)');
        
        canvas.drawingContext.fillStyle = gradient;
        canvas.rect(0, 0, canvas.width, canvas.height);
        canvas.fill();
    }
    
    // Draw temperature grid with color mapping
    drawTemperatureGrid(canvas) {
        const scale = this.cellSize;
        
        for (let i = 0; i < this.gridSize; i++) {
            for (let j = 0; j < this.gridSize; j++) {
                const temp = this.temperature[i][j];
                
                // Normalize temperature to 0-1 range
                let normalizedTemp = temp;
                if (this.maxTemperature > this.minTemperature) {
                    normalizedTemp = (temp - this.minTemperature) / (this.maxTemperature - this.minTemperature);
                }
                
                // Clamp to 0-1
                normalizedTemp = Math.max(0, Math.min(1, normalizedTemp));
                
                // Get color based on temperature
                const color = this.temperatureToColor(normalizedTemp);
                
                // Draw cell
                const x = i * scale;
                const y = j * scale;
                
                canvas.fill(color);
                canvas.noStroke();
                canvas.rect(x, y, scale, scale);
            }
        }
    }
    
    // Convert temperature to color (blue to red gradient)
    temperatureToColor(t) {
        // Blue (cold) -> Cyan -> Green -> Yellow -> Red (hot)
        let r, g, b;
        
        if (t < 0.25) {
            // Blue to Cyan
            const f = t / 0.25;
            r = Math.floor(0);
            g = Math.floor(255 * f);
            b = Math.floor(255);
        } else if (t < 0.5) {
            // Cyan to Green
            const f = (t - 0.25) / 0.25;
            r = Math.floor(0);
            g = Math.floor(255);
            b = Math.floor(255 * (1 - f));
        } else if (t < 0.75) {
            // Green to Yellow
            const f = (t - 0.5) / 0.25;
            r = Math.floor(255 * f);
            g = Math.floor(255);
            b = Math.floor(0);
        } else {
            // Yellow to Red
            const f = (t - 0.75) / 0.25;
            r = Math.floor(255);
            g = Math.floor(255 * (1 - f));
            b = Math.floor(0);
        }
        
        // Add alpha based on temperature (hotter = more opaque)
        const alpha = 150 + t * 105;
        
        return [r, g, b, alpha];
    }
    
    // Draw heat sources
    drawHeatSources(canvas) {
        const scale = this.cellSize;
        
        for (const source of this.heatSources) {
            if (!source.active && source.type !== 'continuous' && source.type !== 'pulse' && source.type !== 'moving') {
                continue;
            }
            
            const x = source.x * scale + scale / 2;
            const y = source.y * scale + scale / 2;
            const radius = source.size * scale / 2;
            
            // Draw source outline
            canvas.noFill();
            canvas.stroke(255, 255, 255, 200);
            canvas.strokeWeight(2);
            canvas.circle(x, y, radius);
            
            // Draw source center
            canvas.fill(255, 255, 255, 150);
            canvas.noStroke();
            canvas.circle(x, y, 4);
            
            // Draw source type indicator
            if (source.type === 'pulse') {
                // Pulsing animation
                const pulseRadius = radius * (0.7 + 0.3 * Math.sin(this.time * 2));
                canvas.noFill();
                canvas.stroke(255, 100, 100, 150);
                canvas.strokeWeight(1);
                canvas.circle(x, y, pulseRadius);
            }
        }
    }
    
    // Draw temperature values (for debugging)
    drawTemperatureValues(canvas) {
        const scale = this.cellSize;
        
        canvas.fill(255, 255, 255, 200);
        canvas.noStroke();
        canvas.textSize(8);
        canvas.textAlign(canvas.CENTER, canvas.CENTER);
        
        // Only draw values for a subset of cells to avoid clutter
        const step = Math.max(1, Math.floor(this.gridSize / 20));
        
        for (let i = 0; i < this.gridSize; i += step) {
            for (let j = 0; j < this.gridSize; j += step) {
                const temp = this.temperature[i][j];
                const x = i * scale + scale / 2;
                const y = j * scale + scale / 2;
                
                canvas.text(temp.toFixed(1), x, y);
            }
        }
    }
    
    // Draw grid lines
    drawGridLines(canvas) {
        const scale = this.cellSize;
        
        canvas.strokeWeight(0.5);
        canvas.stroke(30, 40, 70, 30);
        
        // Vertical lines
        for (let i = 0; i <= this.gridSize; i++) {
            const x = i * scale;
            canvas.line(x, 0, x, canvas.height);
        }
        
        // Horizontal lines
        for (let j = 0; j <= this.gridSize; j++) {
            const y = j * scale;
            canvas.line(0, y, canvas.width, y);
        }
    }
    
    // Update UI elements
    updateUI() {
        // Update FPS
        const fps = Math.round(frameRate());
        document.querySelector('.fps-counter').textContent = `FPS: ${fps}`;
    }
    
    // Handle mouse click to add heat
    handleMouseClick(mx, my) {
        const scale = this.cellSize;
        const x = Math.floor(mx / scale);
        const y = Math.floor(my / scale);
        
        if (x >= 0 && x < this.gridSize && y >= 0 && y < this.gridSize) {
            // Check if we're dragging a moving source
            if (this.movingSource) {
                this.movingSource.x = x;
                this.movingSource.y = y;
                return;
            }
            
            // Add new heat source
            this.addHeatSource(x, y, this.sourceTemp, this.sourceSize);
        }
    }
    
    // Handle mouse drag for moving heat source
    handleMouseDrag(mx, my) {
        if (this.movingSource) {
            const scale = this.cellSize;
            const x = Math.floor(mx / scale);
            const y = Math.floor(my / scale);
            
            if (x >= 0 && x < this.gridSize && y >= 0 && y < this.gridSize) {
                this.movingSource.x = x;
                this.movingSource.y = y;
            }
        }
    }
    
    // Handle key press for cooling
    handleKeyPress(key) {
        if (key === 'c' || key === 'C') {
            // Cool at mouse position
            const mx = mouseX;
            const my = mouseY;
            const scale = this.cellSize;
            const x = Math.floor(mx / scale);
            const y = Math.floor(my / scale);
            
            if (x >= 0 && x < this.gridSize && y >= 0 && y < this.gridSize) {
                this.applyCooling(x, y, this.sourceSize * 2);
            }
        }
    }
    
    // Setup UI controls
    setupControls() {
        // Thermal conductivity slider
        const conductivitySlider = document.getElementById('conductivity');
        const conductivityValue = document.getElementById('conductivity-value');
        
        conductivitySlider.addEventListener('input', () => {
            this.alpha = parseFloat(conductivitySlider.value);
            conductivityValue.textContent = this.alpha.toFixed(2);
            
            // Update material grid
            for (let i = 0; i < this.gridSize; i++) {
                for (let j = 0; j < this.gridSize; j++) {
                    this.materialAlpha[i][j] = this.alpha;
                }
            }
            
            // Update stability condition
            this.maxDt = 1 / (4 * this.alpha);
            if (this.dt > this.maxDt) {
                this.dt = this.maxDt * 0.9;
                document.getElementById('diffusion-speed').value = this.dt;
                document.getElementById('diffusion-speed-value').textContent = this.dt.toFixed(2);
            }
        });
        
        // Diffusion speed slider
        const diffusionSlider = document.getElementById('diffusion-speed');
        const diffusionValue = document.getElementById('diffusion-speed-value');
        
        diffusionSlider.addEventListener('input', () => {
            const newDt = parseFloat(diffusionSlider.value);
            
            // Check stability condition
            if (newDt <= this.maxDt) {
                this.dt = newDt;
                diffusionValue.textContent = this.dt.toFixed(2);
            } else {
                // Revert to maximum stable value
                this.dt = this.maxDt * 0.9;
                diffusionSlider.value = this.dt;
                diffusionValue.textContent = this.dt.toFixed(2);
                alert(`Time step too large for stability! Maximum dt = ${this.maxDt.toFixed(3)}`);
            }
        });
        
        // Boundary temperature slider
        const boundaryTempSlider = document.getElementById('boundary-temp');
        const boundaryTempValue = document.getElementById('boundary-temp-value');
        
        boundaryTempSlider.addEventListener('input', () => {
            this.boundaryTemp = parseFloat(boundaryTempSlider.value);
            boundaryTempValue.textContent = this.boundaryTemp.toFixed(1);
            this.applyBoundaryConditions();
        });
        
        // Source temperature slider
        const sourceTempSlider = document.getElementById('source-temp');
        const sourceTempValue = document.getElementById('source-temp-value');
        
        sourceTempSlider.addEventListener('input', () => {
            this.sourceTemp = parseFloat(sourceTempSlider.value);
            sourceTempValue.textContent = this.sourceTemp.toFixed(1);
        });
        
        // Source size slider
        const sourceSizeSlider = document.getElementById('source-size');
        const sourceSizeValue = document.getElementById('source-size-value');
        
        sourceSizeSlider.addEventListener('input', () => {
            this.sourceSize = parseInt(sourceSizeSlider.value);
            sourceSizeValue.textContent = this.sourceSize;
        });
        
        // Resolution slider
        const resolutionSlider = document.getElementById('resolution');
        const resolutionValue = document.getElementById('resolution-value');
        
        resolutionSlider.addEventListener('input', () => {
            this.gridSize = parseInt(resolutionSlider.value);
            resolutionValue.textContent = this.gridSize;
            
            // Adjust cell size to fit canvas
            const canvasContainer = document.getElementById('heat-canvas');
            this.cellSize = Math.max(2, Math.floor(canvasContainer.offsetWidth / this.gridSize));
            
            // Reinitialize grids
            this.initializeGrids();
            this.addInitialSources();
        });
        
        // Material preset buttons
        const materialPresets = document.querySelectorAll('.material-preset');
        materialPresets.forEach(preset => {
            preset.addEventListener('click', () => {
                materialPresets.forEach(p => p.classList.remove('active'));
                preset.classList.add('active');
                
                switch (preset.id) {
                    case 'preset-copper':
                        this.alpha = 0.40;
                        break;
                    case 'preset-aluminum':
                        this.alpha = 0.25;
                        break;
                    case 'preset-steel':
                        this.alpha = 0.12;
                        break;
                    case 'preset-glass':
                        this.alpha = 0.03;
                        break;
                }
                
                conductivitySlider.value = this.alpha;
                conductivityValue.textContent = this.alpha.toFixed(2);
                
                // Update material grid
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        this.materialAlpha[i][j] = this.alpha;
                    }
                }
                
                // Update stability condition
                this.maxDt = 1 / (4 * this.alpha);
                if (this.dt > this.maxDt) {
                    this.dt = this.maxDt * 0.9;
                    diffusionSlider.value = this.dt;
                    diffusionValue.textContent = this.dt.toFixed(2);
                }
            });
        });
        
        // Boundary preset buttons
        const boundaryPresets = document.querySelectorAll('.boundary-preset');
        boundaryPresets.forEach(preset => {
            preset.addEventListener('click', () => {
                boundaryPresets.forEach(p => p.classList.remove('active'));
                preset.classList.add('active');
                
                this.boundaryType = preset.id.replace('boundary-', '');
                this.applyBoundaryConditions();
            });
        });
        
        // Source type buttons
        const sourceTypes = document.querySelectorAll('.source-type');
        sourceTypes.forEach(type => {
            type.addEventListener('click', () => {
                sourceTypes.forEach(t => t.classList.remove('active'));
                type.classList.add('active');
                
                this.sourceType = type.id.replace('source-', '');
                
                // Update existing sources
                for (const source of this.heatSources) {
                    source.type = this.sourceType;
                    source.active = true;
                    
                    if (this.sourceType === 'instant') {
                        source.active = true; // Will be applied once
                    }
                }
                
                // Clear moving source if not in moving mode
                if (this.sourceType !== 'moving') {
                    this.movingSource = null;
                }
            });
        });
        
        // Toggles
        document.getElementById('convection-toggle').addEventListener('change', (e) => {
            this.convectionEnabled = e.target.checked;
        });
        
        document.getElementById('pause-toggle').addEventListener('change', (e) => {
            this.isPaused = e.target.checked;
        });
        
        document.getElementById('show-values').addEventListener('change', (e) => {
            this.showValues = e.target.checked;
        });
        
        // Buttons
        document.getElementById('add-heat-button').addEventListener('click', () => {
            // Add heat at center
            const center = Math.floor(this.gridSize / 2);
            this.addHeatSource(center, center, this.sourceTemp, this.sourceSize);
        });
        
        document.getElementById('cool-button').addEventListener('click', () => {
            // Cool at center
            const center = Math.floor(this.gridSize / 2);
            this.applyCooling(center, center, this.sourceSize * 3);
        });
        
        // Preset buttons
        document.getElementById('preset-single').addEventListener('click', () => {
            // Single source preset
            this.heatSources = [];
            const center = Math.floor(this.gridSize / 2);
            this.addHeatSource(center, center, 1.0, 5);
        });
        
        document.getElementById('preset-multiple').addEventListener('click', () => {
            // Multiple sources preset
            this.heatSources = [];
            
            const quarter = Math.floor(this.gridSize / 4);
            const threeQuarter = Math.floor(3 * this.gridSize / 4);
            
            this.addHeatSource(quarter, quarter, 1.0, 4);
            this.addHeatSource(threeQuarter, quarter, 0.8, 4);
            this.addHeatSource(quarter, threeQuarter, 0.6, 4);
            this.addHeatSource(threeQuarter, threeQuarter, 0.4, 4);
        });
        
        document.getElementById('preset-gradient').addEventListener('click', () => {
            // Temperature gradient preset
            this.heatSources = [];
            this.boundaryType = 'mixed';
            
            // Update UI
            boundaryPresets.forEach(p => p.classList.remove('active'));
            document.getElementById('boundary-mixed').classList.add('active');
            
            this.applyBoundaryConditions();
        });
        
        document.getElementById('reset-button').addEventListener('click', () => {
            // Reset simulation
            this.initializeGrids();
            this.addInitialSources();
            
            // Reset parameters to defaults
            this.alpha = 0.25;
            this.dt = 0.1;
            this.sourceTemp = 1.0;
            this.sourceSize = 3;
            this.sourceType = 'instant';
            this.boundaryType = 'dirichlet';
            this.boundaryTemp = 0.0;
            
            // Update sliders
            conductivitySlider.value = this.alpha;
            conductivityValue.textContent = this.alpha.toFixed(2);
            diffusionSlider.value = this.dt;
            diffusionValue.textContent = this.dt.toFixed(2);
            sourceTempSlider.value = this.sourceTemp;
            sourceTempValue.textContent = this.sourceTemp.toFixed(1);
            sourceSizeSlider.value = this.sourceSize;
            sourceSizeValue.textContent = this.sourceSize;
            boundaryTempSlider.value = this.boundaryTemp;
            boundaryTempValue.textContent = this.boundaryTemp.toFixed(1);
            
            // Update UI buttons
            materialPresets.forEach(p => p.classList.remove('active'));
            document.getElementById('preset-aluminum').classList.add('active');
            
            boundaryPresets.forEach(p => p.classList.remove('active'));
            document.getElementById('boundary-dirichlet').classList.add('active');
            
            sourceTypes.forEach(t => t.classList.remove('active'));
            document.getElementById('source-instant').classList.add('active');
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            switch(event.key) {
                case ' ':
                    // Space to toggle pause
                    this.isPaused = !this.isPaused;
                    document.getElementById('pause-toggle').checked = this.isPaused;
                    break;
                    
                case 'r':
                case 'R':
                    // R to reset
                    this.initializeGrids();
                    this.addInitialSources();
                    break;
                    
                case 'c':
                case 'C':
                    // C to cool
                    this.handleKeyPress(event.key);
                    break;
                    
                case '1':
                    this.boundaryType = 'dirichlet';
                    boundaryPresets.forEach(p => p.classList.remove('active'));
                    document.getElementById('boundary-dirichlet').classList.add('active');
                    this.applyBoundaryConditions();
                    break;
                    
                case '2':
                    this.boundaryType = 'neumann';
                    boundaryPresets.forEach(p => p.classList.remove('active'));
                    document.getElementById('boundary-neumann').classList.add('active');
                    this.applyBoundaryConditions();
                    break;
                    
                case '3':
                    this.boundaryType = 'periodic';
                    boundaryPresets.forEach(p => p.classList.remove('active'));
                    document.getElementById('boundary-periodic').classList.add('active');
                    this.applyBoundaryConditions();
                    break;
                    
                case '4':
                    this.boundaryType = 'mixed';
                    boundaryPresets.forEach(p => p.classList.remove('active'));
                    document.getElementById('boundary-mixed').classList.add('active');
                    this.applyBoundaryConditions();
                    break;
                    
                case 'm':
                case 'M':
                    // Toggle moving source mode
                    if (this.sourceType === 'moving') {
                        // Create a moving source if none exists
                        if (!this.movingSource) {
                            const center = Math.floor(this.gridSize / 2);
                            this.movingSource = {
                                x: center,
                                y: center,
                                temp: this.sourceTemp,
                                size: this.sourceSize,
                                type: 'moving',
                                active: true,
                                pulsePhase: 0
                            };
                            this.heatSources.push(this.movingSource);
                        }
                    }
                    break;
            }
        });
        
        // Mouse wheel for source size
        const canvasContainer = document.getElementById('heat-canvas');
        canvasContainer.addEventListener('wheel', (event) => {
            if (event.ctrlKey) {
                event.preventDefault();
                // Change source size with Ctrl+Wheel
                const delta = event.deltaY > 0 ? -1 : 1;
                this.sourceSize = Math.max(1, Math.min(10, this.sourceSize + delta));
                sourceSizeSlider.value = this.sourceSize;
                sourceSizeValue.textContent = this.sourceSize;
            }
        });
    }
}

// p5.js Sketch
let heatSim;

function setup() {
    const canvasContainer = document.getElementById('heat-canvas');
    const canvasWidth = canvasContainer.offsetWidth;
    const canvasHeight = canvasContainer.offsetHeight;
    
    // Create canvas
    const canvas = createCanvas(canvasWidth, canvasHeight);
    canvas.parent('heat-canvas');
    
    // Initialize heat simulation
    heatSim = new HeatDiffusionSimulation();
    
    // Setup mouse interaction
    canvas.mousePressed(() => {
        heatSim.handleMouseClick(mouseX, mouseY);
    });
    
    canvas.mouseDragged(() => {
        heatSim.handleMouseDrag(mouseX, mouseY);
    });
}

function draw() {
    // Calculate FPS
    const fps = Math.round(frameRate());
    document.querySelector('.fps-counter').textContent = `FPS: ${fps}`;
    
    // Update simulation
    heatSim.update();
    
    // Draw simulation
    heatSim.draw(canvas);
}

function windowResized() {
    const canvasContainer = document.getElementById('heat-canvas');
    const canvasWidth = canvasContainer.offsetWidth;
    const canvasHeight = canvasContainer.offsetHeight;
    resizeCanvas(canvasWidth, canvasHeight);
}

// Initialize the simulation when the page loads
window.addEventListener('DOMContentLoaded', () => {
    // p5.js will call setup() and draw() automatically
});
    </script>
</body>
</html>