<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy Formation Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #dcdcdc;
        }
        canvas { display: block; }
    </style>
</head>
<body>
<script>
// Configuration
const NUM_PARTICLES = 10000;
const G = 1.0;
const SOFTENING = 8;
const MERGE_DISTANCE = 2.5;
const BLACK_HOLE_MASS = 8000;
const DARK_MATTER_STRENGTH = 0.25;
const THETA = 0.5; // Barnes-Hut theta criterion

let particles = [];
let blackHole;
let quadtree;
let centerX, centerY;

class Particle {
    constructor(x, y, vx, vy, mass) {
        this.pos = createVector(x, y);
        this.vel = createVector(vx, vy);
        this.acc = createVector(0, 0);
        this.mass = mass;
        this.merged = false;
    }

    applyForce(force) {
        let f = p5.Vector.div(force, this.mass);
        this.acc.add(f);
    }

    update() {
        this.vel.add(this.acc);
        this.vel.mult(0.998); // Slight damping for stability
        this.pos.add(this.vel);
        this.acc.mult(0);
    }

    display() {
        let brightness = map(this.mass, 0.5, 15, 180, 255, true);
        let size = map(this.mass, 0.5, 15, 1.2, 3.5, true);
        
        // Color variation based on speed (hotter = bluer, cooler = redder)
        let speed = this.vel.mag();
        let r = constrain(brightness - speed * 3, 150, 255);
        let g = constrain(brightness - speed * 1.5, 150, 255);
        let b = constrain(brightness + speed * 2, 180, 255);
        
        noStroke();
        fill(r, g, b, 220);
        circle(this.pos.x, this.pos.y, size);
        
        // Glow effect for larger masses
        if (this.mass > 5) {
            fill(r, g, b, 80);
            circle(this.pos.x, this.pos.y, size * 2);
        }
    }
}

class Rectangle {
    constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }

    contains(particle) {
        return (particle.pos.x >= this.x - this.w &&
                particle.pos.x < this.x + this.w &&
                particle.pos.y >= this.y - this.h &&
                particle.pos.y < this.y + this.h);
    }

    intersects(range) {
        return !(range.x - range.w > this.x + this.w ||
                 range.x + range.w < this.x - this.w ||
                 range.y - range.h > this.y + this.h ||
                 range.y + range.h < this.y - this.h);
    }
}

class Quadtree {
    constructor(boundary, capacity) {
        this.boundary = boundary;
        this.capacity = capacity;
        this.particles = [];
        this.divided = false;
        this.totalMass = 0;
        this.centerOfMass = createVector(0, 0);
    }

    subdivide() {
        let x = this.boundary.x;
        let y = this.boundary.y;
        let w = this.boundary.w / 2;
        let h = this.boundary.h / 2;

        let ne = new Rectangle(x + w, y - h, w, h);
        let nw = new Rectangle(x - w, y - h, w, h);
        let se = new Rectangle(x + w, y + h, w, h);
        let sw = new Rectangle(x - w, y + h, w, h);

        this.northeast = new Quadtree(ne, this.capacity);
        this.northwest = new Quadtree(nw, this.capacity);
        this.southeast = new Quadtree(se, this.capacity);
        this.southwest = new Quadtree(sw, this.capacity);

        this.divided = true;
    }

    insert(particle) {
        if (!this.boundary.contains(particle)) {
            return false;
        }

        if (this.particles.length < this.capacity) {
            this.particles.push(particle);
            this.updateMassInfo(particle);
            return true;
        }

        if (!this.divided) {
            this.subdivide();
        }

        this.updateMassInfo(particle);

        return (this.northeast.insert(particle) ||
                this.northwest.insert(particle) ||
                this.southeast.insert(particle) ||
                this.southwest.insert(particle));
    }

    updateMassInfo(particle) {
        let weightedPos = p5.Vector.mult(particle.pos, particle.mass);
        this.centerOfMass.mult(this.totalMass);
        this.centerOfMass.add(weightedPos);
        this.totalMass += particle.mass;
        if (this.totalMass > 0) {
            this.centerOfMass.div(this.totalMass);
        }
    }

    query(range, found) {
        if (!found) {
            found = [];
        }

        if (!this.boundary.intersects(range)) {
            return found;
        }

        for (let p of this.particles) {
            if (range.contains(p)) {
                found.push(p);
            }
        }

        if (this.divided) {
            this.northeast.query(range, found);
            this.northwest.query(range, found);
            this.southeast.query(range, found);
            this.southwest.query(range, found);
        }

        return found;
    }

    // Barnes-Hut algorithm for force calculation
    calculateForce(particle, theta) {
        if (this.totalMass === 0) {
            return createVector(0, 0);
        }

        let d = p5.Vector.dist(particle.pos, this.centerOfMass);
        
        // If this is the particle itself, skip
        if (d < 0.1) {
            return createVector(0, 0);
        }

        let s = this.boundary.w * 2;

        // If far enough or leaf node, treat as single body
        if (s / d < theta || !this.divided) {
            let force = p5.Vector.sub(this.centerOfMass, particle.pos);
            let distSq = force.magSq();
            distSq = constrain(distSq, SOFTENING * SOFTENING, 1000000);
            
            let strength = (G * particle.mass * this.totalMass) / distSq;
            force.setMag(strength);
            return force;
        }

        // Otherwise, recurse on children
        let force = createVector(0, 0);
        if (this.divided) {
            force.add(this.northeast.calculateForce(particle, theta));
            force.add(this.northwest.calculateForce(particle, theta));
            force.add(this.southeast.calculateForce(particle, theta));
            force.add(this.southwest.calculateForce(particle, theta));
        }

        return force;
    }
}

function setup() {
    createCanvas(windowWidth, windowHeight);
    centerX = width / 2;
    centerY = height / 2;

    // Central supermassive black hole
    blackHole = {
        pos: createVector(centerX, centerY),
        mass: BLACK_HOLE_MASS
    };

    // Initialize particles in a collapsing protogalactic cloud
    for (let i = 0; i < NUM_PARTICLES; i++) {
        // Spherical distribution with some flattening
        let angle = random(TWO_PI);
        let radius = abs(randomGaussian(0, 120));
        let z = randomGaussian(0, 40); // Vertical component (simulated via velocity)
        
        let x = centerX + cos(angle) * radius;
        let y = centerY + sin(angle) * radius;

        // Keplerian velocity profile with dark matter influence
        let distFromCenter = sqrt(radius * radius + z * z) + 1;
        
        // Combined potential from black hole + dark matter halo
        let centralMass = BLACK_HOLE_MASS + distFromCenter * DARK_MATTER_STRENGTH * 100;
        let orbitSpeed = sqrt(G * centralMass / distFromCenter) * 0.7;
        
        // Add rotation (counter-clockwise)
        let velAngle = angle + HALF_PI;
        let vx = cos(velAngle) * orbitSpeed + randomGaussian(0, 1.5);
        let vy = sin(velAngle) * orbitSpeed + randomGaussian(0, 1.5);
        
        // Initial collapse velocity (inward)
        vx += cos(angle) * randomGaussian(-0.3, 0.5);
        vy += sin(angle) * randomGaussian(-0.3, 0.5);

        let mass = random(0.5, 2.5);
        particles.push(new Particle(x, y, vx, vy, mass));
    }

    background(220);
}

function draw() {
    // Motion trail effect
    fill(220, 220, 220, 35);
    noStroke();
    rect(0, 0, width, height);

    // Build quadtree for current frame
    let boundary = new Rectangle(centerX, centerY, max(width, height), max(width, height));
    quadtree = new Quadtree(boundary, 4);
    
    for (let particle of particles) {
        if (!particle.merged) {
            quadtree.insert(particle);
        }
    }

    // Physics updates
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        if (p.merged) continue;

        // 1. Central black hole gravity
        let toBH = p5.Vector.sub(blackHole.pos, p.pos);
        let distSqBH = toBH.magSq();
        distSqBH = constrain(distSqBH, SOFTENING * SOFTENING, 1000000);
        let bhStrength = (G * p.mass * blackHole.mass) / distSqBH;
        toBH.setMag(bhStrength);
        p.applyForce(toBH);

        // 2. Dark matter halo (spherical, increases with radius)
        let r = p5.Vector.dist(p.pos, blackHole.pos);
        if (r > 10) {
            // Dark matter provides flat rotation curve
            let dmMass = r * DARK_MATTER_STRENGTH * 80;
            let dmForce = p5.Vector.sub(blackHole.pos, p.pos);
            let dmDistSq = dmForce.magSq();
            dmDistSq = constrain(dmDistSq, SOFTENING * SOFTENING, 1000000);
            let dmStrength = (G * p.mass * dmMass) / dmDistSq;
            dmForce.setMag(dmStrength);
            p.applyForce(dmForce);
        }

        // 3. Particle-particle gravity (Barnes-Hut)
        let qtForce = quadtree.calculateForce(p, THETA);
        p.applyForce(qtForce);

        p.update();
    }

    // Collision detection and merging
    for (let i = particles.length - 1; i >= 0; i--) {
        if (particles[i].merged) continue;
        
        let range = new Rectangle(
            particles[i].pos.x,
            particles[i].pos.y,
            MERGE_DISTANCE * 3,
            MERGE_DISTANCE * 3
        );
        
        let nearby = quadtree.query(range);
        
        for (let other of nearby) {
            if (particles[i] === other || other.merged) continue;
            
            let d = p5.Vector.dist(particles[i].pos, other.pos);
            if (d < MERGE_DISTANCE && d > 0) {
                // Conservation of momentum and mass
                let totalMass = particles[i].mass + other.mass;
                let newVel = p5.Vector.mult(particles[i].vel, particles[i].mass);
                newVel.add(p5.Vector.mult(other.vel, other.mass));
                newVel.div(totalMass);
                
                // Merge into more massive particle position (weighted average)
                let newPos = p5.Vector.mult(particles[i].pos, particles[i].mass);
                newPos.add(p5.Vector.mult(other.pos, other.mass));
                newPos.div(totalMass);
                
                particles[i].pos = newPos;
                particles[i].vel = newVel;
                particles[i].mass = totalMass;
                other.merged = true;
                break;
            }
        }
    }

    // Periodic cleanup of merged particles
    if (frameCount % 60 === 0) {
        particles = particles.filter(p => !p.merged);
    }

    // Render particles
    for (let particle of particles) {
        if (!particle.merged) {
            particle.display();
        }
    }

    // Draw central black hole
    fill(20, 20, 40, 200);
    noStroke();
    circle(blackHole.pos.x, blackHole.pos.y, 20);
    fill(10, 10, 20, 100);
    circle(blackHole.pos.x, blackHole.pos.y, 35);
    fill(0, 0, 0, 50);
    circle(blackHole.pos.x, blackHole.pos.y, 50);

    // Info display
    fill(60);
    noStroke();
    textSize(13);
    textAlign(LEFT, TOP);
    let activeParticles = particles.filter(p => !p.merged).length;
    text(`Particles: ${activeParticles}`, 15, 15);
    text(`FPS: ${floor(frameRate())}`, 15, 35);
    text(`Time: ${(frameCount / 60).toFixed(1)}s`, 15, 55);
    
    textSize(11);
    fill(80);
    text(`Galaxy Formation Simulation`, 15, height - 25);
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    centerX = width / 2;
    centerY = height / 2;
    background(220);
}
</script>
</body>
</html>