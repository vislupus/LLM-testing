<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEBULA DEFENDER - Space Shooter</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #0ff;
            image-rendering: pixelated;
        }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            padding: 20px;
            z-index: 100;
        }
        #score {
            font-size: 24px;
            text-shadow: 0 0 10px #0ff;
            letter-spacing: 2px;
        }
        #lives {
            position: absolute;
            bottom: 30px;
            left: 30px;
            font-size: 20px;
            text-shadow: 0 0 10px #f00;
        }
        #gameOver {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 40px 60px;
            border: 2px solid #0ff;
            border-radius: 15px;
            text-align: center;
            display: none;
            box-shadow: 0 0 50px #0ff;
        }
        #gameOver h1 {
            font-size: 48px;
            margin-bottom: 20px;
            background: linear-gradient(90deg, #0ff, #f0f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        #gameOver button {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 24px;
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        #gameOver button:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px #0ff;
        }
        #titleScreen {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle at center, #001122, #000);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        #titleScreen h1 {
            font-size: 72px;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #0ff, #f0f, #ff0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 40px #0ff;
        }
        #titleScreen p {
            font-size: 24px;
            margin: 20px 0;
            opacity: 0.8;
        }
        #startButton {
            margin-top: 50px;
            padding: 20px 60px;
            font-size: 32px;
            background: transparent;
            color: #0ff;
            border: 3px solid #0ff;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.4s;
            box-shadow: 0 0 30px #0ff;
        }
        #startButton:hover {
            background: #0ff;
            color: #000;
            transform: scale(1.1);
            box-shadow: 0 0 60px #0ff;
        }
    </style>
</head>
<body>

<div id="titleScreen">
    <h1>NEBULA DEFENDER</h1>
    <p>Use ← → to move • SPACE to shoot</p>
    <p>Survive the alien invasion!</p>
    <button id="startButton">LAUNCH</button>
</div>

<div id="ui">
    <div id="score">SCORE: 000000</div>
    <div id="lives">LIVES: ❤❤❤</div>
</div>

<div id="gameOver">
    <h1>GAME OVER</h1>
    <p id="finalScore">Final Score: 000000</p>
    <button onclick="restartGame()">PLAY AGAIN</button>
</div>

<canvas id="game"></canvas>

<script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Game state
    let gameActive = false;
    let score = 0;
    let lives = 3;
    let wave = 1;

    // Player
    const player = {
        x: canvas.width / 2 - 30,
        y: canvas.height - 120,
        width: 60,
        height: 80,
        speed: 8,
        velocityX: 0
    };

    // Arrays
    let bullets = [];
    let enemies = [];
    let asteroids = [];
    let particles = [];
    let stars = [];

    // Input
    const keys = {};

    // Initialize stars
    for (let i = 0; i < 200; i++) {
        stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 2 + 0.5,
            speed: Math.random() * 0.5 + 0.1,
            brightness: Math.random() * 0.8 + 0.2
        });
    }

    // Particle system
    function createExplosion(x, y, color = '#ff0066', count = 30) {
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i) / count;
            const velocity = Math.random() * 8 + 4;
            particles.push({
                x, y,
                vx: Math.cos(angle) * velocity,
                vy: Math.sin(angle) * velocity,
                size: Math.random() * 6 + 3,
                color,
                life: 60 + Math.random() * 30,
                decay: Math.random() * 0.03 + 0.02
            });
        }
    }

    // Create enemy
    function spawnEnemy() {
        const types = [
            { width: 50, height: 50, speed: 2, points: 100, color: '#00ff88' },
            { width: 70, height: 60, speed: 1.5, points: 200, color: '#ff00ff' },
            { width: 60, height: 80, speed: 3, points: 300, color: '#ffff00', shoots: true }
        ];
        const type = types[Math.floor(Math.random() * types.length)];
        
        enemies.push({
            x: Math.random() * (canvas.width - type.width),
            y: -type.height,
            ...type,
            health: type.points / 100
        });
    }

    // Create asteroid
    function spawnAsteroid() {
        const size = Math.random() * 60 + 30;
        asteroids.push({
            x: Math.random() * canvas.width,
            y: -size,
            width: size,
            height: size,
            speed: Math.random() * 2 + 1,
            rotation: 0,
            rotationSpeed: (Math.random() - 0.5) * 0.1
        });
    }

    // Bullet class
    class Bullet {
        constructor(x, y, vy = -15) {
            this.x = x;
            this.y = y;
            this.width = 4;
            this.height = 16;
            this.vy = vy;
            this.color = '#00ffff';
        }
        update() {
            this.y += this.vy;
        }
        draw() {
            ctx.fillStyle = '#00ffff';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00ffff';
            ctx.fillRect(this.x - 2, this.y, this.width, this.height);
            ctx.shadowBlur = 0;
        }
    }

    // Player ship drawing
    function drawPlayer() {
        ctx.save();
        ctx.translate(player.x + player.width/2, player.y + player.height/2);
        
        // Engine glow
        const time = Date.now() * 0.01;
        const glowSize = 20 + Math.sin(time * 10) * 5;
        
        const gradient = ctx.createRadialGradient(0, 20, 0, 0, 20, glowSize);
        gradient.addColorStop(0, '#00ffff');
        gradient.addColorStop(0.5, '#0088ff');
        gradient.addColorStop(1, 'transparent');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(-10, 15, 20, 40);
        
        // Ship body
        ctx.fillStyle = '#00ffff';
        ctx.shadowBlur = 30;
        ctx.shadowColor = '#00ffff';
        
        // Main body
        ctx.beginPath();
        ctx.moveTo(0, -40);
        ctx.lineTo(-30, 40);
        ctx.lineTo(-15, 30);
        ctx.lineTo(-10, 50);
        ctx.lineTo(10, 50);
        ctx.lineTo(15, 30);
        ctx.lineTo(30, 40);
        ctx.closePath();
        ctx.fill();
        
        // Cockpit
        ctx.fillStyle = '#0088ff';
        ctx.beginPath();
        ctx.arc(0, -10, 12, 0, Math.PI * 2);
        ctx.fill();
        
        // Wings
        ctx.fillStyle = '#00aaff';
        ctx.fillRect(-35, 10, 15, 40);
        ctx.fillRect(20, 10, 15, 40);
        
        ctx.restore();
    }

    // Enemy drawing
    function drawEnemy(enemy) {
        ctx.save();
        ctx.translate(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
        
        // Glow
        ctx.shadowBlur = 30;
        ctx.shadowColor = enemy.color;
        
        if (enemy.color === '#00ff88') {
            // Saucer type
            ctx.fillStyle = enemy.color;
            ctx.beginPath();
            ctx.ellipse(0, 0, enemy.width/2, enemy.height/2 - 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(0, -15, enemy.width/3, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Lights
            ctx.fillStyle = '#ffff00';
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                ctx.beginPath();
                ctx.arc(Math.cos(angle) * 20, Math.sin(angle) * 20 - 10, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        } else if (enemy.color === '#ff00ff') {
            // Octopus type
            ctx.fillStyle = enemy.color;
            ctx.beginPath();
            ctx.moveTo(0, -30);
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const x = Math.cos(angle) * 25;
                const y = Math.sin(angle) * 25;
                if (i % 2 === 0) {
                    ctx.lineTo(x, y + 10);
                } else {
                    ctx.quadraticCurveTo(x * 1.3, y + 30, x, y + 10);
                }
            }
            ctx.closePath();
            ctx.fill();
            
            // Eye
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(0, -10, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(3, -12, 6, 0, Math.PI * 2);
            ctx.fill();
        } else {
            // Shooter type
            ctx.fillStyle = enemy.color;
            ctx.beginPath();
            ctx.moveTo(0, -40);
            ctx.lineTo(-20, 20);
            ctx.lineTo(-30, 40);
            ctx.lineTo(30, 40);
            ctx.lineTo(20, 20);
            ctx.closePath();
            ctx.fill();
            
            // Cannon
            ctx.fillStyle = '#ff0066';
            ctx.fillRect(-8, -45, 16, 20);
        }
        
        ctx.restore();
    }

    // Game loop
    function gameLoop() {
        if (!gameActive) return;

        // Clear canvas
        ctx.fillStyle = 'rgba(0, 0, 15, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw stars
        ctx.fillStyle = '#ffffff';
        stars.forEach(star => {
            star.y += star.speed;
            if (star.y > canvas.height) star.y = 0;
            
            ctx.globalAlpha = star.brightness;
            ctx.fillRect(star.x, star.y, star.size, star.size);
        });
        ctx.globalAlpha = 1;

        // Player movement
        if ((keys['ArrowLeft'] || keys['a']) && player.x > 0) {
            player.x -= player.speed;
        }
        if ((keys['ArrowRight'] || keys['d']) && player.x < canvas.width - player.width) {
            player.x += player.speed;
        }

        // Shooting
        if (keys[' '] && Date.now() - (player.lastShot || 0) > 150) {
            bullets.push(new Bullet(player.x + player.width/2 - 2, player.y));
            player.lastShot = Date.now();
        }

        // Update bullets
        bullets.forEach((bullet, i) => {
            bullet.update();
            if (bullet.y < -20) {
                bullets.splice(i, 1);
            }
        });

        // Spawn enemies and asteroids
        if (Math.random() < 0.02 + wave * 0.005) spawnEnemy();
        if (Math.random() < 0.03) spawnAsteroid();

        // Update enemies
        enemies.forEach((enemy, i) => {
            enemy.y += enemy.speed;
            
            // Enemy shooting
            if (enemy.shoots && Math.random() < 0.005) {
                bullets.push(new Bullet(enemy.x + enemy.width/2, enemy.y + enemy.height, 8));
            }
            
            if (enemy.y > canvas.height) {
                enemies.splice(i, 1);
                lives--;
                updateLives();
                if (lives <= 0) gameOver();
            }
        });

        // Update asteroids
        asteroids.forEach((asteroid, i) => {
            asteroid.y += asteroid.speed;
            asteroid.rotation += asteroid.rotationSpeed;
            
            if (asteroid.y > canvas.height + asteroid.height) {
                asteroids.splice(i, 1);
            }
        });

        // Collision detection
        bullets.forEach((bullet, bIndex) => {
            // Enemy collision
            enemies.forEach((enemy, eIndex) => {
                if (bullet.y < enemy.y + enemy.height &&
                    bullet.y + bullet.height > enemy.y &&
                    bullet.x < enemy.x + enemy.width &&
                    bullet.x + bullet.width > enemy.x) {
                    
                    bullets.splice(bIndex, 1);
                    enemy.health--;
                    
                    if (enemy.health <= 0) {
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.color);
                        enemies.splice(eIndex, 1);
                        score += enemy.points;
                        updateScore();
                    }
                }
            });
            
            // Asteroid collision
            asteroids.forEach((asteroid, aIndex) => {
                if (bullet.y < asteroid.y + asteroid.height &&
                    bullet.y + bullet.height > asteroid.y &&
                    bullet.x < asteroid.x + asteroid.width &&
                    bullet.x + bullet.width > asteroid.x) {
                    
                    bullets.splice(bIndex, 1);
                    createExplosion(asteroid.x + asteroid.width/2, asteroid.y + asteroid.height/2, '#ff8800');
                    asteroids.splice(aIndex, 1);
                    score += 50;
                    updateScore();
                }
            });
        });

        // Player collision
        [...enemies, ...asteroids].forEach(obj => {
            if (player.x < obj.x + obj.width &&
                player.x + player.width > obj.x &&
                player.y < obj.y + obj.height &&
                player.y + player.height > obj.y) {
                
                createExplosion(player.x + player.width/2, player.y + player.height/2, '#00ffff', 60);
                lives--;
                updateLives();
                
                // Remove the object that hit player
                if ('health' in obj) {
                    enemies.splice(enemies.indexOf(obj), 1);
                } else {
                    asteroids.splice(asteroids.indexOf(obj), 1);
                }
                
                if (lives <= 0) gameOver();
            }
        });

        // Update particles
        particles.forEach((p, i) => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.2;
            p.life--;
            p.size -= p.decay;
            
            if (p.life <= 0 || p.size <= 0) {
                particles.splice(i, 1);
            }
        });

        // Drawing
        // Particles
        particles.forEach(p => {
            ctx.save();
            ctx.globalAlpha = p.life / 90;
            ctx.fillStyle = p.color;
            ctx.shadowBlur = 20;
            ctx.shadowColor = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        });

        // Asteroids
        asteroids.forEach(asteroid => {
            ctx.save();
            ctx.translate(asteroid.x + asteroid.width/2, asteroid.y + asteroid.height/2);
            ctx.rotate(asteroid.rotation);
            
            ctx.fillStyle = '#888';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#666';
            ctx.beginPath();
            ctx.moveTo(0, -asteroid.height/2);
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const radius = asteroid.width/2 * (0.8 + Math.random() * 0.4);
                ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        });

        // Enemies
        enemies.forEach(drawEnemy);

        // Bullets
        bullets.forEach(bullet => bullet.draw());

        // Player
        drawPlayer();

        // Wave progression
        if (score > wave * 2000) {
            wave++;
        }

        requestAnimationFrame(gameLoop);
    }

    function updateScore() {
        document.getElementById('score').textContent = `SCORE: ${score.toString().padStart(6, '0')}`;
    }

    function updateLives() {
        const hearts = '❤'.repeat(lives);
        document.getElementById('lives').textContent = `LIVES: ${hearts}`;
    }

    function gameOver() {
        gameActive = false;
        document.getElementById('finalScore').textContent = `Final Score: ${score.toString().padStart(6, '0')}`;
        document.getElementById('gameOver').style.display = 'block';
    }

    function restartGame() {
        score = 0;
        lives = 3;
        wave = 1;
        bullets = [];
        enemies = [];
        asteroids = [];
        particles = [];
        player.x = canvas.width / 2 - 30;
        updateScore();
        updateLives();
        document.getElementById('gameOver').style.display = 'none';
        gameActive = true;
        gameLoop();
    }

    function startGame() {
        document.getElementById('titleScreen').style.display = 'none';
        gameActive = true;
        updateScore();
        updateLives();
        gameLoop();
    }

    // Event listeners
    window.addEventListener('keydown', e => {
        keys[e.key] = true;
        if (e.key === ' ') e.preventDefault();
    });

    window.addEventListener('keyup', e => {
        keys[e.key] = false;
    });

    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        player.x = canvas.width / 2 - 30;
    });

    document.getElementById('startButton').addEventListener('click', startGame);

    // Start with title screen
    ctx.fillStyle = '#000814';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
</script>
</body>
</html>