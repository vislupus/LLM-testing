<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Space Shooter - Standalone</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at 20% 20%, #111827, #020617 65%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #e5e7eb;
    }
    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background:
        radial-gradient(circle at 15% 15%, rgba(96,165,250,0.18), transparent 55%),
        radial-gradient(circle at 80% 80%, rgba(236,72,153,0.22), transparent 60%),
        radial-gradient(circle at 50% 10%, rgba(56,189,248,0.12), transparent 55%),
        #000010;
    }
    #ui-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 12px 18px;
    }
    #hud-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      font-size: 14px;
      text-shadow: 0 0 8px rgba(0,0,0,0.8);
    }
    #score {
      font-weight: 600;
      letter-spacing: 0.06em;
    }
    #lives {
      font-weight: 500;
    }
    #hints {
      font-size: 12px;
      color: #9ca3af;
      text-shadow: 0 0 8px rgba(0,0,0,0.8);
    }
    #center-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    .message-box {
      padding: 18px 24px;
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.7);
      background: radial-gradient(circle at 0 0, rgba(59,130,246,0.35), transparent 55%),
                  rgba(15,23,42,0.94);
      box-shadow: 0 20px 45px rgba(0,0,0,0.85);
      text-align: center;
      min-width: 260px;
    }
    .message-title {
      font-size: 22px;
      font-weight: 700;
      margin-bottom: 6px;
    }
    .message-sub {
      font-size: 14px;
      color: #9ca3af;
      margin-bottom: 10px;
    }
    .message-key {
      display: inline-block;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.7);
      padding: 4px 8px;
      font-size: 12px;
      margin: 2px;
    }
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
<div id="game-container">
  <canvas id="game"></canvas>
  <div id="ui-overlay">
    <div id="hud-top">
      <div id="score">SCORE: 0</div>
      <div id="lives">LIVES: 3</div>
    </div>
    <div id="hints">
      Move: ← → or A / D &nbsp;·&nbsp;
      Vertical: ↑ ↓ or W / S &nbsp;·&nbsp;
      Shoot: SPACE / Click &nbsp;·&nbsp;
      Pause: P
    </div>
  </div>
  <div id="center-overlay">
    <div class="message-box" id="start-message">
      <div class="message-title">Stellar Run</div>
      <div class="message-sub">Pilot your ship through asteroid fields and alien waves.</div>
      <div>
        <span class="message-key">← → / A D</span>
        <span class="message-key">↑ ↓ / W S</span>
        <span class="message-key">SPACE / Click = Fire</span>
      </div>
      <div style="margin-top: 10px; font-size: 13px;">
        Press <span class="message-key">ENTER</span> to launch.
      </div>
    </div>

    <div class="message-box hidden" id="gameover-message">
      <div class="message-title" id="gameover-title">GAME OVER</div>
      <div class="message-sub" id="gameover-sub">You were lost in the nebula.</div>
      <div id="final-score" style="margin-top: 6px; font-size: 14px;"></div>
      <div style="margin-top: 10px; font-size: 13px;">
        Press <span class="message-key">ENTER</span> to try again.
      </div>
    </div>
  </div>
</div>

<script>
(function () {
  'use strict';

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let width = window.innerWidth;
  let height = window.innerHeight;

  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    const ratio = window.devicePixelRatio || 1;
    canvas.width = width * ratio;
    canvas.height = height * ratio;
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
  }
  resize();
  window.addEventListener('resize', resize);

  // GAME STATE
  const gameState = {
    running: false,
    paused: false,
    gameOver: false,
    score: 0,
    lives: 3,
    time: 0,
    lastSpawnAsteroid: 0,
    lastSpawnAlien: 0,
    asteroidInterval: 1.2,
    alienInterval: 3.0,
    bullets: [],
    enemies: [],
    asteroids: [],
    particles: [],
    stars: [],
    keys: {},
    shooting: false,
    lastShot: 0,
    shotCooldown: 0.22,
    player: null,
    invincibleUntil: 0
  };

  // STARFIELD
  function createStars(count) {
    gameState.stars = [];
    for (let i = 0; i < count; i++) {
      gameState.stars.push({
        x: Math.random() * width,
        y: Math.random() * height,
        speed: 20 + Math.random() * 80,
        radius: 0.5 + Math.random() * 1.5,
        alpha: 0.3 + Math.random() * 0.7,
      });
    }
  }
  createStars(200);

  function updateStars(dt) {
    for (let s of gameState.stars) {
      s.y += s.speed * dt;
      if (s.y > height) {
        s.y = -5;
        s.x = Math.random() * width;
        s.speed = 20 + Math.random() * 80;
        s.radius = 0.5 + Math.random() * 1.5;
        s.alpha = 0.3 + Math.random() * 0.7;
      }
    }
  }

  function drawStars() {
    ctx.save();
    ctx.fillStyle = '#020617';
    ctx.fillRect(0, 0, width, height);
    for (let s of gameState.stars) {
      ctx.beginPath();
      ctx.fillStyle = 'rgba(148, 163, 184,' + s.alpha + ')';
      ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  // PLAYER
  class Player {
    constructor() {
      this.reset();
    }
    reset() {
      this.x = width * 0.5;
      this.y = height * 0.78;
      this.radius = 18;
      this.speed = 320;
      this.color = '#38bdf8';
      this.thrustTimer = 0;
    }
    update(dt) {
      let dx = 0;
      let dy = 0;
      const k = gameState.keys;
      if (k['ArrowLeft'] || k['a']) dx -= 1;
      if (k['ArrowRight'] || k['d']) dx += 1;
      if (k['ArrowUp'] || k['w']) dy -= 1;
      if (k['ArrowDown'] || k['s']) dy += 1;
      const len = Math.hypot(dx, dy);
      if (len > 0) {
        dx /= len;
        dy /= len;
      }
      this.x += dx * this.speed * dt;
      this.y += dy * this.speed * dt;

      const margin = this.radius + 6;
      if (this.x < margin) this.x = margin;
      if (this.x > width - margin) this.x = width - margin;
      if (this.y < height * 0.35) this.y = height * 0.35;
      if (this.y > height - margin) this.y = height - margin;

      // Thruster particles
      this.thrustTimer += dt;
      if (len > 0 && this.thrustTimer > 0.03) {
        this.spawnThruster(dx, dy);
        this.thrustTimer = 0;
      }
    }
    spawnThruster(dx, dy) {
      const baseAngle = Math.atan2(dy, dx) + Math.PI;
      const spread = 0.7;
      const angle = baseAngle + (Math.random() - 0.5) * spread;
      const speed = 80 + Math.random() * 80;
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      const px = this.x - Math.cos(baseAngle) * this.radius * 0.7;
      const py = this.y - Math.sin(baseAngle) * this.radius * 0.7;
      spawnParticle(px, py, vx, vy, 0.4, 2.4, ['#1d4ed8', '#22d3ee', '#0ea5e9']);
    }
    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      const invincible = gameState.time < gameState.invincibleUntil;
      if (invincible) {
        const blink = Math.sin(gameState.time * 30) > 0 ? 1 : 0.35;
        ctx.globalAlpha = blink;
      }

      // Ship glow
      ctx.shadowColor = '#38bdf8';
      ctx.shadowBlur = 18;

      // Body
      ctx.beginPath();
      ctx.moveTo(0, -this.radius * 1.1);
      ctx.lineTo(this.radius * 0.8, this.radius * 1.0);
      ctx.lineTo(0, this.radius * 0.4);
      ctx.lineTo(-this.radius * 0.8, this.radius * 1.0);
      ctx.closePath();
      const grad = ctx.createLinearGradient(0, -this.radius, 0, this.radius);
      grad.addColorStop(0, '#e5f2ff');
      grad.addColorStop(0.5, this.color);
      grad.addColorStop(1, '#0f172a');
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#0ea5e9';
      ctx.stroke();

      // Cockpit
      ctx.beginPath();
      ctx.ellipse(0, -this.radius * 0.3, this.radius * 0.35, this.radius * 0.45, 0, 0, Math.PI * 2);
      const cg = ctx.createRadialGradient(0, -this.radius * 0.4, 2, 0, -this.radius * 0.2, this.radius * 0.6);
      cg.addColorStop(0, 'rgba(248, 250, 252, 0.95)');
      cg.addColorStop(1, 'rgba(59, 130, 246, 0.3)');
      ctx.fillStyle = cg;
      ctx.fill();

      ctx.restore();
    }
  }

  gameState.player = new Player();

  // BULLETS
  function spawnBullet() {
    const now = gameState.time;
    if (now - gameState.lastShot < gameState.shotCooldown) return;
    gameState.lastShot = now;
    const p = gameState.player;
    const speed = 600;
    gameState.bullets.push({
      x: p.x,
      y: p.y - p.radius * 1.1,
      vx: 0,
      vy: -speed,
      radius: 3.5,
      life: 1.5
    });
    // muzzle flash particles
    spawnParticle(p.x, p.y - p.radius * 1.2, 0, -40, 0.2, 1.4, ['#e5f2ff', '#f97316', '#fde047']);
    spawnParticle(p.x, p.y - p.radius * 1.4, 0, -80, 0.2, 1.8, ['#e5f2ff', '#f97316', '#fdba74']);
  }

  function updateBullets(dt) {
    for (let i = gameState.bullets.length - 1; i >= 0; i--) {
      const b = gameState.bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life -= dt;
      if (b.y < -40 || b.life <= 0) {
        gameState.bullets.splice(i, 1);
      }
    }
  }

  function drawBullets() {
    ctx.save();
    ctx.shadowColor = '#e5f2ff';
    ctx.shadowBlur = 18;
    for (let b of gameState.bullets) {
      const grad = ctx.createLinearGradient(b.x, b.y + 10, b.x, b.y - 10);
      grad.addColorStop(0, 'rgba(56,189,248,0)');
      grad.addColorStop(0.4, '#38bdf8');
      grad.addColorStop(1, '#e5f2ff');
      ctx.strokeStyle = grad;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(b.x, b.y + 6);
      ctx.lineTo(b.x, b.y - 12);
      ctx.stroke();
    }
    ctx.restore();
  }

  // PARTICLES
  function spawnParticle(x, y, vx, vy, life, size, colors) {
    const color = colors[Math.floor(Math.random() * colors.length)];
    gameState.particles.push({
      x, y, vx, vy,
      life,
      maxLife: life,
      size,
      color
    });
  }

  function spawnExplosion(x, y, colorSet, count, power) {
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = (Math.random() * 1 + 0.5) * power;
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      const life = 0.5 + Math.random() * 0.6;
      const size = 2 + Math.random() * 3;
      spawnParticle(x, y, vx, vy, life, size, colorSet);
    }
  }

  function updateParticles(dt) {
    for (let i = gameState.particles.length - 1; i >= 0; i--) {
      const p = gameState.particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt;
      p.vx *= 0.98;
      p.vy *= 0.98;
      if (p.life <= 0) {
        gameState.particles.splice(i, 1);
      }
    }
  }

  function drawParticles() {
    ctx.save();
    for (let p of gameState.particles) {
      const t = p.life / p.maxLife;
      ctx.globalAlpha = Math.max(t, 0);
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 12 * t + 6;
      ctx.beginPath();
      ctx.fillStyle = p.color;
      ctx.arc(p.x, p.y, p.size * t + 0.7, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  // ASTEROIDS & ALIENS
  function spawnAsteroid() {
    const radius = 18 + Math.random() * 26;
    const x = Math.random() * width;
    const y = -radius - 20;
    const speed = 60 + Math.random() * 80;
    const drift = (Math.random() - 0.5) * 40;
    const spin = (Math.random() - 0.5) * 2;
    const sides = 7 + (Math.random() * 3 | 0);
    const verts = [];
    for (let i = 0; i < sides; i++) {
      const a = (i / sides) * Math.PI * 2;
      const r = radius * (0.7 + Math.random() * 0.4);
      verts.push({ angle: a, radius: r });
    }
    gameState.asteroids.push({
      x, y,
      vx: drift,
      vy: speed,
      radius,
      verts,
      rot: 0,
      spin,
      type: 'asteroid',
      hp: 3,
      maxHp: 3
    });
  }

  function spawnAlien() {
    const x = 60 + Math.random() * (width - 120);
    const y = -40;
    const speed = 80 + Math.random() * 60;
    const drift = (Math.random() - 0.5) * 40;
    gameState.enemies.push({
      x, y,
      vx: drift,
      vy: speed,
      radius: 16,
      phase: Math.random() * Math.PI * 2,
      fireTimer: 0.6 + Math.random() * 0.8,
      hp: 4,
      maxHp: 4
    });
  }

  function updateAsteroids(dt) {
    for (let i = gameState.asteroids.length - 1; i >= 0; i--) {
      const a = gameState.asteroids[i];
      a.x += a.vx * dt;
      a.y += a.vy * dt;
      a.rot += a.spin * dt;
      if (a.y - a.radius > height + 80) {
        gameState.asteroids.splice(i, 1);
      }
    }
  }

  function drawAsteroids() {
    ctx.save();
    for (let a of gameState.asteroids) {
      ctx.save();
      ctx.translate(a.x, a.y);
      ctx.rotate(a.rot);
      ctx.shadowColor = '#6b7280';
      ctx.shadowBlur = 12;
      ctx.beginPath();
      for (let i = 0; i < a.verts.length; i++) {
        const v = a.verts[i];
        const x = Math.cos(v.angle) * v.radius;
        const y = Math.sin(v.angle) * v.radius;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      const g = ctx.createLinearGradient(-a.radius, -a.radius, a.radius, a.radius);
      g.addColorStop(0, '#4b5563');
      g.addColorStop(0.5, '#9ca3af');
      g.addColorStop(1, '#111827');
      ctx.fillStyle = g;
      ctx.fill();
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(15,23,42,0.8)';
      ctx.stroke();
      ctx.restore();
    }
    ctx.restore();
  }

  function updateEnemies(dt) {
    const player = gameState.player;
    for (let i = gameState.enemies.length - 1; i >= 0; i--) {
      const e = gameState.enemies[i];
      e.y += e.vy * dt;
      e.x += e.vx * dt;
      e.phase += dt;
      e.x += Math.cos(e.phase * 2) * 20 * dt;
      e.fireTimer -= dt;
      if (e.fireTimer <= 0 && gameState.running && !gameState.paused) {
        e.fireTimer = 0.8 + Math.random() * 0.9;
        // enemy bullet
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const L = Math.hypot(dx, dy) || 1;
        const speed = 280;
        const vx = (dx / L) * speed;
        const vy = (dy / L) * speed;
        gameState.bullets.push({
          x: e.x,
          y: e.y + 12,
          vx,
          vy,
          radius: 4,
          life: 3,
          enemy: true
        });
        spawnParticle(e.x, e.y + 12, 0, 40, 0.25, 2, ['#f97316', '#fb923c', '#fed7aa']);
      }

      if (e.y - e.radius > height + 80 || e.x < -80 || e.x > width + 80) {
        gameState.enemies.splice(i, 1);
      }
    }
  }

  function drawEnemies() {
    ctx.save();
    for (let e of gameState.enemies) {
      ctx.save();
      ctx.translate(e.x, e.y);

      // Glow
      ctx.shadowColor = '#f97316';
      ctx.shadowBlur = 16;

      // Saucer base
      ctx.beginPath();
      ctx.ellipse(0, 10, 24, 10, 0, 0, Math.PI * 2);
      let g = ctx.createLinearGradient(-24, 10, 24, 10);
      g.addColorStop(0, '#030712');
      g.addColorStop(0.5, '#f97316');
      g.addColorStop(1, '#030712');
      ctx.fillStyle = g;
      ctx.fill();

      // Dome
      ctx.beginPath();
      ctx.ellipse(0, 0, 14, 10, 0, Math.PI, 0);
      const dg = ctx.createRadialGradient(0, -4, 2, 0, 0, 14);
      dg.addColorStop(0, '#fee2e2');
      dg.addColorStop(1, 'rgba(248,113,113,0.3)');
      ctx.fillStyle = dg;
      ctx.fill();

      // Lights
      for (let i = -2; i <= 2; i++) {
        ctx.beginPath();
        ctx.arc(i * 8, 12, 2, 0, Math.PI * 2);
        ctx.fillStyle = i % 2 === 0 ? '#facc15' : '#22c55e';
        ctx.fill();
      }

      ctx.restore();
    }
    ctx.restore();
  }

  // COLLISIONS / DAMAGE
  function circleHit(a, b, padding) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    const r = (a.radius || 0) + (b.radius || 0) + (padding || 0);
    return dx * dx + dy * dy < r * r;
  }

  function handleBulletHits() {
    const player = gameState.player;

    // Player bullets vs asteroids/enemies
    for (let i = gameState.bullets.length - 1; i >= 0; i--) {
      const b = gameState.bullets[i];
      if (b.enemy) continue;
      let hit = false;

      // vs asteroids
      for (let j = gameState.asteroids.length - 1; j >= 0; j--) {
        const a = gameState.asteroids[j];
        if (circleHit(b, a, -6)) {
          hit = true;
          a.hp -= 1;
          spawnExplosion(b.x, b.y, ['#fbbf24', '#f97316', '#fed7aa'], 8, 200);
          if (a.hp <= 0) {
            const scoreGain = 20;
            gameState.score += scoreGain;
            spawnExplosion(a.x, a.y, ['#f97316', '#facc15', '#fed7aa', '#fef3c7'], 30, 260);
            gameState.asteroids.splice(j, 1);
          }
          break;
        }
      }
      if (hit) {
        gameState.bullets.splice(i, 1);
        continue;
      }

      // vs aliens
      for (let j = gameState.enemies.length - 1; j >= 0; j--) {
        const e = gameState.enemies[j];
        if (circleHit(b, e, -4)) {
          hit = true;
          e.hp -= 1;
          spawnExplosion(b.x, b.y, ['#a5b4fc', '#f97316', '#22d3ee'], 10, 260);
          if (e.hp <= 0) {
            const scoreGain = 50;
            gameState.score += scoreGain;
            spawnExplosion(e.x, e.y, ['#f97316', '#fb7185', '#facc15', '#4ade80'], 36, 300);
            gameState.enemies.splice(j, 1);
          }
          break;
        }
      }
      if (hit) {
        gameState.bullets.splice(i, 1);
      }
    }

    // Enemy bullets vs player
    for (let i = gameState.bullets.length - 1; i >= 0; i--) {
      const b = gameState.bullets[i];
      if (!b.enemy) continue;
      if (circleHit(b, player, -4)) {
        gameState.bullets.splice(i, 1);
        damagePlayer();
      }
    }

    // Asteroids / Enemies vs player
    if (gameState.time >= gameState.invincibleUntil) {
      for (let a of gameState.asteroids) {
        if (circleHit(a, player, -6)) {
          damagePlayer();
          break;
        }
      }
      for (let e of gameState.enemies) {
        if (circleHit(e, player, -4)) {
          damagePlayer();
          break;
        }
      }
    }
  }

  function damagePlayer() {
    if (gameState.time < gameState.invincibleUntil) return;
    gameState.lives -= 1;
    document.getElementById('lives').textContent = 'LIVES: ' + gameState.lives;
    const p = gameState.player;
    spawnExplosion(p.x, p.y, ['#f97316', '#fb7185', '#fecaca', '#facc15'], 40, 280);
    gameState.invincibleUntil = gameState.time + 2.2;
    if (gameState.lives <= 0) {
      endGame();
    }
  }

  // SPAWNING / DIFFICULTY
  function updateSpawns(dt) {
    const t = gameState.time;
    if (t - gameState.lastSpawnAsteroid > gameState.asteroidInterval) {
      gameState.lastSpawnAsteroid = t;
      spawnAsteroid();
      if (gameState.asteroidInterval > 0.6) {
        gameState.asteroidInterval -= 0.005;
      }
    }
    if (t - gameState.lastSpawnAlien > gameState.alienInterval) {
      gameState.lastSpawnAlien = t;
      spawnAlien();
      if (gameState.alienInterval > 1.5) {
        gameState.alienInterval -= 0.01;
      }
    }
  }

  // INPUT
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') e.preventDefault();
    if (e.code === 'ArrowUp' || e.code === 'ArrowDown') e.preventDefault();
    gameState.keys[e.key] = true;

    if (e.key === ' ' || e.code === 'Space') {
      gameState.shooting = true;
    }
    if (e.key === 'p' || e.key === 'P') {
      if (gameState.running && !gameState.gameOver) {
        gameState.paused = !gameState.paused;
      }
    }
    if (e.key === 'Enter') {
      if (!gameState.running || gameState.gameOver) {
        startGame();
      }
    }
  });

  window.addEventListener('keyup', (e) => {
    gameState.keys[e.key] = false;
    if (e.key === ' ' || e.code === 'Space') {
      gameState.shooting = false;
    }
  });

  // Mouse / touch to shoot
  canvas.addEventListener('pointerdown', () => {
    gameState.shooting = true;
  });
  canvas.addEventListener('pointerup', () => {
    gameState.shooting = false;
  });
  canvas.addEventListener('pointerleave', () => {
    gameState.shooting = false;
  });

  // START / GAME OVER
  const startMessage = document.getElementById('start-message');
  const gameoverMessage = document.getElementById('gameover-message');
  const gameoverTitle = document.getElementById('gameover-title');
  const gameoverSub = document.getElementById('gameover-sub');
  const finalScore = document.getElementById('final-score');

  function startGame() {
    gameState.running = true;
    gameState.gameOver = false;
    gameState.paused = false;
    gameState.score = 0;
    gameState.lives = 3;
    gameState.time = 0;
    gameState.lastSpawnAlien = 0;
    gameState.lastSpawnAsteroid = 0;
    gameState.asteroidInterval = 1.1;
    gameState.alienInterval = 2.6;
    gameState.bullets = [];
    gameState.enemies = [];
    gameState.asteroids = [];
    gameState.particles = [];
    gameState.player.reset();
    gameState.invincibleUntil = gameState.time + 2.5;
    document.getElementById('score').textContent = 'SCORE: 0';
    document.getElementById('lives').textContent = 'LIVES: 3';
    startMessage.classList.add('hidden');
    gameoverMessage.classList.add('hidden');
  }

  function endGame() {
    gameState.gameOver = true;
    gameState.running = false;
    gameState.paused = false;
    gameState.shooting = false;
    finalScore.textContent = 'Final score: ' + Math.round(gameState.score);
    gameoverTitle.textContent = 'GAME OVER';
    gameoverSub.textContent = 'Your ship was torn apart in the asteroid storm.';
    gameoverMessage.classList.remove('hidden');
  }

  // MAIN LOOP
  let lastTimestamp = 0;

  function loop(timestamp) {
    requestAnimationFrame(loop);
    if (!lastTimestamp) lastTimestamp = timestamp;
    let dt = (timestamp - lastTimestamp) / 1000;
    if (dt > 0.08) dt = 0.08;
    lastTimestamp = timestamp;

    if (!gameState.running || gameState.paused) {
      drawFrame(dt, false);
      return;
    }

    gameState.time += dt;
    update(dt);
    drawFrame(dt, true);
  }

  function update(dt) {
    const player = gameState.player;

    updateStars(dt);
    player.update(dt);

    if (gameState.shooting) {
      spawnBullet();
    }

    updateBullets(dt);
    updateAsteroids(dt);
    updateEnemies(dt);
    updateParticles(dt);
    updateSpawns(dt);
    handleBulletHits();

    document.getElementById('score').textContent = 'SCORE: ' + Math.round(gameState.score);
  }

  function drawFrame(dt, active) {
    drawStars();

    // Trails overlay
    ctx.save();
    ctx.fillStyle = 'rgba(15,23,42,0.32)';
    ctx.fillRect(0, 0, width, height);
    ctx.restore();

    drawAsteroids();
    drawEnemies();
    drawParticles();
    gameState.player.draw();
    drawBullets();

    // HUD glow at top (subtle)
    ctx.save();
    const g = ctx.createLinearGradient(0, 0, 0, 120);
    g.addColorStop(0, 'rgba(30,64,175,0.35)');
    g.addColorStop(1, 'rgba(15,23,42,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, width, 120);
    ctx.restore();
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
