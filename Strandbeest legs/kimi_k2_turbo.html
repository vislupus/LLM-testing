<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strandbeest Evolution Demo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            color: #e0f7fa;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100vh;
            touch-action: none;
        }
        
        #controls {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(25, 118, 210, 0.15);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 280px;
            color: #e0f7fa;
        }
        
        #controls h3 {
            margin-top: 0;
            color: #4fc3f7;
            border-bottom: 1px solid rgba(79, 195, 247, 0.3);
            padding-bottom: 10px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: inline-block;
            width: 150px;
            font-size: 14px;
            color: #bbdefb;
        }
        
        input[type="range"], input[type="number"] {
            width: 100px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            height: 6px;
            border: none;
        }
        
        input[type="number"] {
            height: auto;
            padding: 5px;
            width: 60px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e0f7fa;
            border-radius: 4px;
        }
        
        button {
            background: linear-gradient(to right, #2196F3, #21CBF3);
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
            width: 100%;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        button:disabled {
            background: linear-gradient(to right, #546e7a, #78909c);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .status {
            margin-top: 15px;
            font-size: 13px;
            color: #bbdefb;
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 8px;
        }
        
        .status div {
            margin: 5px 0;
        }
        
        .value-display {
            color: #4fc3f7;
            font-weight: 600;
        }
        
        #info {
            position: absolute;
            bottom: 15px;
            left: 15px;
            color: #bbdefb;
            background: rgba(25, 118, 210, 0.15);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 16px;
            font-size: 13px;
            max-width: 300px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        #info p {
            margin: 8px 0;
        }
        
        #info strong {
            color: #4fc3f7;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.8);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.8);
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <div id="controls">
        <h3>Evolution Controls</h3>
        
        <div class="control-group">
            <button id="startBtn" onclick="toggleEvolution()">Start Evolution</button>
            <button id="resetBtn" onclick="resetEvolution()">Reset</button>
            <button id="bestBtn" onclick="showBestIndividual()">Show Best</button>
        </div>
        
        <div class="control-group">
            <label>Population Size:</label>
            <input type="number" id="popSize" value="20" min="5" max="50" onchange="updatePopSize()">
        </div>
        
        <div class="control-group">
            <label>Mutation Rate:</label>
            <input type="range" id="mutationRate" min="0" max="0.5" step="0.01" value="0.1">
            <span id="mutationValue" class="value-display">0.1</span>
        </div>
        
        <div class="control-group">
            <label>Cycle Duration:</label>
            <input type="range" id="cycleDuration" min="1" max="10" step="0.5" value="3">
            <span id="cycleValue" class="value-display">3s</span>
        </div>
        
        <div class="status">
            <div>Generation: <span id="genCount" class="value-display">0</span></div>
            <div>Best Fitness: <span id="bestFitness" class="value-display">0</span></div>
            <div>Evaluating: <span id="currentEval" class="value-display">0</span>/<span id="totalPop" class="value-display">20</span></div>
            <div>Legs per Creature: <span id="legCount" class="value-display">4</span></div>
            <div>Joints per Leg: <span id="jointCount" class="value-display">4</span></div>
        </div>
    </div>
    
    <div id="info">
        <p><strong>Strandbeest Evolution Demo</strong></p>
        <p>Watch as creatures evolve better walking mechanisms!</p>
        <p>Each creature has 4 legs with 4 joints each, creating complex walking patterns.</p>
        <p>Fitness = Forward distance - Height instability penalty</p>
    </div>

    <script>
        // Global variables
        let canvas, engine, scene, camera, ground;
        let population = [];
        let currentIndividual = 0;
        let generation = 0;
        let bestFitness = 0;
        let bestIndividual = null;
        let isEvolving = false;
        let evaluationStartTime = 0;
        let cycleTime = 0;
        let currentCreature = null;
        let evaluationTimeout = null;
        
        // Genetic algorithm parameters
        let POPULATION_SIZE = 20;
        let MUTATION_RATE = 0.1;
        let CYCLE_DURATION = 3000; // in milliseconds
        const LEG_COUNT = 4;
        const JOINTS_PER_LEG = 4;
        const GENES_PER_LEG = JOINTS_PER_LEG * 2; // length and angle for each joint
        
        // Creature parameters
        const BODY_WIDTH = 2;
        const BODY_HEIGHT = 0.5;
        const BODY_DEPTH = 1;
        const INITIAL_BODY_Y = 2;
        
        // Initialize Babylon.js
        function initBabylon() {
            canvas = document.getElementById("renderCanvas");
            engine = new BABYLON.Engine(canvas, true);
            
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.05, 0.05, 0.1);
            
            // Camera
            camera = new BABYLON.ArcRotateCamera("camera", 
                Math.PI / 4, Math.PI / 3, 15, 
                new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 5;
            camera.upperRadiusLimit = 30;
            
            // Lights
            const light1 = new BABYLON.HemisphericLight("light1", 
                new BABYLON.Vector3(0, 1, 0), scene);
            light1.intensity = 0.7;
            
            const light2 = new BABYLON.DirectionalLight("light2", 
                new BABYLON.Vector3(-1, -2, 1), scene);
            light2.position = new BABYLON.Vector3(20, 40, 20);
            light2.intensity = 0.5;
            
            // Ground
            ground = BABYLON.MeshBuilder.CreateGround("ground", 
                {width: 50, height: 50}, scene);
            const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            groundMat.specularColor = new BABYLON.Color3(0, 0, 0);
            ground.material = groundMat;
            
            // Grid texture for ground
            const groundTexture = new BABYLON.DynamicTexture("groundTexture", 
                {width: 512, height: 512}, scene);
            const groundContext = groundTexture.getContext();
            groundContext.fillStyle = "#333333";
            groundContext.fillRect(0, 0, 512, 512);
            groundContext.strokeStyle = "#555555";
            groundContext.lineWidth = 2;
            for(let i = 0; i <= 512; i += 32) {
                groundContext.beginPath();
                groundContext.moveTo(i, 0);
                groundContext.lineTo(i, 512);
                groundContext.stroke();
                groundContext.beginPath();
                groundContext.moveTo(0, i);
                groundContext.lineTo(512, i);
                groundContext.stroke();
            }
            groundTexture.update();
            groundMat.diffuseTexture = groundTexture;
            
            engine.runRenderLoop(() => {
                scene.render();
            });
            
            window.addEventListener("resize", () => {
                engine.resize();
            });
        }
        
        // Initialize population
        function initPopulation() {
            population = [];
            for(let i = 0; i < POPULATION_SIZE; i++) {
                const genome = [];
                // Each leg has JOINTS_PER_LEG segments with length and angle
                for(let leg = 0; leg < LEG_COUNT; leg++) {
                    for(let joint = 0; joint < JOINTS_PER_LEG; joint++) {
                        // Segment length (0.5 to 2.0)
                        genome.push(Math.random() * 1.5 + 0.5);
                        // Joint angle range (-π/3 to π/3)
                        genome.push((Math.random() - 0.5) * 2 * Math.PI / 3);
                    }
                    // Phase offset for this leg (0 to 2π)
                    genome.push(Math.random() * 2 * Math.PI);
                }
                // Global walking parameters
                genome.push(Math.random() * 0.5 + 0.5); // stride length factor
                genome.push(Math.random() * 0.5 + 0.5); // walking speed factor
                
                population.push({
                    genome: genome,
                    fitness: 0,
                    distance: 0,
                    stability: 0
                });
            }
            updateStatus();
        }
        
        // Creature class
        class Creature {
            constructor(genome) {
                this.genome = genome;
                this.body = null;
                this.legs = [];
                this.joints = [];
                this.initialPos = new BABYLON.Vector3(0, INITIAL_BODY_Y, 0);
                this.startTime = Date.now();
                this.bodyMaterial = null;
                this.legMaterial = null;
                this.jointMaterial = null;
                
                this.createMesh();
            }
            
            createMesh() {
                // Body
                this.body = BABYLON.MeshBuilder.CreateBox("body", 
                    {width: BODY_WIDTH, height: BODY_HEIGHT, depth: BODY_DEPTH}, scene);
                this.body.position = this.initialPos.clone();
                
                // Materials
                this.bodyMaterial = new BABYLON.StandardMaterial("bodyMat", scene);
                this.bodyMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.6, 1);
                this.bodyMaterial.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                this.body.material = this.bodyMaterial;
                
                this.legMaterial = new BABYLON.StandardMaterial("legMat", scene);
                this.legMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8);
                this.legMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                
                this.jointMaterial = new BABYLON.StandardMaterial("jointMat", scene);
                this.jointMaterial.diffuseColor = new BABYLON.Color3(1, 0.5, 0.2);
                this.jointMaterial.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                
                // Create legs
                this.createLegs();
            }
            
            createLegs() {
                const geneIndexBase = 0;
                const globalParamsIndex = GENES_PER_LEG * LEG_COUNT + LEG_COUNT; // +1 for each leg's phase
                
                for(let leg = 0; leg < LEG_COUNT; leg++) {
                    const legGroup = {
                        segments: [],
                        joints: [],
                        phaseOffset: this.genome[geneIndexBase + leg * (GENES_PER_LEG + 1) + GENES_PER_LEG],
                        footPosition: new BABYLON.Vector3(0, 0, 0)
                    };
                    
                    // Position legs around body
                    const angle = (leg / LEG_COUNT) * Math.PI * 2;
                    const legX = Math.cos(angle) * (BODY_WIDTH / 2 + 0.2);
                    const legZ = Math.sin(angle) * (BODY_DEPTH / 2 + 0.2);
                    
                    let previousMesh = this.body;
                    let previousPos = new BABYLON.Vector3(legX, -BODY_HEIGHT / 2, legZ);
                    
                    // Create leg segments
                    for(let joint = 0; joint < JOINTS_PER_LEG; joint++) {
                        const geneIndex = geneIndexBase + leg * (GENES_PER_LEG + 1) + joint * 2;
                        const length = this.genome[geneIndex];
                        const baseAngle = this.genome[geneIndex + 1];
                        
                        // Create segment
                        const segment = BABYLON.MeshBuilder.CreateCylinder("segment", 
                            {height: length, diameter: 0.1}, scene);
                        segment.material = this.legMaterial;
                        
                        // Position segment
                        const segmentPos = previousPos.clone();
                        segmentPos.y -= length / 2;
                        segment.position = segmentPos.add(this.initialPos);
                        
                        // Store segment data
                        legGroup.segments.push({
                            mesh: segment,
                            length: length,
                            baseAngle: baseAngle,
                            relativePos: segmentPos
                        });
                        
                        // Create joint
                        const jointMesh = BABYLON.MeshBuilder.CreateSphere("joint", 
                            {diameter: 0.15}, scene);
                        jointMesh.material = this.jointMaterial;
                        jointMesh.position = segmentPos.clone().add(this.initialPos);
                        legGroup.joints.push(jointMesh);
                        
                        previousPos = segmentPos.clone();
                        previousPos.y -= length / 2;
                        previousMesh = segment;
                    }
                    
                    // Foot marker
                    const footMarker = BABYLON.MeshBuilder.CreateSphere("foot", 
                        {diameter: 0.2}, scene);
                    footMarker.material = this.jointMaterial;
                    footMarker.position = previousPos.add(this.initialPos);
                    legGroup.foot = footMarker;
                    legGroup.footPosition = previousPos.clone();
                    
                    this.legs.push(legGroup);
                }
                
                this.strideFactor = this.genome[globalParamsIndex];
                this.speedFactor = this.genome[globalParamsIndex + 1];
            }
            
            update(elapsedTime) {
                const cycleProgress = (elapsedTime % CYCLE_DURATION) / CYCLE_DURATION;
                const bodyPos = this.initialPos.clone();
                const footPositions = [];
                
                // Update each leg
                for(let leg = 0; leg < LEG_COUNT; leg++) {
                    const legGroup = this.legs[leg];
                    const legPhase = (cycleProgress * 2 * Math.PI + legGroup.phaseOffset) % (2 * Math.PI);
                    
                    let previousPos = new BABYLON.Vector3(
                        Math.cos((leg / LEG_COUNT) * Math.PI * 2) * (BODY_WIDTH / 2 + 0.2),
                        -BODY_HEIGHT / 2,
                        Math.sin((leg / LEG_COUNT) * Math.PI * 2) * (BODY_DEPTH / 2 + 0.2)
                    );
                    
                    let currentAngle = 0;
                    const legFootPositions = [];
                    
                    // Forward kinematics for each segment
                    for(let joint = 0; joint < JOINTS_PER_LEG; joint++) {
                        const segment = legGroup.segments[joint];
                        const jointAngle = segment.baseAngle + 
                            Math.sin(legPhase + joint * Math.PI / JOINTS_PER_LEG) * 
                            (Math.PI / 4) * this.strideFactor;
                        
                        currentAngle += jointAngle;
                        
                        // Update segment position and rotation
                        const segmentLength = segment.length;
                        const endX = previousPos.x + Math.sin(currentAngle) * segmentLength;
                        const endY = previousPos.y - Math.cos(currentAngle) * segmentLength;
                        const endZ = previousPos.z + Math.sin(legPhase * 0.5) * 0.2; // Side-to-side motion
                        
                        segment.mesh.position = new BABYLON.Vector3(
                            (previousPos.x + endX) / 2,
                            (previousPos.y + endY) / 2,
                            (previousPos.z + endZ) / 2
                        ).add(bodyPos);
                        
                        segment.mesh.rotation.z = -currentAngle;
                        segment.mesh.rotation.x = Math.sin(legPhase * 0.5) * 0.3;
                        
                        // Update joint position
                        if(joint < legGroup.joints.length) {
                            legGroup.joints[joint].position = previousPos.add(bodyPos);
                        }
                        
                        legFootPositions.push(new BABYLON.Vector3(endX, endY, endZ));
                        previousPos = new BABYLON.Vector3(endX, endY, endZ);
                    }
                    
                    // Update foot position
                    const finalFootPos = previousPos;
                    legGroup.foot.position = finalFootPos.add(bodyPos);
                    legGroup.footPosition = finalFootPos;
                    footPositions.push(finalFootPos);
                    
                    // Ground constraint
                    const minFootY = Math.min(...footPositions.map(p => p.y));
                    if(minFootY < 0) {
                        bodyPos.y -= minFootY * 0.5; // Lift body if feet are too low
                    }
                }
                
                // Maintain minimum body height
                bodyPos.y = Math.max(bodyPos.y, INITIAL_BODY_Y - 0.5);
                
                // Update body position
                this.body.position = bodyPos;
                
                return {
                    position: bodyPos,
                    footPositions: footPositions,
                    stability: this.calculateStability(footPositions, bodyPos)
                };
            }
            
            calculateStability(footPositions, bodyPos) {
                // Calculate height variance as instability measure
                const avgHeight = footPositions.reduce((sum, pos) => sum + pos.y, 0) / footPositions.length;
                const heightVariance = footPositions.reduce((sum, pos) => 
                    sum + Math.pow(pos.y - avgHeight, 2), 0) / footPositions.length;
                
                // Calculate body tilt
                const tiltX = Math.abs(bodyPos.x - this.initialPos.x);
                const tiltZ = Math.abs(bodyPos.z - this.initialPos.z);
                
                return heightVariance + tiltX + tiltZ;
            }
            
            dispose() {
                if(this.body) this.body.dispose();
                this.legs.forEach(legGroup => {
                    legGroup.segments.forEach(s => s.mesh.dispose());
                    legGroup.joints.forEach(j => j.dispose());
                    if(legGroup.foot) legGroup.foot.dispose();
                });
                if(this.bodyMaterial) this.bodyMaterial.dispose();
                if(this.legMaterial) this.legMaterial.dispose();
                if(this.jointMaterial) this.jointMaterial.dispose();
            }
        }
        
        // Genetic algorithm functions
        function evaluateCurrentIndividual() {
            if(currentCreature) {
                currentCreature.dispose();
            }
            
            const individual = population[currentIndividual];
            currentCreature = new Creature(individual.genome);
            
            evaluationStartTime = Date.now();
            cycleTime = 0;
            
            // Animate for CYCLE_DURATION
            const animate = () => {
                if(!isEvolving) return;
                
                const elapsed = Date.now() - evaluationStartTime;
                cycleTime = elapsed;
                
                if(elapsed < CYCLE_DURATION) {
                    const result = currentCreature.update(elapsed);
                    
                    // Calculate fitness in real-time
                    const distance = result.position.x - currentCreature.initialPos.x;
                    const speed = distance / (elapsed / 1000); // distance per second
                    const stabilityPenalty = result.stability * 0.1;
                    
                    // Update fitness with current values
                    individual.distance = distance;
                    individual.stability = result.stability;
                    individual.fitness = Math.max(0, distance * 10 + speed * 2 - stabilityPenalty);
                    
                    evaluationTimeout = requestAnimationFrame(animate);
                } else {
                    // Final evaluation
                    const result = currentCreature.update(CYCLE_DURATION);
                    const distance = result.position.x - currentCreature.initialPos.x;
                    const speed = distance / (CYCLE_DURATION / 1000);
                    const stabilityPenalty = result.stability * 0.1;
                    
                    individual.distance = distance;
                    individual.stability = result.stability;
                    individual.fitness = Math.max(0, distance * 10 + speed * 2 - stabilityPenalty);
                    
                    // Update best individual
                    if(individual.fitness > bestFitness) {
                        bestFitness = individual.fitness;
                        bestIndividual = JSON.parse(JSON.stringify(individual));
                    }
                    
                    updateStatus();
                    
                    // Move to next individual
                    currentIndividual++;
                    if(currentIndividual >= POPULATION_SIZE) {
                        // Generation complete
                        nextGeneration();
                    } else {
                        setTimeout(() => evaluateCurrentIndividual(), 100);
                    }
                }
            };
            
            animate();
        }
        
        function nextGeneration() {
            // Sort by fitness
            population.sort((a, b) => b.fitness - a.fitness);
            
            // Create new population
            const newPopulation = [];
            
            // Keep best individual (elitism)
            newPopulation.push(JSON.parse(JSON.stringify(population[0])));
            
            // Generate new individuals
            while(newPopulation.length < POPULATION_SIZE) {
                const parent1 = selectParent();
                const parent2 = selectParent();
                const child = crossover(parent1, parent2);
                mutate(child);
                newPopulation.push(child);
            }
            
            population = newPopulation;
            generation++;
            currentIndividual = 0;
            
            updateStatus();
            
            // Start next generation
            if(isEvolving) {
                setTimeout(() => evaluateCurrentIndividual(), 100);
            }
        }
        
        function selectParent() {
            // Tournament selection
            const tournamentSize = 3;
            let best = population[Math.floor(Math.random() * POPULATION_SIZE)];
            
            for(let i = 1; i < tournamentSize; i++) {
                const contender = population[Math.floor(Math.random() * POPULATION_SIZE)];
                if(contender.fitness > best.fitness) {
                    best = contender;
                }
            }
            
            return best;
        }
        
        function crossover(parent1, parent2) {
            const child = {
                genome: [],
                fitness: 0,
                distance: 0,
                stability: 0
            };
            
            // Single point crossover
            const crossoverPoint = Math.floor(Math.random() * parent1.genome.length);
            
            for(let i = 0; i < parent1.genome.length; i++) {
                if(i < crossoverPoint) {
                    child.genome.push(parent1.genome[i]);
                } else {
                    child.genome.push(parent2.genome[i]);
                }
            }
            
            return child;
        }
        
        function mutate(individual) {
            for(let i = 0; i < individual.genome.length; i++) {
                if(Math.random() < MUTATION_RATE) {
                    // Different mutation based on gene type
                    const geneRange = getGeneRange(i);
                    individual.genome[i] += (Math.random() - 0.5) * geneRange * 0.2;
                    individual.genome[i] = clamp(individual.genome[i], getGeneMin(i), getGeneMax(i));
                }
            }
        }
        
        function getGeneRange(geneIndex) {
            const genesPerLegSet = GENES_PER_LEG + 1; // +1 for phase offset
            const legSetIndex = Math.floor(geneIndex / genesPerLegSet);
            const geneInSet = geneIndex % genesPerLegSet;
            
            if(legSetIndex < LEG_COUNT) {
                // Leg parameters
                if(geneInSet < GENES_PER_LEG) {
                    const paramIndex = geneInSet % 2;
                    if(paramIndex === 0) return 1.5; // length range
                    if(paramIndex === 1) return 2 * Math.PI / 3; // angle range
                } else {
                    return 2 * Math.PI; // phase offset range
                }
            } else {
                // Global parameters
                return 0.5; // stride and speed factor range
            }
            return 1;
        }
        
        function getGeneMin(geneIndex) {
            const genesPerLegSet = GENES_PER_LEG + 1;
            const legSetIndex = Math.floor(geneIndex / genesPerLegSet);
            const geneInSet = geneIndex % genesPerLegSet;
            
            if(legSetIndex < LEG_COUNT) {
                if(geneInSet < GENES_PER_LEG) {
                    const paramIndex = geneInSet % 2;
                    if(paramIndex === 0) return 0.5; // min length
                    if(paramIndex === 1) return -Math.PI / 3; // min angle
                } else {
                    return 0; // min phase
                }
            } else {
                return 0.5; // min stride/speed
            }
            return 0;
        }
        
        function getGeneMax(geneIndex) {
            const genesPerLegSet = GENES_PER_LEG + 1;
            const legSetIndex = Math.floor(geneIndex / genesPerLegSet);
            const geneInSet = geneIndex % genesPerLegSet;
            
            if(legSetIndex < LEG_COUNT) {
                if(geneInSet < GENES_PER_LEG) {
                    const paramIndex = geneInSet % 2;
                    if(paramIndex === 0) return 2.0; // max length
                    if(paramIndex === 1) return Math.PI / 3; // max angle
                } else {
                    return 2 * Math.PI; // max phase
                }
            } else {
                return 1.0; // max stride/speed
            }
            return 1;
        }
        
        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }
        
        // UI functions
        function toggleEvolution() {
            isEvolving = !isEvolving;
            const btn = document.getElementById("startBtn");
            
            if(isEvolving) {
                btn.textContent = "Pause Evolution";
                btn.style.background = "linear-gradient(to right, #f44336, #ff9800)";
                evaluateCurrentIndividual();
            } else {
                btn.textContent = "Resume Evolution";
                btn.style.background = "linear-gradient(to right, #2196F3, #21CBF3)";
                if(evaluationTimeout) {
                    cancelAnimationFrame(evaluationTimeout);
                }
            }
        }
        
        function resetEvolution() {
            isEvolving = false;
            document.getElementById("startBtn").textContent = "Start Evolution";
            document.getElementById("startBtn").style.background = "linear-gradient(to right, #2196F3, #21CBF3)";
            
            if(evaluationTimeout) {
                cancelAnimationFrame(evaluationTimeout);
            }
            
            if(currentCreature) {
                currentCreature.dispose();
                currentCreature = null;
            }
            
            generation = 0;
            bestFitness = 0;
            bestIndividual = null;
            currentIndividual = 0;
            
            initPopulation();
        }
        
        function showBestIndividual() {
            if(bestIndividual) {
                isEvolving = false;
                document.getElementById("startBtn").textContent = "Start Evolution";
                document.getEementById("startBtn").style.background = "linear-gradient(to right, #2196F3, #21CBF3)";
                
                if(evaluationTimeout) {
                    cancelAnimationFrame(evaluationTimeout);
                }
                
                if(currentCreature) {
                    currentCreature.dispose();
                }
                
                currentCreature = new Creature(bestIndividual.genome);
                currentIndividual = POPULATION_SIZE; // Show as evaluation complete
                
                // Animate best individual
                const animateBest = () => {
                    const elapsed = (Date.now() % (CYCLE_DURATION * 2)); // Loop animation
                    currentCreature.update(elapsed);
                    requestAnimationFrame(animateBest);
                };
                animateBest();
                
                updateStatus();
            }
        }
        
        function updatePopSize() {
            POPULATION_SIZE = parseInt(document.getElementById("popSize").value);
            document.getElementById("totalPop").textContent = POPULATION_SIZE;
            resetEvolution();
        }
        
        function updateStatus() {
            document.getElementById("genCount").textContent = generation;
            document.getElementById("bestFitness").textContent = bestFitness.toFixed(2);
            document.getElementById("currentEval").textContent = currentIndividual;
            document.getElementById("totalPop").textContent = POPULATION_SIZE;
            document.getElementById("legCount").textContent = LEG_COUNT;
            document.getElementById("jointCount").textContent = JOINTS_PER_LEG;
        }
        
        // Event listeners
        document.getElementById("mutationRate").addEventListener("input", function(e) {
            MUTATION_RATE = parseFloat(e.target.value);
            document.getElementById("mutationValue").textContent = MUTATION_RATE.toFixed(2);
        });
        
        document.getElementById("cycleDuration").addEventListener("input", function(e) {
            CYCLE_DURATION = parseFloat(e.target.value) * 1000;
            document.getElementById("cycleValue").textContent = (CYCLE_DURATION / 1000) + "s";
        });
        
        // Initialize everything
        window.addEventListener("DOMContentLoaded", function() {
            initBabylon();
            initPopulation();
            updateStatus();
            
            // Set initial values
            document.getElementById("mutationValue").textContent = MUTATION_RATE.toFixed(2);
            document.getElementById("cycleValue").textContent = (CYCLE_DURATION / 1000) + "s";
            document.getElementById("totalPop").textContent = POPULATION_SIZE;
        });
    </script>
</body>
</html>