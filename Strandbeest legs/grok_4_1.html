<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolving Strandbeest Walkers - Genetic Algorithm</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            overflow: hidden;
            color: #e0e0ff;
        }

        #renderCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
        }

        .ui-overlay > * {
            pointer-events: auto;
        }

        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            max-width: 380px;
            transition: transform 0.3s ease;
        }

        .control-panel h2 {
            margin: 0 0 15px 0;
            color: #64b5f6;
            font-size: 20px;
            text-shadow: 0 0 10px rgba(100, 180, 255, 0.5);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 13px;
            color: #b0c4ff;
        }

        .slider {
            width: 100%;
            height: 5px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #64b5f6;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 180, 255, 0.6);
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #64b5f6;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 180, 255, 0.6);
        }

        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            padding: 12px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn.danger {
            background: linear-gradient(135deg, #f56565, #e53e3e);
        }

        .btn.success {
            background: linear-gradient(135deg, #48bb78, #38a169);
        }

        .stats-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 35, 0.95);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(100, 150, 255, 0.3);
            min-width: 250px;
        }

        .stats-panel h3 {
            margin: 0 0 15px 0;
            color: #64b5f6;
            font-size: 16px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 13px;
        }

        .stat-label {
            color: #8a92b2;
        }

        .stat-value {
            font-weight: bold;
            color: #64b5f6;
        }

        .best-creature {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 35, 0.95);
            padding: 15px 30px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(100, 150, 255, 0.5);
            text-align: center;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
        }

        .best-creature h3 {
            margin: 0 0 8px 0;
            color: #ffd700;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .best-distance {
            font-size: 24px;
            font-weight: bold;
            color: #64b5f6;
        }

        .generation-info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 35, 0.98);
            padding: 30px 50px;
            border-radius: 16px;
            text-align: center;
            border: 2px solid #64b5f6;
            display: none;
            z-index: 1000;
        }

        .generation-info h1 {
            font-size: 48px;
            color: #64b5f6;
            margin-bottom: 10px;
        }

        .generation-info p {
            font-size: 18px;
            color: #b0c4ff;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <div class="ui-overlay">
        <div class="control-panel">
            <h2>Evolutionary Walker</h2>
            
            <div class="control-group">
                <label>Population Size: <span id="popSizeValue">20</span></label>
                <input type="range" class="slider" id="popSize" min="10" max="50" step="5" value="20">
            </div>
            
            <div class="control-group">
                <label>Mutation Rate: <span id="mutationRateValue">0.15</span></label>
                <input type="range" class="slider" id="mutationRate" min="0.01" max="0.5" step="0.01" value="0.15">
            </div>
            
            <div class="control-group">
                <label>Cycle Duration: <span id="cycleDurationValue">120</span>s</label>
                <input type="range" class="slider" id="cycleDuration" min="30" max="300" step="10" value="120">
            </div>
            
            <div class="control-group">
                <label>Leg Complexity: <span id="complexityValue">4</span></label>
                <input type="range" class="slider" id="complexity" min="3" max="6" step="1" value="4">
            </div>
            
            <div class="action-buttons">
                <button class="btn" id="startBtn" onclick="evolution.start()">Start Evolution</button>
                <button class="btn" id="pauseBtn" onclick="evolution.pause()">Pause</button>
                <button class="btn success" onclick="evolution.showBest()">Show Best</button>
                <button class="btn danger" onclick="evolution.reset()">Reset</button>
            </div>
        </div>
        
        <div class="stats-panel">
            <h3>Statistics</h3>
            <div class="stat-item">
                <span class="stat-label">Generation</span>
                <span class="stat-value" id="generation">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Best Distance</span>
                <span class="stat-value" id="bestDistance">0.0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Avg Distance</span>
                <span class="stat-value" id="avgDistance">0.0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Time Elapsed</span>
                <span class="stat-value" id="elapsedTime">0s</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Status</span>
                <span class="stat-value" id="status">Ready</span>
            </div>
        </div>
        
        <div class="best-creature">
            <h3>Champion Walker</h3>
            <div class="best-distance" id="championDistance">0.0m</div>
        </div>
        
        <div class="generation-info" id="generationInfo">
            <h1>New Generation!</h1>
            <p id="generationText">Generation 1</p>
        </div>
    </div>

    <script>
        class LegMechanism {
            constructor(genome, side = 'left') {
                this.genome = genome;
                this.side = side;
                this.joints = [];
                this.angle = 0;
                this.phaseOffset = genome.phaseOffset || 0;
            }
            
            create(scene, parent, xOffset) {
                const segments = this.genome.segments;
                let parentJoint = parent;
                let currentX = xOffset;
                let currentY = 0;
                
                for (let i = 0; i < segments.length; i++) {
                    const seg = segments[i];
                    const length = seg.length;
                    const angleOffset = seg.angleOffset;
                    
                    // Create segment
                    const segment = BABYLON.MeshBuilder.CreateBox(
                        `leg_${this.side}_${i}`, 
                        { width: 0.3, height: length, depth: 0.3 }, 
                        scene
                    );
                    segment.material = new BABYLON.StandardMaterial("legMat", scene);
                    segment.material.diffuseColor = new BABYLON.Color3(0.8, 0.6, 0.4);
                    
                    // Position segment
                    segment.position.x = currentX;
                    segment.position.y = currentY - length / 2;
                    segment.position.z = this.side === 'left' ? 0.8 : -0.8;
                    segment.parent = parentJoint;
                    
                    // Create pivot joint
                    const joint = new BABYLON.TransformNode(`joint_${this.side}_${i}`, scene);
                    joint.position.x = currentX;
                    joint.position.y = currentY - length;
                    joint.position.z = this.side === 'left' ? 0.8 : -0.8;
                    joint.parent = parentJoint;
                    
                    this.joints.push({
                        segment: segment,
                        joint: joint,
                        length: length,
                        angleOffset: angleOffset,
                        baseAngle: i === 0 ? 0 : this.joints[i-1].baseAngle + angleOffset
                    });
                    
                    currentY -= length;
                    parentJoint = joint;
                }
                
                // Foot
                const foot = BABYLON.MeshBuilder.CreateSphere(
                    `foot_${this.side}`, { diameter: 0.6 }, scene
                );
                foot.material = new BABYLON.StandardMaterial("footMat", scene);
                foot.material.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                foot.position.copyFrom(parentJoint.position);
                foot.parent = parentJoint;
                
                this.foot = foot;
                return this.joints[0].joint;
            }
            
            update(angle) {
                this.angle = angle + this.phaseOffset;
                
                let currentAngle = this.angle;
                for (let i = 0; i < this.joints.length; i++) {
                    const joint = this.joints[i];
                    joint.joint.rotation.z = currentAngle + joint.angleOffset;
                    currentAngle += joint.angleOffset;
                }
            }
        }
        
        class Creature {
            constructor(genome, scene, position = 0) {
                this.genome = genome;
                this.scene = scene;
                this.position = position;
                this.startPosition = position;
                this.distanceTraveled = 0;
                this.fitness = 0;
                this.alive = true;
                
                this.create();
            }
            
            create() {
                // Body
                this.body = BABYLON.MeshBuilder.CreateBox(
                    "body", { width: 2, height: 1, depth: 1.5 }, this.scene
                );
                this.body.position.x = this.startPosition;
                this.body.position.y = 3;
                this.body.position.z = 0;
                
                const bodyMat = new BABYLON.StandardMaterial("bodyMat", this.scene);
                bodyMat.diffuseColor = new BABYLON.Color3(0.4, 0.6, 0.8);
                this.body.material = bodyMat;
                
                // Create legs
                this.leftLeg = new LegMechanism(this.genome, 'left');
                this.rightLeg = new LegMechanism(this.genome, 'right');
                
                this.leftLeg.phaseOffset = Math.PI; // Opposite phase
                
                this.leftRoot = this.leftLeg.create(this.scene, this.body, -0.8);
                this.rightRoot = this.rightLeg.create(this.scene, this.body, -0.8);
            }
            
            update(time) {
                if (!this.alive) return;
                
                const angle = time * 2;
                
                this.leftLeg.update(angle);
                this.rightLeg.update(angle);
                
                // Simple ground contact simulation
                const leftFootY = this.leftLeg.foot.getAbsolutePosition().y;
                const rightFootY = this.rightLeg.foot.getAbsolutePosition().y;
                const groundY = 0.3;
                
                // Apply forward force based on foot contact
                let forwardForce = 0;
                if (leftFootY <= groundY + 0.1) {
                    forwardForce += 0.02;
                }
                if (rightFootY <= groundY + 0.1) {
                    forwardForce += 0.02;
                }
                
                // Apply stability penalty for tilting
                const tilt = Math.abs(this.body.rotation.z);
                forwardForce *= (1 - tilt * 2);
                
                // Move forward
                this.body.position.x += forwardForce;
                
                // Keep upright with some damping
                this.body.rotation.z *= 0.95;
                
                // Ground collision for body
                if (this.body.position.y < 2) {
                    this.body.position.y = 2;
                    if (tilt > 0.8) {
                        this.alive = false; // Fallen over
                    }
                }
                
                // Update fitness
                this.distanceTraveled = this.body.position.x - this.startPosition;
                this.fitness = this.distanceTraveled;
                if (!this.alive) this.fitness *= 0.1; // Penalty for falling
            }
            
            dispose() {
                this.body.dispose();
                this.leftLeg.joints.forEach(j => {
                    j.segment.dispose();
                    j.joint.dispose();
                });
                this.rightLeg.joints.forEach(j => {
                    j.segment.dispose();
                    j.joint.dispose();
                });
                this.leftLeg.foot.dispose();
                this.rightLeg.foot.dispose();
            }
        }
        
        class GeneticAlgorithm {
            constructor() {
                this.population = [];
                this.generation = 0;
                this.bestCreature = null;
                this.bestFitness = 0;
                
                this.populationSize = 20;
                this.mutationRate = 0.15;
                this.cycleDuration = 120;
                this.complexity = 4;
                
                this.running = false;
                this.paused = false;
                this.simulationTime = 0;
                this.startTime = 0;
                
                this.scene = null;
                this.creatures = [];
                this.showBestMode = false;
            }
            
            init(scene) {
                this.scene = scene;
                this.createInitialPopulation();
            }
            
            createInitialPopulation() {
                this.population = [];
                for (let i = 0; i < this.populationSize; i++) {
                    const genome = this.randomGenome();
                    this.population.push({
                        genome: genome,
                        fitness: 0
                    });
                }
            }
            
            randomGenome() {
                const segments = [];
                for (let i = 0; i < this.complexity; i++) {
                    segments.push({
                        length: 1 + Math.random() * 2,
                        angleOffset: (Math.random() - 0.5) * Math.PI / 2
                    });
                }
                
                return {
                    segments: segments,
                    phaseOffset: Math.random() * Math.PI * 2
                };
            }
            
            crossover(parent1, parent2) {
                const childSegments = [];
                const maxSegments = Math.max(parent1.segments.length, parent2.segments.length);
                
                for (let i = 0; i < maxSegments; i++) {
                    if (i < parent1.segments.length && i < parent2.segments.length) {
                        if (Math.random() < 0.5) {
                            childSegments.push({...parent1.segments[i]});
                        } else {
                            childSegments.push({...parent2.segments[i]});
                        }
                    } else if (i < parent1.segments.length) {
                        childSegments.push({...parent1.segments[i]});
                    } else {
                        childSegments.push({...parent2.segments[i]});
                    }
                }
                
                return {
                    segments: childSegments,
                    phaseOffset: Math.random() < 0.5 ? parent1.phaseOffset : parent2.phaseOffset
                };
            }
            
            mutate(genome) {
                const mutated = JSON.parse(JSON.stringify(genome));
                
                // Mutate segment lengths and angles
                for (let i = 0; i < mutated.segments.length; i++) {
                    if (Math.random() < this.mutationRate) {
                        mutated.segments[i].length = Math.max(0.5, mutated.segments[i].length + (Math.random() - 0.5) * 1);
                    }
                    if (Math.random() < this.mutationRate) {
                        mutated.segments[i].angleOffset += (Math.random() - 0.5) * Math.PI / 4;
                    }
                }
                
                // Mutate phase offset
                if (Math.random() < this.mutationRate) {
                    mutated.phaseOffset += (Math.random() - 0.5) * Math.PI / 2;
                }
                
                // Occasionally add or remove segment
                if (Math.random() < this.mutationRate * 0.5 && mutated.segments.length < 6) {
                    mutated.segments.push({
                        length: 1 + Math.random() * 2,
                        angleOffset: (Math.random() - 0.5) * Math.PI / 2
                    });
                }
                if (Math.random() < this.mutationRate * 0.5 && mutated.segments.length > 3) {
                    mutated.segments.pop();
                }
                
                return mutated;
            }
            
            selectParent() {
                // Tournament selection
                const tournamentSize = 5;
                let best = null;
                let bestFitness = -Infinity;
                
                for (let i = 0; i < tournamentSize; i++) {
                    const candidate = this.population[Math.floor(Math.random() * this.population.length)];
                    if (candidate.fitness > bestFitness) {
                        best = candidate;
                        bestFitness = candidate.fitness;
                    }
                }
                
                return best;
            }
            
            evolve() {
                // Sort by fitness
                this.population.sort((a, b) => b.fitness - a.fitness);
                
                // Keep best individual (elitism)
                const elite = [this.population[0]];
                
                // Track best
                if (this.population[0].fitness > this.bestFitness) {
                    this.bestFitness = this.population[0].fitness;
                    this.bestCreature = JSON.parse(JSON.stringify(this.population[0].genome));
                }
                
                // Create new population
                const newPopulation = [];
                newPopulation.push(this.population[0]); // Elitism
                
                while (newPopulation.length < this.populationSize) {
                    const parent1 = this.selectParent();
                    const parent2 = this.selectParent();
                    
                    let child = this.crossover(parent1.genome, parent2.genome);
                    child = this.mutate(child);
                    
                    newPopulation.push({
                        genome: child,
                        fitness: 0
                    });
                }
                
                this.population = newPopulation;
                this.generation++;
                
                // Show generation info
                this.showGenerationInfo();
            }
            
            showGenerationInfo() {
                const info = document.getElementById('generationInfo');
                document.getElementById('generationText').textContent = `Generation ${this.generation}`;
                info.style.display = 'block';
                setTimeout(() => {
                    info.style.display = 'none';
                }, 2000);
            }
            
            start() {
                if (this.running) return;
                
                this.running = true;
                this.paused = false;
                this.simulationTime = 0;
                this.startTime = Date.now();
                this.updateStatus("Running");
                
                // Create creatures for current population
                this.createCreatures();
            }
            
            pause() {
                this.paused = !this.paused;
                this.updateStatus(this.paused ? "Paused" : "Running");
            }
            
            createCreatures() {
                // Clear existing creatures
                this.creatures.forEach(c => c.dispose());
                this.creatures = [];
                
                const spacing = 8;
                const startX = -spacing * (this.populationSize - 1) / 2;
                
                this.population.forEach((individual, i) => {
                    const creature = new Creature(individual.genome, this.scene, startX + spacing * i);
                    creature.fitness = individual.fitness;
                    this.creatures.push(creature);
                });
                
                this.simulationTime = 0;
            }
            
            update() {
                if (!this.running || this.paused) return;
                
                this.simulationTime = (Date.now() - this.startTime) / 1000;
                
                if (this.showBestMode && this.bestCreature) {
                    // Show only best creature
                    if (this.creatures.length === 1) {
                        this.creatures[0].update(this.simulationTime);
                    }
                } else if (this.creatures.length > 0) {
                    // Update all creatures
                    this.creatures.forEach(creature => {
                        creature.update(this.simulationTime);
                    });
                    
                    // Update population fitness
                    this.creatures.forEach((creature, i) => {
                        if (i < this.population.length) {
                            this.population[i].fitness = creature.fitness;
                        }
                    });
                    
                    // Check if cycle complete
                    if (this.simulationTime > this.cycleDuration) {
                        this.evolve();
                        this.createCreatures();
                        this.startTime = Date.now();
                    }
                }
                
                // Update stats
                this.updateStats();
            }
            
            updateStats() {
                document.getElementById('generation').textContent = this.generation;
                document.getElementById('bestDistance').textContent = this.bestFitness.toFixed(2);
                
                const avgFitness = this.population.reduce((sum, ind) => sum + ind.fitness, 0) / this.population.length;
                document.getElementById('avgDistance').textContent = avgFitness.toFixed(2);
                
                document.getElementById('elapsedTime').textContent = this.simulationTime.toFixed(1) + 's';
                document.getElementById('championDistance').textContent = this.bestFitness.toFixed(2) + 'm';
            }
            
            showBest() {
                this.showBestMode = true;
                this.creatures.forEach(c => c.dispose());
                this.creatures = [];
                
                if (this.bestCreature) {
                    const best = new Creature(this.bestCreature, this.scene, 0);
                    this.creatures.push(best);
                }
                
                this.updateStatus("Best Creature");
            }
            
            reset() {
                this.running = false;
                this.paused = false;
                this.generation = 0;
                this.bestFitness = 0;
                this.bestCreature = null;
                this.simulationTime = 0;
                
                this.creatures.forEach(c => c.dispose());
                this.creatures = [];
                
                this.createInitialPopulation();
                this.updateStatus("Ready");
            }
            
            updateStatus(status) {
                document.getElementById('status').textContent = status;
            }
        }
        
        // Babylon.js setup
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        let scene, camera, light;
        let evolution;
        
        function createScene() {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.1, 1);
            
            // Camera
            camera = new BABYLON.ArcRotateCamera("camera", -Math.PI/2, Math.PI/3.5, 50, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 20;
            camera.upperRadiusLimit = 100;
            
            // Light
            light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;
            
            // Ground
            const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 200, height: 50 }, scene);
            const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.2, 0.3, 0.4);
            groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            ground.material = groundMat;
            ground.position.y = -0.1;
            
            // Grid lines
            for (let i = -100; i <= 100; i += 10) {
                const line = BABYLON.MeshBuilder.CreateLines("line", {
                    points: [
                        new BABYLON.Vector3(i, 0, -25),
                        new BABYLON.Vector3(i, 0, 25)
                    ]
                }, scene);
                line.color = new BABYLON.Color3(0.3, 0.3, 0.4);
                
                const line2 = BABYLON.MeshBuilder.CreateLines("line", {
                    points: [
                        new BABYLON.Vector3(-100, 0, i),
                        new BABYLON.Vector3(100, 0, i)
                    ]
                }, scene);
                line2.color = new BABYLON.Color3(0.3, 0.3, 0.4);
            }
            
            return scene;
        }
        
        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            scene = createScene();
            
            evolution = new GeneticAlgorithm();
            evolution.init(scene);
            
            // Setup controls
            document.getElementById('popSize').addEventListener('input', (e) => {
                evolution.populationSize = parseInt(e.target.value);
                document.getElementById('popSizeValue').textContent = e.target.value;
            });
            
            document.getElementById('mutationRate').addEventListener('input', (e) => {
                evolution.mutationRate = parseFloat(e.target.value);
                document.getElementById('mutationRateValue').textContent = e.target.value;
            });
            
            document.getElementById('cycleDuration').addEventListener('input', (e) => {
                evolution.cycleDuration = parseInt(e.target.value);
                document.getElementById('cycleDurationValue').textContent = e.target.value;
            });
            
            document.getElementById('complexity').addEventListener('input', (e) => {
                evolution.complexity = parseInt(e.target.value);
                document.getElementById('complexityValue').textContent = e.target.value;
                evolution.createInitialPopulation();
            });
            
            engine.runRenderLoop(() => {
                evolution.update();
                scene.render();
            });
            
            window.addEventListener('resize', () => {
                engine.resize();
            });
        });
    </script>
</body>
</html>