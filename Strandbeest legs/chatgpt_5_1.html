<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GA Evolving Strandbeest‑Style Walkers (Babylon.js)</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #050608;
      color: #eee;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    #scene-container {
      flex: 1 1 auto;
      position: relative;
      background: #050608;
    }
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
      display: block;
    }
    #ui-panel {
      width: 320px;
      max-width: 340px;
      background: #11141b;
      border-left: 1px solid #222;
      padding: 14px 14px 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      font-size: 13px;
    }
    h2 {
      margin: 0 0 4px;
      font-size: 18px;
      color: #7dd0ff;
    }
    h3 {
      margin: 10px 0 4px;
      font-size: 14px;
      color: #9ad9ff;
      border-bottom: 1px solid #222;
      padding-bottom: 3px;
    }
    .small {
      font-size: 11px;
      color: #888;
    }
    .stat-box {
      background: rgba(255,255,255,0.03);
      border: 1px solid #222;
      border-radius: 6px;
      padding: 8px 10px;
      font-family: "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      line-height: 1.4;
    }
    .stat-row {
      display: flex;
      justify-content: space-between;
    }
    label {
      display: block;
      margin-top: 6px;
      margin-bottom: 2px;
    }
    .slider-row {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    input[type=range] {
      flex: 1;
    }
    .slider-value {
      width: 40px;
      text-align: right;
      font-size: 11px;
      color: #bbb;
    }
    button {
      margin-top: 6px;
      width: 100%;
      padding: 6px 8px;
      border-radius: 4px;
      border: 1px solid #2980b9;
      background: #3498db;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      font-size: 13px;
    }
    button.secondary {
      border-color: #444;
      background: #2c3e50;
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    .row {
      display: flex;
      gap: 6px;
      margin-top: 4px;
    }
    .row > button {
      flex: 1;
      margin-top: 0;
    }
  </style>
</head>
<body>
  <div id="scene-container">
    <canvas id="renderCanvas"></canvas>
  </div>
  <div id="ui-panel">
    <div>
      <h2>Genetic Strandbeest Walker</h2>
      <div class="small">
        Evolving 2D leg linkages using a genetic algorithm.
        Only one individual is simulated at a time for each generation.
      </div>
    </div>

    <div class="stat-box">
      <div class="stat-row">
        <span>Generation</span><span id="genLabel">0</span>
      </div>
      <div class="stat-row">
        <span>Individual</span><span id="indLabel">0 / 0</span>
      </div>
      <div class="stat-row">
        <span>Best fitness</span><span id="bestFitLabel">–</span>
      </div>
      <div class="stat-row">
        <span>Current distance</span><span id="distLabel">0.00</span>
      </div>
    </div>

    <div>
      <h3>Evolution Controls</h3>
      <div class="slider-group">
        <label for="popSlider">Population size</label>
        <div class="slider-row">
          <input type="range" id="popSlider" min="5" max="40" step="1" value="20">
          <span class="slider-value" id="popValue">20</span>
        </div>

        <label for="mutSlider">Mutation rate</label>
        <div class="slider-row">
          <input type="range" id="mutSlider" min="0.01" max="0.5" step="0.01" value="0.15">
          <span class="slider-value" id="mutValue">0.15</span>
        </div>

        <label for="cycleSlider">Cycle duration (s)</label>
        <div class="slider-row">
          <input type="range" id="cycleSlider" min="2" max="8" step="0.5" value="5">
          <span class="slider-value" id="cycleValue">5.0</span>
        </div>
      </div>

      <div class="row">
        <button id="startPauseBtn">Start evolution</button>
        <button id="resetBtn" class="secondary">Reset GA</button>
      </div>
      <button id="replayBtn" class="secondary" style="margin-top:4px;">Replay best</button>
      <div class="small" style="margin-top:4px;">
        Drag to orbit, mouse wheel to zoom. Evolution runs in real time,
        evaluating one individual after another.
      </div>
    </div>

    <div>
      <h3>Genome (per leg pair)</h3>
      <div class="small">
        Genome encodes hip offset, segment lengths, joint amplitudes,
        phase offsets, and frequency multiplier. Left and right legs share
        parameters but are 180° out of phase.
      </div>
    </div>
  </div>

  <script>
    // ----- Babylon.js scene setup -----
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);
    let scene, camera;
    let displayCreature = null; // meshes for currently visualized creature
    const GROUND_Y = 0;

    function createScene() {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3(0.02, 0.03, 0.06);

      camera = new BABYLON.ArcRotateCamera(
        "camera",
        -Math.PI / 2,
        Math.PI / 3,
        6,
        new BABYLON.Vector3(0, 1, 0),
        scene
      );
      camera.lowerRadiusLimit = 3;
      camera.upperRadiusLimit = 20;
      camera.attachControl(canvas, true);

      const hemiLight = new BABYLON.HemisphericLight(
        "hemi",
        new BABYLON.Vector3(0, 1, 0),
        scene
      );
      hemiLight.intensity = 0.9;

      const dirLight = new BABYLON.DirectionalLight(
        "dir",
        new BABYLON.Vector3(-0.5, -1, -0.3),
        scene
      );
      dirLight.position = new BABYLON.Vector3(5, 5, 5);
      dirLight.intensity = 0.5;

      // Ground
      const ground = BABYLON.MeshBuilder.CreateGround("ground", {
        width: 40,
        height: 6,
        subdivisions: 2
      }, scene);
      ground.position.y = GROUND_Y;
      const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
      groundMat.diffuseColor = new BABYLON.Color3(0.12, 0.15, 0.20);
      groundMat.specularColor = new BABYLON.Color3(0, 0, 0);
      ground.material = groundMat;

      // Subtle grid lines using a second ground
      const grid = BABYLON.MeshBuilder.CreateGround("grid", {
        width: 40,
        height: 6,
        subdivisions: 40
      }, scene);
      grid.position.y = GROUND_Y + 0.001;
      const gridMat = new BABYLON.StandardMaterial("gridMat", scene);
      gridMat.diffuseColor = new BABYLON.Color3(0.15, 0.18, 0.25);
      gridMat.specularColor = new BABYLON.Color3(0, 0, 0);
      gridMat.wireframe = true;
      grid.material = gridMat;

      // Creature meshes (body + 2 legs × 3 segments)
      displayCreature = createCreatureMeshes(scene);

      return scene;
    }

    function createCreatureMeshes(scene) {
      const body = BABYLON.MeshBuilder.CreateBox("body", {
        width: 0.8,
        height: 0.3,
        depth: 0.4
      }, scene);
      body.position.y = 1;

      const bodyMat = new BABYLON.StandardMaterial("bodyMat", scene);
      bodyMat.diffuseColor = new BABYLON.Color3(0.8, 0.9, 1.0);
      bodyMat.emissiveColor = new BABYLON.Color3(0.15, 0.2, 0.3);
      body.material = bodyMat;

      const legMatL = new BABYLON.StandardMaterial("legMatL", scene);
      legMatL.diffuseColor = new BABYLON.Color3(0.2, 0.8, 1.0);
      legMatL.emissiveColor = new BABYLON.Color3(0.0, 0.3, 0.4);

      const legMatR = new BABYLON.StandardMaterial("legMatR", scene);
      legMatR.diffuseColor = new BABYLON.Color3(1.0, 0.5, 0.2);
      legMatR.emissiveColor = new BABYLON.Color3(0.4, 0.15, 0.0);

      const legs = [[], []]; // [left, right] each with 3 segments
      for (let side = 0; side < 2; side++) {
        const mat = side === 0 ? legMatL : legMatR;
        const zOffset = side === 0 ? 0.12 : -0.12;

        for (let i = 0; i < 3; i++) {
          const seg = BABYLON.MeshBuilder.CreateBox(`leg_${side}_${i}`, {
            height: 1,
            width: 0.08,
            depth: 0.12
          }, scene);
          seg.material = mat;
          seg.position.z = zOffset;
          seg.position.y = 0.5;
          seg.position.x = 0;
          legs[side].push(seg);
        }
      }

      return { body, legs };
    }

    scene = createScene();

    // ----- Genetic Algorithm and simulation state -----
    const GENOME_LENGTH = 11; // normalized [0,1]

    const gaSettings = {
      popSize: 20,
      mutationRate: 0.15,
      cycleDuration: 5.0
    };

    const ga = {
      population: [],
      generation: 0,
      currentIndex: 0,
      bestGenome: null,
      bestFitness: -Infinity
    };

    let evolutionRunning = false;
    let replayMode = false;
    let bestReplayIndividual = null;

    let timeAccumulator = 0;
    const FIXED_DT = 1 / 60;

    // ----- Utility: random normal (Box-Muller) -----
    function randNorm() {
      let u = 1 - Math.random();
      let v = 1 - Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    // ----- Genome helpers -----
    function randomGenome() {
      const g = new Float32Array(GENOME_LENGTH);
      for (let i = 0; i < GENOME_LENGTH; i++) {
        g[i] = Math.random(); // [0,1]
      }
      return g;
    }

    function cloneGenome(g) {
      return new Float32Array(g);
    }

    function crossover(g1, g2) {
      const child = new Float32Array(GENOME_LENGTH);
      for (let i = 0; i < GENOME_LENGTH; i++) {
        child[i] = Math.random() < 0.5 ? g1[i] : g2[i];
      }
      return child;
    }

    function mutate(genome, rate) {
      for (let i = 0; i < genome.length; i++) {
        if (Math.random() < rate) {
          genome[i] += randNorm() * 0.15;
          if (genome[i] < 0) genome[i] = 0;
          if (genome[i] > 1) genome[i] = 1;
        }
      }
    }

    function tournamentSelect(pop, k = 3) {
      let best = null;
      for (let i = 0; i < k; i++) {
        const idx = Math.floor(Math.random() * pop.length);
        const cand = pop[idx];
        if (!best || cand.fitness > best.fitness) {
          best = cand;
        }
      }
      return best;
    }

    function createInitialPopulation() {
      ga.population = [];
      ga.generation = 1;
      ga.currentIndex = 0;
      ga.bestFitness = -Infinity;
      ga.bestGenome = null;

      for (let i = 0; i < gaSettings.popSize; i++) {
        ga.population.push({
          genome: randomGenome(),
          fitness: 0,
          state: null
        });
      }
    }

    // ----- Decode genome into physical parameters -----
    function decodeGenome(genome) {
      // All values from normalized [0,1]
      const hipOffsetY = -0.3 - 0.4 * genome[0]; // -0.3 .. -0.7 (below body)
      const L1 = 0.3 + 0.5 * genome[1];         // 0.3 .. 0.8
      const L2 = 0.3 + 0.5 * genome[2];         // 0.3 .. 0.8
      const L3 = 0.1 + 0.4 * genome[3];         // 0.1 .. 0.5

      const basePhase = genome[4] * 2 * Math.PI; // 0..2π

      const amp1 = 0.2 + 1.0 * genome[5]; // 0.2..1.2 rad
      const amp2 = 0.2 + 1.0 * genome[6];
      const amp3 = 0.2 + 1.0 * genome[7];

      const phase2 = (genome[8] * 2 - 1) * Math.PI; // -π..π
      const phase3 = (genome[9] * 2 - 1) * Math.PI;

      const freqMul = 0.5 + 1.5 * genome[10]; // 0.5..2.0

      return {
        hipOffsetY,
        L1, L2, L3,
        basePhase,
        amp1, amp2, amp3,
        phase2, phase3,
        freqMul
      };
    }

    // ----- Creature state and simulation -----
    function initIndividualState(individual) {
      const state = {
        bodyX: 0,
        bodyY: 1.0,
        bodyVelX: 0,
        maxX: 0,
        stabilityPenalty: 0,
        supportTime: 0,
        time: 0,
        legs: [
          { prevFootLocalX: 0, segs: [{}, {}, {}], hipWorld: null, footWorld: null },
          { prevFootLocalX: 0, segs: [{}, {}, {}], hipWorld: null, footWorld: null }
        ]
      };

      // Initialize at t=0 so prevFootLocalX is meaningful
      for (let leg = 0; leg < 2; leg++) {
        const info = computeLegKinematics(
          individual.genome,
          state,
          0,
          leg,
          true
        );
        state.legs[leg].prevFootLocalX = info.footLocalX;
      }
      individual.state = state;
    }

    // Compute leg kinematics at given time
    // Returns foot local X (relative to hip) and foot world Y
    function computeLegKinematics(genome, state, time, legIndex, updateSegments) {
      const params = decodeGenome(genome);
      const {
        hipOffsetY,
        L1, L2, L3,
        basePhase,
        amp1, amp2, amp3,
        phase2, phase3,
        freqMul
      } = params;

      const baseAngleDown = -Math.PI / 2; // vertical down
      const cycleDuration = gaSettings.cycleDuration;
      const omega = 2 * Math.PI * freqMul / cycleDuration;

      const legPhaseOffset = legIndex === 0 ? 0 : Math.PI; // right leg 180° out of phase
      const theta = omega * time + basePhase + legPhaseOffset;

      const ang1 = baseAngleDown + amp1 * Math.sin(theta);
      const ang2 = ang1 + amp2 * Math.sin(theta + phase2);
      const ang3 = ang2 + amp3 * Math.sin(theta + phase3);

      const bodyX = state.bodyX;
      const bodyY = state.bodyY;
      const hipWorld = {
        x: bodyX,
        y: bodyY + hipOffsetY
      };

      const knee = {
        x: hipWorld.x + Math.cos(ang1) * L1,
        y: hipWorld.y + Math.sin(ang1) * L1
      };
      const ankle = {
        x: knee.x + Math.cos(ang2) * L2,
        y: knee.y + Math.sin(ang2) * L2
      };
      const foot = {
        x: ankle.x + Math.cos(ang3) * L3,
        y: ankle.y + Math.sin(ang3) * L3
      };

      if (updateSegments) {
        const legState = state.legs[legIndex];
        legState.segs[0] = { start: hipWorld, end: knee, length: L1 };
        legState.segs[1] = { start: knee, end: ankle, length: L2 };
        legState.segs[2] = { start: ankle, end: foot, length: L3 };
        legState.hipWorld = hipWorld;
        legState.footWorld = foot;
      }

      const footLocalX = foot.x - hipWorld.x;
      return {
        hipWorld,
        knee,
        ankle,
        foot,
        footLocalX,
        footWorldY: foot.y
      };
    }

    function simulateCreatureStep(individual, dt) {
      const state = individual.state;
      if (!state) return;

      state.time += dt;

      let totalPush = 0;
      let anySupport = false;

      for (let leg = 0; leg < 2; leg++) {
        const info = computeLegKinematics(
          individual.genome,
          state,
          state.time,
          leg,
          true
        );

        const footLocalX = info.footLocalX;
        const footWorldY = info.footWorldY;
        const legState = state.legs[leg];

        const prevLocalX = legState.prevFootLocalX;
        const vLocalX = (footLocalX - prevLocalX) / dt;

        // Contact factor: 1 when foot at/below ground, fades out above
        const distToGround = footWorldY - GROUND_Y;
        let contact = 0;
        if (distToGround < 0.08) {
          contact = Math.min(1, (0.08 - distToGround) / 0.08);
          anySupport = true;
        }

        // Penalize leg penetration below ground
        if (distToGround < 0) {
          state.stabilityPenalty += -distToGround * dt;
        }

        // Backward local motion (negative vLocalX) pushes body forward
        if (vLocalX < 0 && contact > 0) {
          totalPush += -vLocalX * contact;
        }

        if (contact > 0.5) {
          state.supportTime += dt;
        }

        legState.prevFootLocalX = footLocalX;
      }

      // Simple 1D horizontal dynamics: F = k * totalPush - damping * v
      const kPush = 1.6;
      const damping = 1.0;
      const accel = kPush * totalPush - damping * state.bodyVelX;
      state.bodyVelX += accel * dt;
      state.bodyX += state.bodyVelX * dt;

      if (state.bodyX < 0) state.bodyX = 0;
      if (state.bodyX > state.maxX) state.maxX = state.bodyX;
    }

    function finalizeFitness(individual) {
      const s = individual.state;
      if (!s) return 0;

      const distance = s.maxX;
      const penalty = s.stabilityPenalty;
      const supportBonus = s.supportTime / gaSettings.cycleDuration; // 0..~1

      // Simple fitness function
      const fitness = distance - 1.0 * penalty + 0.5 * supportBonus;
      individual.fitness = fitness;

      if (fitness > ga.bestFitness || !isFinite(ga.bestFitness)) {
        ga.bestFitness = fitness;
        ga.bestGenome = cloneGenome(individual.genome);
      }
      return fitness;
    }

    function nextGeneration() {
      const pop = ga.population;
      if (pop.length === 0) return;

      // Sort by fitness descending
      pop.sort((a, b) => b.fitness - a.fitness);

      const newSize = gaSettings.popSize;
      const eliteCount = Math.max(1, Math.floor(newSize * 0.1));
      const newPop = [];

      // Elitism
      for (let i = 0; i < eliteCount && i < pop.length; i++) {
        newPop.push({
          genome: cloneGenome(pop[i].genome),
          fitness: 0,
          state: null
        });
      }

      // Fill rest with offspring
      while (newPop.length < newSize) {
        const parentA = tournamentSelect(pop);
        const parentB = tournamentSelect(pop);
        const childGenome = crossover(parentA.genome, parentB.genome);
        mutate(childGenome, gaSettings.mutationRate);
        newPop.push({ genome: childGenome, fitness: 0, state: null });
      }

      ga.population = newPop;
      ga.generation++;
      ga.currentIndex = 0;
    }

    // ----- Visualization update -----
    function updateCreatureVisual(state) {
      if (!displayCreature || !state) return;

      const body = displayCreature.body;
      body.position.x = state.bodyX;
      body.position.y = state.bodyY;

      // Keep camera target following body
      camera.target = new BABYLON.Vector3(state.bodyX, state.bodyY, 0);

      for (let leg = 0; leg < 2; leg++) {
        const zOffset = leg === 0 ? 0.12 : -0.12;
        const legMeshes = displayCreature.legs[leg];
        const legState = state.legs[leg];

        for (let i = 0; i < 3; i++) {
          const segData = legState.segs[i];
          const mesh = legMeshes[i];

          const sx = segData.start.x;
          const sy = segData.start.y;
          const ex = segData.end.x;
          const ey = segData.end.y;
          const length = segData.length;

          const midX = (sx + ex) * 0.5;
          const midY = (sy + ey) * 0.5;

          mesh.position.x = midX;
          mesh.position.y = midY;
          mesh.position.z = zOffset;

          mesh.scaling.y = length;

          const angle = Math.atan2(ey - sy, ex - sx);
          mesh.rotation.z = angle - Math.PI / 2;
        }
      }
    }

    // ----- Main update loop -----
    function runEvolutionStep(dt) {
      if (ga.population.length === 0) return;

      if (ga.currentIndex >= ga.population.length) {
        nextGeneration();
      }

      const ind = ga.population[ga.currentIndex];
      if (!ind.state) {
        initIndividualState(ind);
      }

      simulateCreatureStep(ind, dt);
      updateCreatureVisual(ind.state);

      if (ind.state.time >= gaSettings.cycleDuration) {
        finalizeFitness(ind);
        ga.currentIndex++;
      }
    }

    function runReplayStep(dt) {
      if (!bestReplayIndividual) return;
      if (!bestReplayIndividual.state) {
        initIndividualState(bestReplayIndividual);
      }

      simulateCreatureStep(bestReplayIndividual, dt);
      updateCreatureVisual(bestReplayIndividual.state);

      if (bestReplayIndividual.state.time >= gaSettings.cycleDuration) {
        initIndividualState(bestReplayIndividual); // loop the gait
      }
    }

    let uiUpdateCounter = 0;

    function updateUI() {
      const genLabel = document.getElementById("genLabel");
      const indLabel = document.getElementById("indLabel");
      const bestFitLabel = document.getElementById("bestFitLabel");
      const distLabel = document.getElementById("distLabel");

      genLabel.textContent = ga.generation.toString();
      indLabel.textContent = ga.population.length === 0
        ? "0 / 0"
        : `${Math.min(ga.currentIndex + 1, ga.population.length)} / ${ga.population.length}`;
      bestFitLabel.textContent =
        isFinite(ga.bestFitness) ? ga.bestFitness.toFixed(3) : "–";

      let currentDist = 0;
      if (evolutionRunning && ga.population.length > 0 && ga.currentIndex < ga.population.length) {
        const s = ga.population[ga.currentIndex].state;
        if (s) currentDist = s.bodyX;
      } else if (replayMode && bestReplayIndividual && bestReplayIndividual.state) {
        currentDist = bestReplayIndividual.state.bodyX;
      }
      distLabel.textContent = currentDist.toFixed(2);
    }

    engine.runRenderLoop(() => {
      const dt = engine.getDeltaTime() / 1000;
      timeAccumulator += dt;

      while (timeAccumulator >= FIXED_DT) {
        timeAccumulator -= FIXED_DT;
        if (replayMode) {
          runReplayStep(FIXED_DT);
        } else if (evolutionRunning) {
          runEvolutionStep(FIXED_DT);
        }
      }

      uiUpdateCounter++;
      if (uiUpdateCounter % 10 === 0) {
        updateUI();
      }

      scene.render();
    });

    window.addEventListener("resize", function () {
      engine.resize();
    });

    // ----- UI wiring -----
    const popSlider = document.getElementById("popSlider");
    const popValue = document.getElementById("popValue");
    const mutSlider = document.getElementById("mutSlider");
    const mutValue = document.getElementById("mutValue");
    const cycleSlider = document.getElementById("cycleSlider");
    const cycleValue = document.getElementById("cycleValue");

    const startPauseBtn = document.getElementById("startPauseBtn");
    const resetBtn = document.getElementById("resetBtn");
    const replayBtn = document.getElementById("replayBtn");

    popSlider.oninput = () => {
      gaSettings.popSize = parseInt(popSlider.value, 10);
      popValue.textContent = gaSettings.popSize.toString();
    };

    mutSlider.oninput = () => {
      gaSettings.mutationRate = parseFloat(mutSlider.value);
      mutValue.textContent = gaSettings.mutationRate.toFixed(2);
    };

    cycleSlider.oninput = () => {
      gaSettings.cycleDuration = parseFloat(cycleSlider.value);
      cycleValue.textContent = gaSettings.cycleDuration.toFixed(1);
    };

    startPauseBtn.onclick = () => {
      if (!evolutionRunning) {
        evolutionRunning = true;
        replayMode = false;
        startPauseBtn.textContent = "Pause evolution";
      } else {
        evolutionRunning = false;
        startPauseBtn.textContent = "Resume evolution";
      }
    };

    resetBtn.onclick = () => {
      evolutionRunning = false;
      replayMode = false;
      startPauseBtn.textContent = "Start evolution";
      bestReplayIndividual = null;
      createInitialPopulation();
      updateUI();
    };

    replayBtn.onclick = () => {
      if (!ga.bestGenome) {
        alert("No best individual yet. Let evolution run for a few generations first.");
        return;
      }
      evolutionRunning = false;
      replayMode = true;
      startPauseBtn.textContent = "Start evolution";
      bestReplayIndividual = {
        genome: cloneGenome(ga.bestGenome),
        fitness: ga.bestFitness,
        state: null
      };
      initIndividualState(bestReplayIndividual);
    };

    // Initialize GA at startup
    createInitialPopulation();
    updateUI();
  </script>
</body>
</html>