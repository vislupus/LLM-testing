<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genetic Strandbeest Evolution - Babylon.js</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 320px;
            background: rgba(22, 33, 62, 0.95);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #0f3460;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .main-view {
            flex: 1;
            position: relative;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        h1 {
            color: #00d9ff;
            font-size: 1.3em;
            margin-bottom: 5px;
            text-shadow: 0 0 15px rgba(0, 217, 255, 0.3);
        }

        .subtitle {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 15px;
        }

        .panel {
            background: rgba(15, 52, 96, 0.5);
            border-radius: 12px;
            padding: 15px;
        }

        .panel-title {
            color: #00d9ff;
            font-size: 0.95em;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(0, 217, 255, 0.2);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-title::before {
            content: '';
            display: inline-block;
            width: 4px;
            height: 14px;
            background: linear-gradient(180deg, #00d9ff, #00b8d9);
            border-radius: 2px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-size: 0.85em;
            color: #bbb;
        }

        .control-value {
            color: #00d9ff;
            font-weight: 600;
            font-family: 'Consolas', monospace;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #1a1a2e;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00d9ff, #00b8d9);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #00d9ff;
            cursor: pointer;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .button-row {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.85em;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00d9ff, #00b8d9);
            color: #1a1a2e;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 217, 255, 0.4);
        }

        .btn-secondary {
            background: #0f3460;
            color: #eee;
        }

        .btn-secondary:hover {
            background: #1a4a7a;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(15, 52, 96, 0.5);
            font-size: 0.85em;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #999;
        }

        .stat-value {
            color: #00d9ff;
            font-family: 'Consolas', monospace;
            font-weight: 600;
        }

        .stat-value.highlight {
            color: #4ecdc4;
        }

        .stat-value.best {
            color: #50fa7b;
            font-size: 1.1em;
        }

        .progress-bar {
            height: 8px;
            background: #1a1a2e;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d9ff, #4ecdc4);
            transition: width 0.3s ease;
        }

        .generation-indicator {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px;
            background: rgba(0, 217, 255, 0.1);
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .gen-number {
            font-size: 2em;
            font-weight: bold;
            color: #00d9ff;
            text-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
        }

        .gen-info {
            flex: 1;
        }

        .gen-label {
            font-size: 0.75em;
            color: #888;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.75em;
            font-weight: 600;
        }

        .status-running {
            background: rgba(0, 217, 255, 0.2);
            color: #00d9ff;
        }

        .status-paused {
            background: rgba(255, 217, 61, 0.2);
            color: #ffd93d;
        }

        .status-stopped {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
        }

        .instructions {
            font-size: 0.8em;
            line-height: 1.6;
            color: #aaa;
        }

        .instructions-title {
            color: #00d9ff;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .key {
            display: inline-block;
            background: rgba(0, 217, 255, 0.15);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
            margin-right: 5px;
        }

        .camera-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(22, 33, 62, 0.9);
            padding: 15px;
            border-radius: 10px;
            display: flex;
            gap: 10px;
        }

        .camera-btn {
            padding: 8px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            background: #0f3460;
            color: #eee;
            transition: all 0.3s ease;
        }

        .camera-btn:hover, .camera-btn.active {
            background: #00d9ff;
            color: #1a1a2e;
        }

        .overlay-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(22, 33, 62, 0.9);
            padding: 15px;
            border-radius: 10px;
            font-size: 0.85em;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            padding: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div>
                <h1>Genetic Strandbeest</h1>
                <p class="subtitle">Evolutionary Walking Machine Synthesis</p>
            </div>

            <div class="generation-indicator">
                <div class="gen-number" id="gen-number">0</div>
                <div class="gen-info">
                    <div class="gen-label">GENERATION</div>
                    <div><span class="status-badge status-stopped" id="status-badge">Ready</span></div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">Evolution Controls</div>

                <div class="button-row">
                    <button class="btn-primary" id="start-btn">Start</button>
                    <button class="btn-secondary" id="pause-btn">Pause</button>
                </div>
                <div class="button-row">
                    <button class="btn-danger" id="reset-btn">Reset All</button>
                    <button class="btn-secondary" id="replay-btn">Replay Best</button>
                </div>

                <div class="control-group" style="margin-top: 15px;">
                    <div class="control-label">
                        <span>Population Size</span>
                        <span class="control-value" id="pop-value">20</span>
                    </div>
                    <input type="range" id="pop-size" min="5" max="50" value="20" step="5">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Mutation Rate</span>
                        <span class="control-value" id="mutation-value">0.08</span>
                    </div>
                    <input type="range" id="mutation-rate" min="0.01" max="0.25" value="0.08" step="0.01">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Cycle Duration</span>
                        <span class="control-value" id="cycle-value">2.0s</span>
                    </div>
                    <input type="range" id="cycle-duration" min="1.0" max="4.0" value="2.0" step="0.5">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Simulation Speed</span>
                        <span class="control-value" id="sim-speed-value">1.0x</span>
                    </div>
                    <input type="range" id="sim-speed" min="0.25" max="3.0" value="1.0" step="0.25">
                </div>

                <div class="control-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="show-all" checked>
                        <span>Show All Creatures</span>
                    </label>
                </div>

                <div class="control-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="auto-cam">
                        <span>Auto-Follow Best</span>
                    </label>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">Statistics</div>

                <div class="stat-row">
                    <span class="stat-label">Best Distance</span>
                    <span class="stat-value best" id="best-dist">0.00 m</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Avg Distance</span>
                    <span class="stat-value" id="avg-dist">0.00 m</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Best Stability</span>
                    <span class="stat-value highlight" id="best-stab">100%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Generation Time</span>
                    <span class="stat-value" id="gen-time">0.0s</span>
                </div>

                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">Genome Structure</div>
                <div class="instructions">
                    <p><strong>Each leg has:</strong></p>
                    <p>• 4 bar lengths (L1-L4)</p>
                    <p>• 2 joint positions (P1, P2)</p>
                    <p>• 2 phase offsets (φ1, φ2)</p>
                    <p>• 2 amplitude values (A1, A2)</p>
                    <p><strong>12 genes per leg × 2 legs = 24 genes</strong></p>
                    <p>Genome: 24 floats normalized [0,1]</p>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">Keyboard Controls</div>
                <div class="instructions">
                    <div><span class="key">Space</span> Start/Pause</div>
                    <div><span class="key">R</span> Reset evolution</div>
                    <div><span class="key">B</span> Replay best</div>
                    <div><span class="key">1-5</span> Set camera view</div>
                </div>
            </div>
        </div>

        <div class="main-view">
            <canvas id="renderCanvas"></canvas>

            <div class="camera-controls">
                <button class="camera-btn active" data-view="0">Side</button>
                <button class="camera-btn" data-view="1">Front</button>
                <button class="camera-btn" data-view="2">Top</button>
                <button class="camera-btn" data-view="3">Follow</button>
            </div>

            <div class="overlay-info">
                <div class="info-row">
                    <span style="color: #888;">Creatures:</span>
                    <span id="creature-count">0</span>
                </div>
                <div class="info-row">
                    <span style="color: #888;">Simulation Time:</span>
                    <span id="sim-time">0.00s</span>
                </div>
                <div class="info-row">
                    <span style="color: #888;">Ground Level:</span>
                    <span>0.00</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // Genetic Strandbeest Evolution
        // Uses genetic algorithm to evolve walking machines
        // Inspired by Theo Jansen's Strandbeesten
        // ============================================

        // Global state
        let engine, scene, camera;
        let ground;
        let creatures = [];
        let bestCreature = null;
        let generation = 0;
        let isRunning = false;
        let isPaused = false;
        let simTime = 0;
        let generationStartTime = 0;

        // GA Parameters
        const gaParams = {
            populationSize: 20,
            mutationRate: 0.08,
            cycleDuration: 2.0,
            simSpeed: 1.0,
            showAll: true,
            autoCam: false,
            eliteCount: 2,
            tournamentSize: 3
        };

        // Genome constants
        const GENES_PER_LEG = 12; // L1, L2, L3, L4, P1x, P1y, P2x, P2y, phi1, amp1, phi2, amp2
        const NUM_LEGS = 2;
        const GENOME_LENGTH = GENES_PER_LEG * NUM_LEGS;

        // ============================================
        // Creature Class
        // ============================================
        class Creature {
            constructor(genome = null, id = 0) {
                this.id = id;
                this.genome = genome || this.randomGenome();
                this.fitness = 0;
                this.distance = 0;
                this.stability = 100;
                this.isAlive = true;
                this.bodies = [];
                this.legMeshes = [];
                this.time = 0;

                // Decode genome into physical parameters
                this.decodeGenome();

                // Initial position
                this.position = new BABYLON.Vector3(0, 0, 0);
                this.velocity = new BABYLON.Vector3(0, 0, 0);
                this.orientation = 0; // Body angle

                // Leg phase
                this.legPhase = [0, Math.PI]; // Two legs offset by 180 degrees
            }

            randomGenome() {
                const genome = [];
                for (let i = 0; i < GENOME_LENGTH; i++) {
                    genome.push(Math.random());
                }
                return genome;
            }

            decodeGenome() {
                const g = this.genome;

                // Decode leg parameters from genome
                // Each gene is normalized [0,1], decode to physical values
                this.legs = [];

                for (let legIdx = 0; legIdx < NUM_LEGS; legIdx++) {
                    const base = legIdx * GENES_PER_LEG;

                    const leg = {
                        // Bar lengths (0.1 to 0.5 meters)
                        L1: 0.1 + g[base + 0] * 0.4,
                        L2: 0.1 + g[base + 1] * 0.4,
                        L3: 0.1 + g[base + 2] * 0.4,
                        L4: 0.1 + g[base + 3] * 0.4,

                        // Joint positions relative to body (0.05 to 0.2 meters)
                        P1: new BABYLON.Vector3(
                            0.05 + g[base + 4] * 0.15,
                            0.05 + g[base + 5] * 0.15,
                            0
                        ),
                        P2: new BABYLON.Vector3(
                            0.05 + g[base + 6] * 0.15,
                            -0.05 - g[base + 7] * 0.15,
                            0
                        ),

                        // Crank phase and amplitude
                        phase1: g[base + 8] * Math.PI * 2,
                        amp1: 0.2 + g[base + 9] * 0.3,

                        phase2: g[base + 10] * Math.PI * 2,
                        amp2: 0.2 + g[base + 11] * 0.3
                    };

                    // Adjust P positions based on leg index
                    leg.P1.x = leg.P1.x * (legIdx === 0 ? 1 : -1);
                    leg.P2.x = leg.P2.x * (legIdx === 0 ? 1 : -1);

                    this.legs.push(leg);
                }

                // Body dimensions
                this.bodyWidth = 0.15;
                this.bodyHeight = 0.08;
                this.bodyLength = 0.3;
            }

            createMeshes(scene) {
                // Create body (central torso)
                const bodyMat = new BABYLON.StandardMaterial(`bodyMat${this.id}`, scene);
                bodyMat.diffuseColor = new BABYLON.Color3(0.2, 0.6, 0.8);
                bodyMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);

                const body = BABYLON.MeshBuilder.CreateBox(`body${this.id}`, {
                    width: this.bodyLength,
                    height: this.bodyHeight,
                    depth: this.bodyWidth
                }, scene);
                body.material = bodyMat;
                body.position = this.position.clone();
                this.bodies.push(body);

                // Create leg meshes for each leg
                for (let legIdx = 0; legIdx < NUM_LEGS; legIdx++) {
                    const legMeshes = this.createLegMeshes(legIdx, scene);
                    this.legMeshes.push(legMeshes);
                }

                // Set initial visibility
                this.updateVisibility();
            }

            createLegMeshes(legIdx, scene) {
                const leg = this.legs[legIdx];
                const meshes = {};
                const mat = new BABYLON.StandardMaterial(`legMat${this.id}_${legIdx}`, scene);

                // Different color for each leg
                if (legIdx === 0) {
                    mat.diffuseColor = new BABYLON.Color3(0.9, 0.4, 0.2);
                } else {
                    mat.diffuseColor = new BABYLON.Color3(0.9, 0.7, 0.2);
                }
                mat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);

                // Create bars (cylinders for bones)
                meshes.L1 = BABYLON.MeshBuilder.CreateCylinder(`L1_${this.id}_${legIdx}`, {
                    height: leg.L1,
                    diameter: 0.02
                }, scene);
                meshes.L1.material = mat;

                meshes.L2 = BABYLON.MeshBuilder.CreateCylinder(`L2_${this.id}_${legIdx}`, {
                    height: leg.L2,
                    diameter: 0.02
                }, scene);
                meshes.L2.material = mat;

                meshes.L3 = BABYLON.MeshBuilder.CreateCylinder(`L3_${this.id}_${legIdx}`, {
                    height: leg.L3,
                    diameter: 0.018
                }, scene);
                meshes.L3.material = mat;

                meshes.L4 = BABYLON.MeshBuilder.CreateCylinder(`L4_${this.id}_${legIdx}`, {
                    height: leg.L4,
                    diameter: 0.018
                }, scene);
                meshes.L4.material = mat;

                // Create joint spheres
                const jointMat = new BABYLON.StandardMaterial(`jointMat${this.id}_${legIdx}`, scene);
                jointMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);

                meshes.jointA = BABYLON.MeshBuilder.CreateSphere(`jointA_${this.id}_${legIdx}`, {
                    diameter: 0.035
                }, scene);
                meshes.jointA.material = jointMat;

                meshes.jointB = BABYLON.MeshBuilder.CreateSphere(`jointB_${this.id}_${legIdx}`, {
                    diameter: 0.035
                }, scene);
                meshes.jointB.material = jointMat;

                meshes.hipJoint = BABYLON.MeshBuilder.CreateSphere(`hip_${this.id}_${legIdx}`, {
                    diameter: 0.04
                }, scene);
                meshes.hipJoint.material = jointMat;

                return meshes;
            }

            updateVisibility() {
                const showAll = gaParams.showAll;
                const isBest = this === bestCreature;

                for (const body of this.bodies) {
                    body.setEnabled(showAll || isBest);
                }

                for (const legGroup of this.legMeshes) {
                    for (const mesh of Object.values(legGroup)) {
                        mesh.setEnabled(showAll || isBest);
                    }
                }
            }

            // Forward kinematics - compute crank angle
            getCrankAngle(legIdx, time) {
                const leg = this.legs[legIdx];
                const basePhase = legIdx === 0 ? 0 : Math.PI;
                return basePhase + time * (Math.PI * 2 / gaParams.cycleDuration);
            }

            // Compute linkage positions using forward kinematics
            computeLinkage(legIdx, crankAngle) {
                const leg = this.legs[legIdx];
                const cosA = Math.cos(crankAngle);
                const sinA = Math.sin(crankAngle);

                // Hip joint position (on body)
                const hip = leg.P1.clone();

                // Crank circle center (offset from hip)
                const crankCenterX = leg.P1.x + leg.amp1 * cosA;
                const crankCenterY = leg.P1.y + leg.amp1 * sinA;
                const crankCenter = new BABYLON.Vector3(crankCenterX, crankCenterY, 0);

                // Second crank (foot drive)
                const footCenterX = leg.P2.x + leg.amp2 * Math.cos(crankAngle + leg.phase2);
                const footCenterY = leg.P2.y + leg.amp2 * Math.sin(crankAngle + leg.phase2);
                const footCenter = new BABYLON.Vector3(footCenterX, footCenterY, 0);

                // Calculate joint positions using circle intersection
                // L1 from hip to crank point
                const crankPoint = this.intersectCircles(
                    hip, leg.L1,
                    crankCenter, leg.L2
                );

                // L3 from crank to foot
                const footPoint = this.intersectCircles(
                    crankPoint, leg.L3,
                    footCenter, leg.L4
                );

                // Calculate knee joint (simplified linkage)
                const knee = this.computeKnee(crankPoint, footPoint, leg);

                return {
                    hip,
                    crankPoint,
                    footPoint,
                    knee,
                    crankCenter,
                    footCenter
                };
            }

            intersectCircles(c1, r1, c2, r2) {
                const dx = c2.x - c1.x;
                const dy = c2.y - c1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > r1 + r2 || dist < Math.abs(r1 - r2) || dist === 0) {
                    // No intersection or circles are tangent - return midpoint
                    return new BABYLON.Vector3(
                        (c1.x + c2.x) / 2,
                        (c1.y + c2.y) / 2,
                        0
                    );
                }

                // Circle intersection
                const a = (r1 * r1 - r2 * r2 + dist * dist) / (2 * dist);
                const h = Math.sqrt(Math.max(0, r1 * r1 - a * a));

                const x2 = c1.x + a * dx / dist;
                const y2 = c1.y + a * dy / dist;

                // Choose the upper intersection point (walking creatures step forward)
                return new BABYLON.Vector3(
                    x2 + h * dy / dist,
                    y2 - h * dx / dist,
                    0
                );
            }

            computeKnee(crankPt, footPt, leg) {
                // Simplified knee position
                const midX = (crankPt.x + footPt.x) / 2;
                const midY = (crankPt.y + footPt.y) / 2 - 0.05;
                return new BABYLON.Vector3(midX, midY, 0);
            }

            // Position and orient a mesh between two points
            positionBar(mesh, p1, p2) {
                const center = p1.add(p2).scale(0.5);
                mesh.position = center;

                const diff = p2.subtract(p1);
                const length = diff.length();
                mesh.scaling.y = length;

                const angle = Math.atan2(diff.y, diff.x);
                mesh.rotation.z = angle;
            }

            update(dt) {
                if (!this.isAlive) return;

                this.time += dt;

                // Update leg phases
                for (let legIdx = 0; legIdx < NUM_LEGS; legIdx++) {
                    this.legPhase[legIdx] = this.getCrankAngle(legIdx, this.time);
                }

                // Compute linkage positions for each leg
                const legPositions = [];
                for (let legIdx = 0; legIdx < NUM_LEGS; legIdx++) {
                    legPositions.push(this.computeLinkage(legIdx, this.legPhase[legIdx]));
                }

                // Calculate foot positions and determine ground contact
                const footPositions = [];
                let numContact = 0;

                for (let legIdx = 0; legIdx < NUM_LEGS; legIdx++) {
                    const pos = legPositions[legIdx];
                    const footPos = pos.footPoint.clone();

                    // Transform to world space
                    const worldFoot = this.bodyToWorld(footPos);
                    footPositions.push(worldFoot);

                    // Ground contact detection
                    if (worldFoot.y <= 0.02) {
                        numContact++;
                    }
                }

                // Simple walking motion - move body based on leg positions
                // The creature moves in the positive X direction
                let forwardSpeed = 0;
                let verticalSpeed = 0;

                // Use the leg with ground contact to determine movement
                if (numContact > 0) {
                    // Calculate body bobbing
                    const bodyHeight = 0.15 + 0.05 * Math.sin(this.time * Math.PI * 2 / gaParams.cycleDuration);
                    verticalSpeed = Math.cos(this.time * Math.PI * 2 / gaParams.cycleDuration) * 0.02;

                    // Forward motion from leg cycle
                    forwardSpeed = 0.3 * Math.sin(this.time * Math.PI * 2 / gaParams.cycleDuration);
                }

                // Apply velocity
                this.velocity.x = forwardSpeed;
                this.velocity.y = verticalSpeed;

                // Update position
                this.position.x += this.velocity.x * dt;
                this.position.y += Math.max(0, this.velocity.y * dt + 0.15);

                // Calculate orientation (slight tilt based on leg positions)
                const legDiff = legPositions[1].footPoint.y - legPositions[0].footPoint.y;
                this.orientation = legDiff * 0.1;

                // Clamp to ground
                if (this.position.y < 0.1) {
                    this.position.y = 0.1;
                    this.velocity.y = 0;
                }

                // Calculate stability (based on body height and orientation)
                const heightStable = this.position.y > 0.12 && this.position.y < 0.25;
                const angleStable = Math.abs(this.orientation) < 0.3;
                this.stability = (heightStable && angleStable) ? 100 : 50;

                // Update distance traveled
                this.distance = this.position.x;

                // Check if creature has fallen
                if (this.position.y < 0.05 || Math.abs(this.orientation) > 0.5) {
                    this.stability = 0;
                }

                // Update meshes
                this.updateMeshes(legPositions);
            }

            bodyToWorld(localPos) {
                // Transform local position to world space
                const cos = Math.cos(this.orientation);
                const sin = Math.sin(this.orientation);

                const worldX = this.position.x + localPos.x * cos - localPos.y * sin;
                const worldY = this.position.y + localPos.x * sin + localPos.y * cos;
                const worldZ = localPos.z;

                return new BABYLON.Vector3(worldX, worldY, worldZ);
            }

            updateMeshes(legPositions) {
                // Update body position and rotation
                if (this.bodies[0]) {
                    this.bodies[0].position = this.position.clone();
                    this.bodies[0].rotation.z = this.orientation;
                }

                // Update leg meshes
                for (let legIdx = 0; legIdx < NUM_LEGS; legIdx++) {
                    const meshes = this.legMeshes[legIdx];
                    const pos = legPositions[legIdx];

                    // Transform positions to world space
                    const hipWorld = this.bodyToWorld(pos.hip);
                    const crankWorld = this.bodyToWorld(pos.crankPoint);
                    const footWorld = this.bodyToWorld(pos.footPoint);
                    const kneeWorld = this.bodyToWorld(pos.knee);

                    // Position bars
                    this.positionBar(meshes.L1, hipWorld, crankWorld);
                    this.positionBar(meshes.L2, crankWorld, kneeWorld);
                    this.positionBar(meshes.L3, kneeWorld, footWorld);
                    this.positionBar(meshes.L4, footWorld, this.bodyToWorld(pos.footCenter));

                    // Position joints
                    meshes.hipJoint.position = hipWorld;
                    meshes.jointA.position = crankWorld;
                    meshes.jointB.position = footWorld;
                }
            }

            calculateFitness() {
                // Fitness = distance * stability * movement efficiency
                const distanceBonus = Math.max(0, this.distance);
                const stabilityFactor = this.stability / 100;
                const movementBonus = this.velocity.x > 0 ? 1.0 : 0.5; // Prefer forward movement

                this.fitness = distanceBonus * stabilityFactor * movementBonus;

                // Penalize creatures that don't move
                if (this.distance < 0.01) {
                    this.fitness *= 0.1;
                }

                return this.fitness;
            }

            cleanup() {
                for (const body of this.bodies) {
                    if (body) body.dispose();
                }
                for (const legGroup of this.legMeshes) {
                    for (const mesh of Object.values(legGroup)) {
                        if (mesh) mesh.dispose();
                    }
                }
            }
        }

        // ============================================
        // Genetic Algorithm
        // ============================================
        class GeneticAlgorithm {
            constructor() {
                this.population = [];
                this.generation = 0;
                this.bestGenome = null;
                this.bestFitness = 0;
            }

            initialize() {
                this.population = [];
                for (let i = 0; i < gaParams.populationSize; i++) {
                    const creature = new Creature(null, i);
                    this.population.push(creature);
                }
                this.generation = 0;
                this.bestFitness = 0;
            }

            evaluateGeneration() {
                let totalFitness = 0;
                let bestInGen = null;
                let bestFitInGen = -Infinity;

                for (const creature of this.population) {
                    creature.calculateFitness();
                    totalFitness += creature.fitness;

                    if (creature.fitness > bestFitInGen) {
                        bestFitInGen = creature.fitness;
                        bestInGen = creature;
                    }
                }

                // Update global best
                if (bestFitInGen > this.bestFitness) {
                    this.bestFitness = bestFitInGen;
                    this.bestGenome = [...bestInGen.genome];
                }

                return {
                    avgFitness: totalFitness / this.population.length,
                    bestFitness: bestFitInGen,
                    bestCreature: bestInGen
                };
            }

            selection() {
                // Tournament selection
                const selected = [];

                for (let i = 0; i < this.population.length; i++) {
                    const winner = this.tournamentSelect();
                    selected.push(winner);
                }

                return selected;
            }

            tournamentSelect() {
                let best = null;
                let bestFitness = -Infinity;

                for (let i = 0; i < gaParams.tournamentSize; i++) {
                    const idx = Math.floor(Math.random() * this.population.length);
                    if (this.population[idx].fitness > bestFitness) {
                        bestFitness = this.population[idx].fitness;
                        best = this.population[idx];
                    }
                }

                return best;
            }

            crossover(parent1, parent2) {
                // Blend crossover for real-valued genes
                const childGenome = [];
                const alpha = 0.5;

                for (let i = 0; i < GENOME_LENGTH; i++) {
                    const gene1 = parent1.genome[i];
                    const gene2 = parent2.genome[i];
                    childGenome.push(gene1 * alpha + gene2 * (1 - alpha));
                }

                return childGenome;
            }

            mutate(genome) {
                const mutated = [...genome];

                for (let i = 0; i < GENOME_LENGTH; i++) {
                    if (Math.random() < gaParams.mutationRate) {
                        // Gaussian mutation
                        mutated[i] += (Math.random() - 0.5) * 0.2;
                        mutated[i] = Math.max(0, Math.min(1, mutated[i]));
                    }
                }

                return mutated;
            }

            evolve() {
                // Evaluate current generation
                const stats = this.evaluateGeneration();

                // Create new population
                const newPopulation = [];

                // Elitism - keep best individuals
                const sorted = [...this.population].sort((a, b) => b.fitness - a.fitness);

                for (let i = 0; i < gaParams.eliteCount; i++) {
                    const elite = new Creature([...sorted[i].genome], i);
                    newPopulation.push(elite);
                }

                // Generate rest through selection, crossover, mutation
                const selected = this.selection();

                while (newPopulation.length < gaParams.populationSize) {
                    const parent1 = selected[Math.floor(Math.random() * selected.length)];
                    const parent2 = selected[Math.floor(Math.random() * selected.length)];

                    let childGenome = this.crossover(parent1, parent2);
                    childGenome = this.mutate(childGenome);

                    const child = new Creature(childGenome, newPopulation.length);
                    newPopulation.push(child);
                }

                // Clean up old meshes
                for (const creature of this.population) {
                    creature.cleanup();
                }

                this.population = newPopulation;
                this.generation++;

                return stats;
            }

            getBestCreature() {
                if (this.bestGenome) {
                    return new Creature([...this.bestGenome], -1);
                }
                return null;
            }
        }

        // Global GA instance
        let ga = new GeneticAlgorithm();

        // ============================================
        // Babylon.js Scene Setup
        // ============================================
        function createScene() {
            const canvas = document.getElementById('renderCanvas');
            engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.15, 1);

            // Camera
            camera = new BABYLON.ArcRotateCamera('camera', -Math.PI / 2, Math.PI / 3, 8, new BABYLON.Vector3(0, 0.5, 0), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 2;
            camera.upperRadiusLimit = 20;
            camera.wheelPrecision = 50;

            // Lighting
            const hemiLight = new BABYLON.HemisphericLight('hemiLight', new BABYLON.Vector3(0, 1, 0), scene);
            hemiLight.intensity = 0.6;
            hemiLight.diffuse = new BABYLON.Color3(0.9, 0.9, 1);
            hemiLight.groundColor = new BABYLON.Color3(0.3, 0.3, 0.4);

            const dirLight = new BABYLON.DirectionalLight('dirLight', new BABYLON.Vector3(-1, -2, -1), scene);
            dirLight.intensity = 0.8;
            dirLight.position = new BABYLON.Vector3(5, 10, 5);

            // Shadows
            const shadowGenerator = new BABYLON.ShadowGenerator(1024, dirLight);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;

            // Ground
            ground = BABYLON.MeshBuilder.CreateGround('ground', {
                width: 50,
                height: 20
            }, scene);
            ground.position.x = 10;

            const groundMat = new BABYLON.StandardMaterial('groundMat', scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.15, 0.2, 0.25);
            groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            // Grid texture
            const gridTexture = new BABYLON.DynamicTexture('gridTex', 512, scene);
            const ctx = gridTexture.getContext();
            ctx.fillStyle = '#1a2a35';
            ctx.fillRect(0, 0, 512, 512);
            ctx.strokeStyle = '#2a3a45';
            ctx.lineWidth = 2;

            const divisions = 20;
            const step = 512 / divisions;

            for (let i = 0; i <= divisions; i++) {
                ctx.beginPath();
                ctx.moveTo(i * step, 0);
                ctx.lineTo(i * step, 512);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i * step);
                ctx.lineTo(512, i * step);
                ctx.stroke();
            }

            gridTexture.update();
            groundMat.diffuseTexture = gridTexture;
            ground.material = groundMat;
            ground.receiveShadows = true;

            // Start line marker
            const startLine = BABYLON.MeshBuilder.CreateBox('startLine', {
                width: 0.05,
                height: 0.02,
                depth: 20
            }, scene);
            startLine.position = new BABYLON.Vector3(0, 0.01, 0);
            const startMat = new BABYLON.StandardMaterial('startMat', scene);
            startMat.diffuseColor = new BABYLON.Color3(0, 1, 0.5);
            startLine.material = startMat;

            // Distance markers
            for (let d = 5; d <= 30; d += 5) {
                const marker = BABYLON.MeshBuilder.CreateBox(`marker${d}`, {
                    width: 0.05,
                    height: 0.02,
                    depth: 2
                }, scene);
                marker.position = new BABYLON.Vector3(d, 0.01, 0);
                marker.material = startMat;
            }

            // Set camera view
            setCameraView(0);

            return scene;
        }

        // ============================================
        // UI Setup
        // ============================================
        function setupUI() {
            // Population size
            document.getElementById('pop-size').addEventListener('input', function() {
                gaParams.populationSize = parseInt(this.value);
                document.getElementById('pop-value').textContent = gaParams.populationSize;
            });

            // Mutation rate
            document.getElementById('mutation-rate').addEventListener('input', function() {
                gaParams.mutationRate = parseFloat(this.value);
                document.getElementById('mutation-value').textContent = gaParams.mutationRate.toFixed(2);
            });

            // Cycle duration
            document.getElementById('cycle-duration').addEventListener('input', function() {
                gaParams.cycleDuration = parseFloat(this.value);
                document.getElementById('cycle-value').textContent = gaParams.cycleDuration.toFixed(1) + 's';
            });

            // Simulation speed
            document.getElementById('sim-speed').addEventListener('input', function() {
                gaParams.simSpeed = parseFloat(this.value);
                document.getElementById('sim-speed-value').textContent = gaParams.simSpeed.toFixed(2) + 'x';
            });

            // Show all checkbox
            document.getElementById('show-all').addEventListener('change', function() {
                gaParams.showAll = this.checked;
                for (const creature of creatures) {
                    creature.updateVisibility();
                }
            });

            // Auto camera checkbox
            document.getElementById('auto-cam').addEventListener('change', function() {
                gaParams.autoCam = this.checked;
            });

            // Start button
            document.getElementById('start-btn').addEventListener('click', function() {
                if (!isRunning) {
                    startEvolution();
                }
            });

            // Pause button
            document.getElementById('pause-btn').addEventListener('click', function() {
                if (isRunning) {
                    isPaused = !isPaused;
                    this.textContent = isPaused ? 'Resume' : 'Pause';
                    updateStatus(isPaused ? 'paused' : 'running');
                }
            });

            // Reset button
            document.getElementById('reset-btn').addEventListener('click', function() {
                resetEvolution();
            });

            // Replay best button
            document.getElementById('replay-btn').addEventListener('click', function() {
                replayBest();
            });

            // Camera buttons
            document.querySelectorAll('.camera-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.camera-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    setCameraView(parseInt(this.dataset.view));
                });
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                if (e.code === 'Space') {
                    e.preventDefault();
                    if (!isRunning) {
                        startEvolution();
                    } else {
                        isPaused = !isPaused;
                        document.getElementById('pause-btn').textContent = isPaused ? 'Resume' : 'Pause';
                        updateStatus(isPaused ? 'paused' : 'running');
                    }
                } else if (e.code === 'KeyR') {
                    resetEvolution();
                } else if (e.code === 'KeyB') {
                    replayBest();
                } else if (e.code >= 'Digit1' && e.code <= 'Digit5') {
                    const view = parseInt(e.code.slice(-1)) - 1;
                    document.querySelectorAll('.camera-btn').forEach(b => b.classList.remove('active'));
                    document.querySelector(`.camera-btn[data-view="${view}"]`)?.classList.add('active');
                    setCameraView(view);
                }
            });
        }

        function setCameraView(view) {
            switch (view) {
                case 0: // Side
                    camera.alpha = -Math.PI / 2;
                    camera.beta = Math.PI / 4;
                    camera.radius = 8;
                    break;
                case 1: // Front
                    camera.alpha = 0;
                    camera.beta = Math.PI / 3;
                    camera.radius = 6;
                    break;
                case 2: // Top
                    camera.alpha = -Math.PI / 2;
                    camera.beta = 0.1;
                    camera.radius = 10;
                    break;
                case 3: // Follow
                    if (bestCreature) {
                        camera.target = bestCreature.position.clone();
                    }
                    camera.alpha = -Math.PI / 2;
                    camera.beta = Math.PI / 4;
                    camera.radius = 5;
                    break;
            }
        }

        function updateStatus(status) {
            const badge = document.getElementById('status-badge');
            badge.className = 'status-badge';

            switch (status) {
                case 'running':
                    badge.classList.add('status-running');
                    badge.textContent = 'Running';
                    break;
                case 'paused':
                    badge.classList.add('status-paused');
                    badge.textContent = 'Paused';
                    break;
                case 'stopped':
                    badge.classList.add('status-stopped');
                    badge.textContent = 'Ready';
                    break;
            }
        }

        // ============================================
        // Evolution Control
        // ============================================
        function startEvolution() {
            // Initialize GA if needed
            if (ga.population.length === 0) {
                ga.initialize();
            }

            // Create meshes for population
            for (const creature of ga.population) {
                creature.createMeshes(scene);
            }

            creatures = ga.population;
            isRunning = true;
            isPaused = false;
            simTime = 0;
            generationStartTime = performance.now();
            updateStatus('running');
        }

        function resetEvolution() {
            isRunning = false;
            isPaused = false;
            simTime = 0;
            generation = 0;

            // Clean up meshes
            for (const creature of creatures) {
                creature.cleanup();
            }
            creatures = [];
            bestCreature = null;

            // Reset GA
            ga = new GeneticAlgorithm();

            // Update UI
            document.getElementById('gen-number').textContent = '0';
            document.getElementById('best-dist').textContent = '0.00 m';
            document.getElementById('avg-dist').textContent = '0.00 m';
            document.getElementById('best-stab').textContent = '100%';
            document.getElementById('progress-fill').style.width = '0%';
            document.getElementById('start-btn').textContent = 'Start';
            document.getElementById('pause-btn').textContent = 'Pause';
            document.getElementById('creature-count').textContent = '0';
            updateStatus('stopped');
        }

        function replayBest() {
            // Clean up current creatures
            for (const creature of creatures) {
                creature.cleanup();
            }

            // Create best creature
            bestCreature = ga.getBestCreature();
            if (bestCreature) {
                bestCreature.createMeshes(scene);
                creatures = [bestCreature];

                // Reset sim time
                simTime = 0;
                bestCreature.time = 0;
                bestCreature.position = new BABYLON.Vector3(0, 0, 0);

                // Update visibility
                gaParams.showAll = false;
                document.getElementById('show-all').checked = false;
                bestCreature.updateVisibility();

                // Update camera to follow
                document.querySelectorAll('.camera-btn').forEach(b => b.classList.remove('active'));
                document.querySelector('.camera-btn[data-view="3"]').classList.add('active');
                setCameraView(3);
            }
        }

        function evolveGeneration() {
            // Evolve GA
            const stats = ga.evolve();
            generation = ga.generation;

            // Update best creature reference
            bestCreature = ga.getBestCreature();

            // Update UI
            document.getElementById('gen-number').textContent = generation;
            document.getElementById('best-dist').textContent = stats.bestCreature.distance.toFixed(2) + ' m';
            document.getElementById('avg-dist').textContent = (stats.avgFitness * 10).toFixed(2) + ' m';
            document.getElementById('best-stab').textContent = stats.bestCreature.stability.toFixed(0) + '%';

            const genTime = (performance.now() - generationStartTime) / 1000;
            document.getElementById('gen-time').textContent = genTime.toFixed(1) + 's';
            generationStartTime = performance.now();

            // Reset sim time for new generation
            simTime = 0;

            // Update creature visibility
            for (const creature of creatures) {
                creature.updateVisibility();
            }
        }

        // ============================================
        // Main Loop
        // ============================================
        let lastTime = 0;
        const generationDuration = 8.0; // seconds per generation

        function animate(time) {
            const deltaTime = (time - lastTime) / 1000;
            lastTime = time;

            if (isRunning && !isPaused) {
                const scaledDt = deltaTime * gaParams.simSpeed;
                simTime += scaledDt;

                // Update all creatures
                for (const creature of creatures) {
                    creature.update(scaledDt);
                }

                // Update progress bar
                const progress = (simTime / generationDuration) * 100;
                document.getElementById('progress-fill').style.width = progress + '%';

                // Update simulation time display
                document.getElementById('sim-time').textContent = simTime.toFixed(2) + 's';
                document.getElementById('creature-count').textContent = creatures.length;

                // Auto camera follow
                if (gaParams.autoCam && bestCreature) {
                    camera.target.x = bestCreature.position.x + 2;
                    camera.target.y = 0.5;
                }

                // Check if generation is complete
                if (simTime >= generationDuration) {
                    evolveGeneration();
                }
            }

            engine.render();
            requestAnimationFrame(animate);
        }

        // ============================================
        // Initialize
        // ============================================
        window.addEventListener('DOMContentLoaded', function() {
            createScene();
            setupUI();

            // Start render loop
            requestAnimationFrame(animate);

            // Handle window resize
            window.addEventListener('resize', function() {
                engine.resize();
            });
        });
    </script>

<script>
/**
 * Iframe 元素高亮注入脚本
 * 需要在目标网站中引入此脚本来支持跨域 iframe 高亮功能
 *
 * 使用方法：
 * 1. 将此脚本添加到目标网站的 HTML 中
 * 2. 或通过浏览器扩展、用户脚本等方式注入
 */

(function () {
  "use strict";

  // 检查是否在 iframe 中
  if (window.self === window.top) {
    return; // 不在 iframe 中，不执行
  }

  // 检查是否已经初始化过
  if (window.__iframeHighlightInitialized) {
    return;
  }
  window.__iframeHighlightInitialized = true;
  console.log("Iframe 高亮脚本已加载");

  // 创建高亮覆盖层
  var overlay = document.createElement("div");
  overlay.id = "iframe-highlight-overlay";
  overlay.style.cssText = "\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n    pointer-events: none;\n    z-index: 999999;\n    overflow: hidden;\n  ";

  // 创建悬停高亮框（虚线边框）
  var highlightBox = document.createElement("div");
  highlightBox.id = "iframe-highlight-box";
  highlightBox.style.cssText = "\n    position: absolute;\n    border: 2px dashed #007AFF;\n    background: rgba(0, 122, 255, 0.08);\n    pointer-events: none;\n    display: none;\n    transition: all 0.1s ease;\n    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.8);\n    border-radius: 2px;\n  ";

  // 创建选中节点的常驻高亮框（实线边框）
  var selectedBox = document.createElement("div");
  selectedBox.id = "iframe-selected-box";
  selectedBox.style.cssText = "\n    position: absolute;\n    border: 2px solid #007AFF;\n    pointer-events: none;\n    display: none;\n    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.9), 0 0 8px rgba(255, 107, 53, 0.4);\n    border-radius: 2px;\n    z-index: 1000000;\n  ";

  // 创建悬停标签显示
  var tagLabel = document.createElement("div");
  tagLabel.id = "iframe-tag-label";
  tagLabel.style.cssText = "\n    position: absolute;\n    background: #007AFF;\n    color: white;\n    padding: 2px 6px;\n    font-size: 11px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    border-radius: 2px;\n    pointer-events: none;\n    display: none;\n    white-space: nowrap;\n    z-index: 1000001;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    font-weight: 500;\n  ";

  // 创建选中节点标签
  var selectedLabel = document.createElement("div");
  selectedLabel.id = "iframe-selected-label";
  selectedLabel.style.cssText = "\n    position: absolute;\n    background: #007AFF;\n    color: white;\n    padding: 3px 8px;\n    font-size: 11px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    border-radius: 3px;\n    pointer-events: none;\n    display: none;\n    white-space: nowrap;\n    z-index: 1000002;\n    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);\n    font-weight: 600;\n  ";
  overlay.appendChild(highlightBox);
  overlay.appendChild(selectedBox);
  overlay.appendChild(tagLabel);
  overlay.appendChild(selectedLabel);
  document.body.appendChild(overlay);

  // 存储当前选中的元素
  var selectedElement = null;
  var highlightEnabled = false;

  // 更新选中元素的高亮显示
  function updateSelectedHighlight(element) {
    console.log("updateSelectedHighlight called with:", element);
    if (!element) {
      selectedBox.style.display = "none";
      selectedLabel.style.display = "none";
      selectedElement = null;
      console.log("Cleared selected highlight");
      return;
    }
    selectedElement = element;
    var rect = element.getBoundingClientRect();
    console.log("Selected element rect:", rect);

    // 更新选中高亮框位置
    selectedBox.style.display = "block";
    selectedBox.style.left = "".concat(rect.left - 2, "px");
    selectedBox.style.top = "".concat(rect.top - 2, "px");
    selectedBox.style.width = "".concat(rect.width + 4, "px");
    selectedBox.style.height = "".concat(rect.height + 4, "px");

    // 更新选中标签位置和内容
    selectedLabel.style.display = "block";
    selectedLabel.textContent = "\u2713 <".concat(element.tagName.toLowerCase(), ">");

    // 计算标签位置，确保不超出视窗
    var labelTop = rect.top - 28;
    var labelLeft = rect.left;

    // 如果标签会超出顶部，显示在元素下方
    if (labelTop < 5) {
      labelTop = rect.bottom + 5;
    }

    // 如果标签会超出右侧，向左调整
    var labelWidth = selectedLabel.offsetWidth || 100; // 预估宽度
    if (labelLeft + labelWidth > window.innerWidth - 10) {
      labelLeft = window.innerWidth - labelWidth - 10;
    }
    selectedLabel.style.left = "".concat(Math.max(5, labelLeft), "px");
    selectedLabel.style.top = "".concat(labelTop, "px");
    console.log("Selected highlight positioned at:", {
      left: selectedBox.style.left,
      top: selectedBox.style.top,
      width: selectedBox.style.width,
      height: selectedBox.style.height
    });
  }
  function getElementSelector(element) {
    if (!(element instanceof Element)) throw new Error('Argument must be a DOM element');
    var segments = [];
    var current = element;
    while (current !== document.documentElement) {
      var selector = '';
      // 优先检查唯一ID
      if (current.id && document.querySelectorAll("#".concat(current.id)).length === 1) {
        segments.unshift("#".concat(current.id));
        break; // ID唯一，无需继续向上
      }

      // 生成类名选择器（取第一个有效类名）
      var classes = Array.from(current.classList).filter(function (c) {
        return !c.startsWith('js-');
      });
      var className = classes.length > 0 ? ".".concat(classes[0]) : '';

      // 生成位置索引（nth-child）
      var tag = current.tagName.toLowerCase();
      if (!className) {
        var siblings = Array.from(current.parentNode.children);
        var index = siblings.findIndex(function (el) {
          return el === current;
        }) + 1;
        selector = "".concat(tag, ":nth-child(").concat(index, ")");
      } else {
        selector = className;
      }
      segments.unshift(selector);
      current = current.parentElement;
    }

    // 处理根元素
    if (current === document.documentElement) {
      segments.unshift('html');
    }
    return segments.join(' > ');
  }

  // 获取元素文本内容
  function getElementText(element) {
    var _element$textContent;
    if (element.tagName === "INPUT") {
      return element.value || element.placeholder || "";
    }
    if (element.tagName === "TEXTAREA") {
      return element.value || element.placeholder || "";
    }
    var text = ((_element$textContent = element.textContent) === null || _element$textContent === void 0 ? void 0 : _element$textContent.trim()) || "";
    return text.length > 50 ? text.substring(0, 50) + "..." : text;
  }

  // 获取元素属性信息
  function getElementAttributes(element) {
    var attrs = {};
    for (var i = 0; i < element.attributes.length; i++) {
      var attr = element.attributes[i];
      attrs[attr.name] = attr.value;
    }
    return attrs;
  }

  // 鼠标悬停事件处理
  function handleMouseOver(e) {
    if (!highlightEnabled) return;
    var target = e.target;
    if (!target || target === overlay || target === highlightBox || target === tagLabel || target === selectedBox || target === selectedLabel) {
      return;
    }

    // 避免高亮 html 和 body 元素
    if (target === document.documentElement || target === document.body) {
      return;
    }

    // 如果是已选中的元素，不显示悬停高亮
    if (target === selectedElement) {
      highlightBox.style.display = "none";
      tagLabel.style.display = "none";
      return;
    }
    var rect = target.getBoundingClientRect();
    var selector = getElementSelector(target);
    var text = getElementText(target);
    var attributes = getElementAttributes(target);

    // 更新悬停高亮框位置
    highlightBox.style.display = "block";
    highlightBox.style.left = "".concat(rect.left - 2, "px");
    highlightBox.style.top = "".concat(rect.top - 2, "px");
    highlightBox.style.width = "".concat(rect.width + 4, "px");
    highlightBox.style.height = "".concat(rect.height + 4, "px");

    // 更新标签位置和内容
    tagLabel.style.display = "block";
    tagLabel.textContent = "<".concat(target.tagName.toLowerCase(), ">");

    // 计算标签位置，确保不超出视窗
    var labelTop = rect.top - 22;
    var labelLeft = rect.left;

    // 如果标签会超出顶部，显示在元素下方
    if (labelTop < 0) {
      labelTop = rect.bottom + 5;
    }

    // 如果标签会超出右侧，向左调整
    if (labelLeft + tagLabel.offsetWidth > window.innerWidth) {
      labelLeft = window.innerWidth - tagLabel.offsetWidth - 5;
    }
    tagLabel.style.left = "".concat(Math.max(0, labelLeft), "px");
    tagLabel.style.top = "".concat(labelTop, "px");

    // 发送消息到父窗口
    var elementInfo = {
      tagName: target.tagName.toLowerCase(),
      rect: {
        left: rect.left,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.width,
        height: rect.height,
        x: rect.x,
        y: rect.y
      },
      selector: selector,
      text: text,
      attributes: attributes,
      url: window.location.href,
      path: window.location.pathname,
      timestamp: Date.now()
    };
    try {
      window.parent.postMessage({
        type: "iframe-element-hover",
        data: elementInfo,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("无法发送消息到父窗口:", error);
    }
  }

  // 鼠标离开事件处理
  function handleMouseOut(e) {
    if (!highlightEnabled) return;
    var relatedTarget = e.relatedTarget;

    // 如果鼠标移动到高亮相关元素上，不隐藏高亮
    if (relatedTarget && (relatedTarget === highlightBox || relatedTarget === tagLabel || relatedTarget === overlay || relatedTarget === selectedBox || relatedTarget === selectedLabel)) {
      return;
    }
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    try {
      window.parent.postMessage({
        type: "iframe-element-hover",
        data: null,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("无法发送消息到父窗口:", error);
    }
  }

  // 点击事件处理
  function handleClick(e) {
    var target = e.target;
    if (!target || target === overlay || target === highlightBox || target === tagLabel || target === selectedBox || target === selectedLabel) {
      return;
    }

    // 避免处理 html 和 body 元素
    if (target === document.documentElement || target === document.body) {
      return;
    }

    // 检查是否是交互元素，这些元素需要保留默认行为
    var isInteractiveElement = ['input', 'textarea', 'select', 'button', 'a'].includes(target.tagName.toLowerCase());

    // 如果高亮功能启用，对于非交互元素阻止默认行为和事件传播
    if (highlightEnabled) {
      e.preventDefault();
      e.stopPropagation();
    }
    var rect = target.getBoundingClientRect();
    var selector = getElementSelector(target);
    var text = getElementText(target);
    var attributes = getElementAttributes(target);
    console.log("Element clicked:", {
      tagName: target.tagName,
      selector: selector,
      rect: rect
    });

    // 立即更新选中高亮
    updateSelectedHighlight(target);

    // 隐藏悬停高亮，因为现在是选中状态
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    var elementInfo = {
      tagName: target.tagName.toLowerCase(),
      rect: {
        left: rect.left,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.width,
        height: rect.height,
        x: rect.x,
        y: rect.y
      },
      selector: selector,
      text: text,
      attributes: attributes,
      url: window.location.href,
      path: window.location.pathname,
      timestamp: Date.now()
    };
    try {
      window.parent.postMessage({
        type: "iframe-element-click",
        data: elementInfo,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("无法发送消息到父窗口:", error);
    }
  }

  // 监听来自父窗口的消息
  function handleParentMessage(event) {
    console.log("Received message from parent:", event.data);
    if (event.data.type === "iframe-highlight-toggle") {
      var enabled = event.data.enabled;
      console.log("Highlight toggle:", enabled);
      if (enabled) {
        enableHighlight();
      } else {
        disableHighlight();
      }
    } else if (event.data.type === "enable-iframe-highlight") {
      console.log("Enable iframe highlight");
      enableHighlight();
    } else if (event.data.type === "disable-iframe-highlight") {
      console.log("Disable iframe highlight");
      disableHighlight();
    } else if (event.data.type === "toggle-iframe-highlight") {
      var _enabled = event.data.enabled !== undefined ? event.data.enabled : !highlightEnabled;
      console.log("Toggle iframe highlight to:", _enabled);
      if (_enabled) {
        enableHighlight();
      } else {
        disableHighlight();
      }
    } else if (event.data.type === "update-selected-element") {
      var selector = event.data.selector;
      console.log("Update selected element with selector:", selector);
      if (selector) {
        try {
          var element = document.querySelector(selector);
          console.log("Found element by selector:", element);
          updateSelectedHighlight(element);
        } catch (error) {
          console.warn("Failed to select element:", error);
          updateSelectedHighlight(null);
        }
      } else {
        updateSelectedHighlight(null);
      }
    } else if (event.data.type === "clear-selected-element") {
      console.log("Clear selected element");
      updateSelectedHighlight(null);
    }
  }

  // 启用高亮功能
  function enableHighlight() {
    console.log("Enabling highlight");
    document.addEventListener("mouseover", handleMouseOver, true);
    document.addEventListener("mouseout", handleMouseOut, true);
    document.addEventListener("click", handleClick, true);
    highlightEnabled = true;
    overlay.style.display = "block";
  }

  // 禁用高亮功能
  function disableHighlight() {
    console.log("Disabling highlight");
    highlightEnabled = false;
    // 保持事件监听器，但通过 highlightEnabled 变量控制行为
    // 这样可以保留选中状态的显示
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    // 不隐藏 selectedBox 和 selectedLabel，保留选中状态
  }

  // 完全禁用高亮功能（移除所有监听器）
  function fullyDisableHighlight() {
    console.log("Fully disabling highlight");
    highlightEnabled = false;
    document.removeEventListener("mouseover", handleMouseOver, true);
    document.removeEventListener("mouseout", handleMouseOut, true);
    document.removeEventListener("click", handleClick, true);
    overlay.style.display = "none";
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    selectedBox.style.display = "none";
    selectedLabel.style.display = "none";
  }

  // 添加事件监听
  enableHighlight();
  window.addEventListener("message", handleParentMessage);

  // 暴露全局函数供外部调用
  window.__iframeHighlightControl = {
    enable: enableHighlight,
    disable: disableHighlight,
    fullyDisable: fullyDisableHighlight,
    isEnabled: function isEnabled() {
      return highlightEnabled;
    },
    getSelectedElement: function getSelectedElement() {
      return selectedElement;
    },
    updateSelected: updateSelectedHighlight,
    // 通过消息发送开关控制
    sendToggleMessage: function sendToggleMessage(enabled) {
      window.parent.postMessage({
        type: 'iframe-highlight-status',
        enabled: enabled || highlightEnabled,
        source: 'iframe-highlight-injector'
      }, '*');
    }
  };

  // 通知父窗口脚本已加载
  try {
    window.parent.postMessage({
      type: "iframe-highlight-ready",
      data: {
        url: window.location.href,
        userAgent: navigator.userAgent,
        timestamp: Date.now()
      },
      source: "iframe-highlight-injector"
    }, "*");
  } catch (error) {
    console.warn("无法发送就绪消息到父窗口:", error);
  }

  // 清理函数
  window.__iframeHighlightCleanup = function () {
    fullyDisableHighlight();
    window.removeEventListener("message", handleParentMessage);
    if (overlay.parentElement) {
      overlay.parentElement.removeChild(overlay);
    }
    delete window.__iframeHighlightInitialized;
    delete window.__iframeHighlightCleanup;
  };
})();

</script>
</body>
</html>
