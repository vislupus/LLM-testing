<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebPhotoshop - Professional Image Editor</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; }
        
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #2b2b2b;
            --bg-hover: #3c3c3c;
            --accent: #0078d4;
            --border: #444;
            --text: #e0e0e0;
            --text-muted: #888;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Menu Bar */
        .menu-bar {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            padding: 0 12px;
            display: flex;
            gap: 24px;
            font-size: 13px;
            height: 28px;
            align-items: center;
        }

        .menu-item {
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .menu-item:hover { background: var(--bg-hover); }

        .dropdown {
            display: none;
            position: absolute;
            top: 28px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            z-index: 1000;
            min-width: 200px;
            padding: 4px 0;
        }

        .menu-item:hover .dropdown { display: block; }

        .dropdown-item {
            padding: 6px 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
        }

        .dropdown-item:hover { background: var(--accent); color: white; }
        .dropdown-item span { color: var(--text-muted); font-size: 11px; }

        /* Main Layout */
        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Toolbox */
        .toolbox {
            width: 48px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 4px;
            gap: 2px;
        }

        .tool {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            font-size: 18px;
        }

        .tool:hover { background: var(--bg-hover); }
        .tool.active { background: var(--accent); color: white; }
        .tool::after {
            content: attr(data-key);
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 9px;
            opacity: 0.7;
        }

        /* Canvas Area */
        .canvas-area {
            flex: 1;
            background: #0a0a0a;
            position: relative;
            overflow: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .canvas-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            background: white;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        canvas.active-layer { outline: 1px solid var(--accent); }

        /* Panels */
        .panels {
            width: 240px;
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: auto;
        }

        .panel {
            border-bottom: 1px solid var(--border);
            padding: 12px;
        }

        .panel-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            color: var(--text-muted);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Layers Panel */
        .layer-item {
            background: #333;
            border: 1px solid var(--border);
            padding: 8px;
            margin-bottom: 4px;
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .layer-item.active {
            border-color: var(--accent);
            background: var(--bg-hover);
        }

        .layer-item:hover { background: var(--bg-hover); }

        .layer-visibility {
            width: 16px;
            height: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .layer-thumb {
            width: 32px;
            height: 32px;
            background: #222;
            border: 1px solid #444;
        }

        .layer-info { flex: 1; }
        .layer-name { font-weight: 500; }
        .layer-blend {
            background: #222;
            border: 1px solid #444;
            color: var(--text);
            padding: 2px 4px;
            font-size: 10px;
            width: 80px;
        }

        .layer-opacity {
            width: 50px;
            background: transparent;
            border: 1px solid #444;
            color: var(--text);
            padding: 2px;
            text-align: center;
        }

        .btn-small {
            background: #444;
            border: 1px solid #555;
            color: white;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            border-radius: 3px;
            margin-right: 4px;
            margin-bottom: 4px;
        }

        .btn-small:hover { background: #555; }

        /* History Panel */
        .history-item {
            padding: 6px 8px;
            font-size: 12px;
            cursor: pointer;
            border-radius: 3px;
            margin-bottom: 2px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .history-item:hover { background: var(--bg-hover); }
        .history-item.active { background: var(--accent); color: white; }
        .history-item::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            opacity: 0.5;
        }

        /* Color Panel */
        .color-box {
            width: 100%;
            height: 100px;
            border: 1px solid var(--border);
            margin-bottom: 8px;
            cursor: pointer;
            background: linear-gradient(to bottom right, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%);
            position: relative;
        }

        .color-indicator {
            width: 12px;
            height: 12px;
            border: 2px solid white;
            border-radius: 50%;
            position: absolute;
            box-shadow: 0 0 0 1px black;
            pointer-events: none;
        }

        .color-sliders {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
        }

        .slider-row input[type="range"] {
            flex: 1;
        }

        /* Brush Settings */
        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 11px;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #444;
            outline: none;
            border-radius: 2px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        /* Status Bar */
        .status-bar {
            height: 24px;
            background: var(--accent);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 12px;
            font-size: 11px;
            justify-content: space-between;
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            padding: 20px;
            border-radius: 8px;
            min-width: 300px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        .modal-title { margin-bottom: 16px; font-size: 16px; }
        .modal-row { margin-bottom: 12px; }
        .modal-row label { display: block; margin-bottom: 4px; font-size: 12px; }
        .modal-row input {
            width: 100%;
            background: #222;
            border: 1px solid #444;
            color: white;
            padding: 6px;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 16px;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
            border: none;
            padding: 6px 16px;
            cursor: pointer;
            border-radius: 3px;
        }

        .btn-secondary {
            background: #444;
            color: white;
            border: 1px solid #555;
            padding: 6px 16px;
            cursor: pointer;
            border-radius: 3px;
        }

        .resize-handle {
            width: 10px;
            height: 10px;
            background: var(--accent);
            position: absolute;
            right: 0;
            bottom: 0;
            cursor: se-resize;
            z-index: 100;
        }
    </style>
</head>
<body>

<div class="menu-bar">
    <div class="menu-item">File
        <div class="dropdown">
            <div class="dropdown-item" onclick="app.newDocument()">New... <span>Ctrl+N</span></div>
            <div class="dropdown-item" onclick="app.openImage()">Open... <span>Ctrl+O</span></div>
            <div class="dropdown-item" onclick="app.savePNG()">Save as PNG <span>Ctrl+S</span></div>
            <div class="dropdown-item" onclick="app.exportJPG()">Export as JPG</div>
        </div>
    </div>
    <div class="menu-item">Edit
        <div class="dropdown">
            <div class="dropdown-item" onclick="app.undo()">Undo <span>Ctrl+Z</span></div>
            <div class="dropdown-item" onclick="app.redo()">Redo <span>Ctrl+Y</span></div>
            <div class="dropdown-item" onclick="app.clearCanvas()">Clear</div>
        </div>
    </div>
    <div class="menu-item">Image
        <div class="dropdown">
            <div class="dropdown-item" onclick="app.adjustBrightness(20)">Brightness +</div>
            <div class="dropdown-item" onclick="app.adjustBrightness(-20)">Brightness -</div>
            <div class="dropdown-item" onclick="app.adjustContrast(1.2)">Contrast +</div>
            <div class="dropdown-item" onclick="app.resizeCanvas()">Canvas Size...</div>
        </div>
    </div>
    <div class="menu-item">Filter
        <div class="dropdown">
            <div class="dropdown-item" onclick="app.filterBlur()">Gaussian Blur</div>
            <div class="dropdown-item" onclick="app.filterGrayscale()">Grayscale</div>
            <div class="dropdown-item" onclick="app.filterSepia()">Sepia</div>
            <div class="dropdown-item" onclick="app.filterInvert()">Invert</div>
            <div class="dropdown-item" onclick="app.filterSharpen()">Sharpen</div>
        </div>
    </div>
</div>

<div class="main-container">
    <div class="toolbox">
        <div class="tool active" data-tool="brush" data-key="B" title="Brush">üñåÔ∏è</div>
        <div class="tool" data-tool="eraser" data-key="E" title="Eraser">üßπ</div>
        <div class="tool" data-tool="rect" data-key="R" title="Rectangle">‚¨ú</div>
        <div class="tool" data-tool="circle" data-key="C" title="Circle">‚≠ï</div>
        <div class="tool" data-tool="line" data-key="L" title="Line">üìè</div>
        <div class="tool" data-tool="fill" data-key="G" title="Paint Bucket">ü™£</div>
        <div class="tool" data-tool="picker" data-key="I" title="Eyedropper">üíß</div>
        <div class="tool" data-tool="move" data-key="V" title="Move">‚úã</div>
        <div class="tool" data-tool="text" data-key="T" title="Text">T</div>
        <div class="tool" data-tool="marquee" data-key="M" title="Marquee">‚¨õ</div>
    </div>

    <div class="canvas-area" id="canvasArea">
        <div class="canvas-container" id="canvasContainer" style="width: 800px; height: 600px;">
            <!-- Layers will be inserted here -->
        </div>
    </div>

    <div class="panels">
        <div class="panel">
            <div class="panel-title">Settings</div>
            <div id="toolSettings">
                <div class="setting-row">
                    <span>Size</span>
                    <span id="sizeVal">10</span>
                </div>
                <input type="range" id="brushSize" min="1" max="100" value="10">
                
                <div class="setting-row">
                    <span>Opacity</span>
                    <span id="opacityVal">100%</span>
                </div>
                <input type="range" id="brushOpacity" min="1" max="100" value="100">
                
                <div class="setting-row">
                    <span>Hardness</span>
                    <span id="hardnessVal">100%</span>
                </div>
                <input type="range" id="brushHardness" min="0" max="100" value="100">
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">Color</div>
            <div class="color-box" id="colorBox">
                <div class="color-indicator" id="colorIndicator"></div>
            </div>
            <div class="color-sliders">
                <div class="slider-row">
                    <span>R</span>
                    <input type="range" id="rSlider" min="0" max="255" value="0">
                </div>
                <div class="slider-row">
                    <span>G</span>
                    <input type="range" id="gSlider" min="0" max="255" value="0">
                </div>
                <div class="slider-row">
                    <span>B</span>
                    <input type="range" id="bSlider" min="0" max="255" value="0">
                </div>
            </div>
            <div id="hexColor" style="margin-top: 8px; font-family: monospace; text-align: center;">#000000</div>
        </div>

        <div class="panel">
            <div class="panel-title">History</div>
            <div id="historyList" style="max-height: 150px; overflow-y: auto;">
                <!-- History items -->
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">
                Layers
                <div>
                    <button class="btn-small" onclick="app.addLayer()">+</button>
                    <button class="btn-small" onclick="app.deleteLayer()">üóë</button>
                    <button class="btn-small" onclick="app.duplicateLayer()">‚éò</button>
                </div>
            </div>
            <div id="layersList"></div>
        </div>
    </div>
</div>

<div class="status-bar">
    <span id="statusText">Ready</span>
    <span id="zoomLevel">100%</span>
</div>

<div class="modal-overlay" id="newDocModal">
    <div class="modal">
        <div class="modal-title">New Document</div>
        <div class="modal-row">
            <label>Width (px)</label>
            <input type="number" id="newWidth" value="800">
        </div>
        <div class="modal-row">
            <label>Height (px)</label>
            <input type="number" id="newHeight" value="600">
        </div>
        <div class="modal-row">
            <label>Background</label>
            <select id="newBg" style="width: 100%; background: #222; color: white; padding: 6px; border: 1px solid #444;">
                <option value="white">White</option>
                <option value="transparent">Transparent</option>
            </select>
        </div>
        <div class="modal-buttons">
            <button class="btn-secondary" onclick="document.getElementById('newDocModal').style.display='none'">Cancel</button>
            <button class="btn-primary" onclick="app.createNewDocument()">Create</button>
        </div>
    </div>
</div>

<input type="file" id="fileInput" accept="image/*" style="display: none;">

<script>
class WebPhotoshop {
    constructor() {
        this.layers = [];
        this.activeLayerIndex = 0;
        this.history = [];
        this.historyIndex = -1;
        this.maxHistory = 20;
        
        this.width = 800;
        this.height = 600;
        
        this.tool = 'brush';
        this.brushSize = 10;
        this.brushOpacity = 100;
        this.brushHardness = 100;
        this.color = {r: 0, g: 0, b: 0};
        
        this.isDrawing = false;
        this.startPos = null;
        this.lastPos = null;
        
        this.init();
    }

    init() {
        this.container = document.getElementById('canvasContainer');
        this.setupEvents();
        this.addLayer('Background');
        this.saveState();
        this.setupColorPicker();
    }

    setupEvents() {
        // Tools
        document.querySelectorAll('.tool').forEach(tool => {
            tool.addEventListener('click', () => {
                document.querySelectorAll('.tool').forEach(t => t.classList.remove('active'));
                tool.classList.add('active');
                this.tool = tool.dataset.tool;
                this.updateCursor();
            });
        });

        // Sliders
        document.getElementById('brushSize').addEventListener('input', (e) => {
            this.brushSize = parseInt(e.target.value);
            document.getElementById('sizeVal').textContent = this.brushSize;
        });

        document.getElementById('brushOpacity').addEventListener('input', (e) => {
            this.brushOpacity = parseInt(e.target.value);
            document.getElementById('opacityVal').textContent = this.brushOpacity + '%';
        });

        document.getElementById('brushHardness').addEventListener('input', (e) => {
            this.brushHardness = parseInt(e.target.value);
            document.getElementById('hardnessVal').textContent = this.brushHardness + '%';
        });

        // Canvas interactions
        this.container.addEventListener('mousedown', this.onMouseDown.bind(this));
        document.addEventListener('mousemove', this.onMouseMove.bind(this));
        document.addEventListener('mouseup', this.onMouseUp.bind(this));

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'z') { e.preventDefault(); this.undo(); }
            if (e.ctrlKey && e.key === 'y') { e.preventDefault(); this.redo(); }
            
            const key = e.key.toLowerCase();
            const tool = document.querySelector(`[data-key="${key}"]`);
            if (tool) tool.click();
        });

        // File input
        document.getElementById('fileInput').addEventListener('change', this.loadImage.bind(this));
    }

    setupColorPicker() {
        const box = document.getElementById('colorBox');
        const indicator = document.getElementById('colorIndicator');
        const r = document.getElementById('rSlider');
        const g = document.getElementById('gSlider');
        const b = document.getElementById('bSlider');
        const hex = document.getElementById('hexColor');

        const updateColor = () => {
            this.color = {r: parseInt(r.value), g: parseInt(g.value), b: parseInt(b.value)};
            hex.textContent = '#' + [r,g,b].map(x => parseInt(x.value).toString(16).padStart(2,'0')).join('');
        };

        [r,g,b].forEach(slider => slider.addEventListener('input', updateColor));

        box.addEventListener('click', (e) => {
            const rect = box.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            
            // Simple HSV to RGB for demo
            const hue = x * 360;
            const sat = 1;
            const val = 1 - y * 0.5;
            
            this.color = this.hsvToRgb(hue, sat, val);
            r.value = this.color.r;
            g.value = this.color.g;
            b.value = this.color.b;
            updateColor();
            
            indicator.style.left = (x * 100) + '%';
            indicator.style.top = (y * 100) + '%';
        });
    }

    hsvToRgb(h, s, v) {
        const c = v * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = v - c;
        let r, g, b;
        
        if (h < 60) [r,g,b] = [c,x,0];
        else if (h < 120) [r,g,b] = [x,c,0];
        else if (h < 180) [r,g,b] = [0,c,x];
        else if (h < 240) [r,g,b] = [0,x,c];
        else if (h < 300) [r,g,b] = [x,0,c];
        else [r,g,b] = [c,0,x];
        
        return {
            r: Math.round((r + m) * 255),
            g: Math.round((g + m) * 255),
            b: Math.round((b + m) * 255)
        };
    }

    addLayer(name = null) {
        const canvas = document.createElement('canvas');
        canvas.width = this.width;
        canvas.height = this.height;
        canvas.className = 'layer-canvas';
        if (this.layers.length === 0) {
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, this.width, this.height);
        }
        
        this.container.appendChild(canvas);
        
        const layer = {
            name: name || `Layer ${this.layers.length + 1}`,
            canvas: canvas,
            ctx: canvas.getContext('2d'),
            visible: true,
            opacity: 1,
            blendMode: 'normal'
        };
        
        this.layers.push(layer);
        this.activeLayerIndex = this.layers.length - 1;
        this.updateLayersUI();
        this.saveState();
    }

    deleteLayer() {
        if (this.layers.length <= 1) return;
        const layer = this.layers[this.activeLayerIndex];
        layer.canvas.remove();
        this.layers.splice(this.activeLayerIndex, 1);
        this.activeLayerIndex = Math.max(0, this.activeLayerIndex - 1);
        this.updateLayersUI();
        this.saveState();
    }

    duplicateLayer() {
        const source = this.layers[this.activeLayerIndex];
        this.addLayer();
        const target = this.layers[this.layers.length - 1];
        target.ctx.drawImage(source.canvas, 0, 0);
        target.name = source.name + ' Copy';
        this.updateLayersUI();
        this.saveState();
    }

    setActiveLayer(index) {
        this.activeLayerIndex = index;
        this.updateLayersUI();
    }

    toggleLayerVisibility(index, e) {
        e.stopPropagation();
        this.layers[index].visible = !this.layers[index].visible;
        this.layers[index].canvas.style.visibility = this.layers[index].visible ? 'visible' : 'hidden';
        this.updateLayersUI();
    }

    updateLayersUI() {
        const list = document.getElementById('layersList');
        list.innerHTML = '';
        
        [...this.layers].reverse().forEach((layer, idx) => {
            const realIdx = this.layers.length - 1 - idx;
            const div = document.createElement('div');
            div.className = 'layer-item' + (realIdx === this.activeLayerIndex ? ' active' : '');
            div.innerHTML = `
                <div class="layer-visibility" onclick="app.toggleLayerVisibility(${realIdx}, event)">${layer.visible ? 'üëÅ' : 'üö´'}</div>
                <canvas class="layer-thumb" width="32" height="32"></canvas>
                <div class="layer-info">
                    <div class="layer-name">${layer.name}</div>
                    <div style="display: flex; gap: 4px; margin-top: 2px;">
                        <select class="layer-blend" onchange="app.setBlendMode(${realIdx}, this.value)" onclick="event.stopPropagation()">
                            <option value="normal" ${layer.blendMode === 'normal' ? 'selected' : ''}>Normal</option>
                            <option value="multiply" ${layer.blendMode === 'multiply' ? 'selected' : ''}>Multiply</option>
                            <option value="screen" ${layer.blendMode === 'screen' ? 'selected' : ''}>Screen</option>
                            <option value="overlay" ${layer.blendMode === 'overlay' ? 'selected' : ''}>Overlay</option>
                         </select>
                        <input type="number" class="layer-opacity" value="${Math.round(layer.opacity * 100)}" 
                               onchange="app.setOpacity(${realIdx}, this.value)" onclick="event.stopPropagation()">
                    </div>
                </div>
            `;
            div.addEventListener('click', () => this.setActiveLayer(realIdx));
            
            // Update thumbnail
            const thumb = div.querySelector('.layer-thumb');
            const tctx = thumb.getContext('2d');
            tctx.drawImage(layer.canvas, 0, 0, 32, 32);
            
            list.appendChild(div);
        });

        // Update active canvas visual
        document.querySelectorAll('.layer-canvas').forEach((c, i) => {
            c.classList.toggle('active-layer', i === this.activeLayerIndex);
            c.style.zIndex = i;
            c.style.opacity = this.layers[i].opacity;
            c.style.mixBlendMode = this.layers[i].blendMode === 'normal' ? '' : this.layers[i].blendMode;
        });
    }

    setBlendMode(index, mode) {
        this.layers[index].blendMode = mode;
        this.updateLayersUI();
    }

    setOpacity(index, val) {
        this.layers[index].opacity = val / 100;
        this.updateLayersUI();
    }

    getMousePos(e) {
        const rect = this.container.getBoundingClientRect();
        return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
    }

    onMouseDown(e) {
        if (e.button !== 0) return;
        this.isDrawing = true;
        const pos = this.getMousePos(e);
        this.startPos = pos;
        this.lastPos = pos;
        
        const ctx = this.layers[this.activeLayerIndex].ctx;
        
        switch(this.tool) {
            case 'brush':
            case 'eraser':
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                this.drawBrush(pos);
                break;
            case 'fill':
                this.floodFill(Math.floor(pos.x), Math.floor(pos.y));
                this.isDrawing = false;
                break;
            case 'picker':
                this.pickColor(pos.x, pos.y);
                this.isDrawing = false;
                break;
            case 'text':
                this.addText(pos.x, pos.y);
                this.isDrawing = false;
                break;
        }
    }

    onMouseMove(e) {
        if (!this.isDrawing) return;
        const pos = this.getMousePos(e);
        
        const layer = this.layers[this.activeLayerIndex];
        const ctx = layer.ctx;
        
        switch(this.tool) {
            case 'brush':
            case 'eraser':
                this.drawLine(this.lastPos, pos);
                this.lastPos = pos;
                break;
            case 'rect':
            case 'circle':
            case 'line':
            case 'marquee':
                this.drawPreview(pos);
                break;
            case 'move':
                this.moveLayer(pos.x - this.lastPos.x, pos.y - this.lastPos.y);
                this.lastPos = pos;
                break;
        }
    }

    onMouseUp(e) {
        if (!this.isDrawing) return;
        this.isDrawing = false;
        
        if (this.tool === 'rect' || this.tool === 'circle' || this.tool === 'line') {
            const pos = this.getMousePos(e);
            this.commitShape(pos);
        }
        
        this.saveState();
        this.updateLayersUI();
    }

    drawBrush(pos) {
        const layer = this.layers[this.activeLayerIndex];
        const ctx = layer.ctx;
        
        const alpha = this.brushOpacity / 100;
        ctx.globalAlpha = alpha;
        
        if (this.tool === 'eraser') {
            ctx.globalCompositeOperation = 'destination-out';
        } else {
            ctx.globalCompositeOperation = 'source-over';
        }
        
        const grad = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, this.brushSize);
        const r = this.color.r, g = this.color.g, b = this.color.b;
        grad.addColorStop(0, `rgba(${r},${g},${b},1)`);
        grad.addColorStop(this.brushHardness / 100, `rgba(${r},${g},${b},${this.brushHardness / 100})`);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, this.brushSize, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';
    }

    drawLine(from, to) {
        const dist = Math.hypot(to.x - from.x, to.y - from.y);
        const steps = Math.ceil(dist / 2);
        
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const x = from.x + (to.x - from.x) * t;
            const y = from.y + (to.y - from.y) * t;
            this.drawBrush({x, y});
        }
    }

    drawPreview(currentPos) {
        // Clear and redraw
        this.updateLayersUI();
        
        const layer = this.layers[this.activeLayerIndex];
        const ctx = layer.ctx;
        ctx.save();
        ctx.globalAlpha = 0.5;
        ctx.strokeStyle = `rgb(${this.color.r},${this.color.g},${this.color.b})`;
        ctx.fillStyle = `rgba(${this.color.r},${this.color.g},${this.color.b},0.3)`;
        ctx.lineWidth = 1;
        
        const x = Math.min(this.startPos.x, currentPos.x);
        const y = Math.min(this.startPos.y, currentPos.y);
        const w = Math.abs(currentPos.x - this.startPos.x);
        const h = Math.abs(currentPos.y - this.startPos.y);
        
        if (this.tool === 'rect') {
            ctx.fillRect(x, y, w, h);
            ctx.strokeRect(x, y, w, h);
        } else if (this.tool === 'circle') {
            ctx.beginPath();
            ctx.ellipse(x + w/2, y + h/2, w/2, h/2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
        } else if (this.tool === 'line') {
            ctx.beginPath();
            ctx.moveTo(this.startPos.x, this.startPos.y);
            ctx.lineTo(currentPos.x, currentPos.y);
            ctx.stroke();
        } else if (this.tool === 'marquee') {
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(x, y, w, h);
        }
        ctx.restore();
    }

    commitShape(endPos) {
        const layer = this.layers[this.activeLayerIndex];
        const ctx = layer.ctx;
        
        const x = Math.min(this.startPos.x, endPos.x);
        const y = Math.min(this.startPos.y, endPos.y);
        const w = Math.abs(endPos.x - this.startPos.x);
        const h = Math.abs(endPos.y - this.startPos.y);
        
        ctx.fillStyle = `rgb(${this.color.r},${this.color.g},${this.color.b})`;
        ctx.strokeStyle = `rgb(${this.color.r},${this.color.g},${this.color.b})`;
        
        if (this.tool === 'rect') {
            ctx.fillRect(x, y, w, h);
        } else if (this.tool === 'circle') {
            ctx.beginPath();
            ctx.ellipse(x + w/2, y + h/2, w/2, h/2, 0, 0, Math.PI * 2);
            ctx.fill();
        } else if (this.tool === 'line') {
            ctx.lineWidth = this.brushSize;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(this.startPos.x, this.startPos.y);
            ctx.lineTo(endPos.x, endPos.y);
            ctx.stroke();
        }
    }

    floodFill(x, y) {
        const layer = this.layers[this.activeLayerIndex];
        const ctx = layer.ctx;
        const imageData = ctx.getImageData(0, 0, this.width, this.height);
        const data = imageData.data;
        const targetColor = this.getPixel(data, x, y);
        const fillColor = [this.color.r, this.color.g, this.color.b, 255];
        
        if (this.colorsMatch(targetColor, fillColor)) return;
        
        const stack = [[x, y]];
        const width = this.width;
        const height = this.height;
        
        while (stack.length) {
            const [cx, cy] = stack.pop();
            const idx = (cy * width + cx) * 4;
            
            if (cx < 0 || cx >= width || cy < 0 || cy >= height) continue;
            if (!this.colorsMatch([data[idx], data[idx+1], data[idx+2], data[idx+3]], targetColor)) continue;
            
            data[idx] = fillColor[0];
            data[idx+1] = fillColor[1];
            data[idx+2] = fillColor[2];
            data[idx+3] = fillColor[3];
            
            stack.push([cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]);
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    getPixel(data, x, y) {
        const idx = (y * this.width + x) * 4;
        return [data[idx], data[idx+1], data[idx+2], data[idx+3]];
    }

    colorsMatch(a, b) {
        return Math.abs(a[0]-b[0]) < 10 && Math.abs(a[1]-b[1]) < 10 && 
               Math.abs(a[2]-b[2]) < 10 && Math.abs(a[3]-b[3]) < 10;
    }

    pickColor(x, y) {
        const layer = this.layers[this.activeLayerIndex];
        const pixel = layer.ctx.getImageData(x, y, 1, 1).data;
        this.color = {r: pixel[0], g: pixel[1], b: pixel[2]};
        document.getElementById('rSlider').value = this.color.r;
        document.getElementById('gSlider').value = this.color.g;
        document.getElementById('bSlider').value = this.color.b;
        document.getElementById('hexColor').textContent = '#' + 
            [this.color.r, this.color.g, this.color.b].map(v => v.toString(16).padStart(2,'0')).join('');
    }

    addText(x, y) {
        const text = prompt('Enter text:');
        if (!text) return;
        const layer = this.layers[this.activeLayerIndex];
        const ctx = layer.ctx;
        ctx.font = `${this.brushSize * 3}px Arial`;
        ctx.fillStyle = `rgb(${this.color.r},${this.color.g},${this.color.b})`;
        ctx.fillText(text, x, y);
        this.saveState();
        this.updateLayersUI();
    }

    moveLayer(dx, dy) {
        // Simplified: clear and redraw shifted (destructive)
        const layer = this.layers[this.activeLayerIndex];
        const ctx = layer.ctx;
        const data = ctx.getImageData(0, 0, this.width, this.height);
        ctx.clearRect(0, 0, this.width, this.height);
        ctx.putImageData(data, dx, dy);
    }

    // History Management
    saveState() {
        // Remove redo states
        this.history = this.history.slice(0, this.historyIndex + 1);
        
        // Save layer data
        const state = this.layers.map(l => ({
            imageData: l.ctx.getImageData(0, 0, this.width, this.height),
            name: l.name,
            visible: l.visible,
            opacity: l.opacity,
            blendMode: l.blendMode
        }));
        
        this.history.push(state);
        if (this.history.length > this.maxHistory) this.history.shift();
        else this.historyIndex++;
        
        this.updateHistoryUI();
    }

    undo() {
        if (this.historyIndex <= 0) return;
        this.historyIndex--;
        this.restoreState();
    }

    redo() {
        if (this.historyIndex >= this.history.length - 1) return;
        this.historyIndex++;
        this.restoreState();
    }

    restoreState() {
        const state = this.history[this.historyIndex];
        
        // Rebuild layers if count mismatch
        if (state.length !== this.layers.length) {
            this.container.innerHTML = '';
            this.layers = [];
            state.forEach(s => {
                const canvas = document.createElement('canvas');
                canvas.width = this.width;
                canvas.height = this.height;
                canvas.className = 'layer-canvas';
                this.container.appendChild(canvas);
                const ctx = canvas.getContext('2d');
                ctx.putImageData(s.imageData, 0, 0);
                this.layers.push({
                    name: s.name,
                    canvas: canvas,
                    ctx: ctx,
                    visible: s.visible,
                    opacity: s.opacity,
                    blendMode: s.blendMode
                });
            });
        } else {
            state.forEach((s, i) => {
                this.layers[i].ctx.putImageData(s.imageData, 0, 0);
                this.layers[i].name = s.name;
                this.layers[i].visible = s.visible;
                this.layers[i].opacity = s.opacity;
                this.layers[i].blendMode = s.blendMode;
                this.layers[i].canvas.style.visibility = s.visible ? 'visible' : 'hidden';
            });
        }
        
        this.updateLayersUI();
        this.updateHistoryUI();
    }

    updateHistoryUI() {
        const list = document.getElementById('historyList');
        list.innerHTML = '';
        
        const actions = ['New Document', 'Brush Stroke', 'Shape', 'Filter', 'Fill', 'Text', 'Clear'];
        
        this.history.forEach((state, idx) => {
            const div = document.createElement('div');
            div.className = 'history-item' + (idx === this.historyIndex ? ' active' : '');
            div.textContent = actions[idx % actions.length] || 'Action ' + idx;
            div.onclick = () => {
                this.historyIndex = idx;
                this.restoreState();
            };
            list.appendChild(div);
        });
        
        list.scrollTop = list.scrollHeight;
    }

    // Filters
    applyFilter(filterFn) {
        const layer = this.layers[this.activeLayerIndex];
        const ctx = layer.ctx;
        const imageData = ctx.getImageData(0, 0, this.width, this.height);
        filterFn(imageData.data);
        ctx.putImageData(imageData, 0, 0);
        this.saveState();
        this.updateLayersUI();
    }

    filterGrayscale() {
        this.applyFilter(data => {
            for (let i = 0; i < data.length; i += 4) {
                const gray = data[i] * 0.299 + data[i+1] * 0.587 + data[i+2] * 0.114;
                data[i] = data[i+1] = data[i+2] = gray;
            }
        });
    }

    filterSepia() {
        this.applyFilter(data => {
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i+1], b = data[i+2];
                data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
                data[i+1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
                data[i+2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
            }
        });
    }

    filterInvert() {
        this.applyFilter(data => {
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];
                data[i+1] = 255 - data[i+1];
                data[i+2] = 255 - data[i+2];
            }
        });
    }

    filterBlur() {
        const layer = this.layers[this.activeLayerIndex];
        const ctx = layer.ctx;
        ctx.filter = 'blur(4px)';
        ctx.drawImage(layer.canvas, 0, 0);
        ctx.filter = 'none';
        this.saveState();
        this.updateLayersUI();
    }

    filterSharpen() {
        const kernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];
        this.convolute(kernel);
    }

    convolute(kernel) {
        const layer = this.layers[this.activeLayerIndex];
        const ctx = layer.ctx;
        const srcData = ctx.getImageData(0, 0, this.width, this.height);
        const dstData = ctx.createImageData(this.width, this.height);
        
        const side = Math.round(Math.sqrt(kernel.length));
        const halfSide = Math.floor(side / 2);
        
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                let r = 0, g = 0, b = 0;
                for (let cy = 0; cy < side; cy++) {
                    for (let cx = 0; cx < side; cx++) {
                        const scy = y + cy - halfSide;
                        const scx = x + cx - halfSide;
                        if (scy >= 0 && scy < this.height && scx >= 0 && scx < this.width) {
                            const srcOff = (scy * this.width + scx) * 4;
                            const wt = kernel[cy * side + cx];
                            r += srcData.data[srcOff] * wt;
                            g += srcData.data[srcOff + 1] * wt;
                            b += srcData.data[srcOff + 2] * wt;
                        }
                    }
                }
                const dstOff = (y * this.width + x) * 4;
                dstData.data[dstOff] = Math.min(255, Math.max(0, r));
                dstData.data[dstOff + 1] = Math.min(255, Math.max(0, g));
                dstData.data[dstOff + 2] = Math.min(255, Math.max(0, b));
                dstData.data[dstOff + 3] = srcData.data[dstOff + 3];
            }
        }
        ctx.putImageData(dstData, 0, 0);
        this.saveState();
        this.updateLayersUI();
    }

    adjustBrightness(amount) {
        this.applyFilter(data => {
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, data[i] + amount));
                data[i+1] = Math.min(255, Math.max(0, data[i+1] + amount));
                data[i+2] = Math.min(255, Math.max(0, data[i+2] + amount));
            }
        });
    }

    adjustContrast(factor) {
        this.applyFilter(data => {
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, (data[i] - 128) * factor + 128));
                data[i+1] = Math.min(255, Math.max(0, (data[i+1] - 128) * factor + 128));
                data[i+2] = Math.min(255, Math.max(0, (data[i+2] - 128) * factor + 128));
            }
        });
    }

    clearCanvas() {
        const layer = this.layers[this.activeLayerIndex];
        layer.ctx.clearRect(0, 0, this.width, this.height);
        this.saveState();
        this.updateLayersUI();
    }

    // File Operations
    newDocument() {
        document.getElementById('newDocModal').style.display = 'flex';
    }

    createNewDocument() {
        const w = parseInt(document.getElementById('newWidth').value);
        const h = parseInt(document.getElementById('newHeight').value);
        const bg = document.getElementById('newBg').value;
        
        this.width = w;
        this.height = h;
        this.container.style.width = w + 'px';
        this.container.style.height = h + 'px';
        
        this.layers.forEach(l => l.canvas.remove());
        this.layers = [];
        this.history = [];
        this.historyIndex = -1;
        
        this.addLayer('Background');
        if (bg === 'white') {
            const ctx = this.layers[0].ctx;
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, w, h);
        }
        
        this.saveState();
        document.getElementById('newDocModal').style.display = 'none';
    }

    openImage() {
        document.getElementById('fileInput').click();
    }

    loadImage(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const img = new Image();
        img.onload = () => {
            this.width = img.width;
            this.height = img.height;
            this.container.style.width = img.width + 'px';
            this.container.style.height = img.height + 'px';
            
            this.layers.forEach(l => l.canvas.remove());
            this.layers = [];
            
            this.addLayer('Image');
            const ctx = this.layers[0].ctx;
            ctx.drawImage(img, 0, 0);
            
            this.saveState();
            this.updateLayersUI();
        };
        img.src = URL.createObjectURL(file);
    }

    savePNG() {
        const canvas = document.createElement('canvas');
        canvas.width = this.width;
        canvas.height = this.height;
        const ctx = canvas.getContext('2d');
        
        this.layers.forEach(layer => {
            if (layer.visible) {
                ctx.globalAlpha = layer.opacity;
                if (layer.blendMode !== 'normal') {
                    ctx.globalCompositeOperation = layer.blendMode;
                }
                ctx.drawImage(layer.canvas, 0, 0);
            }
        });
        
        const link = document.createElement('a');
        link.download = 'image.png';
        link.href = canvas.toDataURL();
        link.click();
    }

    exportJPG() {
        const canvas = document.createElement('canvas');
        canvas.width = this.width;
        canvas.height = this.height;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, this.width, this.height);
        
        this.layers.forEach(layer => {
            if (layer.visible) {
                ctx.globalAlpha = layer.opacity;
                ctx.drawImage(layer.canvas, 0, 0);
            }
        });
        
        const link = document.createElement('a');
        link.download = 'image.jpg';
        link.href = canvas.toDataURL('image/jpeg', 0.9);
        link.click();
    }

    updateCursor() {
        const cursors = {
            brush: 'crosshair',
            eraser: 'cell',
            picker: 'copy',
            fill: 'pointer',
            text: 'text',
            move: 'move',
            default: 'default'
        };
        this.container.style.cursor = cursors[this.tool] || cursors.default;
    }

    resizeCanvas() {
        const w = prompt('New width:', this.width);
        const h = prompt('New height:', this.height);
        if (w && h) {
            // Resize all layers
            this.layers.forEach(layer => {
                const canvas = document.createElement('canvas');
                canvas.width = parseInt(w);
                canvas.height = parseInt(h);
                const ctx = canvas.getContext('2d');
                ctx.drawImage(layer.canvas, 0, 0);
                layer.canvas.width = parseInt(w);
                layer.canvas.height = parseInt(h);
                layer.ctx.drawImage(canvas, 0, 0);
            });
            this.width = parseInt(w);
            this.height = parseInt(h);
            this.container.style.width = this.width + 'px';
            this.container.style.height = this.height + 'px';
            this.saveState();
        }
    }
}

const app = new WebPhotoshop();
</script>

</body>
</html>