<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PixelForge ‚Äî Image Editor</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap');
:root {
  --bg-darkest: #1a1a1a;
  --bg-dark: #232323;
  --bg-mid: #2c2c2c;
  --bg-panel: #272727;
  --bg-input: #1e1e1e;
  --bg-hover: #383838;
  --bg-active: #4a4a4a;
  --border: #3a3a3a;
  --border-light: #444;
  --text: #d4d4d4;
  --text-dim: #888;
  --text-bright: #f0f0f0;
  --accent: #2d8cf0;
  --accent-dim: #1a5fa8;
  --accent-glow: rgba(45,140,240,0.25);
  --warn: #e8a838;
  --danger: #e04848;
  --success: #4caf50;
  --menu-bg: #2a2a2a;
  --slider-track: #444;
  --slider-thumb: #aaa;
  --panel-header: #303030;
  --tool-size: 32px;
  --topbar-h: 26px;
  --toolbar-w: 42px;
  --panel-w: 260px;
  --options-h: 34px;
  --status-h: 22px;
}
* { margin:0; padding:0; box-sizing:border-box; }
body {
  font-family: 'IBM Plex Sans', sans-serif;
  background: var(--bg-darkest);
  color: var(--text);
  overflow: hidden;
  height: 100vh;
  display: flex;
  flex-direction: column;
  font-size: 12px;
  user-select: none;
  cursor: default;
}

/* ===== SCROLLBAR ===== */
::-webkit-scrollbar { width:8px; height:8px; }
::-webkit-scrollbar-track { background:var(--bg-dark); }
::-webkit-scrollbar-thumb { background:#555; border-radius:4px; }
::-webkit-scrollbar-thumb:hover { background:#777; }

/* ===== TOP MENU BAR ===== */
#menubar {
  height: var(--topbar-h);
  background: var(--bg-dark);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 6px;
  gap: 0;
  z-index: 1000;
  flex-shrink: 0;
}
.menu-item {
  padding: 3px 10px;
  font-size: 12px;
  color: var(--text);
  cursor: pointer;
  border-radius: 3px;
  position: relative;
}
.menu-item:hover { background: var(--bg-hover); color: var(--text-bright); }
.menu-dropdown {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  background: var(--menu-bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
  min-width: 200px;
  padding: 4px 0;
  z-index: 2000;
}
.menu-item:hover .menu-dropdown { display: block; }
.menu-dropdown .md-item {
  padding: 5px 16px 5px 12px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  font-size: 12px;
  color: var(--text);
}
.menu-dropdown .md-item:hover { background: var(--accent); color: #fff; }
.menu-dropdown .md-item .shortcut { color: var(--text-dim); font-size: 11px; }
.menu-dropdown .md-item:hover .shortcut { color: rgba(255,255,255,0.7); }
.md-sep { height: 1px; background: var(--border); margin: 3px 8px; }
#app-title {
  margin-left: auto;
  font-size: 11px;
  color: var(--text-dim);
  font-family: 'JetBrains Mono', monospace;
  letter-spacing: 0.5px;
}

/* ===== OPTIONS BAR ===== */
#optionsbar {
  height: var(--options-h);
  background: var(--bg-panel);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 10px;
  gap: 10px;
  flex-shrink: 0;
  overflow-x: auto;
  z-index: 100;
}
.opt-group {
  display: flex;
  align-items: center;
  gap: 5px;
  white-space: nowrap;
}
.opt-label {
  font-size: 11px;
  color: var(--text-dim);
}
.opt-input {
  width: 50px;
  height: 22px;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text);
  font-family: inherit;
  font-size: 11px;
  padding: 0 4px;
  text-align: center;
  outline: none;
}
.opt-input:focus { border-color: var(--accent); }
.opt-slider {
  -webkit-appearance: none;
  width: 80px;
  height: 4px;
  background: var(--slider-track);
  border-radius: 2px;
  outline: none;
}
.opt-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 12px; height: 12px;
  background: var(--slider-thumb);
  border-radius: 50%;
  cursor: pointer;
}
.opt-select {
  height: 22px;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text);
  font-family: inherit;
  font-size: 11px;
  padding: 0 4px;
  outline: none;
  cursor: pointer;
}
.opt-sep { width:1px; height:20px; background:var(--border); }
.opt-btn {
  height: 22px;
  padding: 0 8px;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text);
  font-family: inherit;
  font-size: 11px;
  cursor: pointer;
}
.opt-btn:hover { background: var(--bg-hover); }

/* ===== MAIN LAYOUT ===== */
#main {
  flex: 1;
  display: flex;
  overflow: hidden;
}

/* ===== LEFT TOOLBAR ===== */
#toolbar {
  width: var(--toolbar-w);
  background: var(--bg-panel);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 4px 0;
  gap: 1px;
  flex-shrink: 0;
  overflow-y: auto;
}
.tool-btn {
  width: var(--tool-size);
  height: var(--tool-size);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  cursor: pointer;
  transition: background 0.1s;
  position: relative;
  font-size: 15px;
  color: var(--text);
}
.tool-btn:hover { background: var(--bg-hover); }
.tool-btn.active { background: var(--bg-active); color: var(--text-bright); }
.tool-btn svg { width: 18px; height: 18px; }
.tool-sep { width: 28px; height: 1px; background: var(--border); margin: 3px 0; }

/* Color swatches at bottom of toolbar */
#color-swatches {
  margin-top: auto;
  padding: 6px;
  position: relative;
  width: 38px;
  height: 38px;
}
#fg-color, #bg-color {
  position: absolute;
  width: 22px;
  height: 22px;
  border: 2px solid var(--text);
  border-radius: 3px;
  cursor: pointer;
}
#fg-color { top: 2px; left: 2px; z-index: 2; background: #000; }
#bg-color { bottom: 2px; right: 2px; z-index: 1; background: #fff; }
#swap-colors {
  position: absolute;
  top: -2px;
  right: 0;
  font-size: 10px;
  cursor: pointer;
  color: var(--text-dim);
  z-index: 3;
}
#swap-colors:hover { color: var(--text-bright); }

/* ===== CANVAS AREA ===== */
#canvas-area {
  flex: 1;
  background: var(--bg-darkest);
  position: relative;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  background-image:
    linear-gradient(45deg, #222 25%, transparent 25%),
    linear-gradient(-45deg, #222 25%, transparent 25%),
    linear-gradient(45deg, transparent 75%, #222 75%),
    linear-gradient(-45deg, transparent 75%, #222 75%);
  background-size: 20px 20px;
  background-position: 0 0, 0 10px, 10px -10px, -10px 0;
}
#canvas-container {
  position: relative;
  box-shadow: 0 4px 30px rgba(0,0,0,0.6);
  transform-origin: center center;
}
#main-canvas {
  display: block;
  image-rendering: auto;
}
#overlay-canvas {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
}
#cursor-canvas {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
  z-index: 50;
}
#selection-canvas {
  position: absolute;
  top: 0; left: 0;
  pointer-events: none;
  z-index: 40;
}

/* ===== RIGHT PANELS ===== */
#panels {
  width: var(--panel-w);
  background: var(--bg-panel);
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
  overflow-y: auto;
}
.panel {
  border-bottom: 1px solid var(--border);
}
.panel-header {
  height: 28px;
  background: var(--panel-header);
  display: flex;
  align-items: center;
  padding: 0 10px;
  font-size: 11px;
  font-weight: 600;
  color: var(--text-bright);
  cursor: pointer;
  gap: 6px;
  letter-spacing: 0.3px;
  text-transform: uppercase;
}
.panel-header .toggle { font-size: 8px; color: var(--text-dim); }
.panel-body {
  padding: 8px;
  max-height: 300px;
  overflow-y: auto;
}
.panel.collapsed .panel-body { display: none; }

/* Color Panel */
#color-wheel-wrap {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}
#color-preview-row {
  display: flex;
  gap: 6px;
  align-items: center;
  width: 100%;
}
#color-preview {
  width: 36px;
  height: 36px;
  border: 1px solid var(--border);
  border-radius: 4px;
}
#hex-input {
  flex: 1;
  height: 24px;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text);
  font-family: 'JetBrains Mono', monospace;
  font-size: 11px;
  padding: 0 6px;
  outline: none;
}
.color-slider-row {
  display: flex;
  align-items: center;
  gap: 5px;
  width: 100%;
}
.color-slider-row label {
  font-size: 10px;
  color: var(--text-dim);
  width: 12px;
}
.color-slider-row input[type=range] {
  flex: 1;
  height: 6px;
  -webkit-appearance: none;
  background: var(--slider-track);
  border-radius: 3px;
  outline: none;
}
.color-slider-row input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 12px; height: 12px;
  background: var(--text);
  border-radius: 50%;
  cursor: pointer;
}
.color-slider-row .val {
  font-size: 10px;
  color: var(--text-dim);
  width: 24px;
  text-align: right;
  font-family: 'JetBrains Mono', monospace;
}

/* Layers Panel */
#layers-list {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.layer-item {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 6px;
  border-radius: 4px;
  cursor: pointer;
  min-height: 40px;
  border: 1px solid transparent;
}
.layer-item:hover { background: var(--bg-hover); }
.layer-item.active { background: var(--accent-dim); border-color: var(--accent); }
.layer-thumb {
  width: 36px; height: 28px;
  border: 1px solid var(--border);
  border-radius: 2px;
  background-image:
    linear-gradient(45deg,#333 25%,transparent 25%),
    linear-gradient(-45deg,#333 25%,transparent 25%),
    linear-gradient(45deg,transparent 75%,#333 75%),
    linear-gradient(-45deg,transparent 75%,#333 75%);
  background-size: 6px 6px;
  background-position:0 0,0 3px,3px -3px,-3px 0;
  overflow: hidden;
  flex-shrink: 0;
}
.layer-thumb canvas { width:100%; height:100%; }
.layer-info { flex:1; min-width:0; }
.layer-name {
  font-size: 11px;
  color: var(--text-bright);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.layer-blend-info {
  font-size: 9px;
  color: var(--text-dim);
  margin-top: 1px;
}
.layer-vis {
  width: 18px; height: 18px;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer;
  font-size: 12px;
  color: var(--text-dim);
  border-radius: 3px;
  flex-shrink: 0;
}
.layer-vis:hover { background: var(--bg-active); }
.layer-vis.hidden { opacity: 0.3; }
.layer-controls {
  display: flex;
  gap: 3px;
  padding: 6px 0 2px;
}
.layer-ctrl-btn {
  flex: 1;
  height: 24px;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text);
  font-family: inherit;
  font-size: 11px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}
.layer-ctrl-btn:hover { background: var(--bg-hover); }
.layer-blend-row {
  display: flex;
  align-items: center;
  gap: 5px;
  padding: 4px 0;
}
.layer-blend-row label { font-size: 10px; color: var(--text-dim); }
.layer-blend-row select {
  flex: 1;
  height: 20px;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text);
  font-size: 10px;
  outline: none;
}
.layer-opacity-row {
  display: flex;
  align-items: center;
  gap: 5px;
  padding: 2px 0 4px;
}
.layer-opacity-row label { font-size: 10px; color: var(--text-dim); width: 40px; }
.layer-opacity-row input[type=range] {
  flex: 1;
  height: 4px;
  -webkit-appearance: none;
  background: var(--slider-track);
  border-radius: 2px;
  outline: none;
}
.layer-opacity-row input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 10px; height: 10px;
  background: var(--text);
  border-radius: 50%;
  cursor: pointer;
}
.layer-opacity-row .val { font-size: 10px; color: var(--text-dim); width: 28px; text-align: right; }

/* History Panel */
.history-item {
  padding: 3px 8px;
  font-size: 11px;
  color: var(--text-dim);
  cursor: pointer;
  border-radius: 3px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.history-item:hover { background: var(--bg-hover); }
.history-item.active { background: var(--accent-dim); color: var(--text-bright); }
.history-item.future { opacity: 0.35; }
.history-item .h-icon { font-size: 12px; }

/* ===== FILTER DIALOG ===== */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  z-index: 5000;
  display: flex;
  align-items: center;
  justify-content: center;
}
.modal-overlay.hidden { display: none; }
.modal {
  background: var(--bg-mid);
  border: 1px solid var(--border);
  border-radius: 8px;
  box-shadow: 0 16px 64px rgba(0,0,0,0.5);
  min-width: 320px;
  max-width: 500px;
}
.modal-header {
  padding: 10px 16px;
  font-size: 13px;
  font-weight: 600;
  border-bottom: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.modal-close {
  cursor: pointer;
  font-size: 16px;
  color: var(--text-dim);
}
.modal-close:hover { color: var(--danger); }
.modal-body { padding: 16px; }
.modal-footer {
  padding: 10px 16px;
  border-top: 1px solid var(--border);
  display: flex;
  justify-content: flex-end;
  gap: 8px;
}
.modal-btn {
  padding: 5px 16px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg-input);
  color: var(--text);
  font-family: inherit;
  font-size: 12px;
  cursor: pointer;
}
.modal-btn:hover { background: var(--bg-hover); }
.modal-btn.primary { background: var(--accent); border-color: var(--accent); color: #fff; }
.modal-btn.primary:hover { background: var(--accent-dim); }
.filter-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
}
.filter-row label { font-size: 12px; width: 90px; color: var(--text); }
.filter-row input[type=range] {
  flex: 1;
  height: 4px;
  -webkit-appearance: none;
  background: var(--slider-track);
  border-radius: 2px;
}
.filter-row input[type=range]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px; height: 14px;
  background: var(--accent);
  border-radius: 50%;
  cursor: pointer;
}
.filter-row .val { width: 36px; text-align: right; font-size: 11px; color: var(--text-dim); font-family: 'JetBrains Mono', monospace; }

/* ===== STATUS BAR ===== */
#statusbar {
  height: var(--status-h);
  background: var(--bg-dark);
  border-top: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 10px;
  font-size: 11px;
  color: var(--text-dim);
  gap: 16px;
  flex-shrink: 0;
  z-index: 100;
}
#zoom-display { cursor: pointer; }
#zoom-display:hover { color: var(--text-bright); }

/* ===== NEW CANVAS DIALOG ===== */
.new-dialog-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
}
.new-dialog-row label { font-size: 12px; width: 70px; color: var(--text); }
.new-dialog-row input {
  flex: 1;
  height: 26px;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text);
  font-family: inherit;
  font-size: 12px;
  padding: 0 8px;
  outline: none;
}

/* File input hidden */
#file-input { display: none; }
</style>
</head>
<body>

<!-- MENU BAR -->
<div id="menubar">
  <div class="menu-item">File
    <div class="menu-dropdown">
      <div class="md-item" onclick="showNewDialog()">New‚Ä¶ <span class="shortcut">Ctrl+N</span></div>
      <div class="md-item" onclick="openFile()">Open‚Ä¶ <span class="shortcut">Ctrl+O</span></div>
      <div class="md-sep"></div>
      <div class="md-item" onclick="saveFile('png')">Export PNG <span class="shortcut">Ctrl+S</span></div>
      <div class="md-item" onclick="saveFile('jpeg')">Export JPEG</div>
      <div class="md-item" onclick="saveFile('webp')">Export WebP</div>
    </div>
  </div>
  <div class="menu-item">Edit
    <div class="menu-dropdown">
      <div class="md-item" onclick="undo()">Undo <span class="shortcut">Ctrl+Z</span></div>
      <div class="md-item" onclick="redo()">Redo <span class="shortcut">Ctrl+Y</span></div>
      <div class="md-sep"></div>
      <div class="md-item" onclick="clearLayer()">Clear Layer</div>
      <div class="md-item" onclick="fillLayer()">Fill with FG Color</div>
    </div>
  </div>
  <div class="menu-item">Image
    <div class="menu-dropdown">
      <div class="md-item" onclick="flipH()">Flip Horizontal</div>
      <div class="md-item" onclick="flipV()">Flip Vertical</div>
      <div class="md-sep"></div>
      <div class="md-item" onclick="flattenImage()">Flatten Image</div>
    </div>
  </div>
  <div class="menu-item">Filter
    <div class="menu-dropdown">
      <div class="md-item" onclick="showFilter('blur')">Gaussian Blur‚Ä¶</div>
      <div class="md-item" onclick="showFilter('sharpen')">Sharpen</div>
      <div class="md-sep"></div>
      <div class="md-item" onclick="showFilter('brightness')">Brightness / Contrast‚Ä¶</div>
      <div class="md-item" onclick="showFilter('huesat')">Hue / Saturation‚Ä¶</div>
      <div class="md-sep"></div>
      <div class="md-item" onclick="applyQuickFilter('grayscale')">Grayscale</div>
      <div class="md-item" onclick="applyQuickFilter('sepia')">Sepia</div>
      <div class="md-item" onclick="applyQuickFilter('invert')">Invert Colors</div>
      <div class="md-item" onclick="applyQuickFilter('posterize')">Posterize</div>
      <div class="md-item" onclick="applyQuickFilter('noise')">Add Noise</div>
      <div class="md-item" onclick="applyQuickFilter('emboss')">Emboss</div>
      <div class="md-item" onclick="applyQuickFilter('edge')">Edge Detect</div>
    </div>
  </div>
  <div class="menu-item">View
    <div class="menu-dropdown">
      <div class="md-item" onclick="setZoom(1)">Zoom 100% <span class="shortcut">Ctrl+1</span></div>
      <div class="md-item" onclick="zoomIn()">Zoom In <span class="shortcut">Ctrl++</span></div>
      <div class="md-item" onclick="zoomOut()">Zoom Out <span class="shortcut">Ctrl+-</span></div>
      <div class="md-item" onclick="fitToScreen()">Fit to Screen <span class="shortcut">Ctrl+0</span></div>
    </div>
  </div>
  <span id="app-title">PIXELFORGE</span>
</div>

<!-- OPTIONS BAR -->
<div id="optionsbar">
  <div class="opt-group" id="brush-options">
    <span class="opt-label">Size:</span>
    <input type="range" class="opt-slider" id="brush-size" min="1" max="200" value="12">
    <input type="number" class="opt-input" id="brush-size-num" value="12" min="1" max="500">
    <div class="opt-sep"></div>
    <span class="opt-label">Opacity:</span>
    <input type="range" class="opt-slider" id="brush-opacity" min="1" max="100" value="100">
    <input type="number" class="opt-input" id="brush-opacity-num" value="100" min="1" max="100" style="width:40px">
    <div class="opt-sep"></div>
    <span class="opt-label">Hardness:</span>
    <input type="range" class="opt-slider" id="brush-hardness" min="0" max="100" value="80">
    <div class="opt-sep"></div>
    <span class="opt-label">Shape:</span>
    <select class="opt-select" id="brush-shape">
      <option value="round">Round</option>
      <option value="square">Square</option>
    </select>
  </div>
  <div class="opt-group" id="shape-options" style="display:none">
    <span class="opt-label">Stroke:</span>
    <input type="number" class="opt-input" id="shape-stroke" value="2" min="1" max="50">
    <span class="opt-label">Fill:</span>
    <select class="opt-select" id="shape-fill">
      <option value="none">None</option>
      <option value="fg">Foreground</option>
      <option value="bg">Background</option>
    </select>
  </div>
  <div class="opt-group" id="text-options" style="display:none">
    <span class="opt-label">Font:</span>
    <select class="opt-select" id="text-font" style="width:120px">
      <option>IBM Plex Sans</option><option>Arial</option><option>Georgia</option>
      <option>Courier New</option><option>Impact</option><option>Comic Sans MS</option>
      <option>Verdana</option><option>Times New Roman</option>
    </select>
    <span class="opt-label">Size:</span>
    <input type="number" class="opt-input" id="text-size" value="32" min="8" max="200">
    <button class="opt-btn" id="text-bold-btn" onclick="this.classList.toggle('active');textBold=this.classList.contains('active')" style="font-weight:bold">B</button>
    <button class="opt-btn" id="text-italic-btn" onclick="this.classList.toggle('active');textItalic=this.classList.contains('active')" style="font-style:italic">I</button>
  </div>
  <div class="opt-group" id="select-options" style="display:none">
    <button class="opt-btn" onclick="selectAll()">Select All</button>
    <button class="opt-btn" onclick="deselectAll()">Deselect</button>
  </div>
</div>

<!-- MAIN AREA -->
<div id="main">
  <!-- TOOLBAR -->
  <div id="toolbar">
    <div class="tool-btn active" data-tool="brush" title="Brush (B)">üñåÔ∏è</div>
    <div class="tool-btn" data-tool="eraser" title="Eraser (E)">üßπ</div>
    <div class="tool-btn" data-tool="pencil" title="Pencil (P)">‚úèÔ∏è</div>
    <div class="tool-sep"></div>
    <div class="tool-btn" data-tool="line" title="Line (L)">‚ï±</div>
    <div class="tool-btn" data-tool="rect" title="Rectangle (U)">‚ñ≠</div>
    <div class="tool-btn" data-tool="ellipse" title="Ellipse (O)">‚óØ</div>
    <div class="tool-sep"></div>
    <div class="tool-btn" data-tool="fill" title="Fill Bucket (G)">ü™£</div>
    <div class="tool-btn" data-tool="eyedropper" title="Eyedropper (I)">üíâ</div>
    <div class="tool-btn" data-tool="text" title="Text (T)">T</div>
    <div class="tool-sep"></div>
    <div class="tool-btn" data-tool="select" title="Marquee Select (M)">‚¨ö</div>
    <div class="tool-btn" data-tool="move" title="Move (V)">‚ú•</div>
    <div class="tool-btn" data-tool="hand" title="Hand (H)">ü§ö</div>
    <div class="tool-btn" data-tool="zoom" title="Zoom (Z)">üîç</div>

    <div id="color-swatches">
      <span id="swap-colors" onclick="swapColors()" title="Swap (X)">‚áÑ</span>
      <div id="fg-color" onclick="pickingColor='fg'; document.getElementById('fg-picker').click()"></div>
      <div id="bg-color" onclick="pickingColor='bg'; document.getElementById('bg-picker').click()"></div>
      <input type="color" id="fg-picker" value="#000000" style="display:none">
      <input type="color" id="bg-picker" value="#ffffff" style="display:none">
    </div>
  </div>

  <!-- CANVAS AREA -->
  <div id="canvas-area">
    <div id="canvas-container">
      <canvas id="main-canvas"></canvas>
      <canvas id="overlay-canvas"></canvas>
      <canvas id="selection-canvas"></canvas>
      <canvas id="cursor-canvas"></canvas>
    </div>
  </div>

  <!-- RIGHT PANELS -->
  <div id="panels">
    <!-- Color Panel -->
    <div class="panel" id="panel-color">
      <div class="panel-header" onclick="this.parentElement.classList.toggle('collapsed')">
        <span class="toggle">‚ñº</span> Color
      </div>
      <div class="panel-body">
        <div id="color-wheel-wrap">
          <canvas id="color-canvas" width="236" height="130" style="border-radius:4px;cursor:crosshair"></canvas>
          <canvas id="hue-bar" width="236" height="14" style="border-radius:3px;cursor:crosshair"></canvas>
          <div id="color-preview-row">
            <div id="color-preview"></div>
            <input id="hex-input" value="#000000" maxlength="7">
          </div>
          <div class="color-slider-row">
            <label>R</label>
            <input type="range" id="r-slider" min="0" max="255" value="0">
            <span class="val" id="r-val">0</span>
          </div>
          <div class="color-slider-row">
            <label>G</label>
            <input type="range" id="g-slider" min="0" max="255" value="0">
            <span class="val" id="g-val">0</span>
          </div>
          <div class="color-slider-row">
            <label>B</label>
            <input type="range" id="b-slider" min="0" max="255" value="0">
            <span class="val" id="b-val">0</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Layers Panel -->
    <div class="panel" id="panel-layers">
      <div class="panel-header" onclick="this.parentElement.classList.toggle('collapsed')">
        <span class="toggle">‚ñº</span> Layers
      </div>
      <div class="panel-body" style="padding:4px 8px">
        <div class="layer-blend-row">
          <label>Blend:</label>
          <select id="layer-blend" onchange="setLayerBlend(this.value)">
            <option value="source-over">Normal</option>
            <option value="multiply">Multiply</option>
            <option value="screen">Screen</option>
            <option value="overlay">Overlay</option>
            <option value="darken">Darken</option>
            <option value="lighten">Lighten</option>
            <option value="color-dodge">Color Dodge</option>
            <option value="color-burn">Color Burn</option>
            <option value="hard-light">Hard Light</option>
            <option value="soft-light">Soft Light</option>
            <option value="difference">Difference</option>
            <option value="exclusion">Exclusion</option>
            <option value="hue">Hue</option>
            <option value="saturation">Saturation</option>
            <option value="color">Color</option>
            <option value="luminosity">Luminosity</option>
          </select>
        </div>
        <div class="layer-opacity-row">
          <label>Opacity:</label>
          <input type="range" id="layer-opacity" min="0" max="100" value="100" oninput="setLayerOpacity(this.value)">
          <span class="val" id="layer-opacity-val">100%</span>
        </div>
        <div id="layers-list"></div>
        <div class="layer-controls">
          <button class="layer-ctrl-btn" onclick="addLayer()" title="New Layer">Ôºã</button>
          <button class="layer-ctrl-btn" onclick="duplicateLayer()" title="Duplicate">‚ßâ</button>
          <button class="layer-ctrl-btn" onclick="mergeDown()" title="Merge Down">‚§ì</button>
          <button class="layer-ctrl-btn" onclick="moveLayerUp()" title="Move Up">‚Üë</button>
          <button class="layer-ctrl-btn" onclick="moveLayerDown()" title="Move Down">‚Üì</button>
          <button class="layer-ctrl-btn" onclick="deleteLayer()" title="Delete" style="color:var(--danger)">‚úï</button>
        </div>
      </div>
    </div>

    <!-- History Panel -->
    <div class="panel" id="panel-history">
      <div class="panel-header" onclick="this.parentElement.classList.toggle('collapsed')">
        <span class="toggle">‚ñº</span> History
      </div>
      <div class="panel-body" id="history-list" style="max-height:200px"></div>
    </div>

    <!-- Brushes Panel -->
    <div class="panel" id="panel-brushes">
      <div class="panel-header" onclick="this.parentElement.classList.toggle('collapsed')">
        <span class="toggle">‚ñº</span> Brush Presets
      </div>
      <div class="panel-body" style="display:flex;flex-wrap:wrap;gap:4px"></div>
    </div>
  </div>
</div>

<!-- STATUS BAR -->
<div id="statusbar">
  <span id="cursor-pos">0, 0</span>
  <span id="canvas-size">800 √ó 600</span>
  <span id="zoom-display" onclick="setZoom(1)">100%</span>
  <span id="active-tool-name">Brush</span>
  <span style="flex:1"></span>
  <span id="status-msg">Ready</span>
</div>

<!-- MODALS -->
<div class="modal-overlay hidden" id="filter-modal">
  <div class="modal">
    <div class="modal-header"><span id="filter-title">Filter</span><span class="modal-close" onclick="closeFilterModal()">‚úï</span></div>
    <div class="modal-body" id="filter-body"></div>
    <div class="modal-footer">
      <button class="modal-btn" onclick="closeFilterModal()">Cancel</button>
      <button class="modal-btn primary" onclick="applyFilterModal()">Apply</button>
    </div>
  </div>
</div>

<div class="modal-overlay hidden" id="new-modal">
  <div class="modal">
    <div class="modal-header"><span>New Canvas</span><span class="modal-close" onclick="document.getElementById('new-modal').classList.add('hidden')">‚úï</span></div>
    <div class="modal-body">
      <div class="new-dialog-row"><label>Width:</label><input id="new-width" type="number" value="800" min="1" max="4096"></div>
      <div class="new-dialog-row"><label>Height:</label><input id="new-height" type="number" value="600" min="1" max="4096"></div>
      <div class="new-dialog-row"><label>Background:</label>
        <select id="new-bg" style="flex:1;height:26px;background:var(--bg-input);border:1px solid var(--border);border-radius:3px;color:var(--text);font-size:12px;padding:0 6px">
          <option value="white">White</option>
          <option value="transparent">Transparent</option>
          <option value="black">Black</option>
        </select>
      </div>
    </div>
    <div class="modal-footer">
      <button class="modal-btn" onclick="document.getElementById('new-modal').classList.add('hidden')">Cancel</button>
      <button class="modal-btn primary" onclick="createNewCanvas()">Create</button>
    </div>
  </div>
</div>

<input type="file" id="file-input" accept="image/*">

<script>
// =====================================================================
// PixelForge Engine
// =====================================================================

let W = 800, H = 600;
let zoom = 1;
let panX = 0, panY = 0;
let fgColor = '#000000', bgColor = '#ffffff';
let pickingColor = 'fg';
let currentTool = 'brush';
let brushSize = 12, brushOpacity = 100, brushHardness = 80, brushShape = 'round';
let textBold = false, textItalic = false;
let isDrawing = false;
let lastX = 0, lastY = 0;
let shapeStartX = 0, shapeStartY = 0;
let selection = null; // {x,y,w,h}
let selectDragging = false;
let movingLayer = false, moveStartX = 0, moveStartY = 0;
let handActive = false, handStartX = 0, handStartY = 0, handStartPanX = 0, handStartPanY = 0;

// ===== LAYERS =====
let layers = [];
let activeLayerIdx = 0;

class Layer {
  constructor(name, w, h) {
    this.name = name;
    this.canvas = document.createElement('canvas');
    this.canvas.width = w;
    this.canvas.height = h;
    this.ctx = this.canvas.getContext('2d');
    this.visible = true;
    this.opacity = 1;
    this.blendMode = 'source-over';
    this.locked = false;
  }
  clone() {
    const l = new Layer(this.name + ' copy', this.canvas.width, this.canvas.height);
    l.ctx.drawImage(this.canvas, 0, 0);
    l.visible = this.visible;
    l.opacity = this.opacity;
    l.blendMode = this.blendMode;
    return l;
  }
}

function getActiveLayer() { return layers[activeLayerIdx]; }

// ===== HISTORY =====
let history = [];
let historyIdx = -1;
const MAX_HISTORY = 40;

function saveHistory(actionName) {
  // Remove future states
  if (historyIdx < history.length - 1) {
    history = history.slice(0, historyIdx + 1);
  }
  // Save snapshot of all layers
  const snap = layers.map(l => {
    const c = document.createElement('canvas');
    c.width = l.canvas.width; c.height = l.canvas.height;
    c.getContext('2d').drawImage(l.canvas, 0, 0);
    return { data: c, name: l.name, visible: l.visible, opacity: l.opacity, blendMode: l.blendMode };
  });
  history.push({ name: actionName, layers: snap, activeIdx: activeLayerIdx });
  if (history.length > MAX_HISTORY) history.shift();
  historyIdx = history.length - 1;
  renderHistory();
}

function restoreHistory(idx) {
  if (idx < 0 || idx >= history.length) return;
  historyIdx = idx;
  const snap = history[idx];
  layers = snap.layers.map(s => {
    const l = new Layer(s.name, s.data.width, s.data.height);
    l.ctx.drawImage(s.data, 0, 0);
    l.visible = s.visible;
    l.opacity = s.opacity;
    l.blendMode = s.blendMode;
    return l;
  });
  activeLayerIdx = Math.min(snap.activeIdx, layers.length - 1);
  compositeAndDisplay();
  renderLayers();
  renderHistory();
}

function undo() { if (historyIdx > 0) restoreHistory(historyIdx - 1); }
function redo() { if (historyIdx < history.length - 1) restoreHistory(historyIdx + 1); }

// ===== INIT =====
const mainCanvas = document.getElementById('main-canvas');
const mainCtx = mainCanvas.getContext('2d');
const overlayCanvas = document.getElementById('overlay-canvas');
const overlayCtx = overlayCanvas.getContext('2d');
const selCanvas = document.getElementById('selection-canvas');
const selCtx = selCanvas.getContext('2d');
const cursorCanvas = document.getElementById('cursor-canvas');
const cursorCtx = cursorCanvas.getContext('2d');
const container = document.getElementById('canvas-container');
const canvasArea = document.getElementById('canvas-area');

function initCanvas(w, h, bg) {
  W = w; H = h;
  mainCanvas.width = W; mainCanvas.height = H;
  overlayCanvas.width = W; overlayCanvas.height = H;
  selCanvas.width = W; selCanvas.height = H;
  cursorCanvas.width = W; cursorCanvas.height = H;
  
  layers = [];
  const bgLayer = new Layer('Background', W, H);
  if (bg === 'white') { bgLayer.ctx.fillStyle = '#fff'; bgLayer.ctx.fillRect(0, 0, W, H); }
  else if (bg === 'black') { bgLayer.ctx.fillStyle = '#000'; bgLayer.ctx.fillRect(0, 0, W, H); }
  layers.push(bgLayer);
  activeLayerIdx = 0;
  
  history = [];
  historyIdx = -1;
  selection = null;
  
  compositeAndDisplay();
  fitToScreen();
  saveHistory('New Canvas');
  renderLayers();
  updateStatus();
}

function compositeAndDisplay() {
  mainCtx.clearRect(0, 0, W, H);
  // Draw checkerboard for transparency
  const cSize = 8;
  for (let y = 0; y < H; y += cSize) {
    for (let x = 0; x < W; x += cSize) {
      mainCtx.fillStyle = ((x/cSize + y/cSize) % 2 === 0) ? '#ccc' : '#fff';
      mainCtx.fillRect(x, y, cSize, cSize);
    }
  }
  // Composite layers
  for (const layer of layers) {
    if (!layer.visible) continue;
    mainCtx.save();
    mainCtx.globalAlpha = layer.opacity;
    mainCtx.globalCompositeOperation = layer.blendMode;
    mainCtx.drawImage(layer.canvas, 0, 0);
    mainCtx.restore();
  }
  updateZoom();
}

function updateZoom() {
  container.style.transform = `scale(${zoom})`;
  container.style.width = W + 'px';
  container.style.height = H + 'px';
  document.getElementById('zoom-display').textContent = Math.round(zoom * 100) + '%';
}

function setZoom(z) {
  zoom = Math.max(0.05, Math.min(32, z));
  updateZoom();
}

function zoomIn() { setZoom(zoom * 1.25); }
function zoomOut() { setZoom(zoom / 1.25); }

function fitToScreen() {
  const area = canvasArea.getBoundingClientRect();
  const sx = (area.width - 40) / W;
  const sy = (area.height - 40) / H;
  setZoom(Math.min(sx, sy, 1));
}

// ===== MOUSE / DRAWING =====
function getCanvasCoords(e) {
  const rect = mainCanvas.getBoundingClientRect();
  return {
    x: (e.clientX - rect.left) / zoom,
    y: (e.clientY - rect.top) / zoom
  };
}

canvasArea.addEventListener('wheel', (e) => {
  e.preventDefault();
  if (e.deltaY < 0) zoomIn(); else zoomOut();
}, { passive: false });

mainCanvas.addEventListener('mousedown', onMouseDown);
mainCanvas.addEventListener('mousemove', onMouseMove);
document.addEventListener('mouseup', onMouseUp);
mainCanvas.addEventListener('mouseleave', () => { cursorCtx.clearRect(0,0,W,H); });

function onMouseDown(e) {
  const {x, y} = getCanvasCoords(e);
  const ix = Math.floor(x), iy = Math.floor(y);
  
  if (currentTool === 'hand') {
    handActive = true;
    handStartX = e.clientX;
    handStartY = e.clientY;
    const ct = container.style.transform;
    return;
  }
  
  if (currentTool === 'zoom') {
    if (e.button === 0) zoomIn(); else zoomOut();
    return;
  }
  
  if (currentTool === 'eyedropper') {
    pickColor(ix, iy);
    return;
  }
  
  if (currentTool === 'fill') {
    floodFill(ix, iy);
    return;
  }
  
  if (currentTool === 'text') {
    placeText(ix, iy);
    return;
  }
  
  if (currentTool === 'select') {
    selectDragging = true;
    shapeStartX = ix; shapeStartY = iy;
    return;
  }
  
  if (currentTool === 'move') {
    movingLayer = true;
    moveStartX = ix; moveStartY = iy;
    return;
  }
  
  isDrawing = true;
  lastX = x; lastY = y;
  
  if (['line','rect','ellipse'].includes(currentTool)) {
    shapeStartX = x; shapeStartY = y;
    return;
  }
  
  // Brush/Eraser/Pencil - draw dot
  drawStroke(x, y, x, y);
}

function onMouseMove(e) {
  const {x, y} = getCanvasCoords(e);
  const ix = Math.floor(x), iy = Math.floor(y);
  document.getElementById('cursor-pos').textContent = `${Math.max(0,ix)}, ${Math.max(0,iy)}`;
  
  // Draw brush cursor
  drawBrushCursor(x, y);
  
  if (handActive) {
    const dx = e.clientX - handStartX;
    const dy = e.clientY - handStartY;
    canvasArea.scrollLeft -= dx;
    canvasArea.scrollTop -= dy;
    handStartX = e.clientX;
    handStartY = e.clientY;
    return;
  }
  
  if (selectDragging) {
    const sx = Math.min(shapeStartX, ix), sy = Math.min(shapeStartY, iy);
    const sw = Math.abs(ix - shapeStartX), sh = Math.abs(iy - shapeStartY);
    drawSelectionRect(sx, sy, sw, sh);
    return;
  }
  
  if (movingLayer) {
    const dx = ix - moveStartX;
    const dy = iy - moveStartY;
    const layer = getActiveLayer();
    const temp = document.createElement('canvas');
    temp.width = W; temp.height = H;
    temp.getContext('2d').drawImage(layer.canvas, 0, 0);
    layer.ctx.clearRect(0, 0, W, H);
    layer.ctx.drawImage(temp, dx, dy);
    moveStartX = ix; moveStartY = iy;
    compositeAndDisplay();
    return;
  }
  
  if (!isDrawing) return;
  
  if (['line','rect','ellipse'].includes(currentTool)) {
    drawShapePreview(x, y);
    return;
  }
  
  drawStroke(lastX, lastY, x, y);
  lastX = x; lastY = y;
}

function onMouseUp(e) {
  if (handActive) { handActive = false; return; }
  if (selectDragging) {
    selectDragging = false;
    const {x, y} = getCanvasCoords(e);
    const ix = Math.floor(x), iy = Math.floor(y);
    const sx = Math.min(shapeStartX, ix), sy = Math.min(shapeStartY, iy);
    const sw = Math.abs(ix - shapeStartX), sh = Math.abs(iy - shapeStartY);
    if (sw > 2 && sh > 2) {
      selection = { x: sx, y: sy, w: sw, h: sh };
      drawSelectionMarching();
    } else {
      selection = null;
      selCtx.clearRect(0, 0, W, H);
    }
    return;
  }
  if (movingLayer) {
    movingLayer = false;
    saveHistory('Move Layer');
    renderLayers();
    return;
  }
  if (!isDrawing) return;
  isDrawing = false;
  
  if (['line','rect','ellipse'].includes(currentTool)) {
    const {x, y} = getCanvasCoords(e);
    drawShapeFinal(x, y);
  }
  
  overlayCtx.clearRect(0, 0, W, H);
  compositeAndDisplay();
  saveHistory(getToolName(currentTool));
  renderLayers();
}

// ===== DRAWING ENGINE =====
function drawStroke(x1, y1, x2, y2) {
  const layer = getActiveLayer();
  if (!layer || layer.locked) return;
  const ctx = layer.ctx;
  
  ctx.save();
  if (selection) {
    ctx.beginPath();
    ctx.rect(selection.x, selection.y, selection.w, selection.h);
    ctx.clip();
  }
  
  const size = brushSize;
  const opacity = brushOpacity / 100;
  
  ctx.globalAlpha = opacity;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.lineWidth = size;
  
  if (currentTool === 'eraser') {
    ctx.globalCompositeOperation = 'destination-out';
    ctx.strokeStyle = 'rgba(0,0,0,1)';
  } else if (currentTool === 'pencil') {
    ctx.strokeStyle = fgColor;
    ctx.globalAlpha = 1;
    ctx.lineWidth = 1;
    ctx.imageSmoothingEnabled = false;
  } else {
    ctx.strokeStyle = fgColor;
  }
  
  // Hardness via shadow
  if (brushHardness < 100 && currentTool === 'brush') {
    const blur = size * (1 - brushHardness / 100) * 0.5;
    ctx.shadowColor = fgColor;
    ctx.shadowBlur = blur;
  }
  
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  
  ctx.restore();
  compositeAndDisplay();
}

function drawShapePreview(x, y) {
  overlayCtx.clearRect(0, 0, W, H);
  overlayCtx.strokeStyle = fgColor;
  overlayCtx.lineWidth = parseInt(document.getElementById('shape-stroke').value) || 2;
  overlayCtx.setLineDash([5, 5]);
  
  if (currentTool === 'line') {
    overlayCtx.beginPath();
    overlayCtx.moveTo(shapeStartX, shapeStartY);
    overlayCtx.lineTo(x, y);
    overlayCtx.stroke();
  } else if (currentTool === 'rect') {
    overlayCtx.strokeRect(shapeStartX, shapeStartY, x - shapeStartX, y - shapeStartY);
  } else if (currentTool === 'ellipse') {
    const cx = (shapeStartX + x) / 2;
    const cy = (shapeStartY + y) / 2;
    const rx = Math.abs(x - shapeStartX) / 2;
    const ry = Math.abs(y - shapeStartY) / 2;
    overlayCtx.beginPath();
    overlayCtx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
    overlayCtx.stroke();
  }
  overlayCtx.setLineDash([]);
}

function drawShapeFinal(x, y) {
  const layer = getActiveLayer();
  if (!layer) return;
  const ctx = layer.ctx;
  const strokeW = parseInt(document.getElementById('shape-stroke').value) || 2;
  const fillMode = document.getElementById('shape-fill').value;
  
  ctx.save();
  if (selection) { ctx.beginPath(); ctx.rect(selection.x, selection.y, selection.w, selection.h); ctx.clip(); }
  ctx.strokeStyle = fgColor;
  ctx.lineWidth = strokeW;
  ctx.lineCap = 'round';
  ctx.globalAlpha = brushOpacity / 100;
  
  let fillColor = null;
  if (fillMode === 'fg') fillColor = fgColor;
  else if (fillMode === 'bg') fillColor = bgColor;
  
  if (currentTool === 'line') {
    ctx.beginPath();
    ctx.moveTo(shapeStartX, shapeStartY);
    ctx.lineTo(x, y);
    ctx.stroke();
  } else if (currentTool === 'rect') {
    if (fillColor) { ctx.fillStyle = fillColor; ctx.fillRect(shapeStartX, shapeStartY, x - shapeStartX, y - shapeStartY); }
    ctx.strokeRect(shapeStartX, shapeStartY, x - shapeStartX, y - shapeStartY);
  } else if (currentTool === 'ellipse') {
    const cx = (shapeStartX + x) / 2, cy = (shapeStartY + y) / 2;
    const rx = Math.abs(x - shapeStartX) / 2, ry = Math.abs(y - shapeStartY) / 2;
    ctx.beginPath();
    ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
    if (fillColor) { ctx.fillStyle = fillColor; ctx.fill(); }
    ctx.stroke();
  }
  ctx.restore();
  overlayCtx.clearRect(0, 0, W, H);
}

// ===== FLOOD FILL =====
function floodFill(sx, sy) {
  const layer = getActiveLayer();
  if (!layer) return;
  const ctx = layer.ctx;
  const id = ctx.getImageData(0, 0, W, H);
  const d = id.data;
  const target = getPixel(d, sx, sy);
  const fill = hexToRGBA(fgColor, brushOpacity / 100);
  if (colorsMatch(target, fill)) return;
  
  const stack = [[sx, sy]];
  const visited = new Set();
  while (stack.length) {
    const [cx, cy] = stack.pop();
    if (cx < 0 || cx >= W || cy < 0 || cy >= H) continue;
    const key = cy * W + cx;
    if (visited.has(key)) continue;
    const p = getPixel(d, cx, cy);
    if (!colorsMatch(p, target, 30)) continue;
    visited.add(key);
    setPixel(d, cx, cy, fill);
    stack.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]);
  }
  ctx.putImageData(id, 0, 0);
  compositeAndDisplay();
  saveHistory('Fill');
  renderLayers();
}

function getPixel(d, x, y) {
  const i = (y * W + x) * 4;
  return [d[i], d[i+1], d[i+2], d[i+3]];
}
function setPixel(d, x, y, c) {
  const i = (y * W + x) * 4;
  d[i]=c[0]; d[i+1]=c[1]; d[i+2]=c[2]; d[i+3]=c[3];
}
function colorsMatch(a, b, tol=0) {
  return Math.abs(a[0]-b[0])<=tol && Math.abs(a[1]-b[1])<=tol && Math.abs(a[2]-b[2])<=tol && Math.abs(a[3]-b[3])<=tol;
}
function hexToRGBA(hex, alpha=1) {
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  return [r, g, b, Math.round(alpha * 255)];
}

// ===== EYEDROPPER =====
function pickColor(x, y) {
  const pixel = mainCtx.getImageData(x, y, 1, 1).data;
  const hex = '#' + [pixel[0],pixel[1],pixel[2]].map(v => v.toString(16).padStart(2,'0')).join('');
  setFGColor(hex);
}

// ===== TEXT =====
function placeText(x, y) {
  const text = prompt('Enter text:');
  if (!text) return;
  const layer = getActiveLayer();
  if (!layer) return;
  const ctx = layer.ctx;
  const size = parseInt(document.getElementById('text-size').value) || 32;
  const font = document.getElementById('text-font').value;
  let fontStr = '';
  if (textItalic) fontStr += 'italic ';
  if (textBold) fontStr += 'bold ';
  fontStr += size + 'px ' + font;
  
  ctx.save();
  ctx.font = fontStr;
  ctx.fillStyle = fgColor;
  ctx.globalAlpha = brushOpacity / 100;
  ctx.textBaseline = 'top';
  ctx.fillText(text, x, y);
  ctx.restore();
  compositeAndDisplay();
  saveHistory('Text');
  renderLayers();
}

// ===== SELECTION =====
function drawSelectionRect(x, y, w, h) {
  selCtx.clearRect(0, 0, W, H);
  selCtx.setLineDash([4, 4]);
  selCtx.strokeStyle = '#fff';
  selCtx.lineWidth = 1;
  selCtx.strokeRect(x + 0.5, y + 0.5, w, h);
  selCtx.strokeStyle = '#000';
  selCtx.lineDashOffset = 4;
  selCtx.strokeRect(x + 0.5, y + 0.5, w, h);
  selCtx.setLineDash([]);
  selCtx.lineDashOffset = 0;
}

let marchOffset = 0;
function drawSelectionMarching() {
  if (!selection) return;
  marchOffset = (marchOffset + 0.5) % 8;
  selCtx.clearRect(0, 0, W, H);
  selCtx.setLineDash([4, 4]);
  selCtx.lineDashOffset = marchOffset;
  selCtx.strokeStyle = '#000';
  selCtx.lineWidth = 1;
  selCtx.strokeRect(selection.x + 0.5, selection.y + 0.5, selection.w, selection.h);
  selCtx.lineDashOffset = marchOffset + 4;
  selCtx.strokeStyle = '#fff';
  selCtx.strokeRect(selection.x + 0.5, selection.y + 0.5, selection.w, selection.h);
  selCtx.setLineDash([]);
  if (selection) requestAnimationFrame(drawSelectionMarching);
}

function selectAll() { selection = {x:0,y:0,w:W,h:H}; drawSelectionMarching(); }
function deselectAll() { selection = null; selCtx.clearRect(0,0,W,H); }

// ===== BRUSH CURSOR =====
function drawBrushCursor(x, y) {
  cursorCtx.clearRect(0, 0, W, H);
  if (!['brush','eraser','pencil'].includes(currentTool)) return;
  const r = (currentTool === 'pencil' ? 1 : brushSize) / 2;
  cursorCtx.beginPath();
  cursorCtx.arc(x, y, r, 0, Math.PI * 2);
  cursorCtx.strokeStyle = 'rgba(255,255,255,0.7)';
  cursorCtx.lineWidth = 1 / zoom;
  cursorCtx.stroke();
  cursorCtx.beginPath();
  cursorCtx.arc(x, y, r + 1/zoom, 0, Math.PI * 2);
  cursorCtx.strokeStyle = 'rgba(0,0,0,0.5)';
  cursorCtx.stroke();
}

// ===== TOOL SELECTION =====
document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
  btn.addEventListener('click', () => {
    currentTool = btn.dataset.tool;
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('active-tool-name').textContent = getToolName(currentTool);
    updateOptionsBar();
  });
});

function getToolName(t) {
  return {brush:'Brush',eraser:'Eraser',pencil:'Pencil',line:'Line',rect:'Rectangle',
    ellipse:'Ellipse',fill:'Fill',eyedropper:'Eyedropper',text:'Text',
    select:'Selection',move:'Move',hand:'Hand',zoom:'Zoom'}[t] || t;
}

function updateOptionsBar() {
  document.getElementById('brush-options').style.display = ['brush','eraser','pencil'].includes(currentTool) ? 'flex' : 'none';
  document.getElementById('shape-options').style.display = ['line','rect','ellipse'].includes(currentTool) ? 'flex' : 'none';
  document.getElementById('text-options').style.display = currentTool === 'text' ? 'flex' : 'none';
  document.getElementById('select-options').style.display = currentTool === 'select' ? 'flex' : 'none';
  mainCanvas.style.cursor = {
    brush:'crosshair',eraser:'crosshair',pencil:'crosshair',
    fill:'crosshair',eyedropper:'crosshair',text:'text',
    select:'crosshair',move:'move',hand:'grab',zoom:'zoom-in'
  }[currentTool] || 'default';
}

// ===== OPTIONS SYNC =====
const bsSlider = document.getElementById('brush-size');
const bsNum = document.getElementById('brush-size-num');
const boSlider = document.getElementById('brush-opacity');
const boNum = document.getElementById('brush-opacity-num');
const bhSlider = document.getElementById('brush-hardness');

bsSlider.oninput = () => { brushSize = +bsSlider.value; bsNum.value = brushSize; };
bsNum.onchange = () => { brushSize = +bsNum.value; bsSlider.value = brushSize; };
boSlider.oninput = () => { brushOpacity = +boSlider.value; boNum.value = brushOpacity; };
boNum.onchange = () => { brushOpacity = +boNum.value; boSlider.value = brushOpacity; };
bhSlider.oninput = () => { brushHardness = +bhSlider.value; };
document.getElementById('brush-shape').onchange = (e) => { brushShape = e.target.value; };

// ===== COLORS =====
function setFGColor(hex) {
  fgColor = hex;
  document.getElementById('fg-color').style.background = hex;
  document.getElementById('fg-picker').value = hex;
  document.getElementById('hex-input').value = hex;
  document.getElementById('color-preview').style.background = hex;
  updateColorSliders(hex);
  updateColorCanvas();
}

function setBGColor(hex) {
  bgColor = hex;
  document.getElementById('bg-color').style.background = hex;
  document.getElementById('bg-picker').value = hex;
}

function swapColors() {
  const tmp = fgColor;
  setFGColor(bgColor);
  setBGColor(tmp);
}

document.getElementById('fg-picker').addEventListener('input', (e) => setFGColor(e.target.value));
document.getElementById('bg-picker').addEventListener('input', (e) => setBGColor(e.target.value));
document.getElementById('hex-input').addEventListener('change', (e) => {
  let v = e.target.value;
  if (!v.startsWith('#')) v = '#' + v;
  if (/^#[0-9a-fA-F]{6}$/.test(v)) setFGColor(v);
});

function updateColorSliders(hex) {
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  document.getElementById('r-slider').value = r;
  document.getElementById('g-slider').value = g;
  document.getElementById('b-slider').value = b;
  document.getElementById('r-val').textContent = r;
  document.getElementById('g-val').textContent = g;
  document.getElementById('b-val').textContent = b;
}

['r-slider','g-slider','b-slider'].forEach(id => {
  document.getElementById(id).addEventListener('input', () => {
    const r = +document.getElementById('r-slider').value;
    const g = +document.getElementById('g-slider').value;
    const b = +document.getElementById('b-slider').value;
    const hex = '#' + [r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');
    setFGColor(hex);
  });
});

// Color Canvas (saturation/brightness)
const colorCanvas = document.getElementById('color-canvas');
const colorCCtx = colorCanvas.getContext('2d');
const hueBar = document.getElementById('hue-bar');
const hueCtx = hueBar.getContext('2d');
let currentHue = 0;

function drawHueBar() {
  const grad = hueCtx.createLinearGradient(0, 0, hueBar.width, 0);
  for (let i = 0; i <= 360; i += 30) grad.addColorStop(i/360, `hsl(${i},100%,50%)`);
  hueCtx.fillStyle = grad;
  hueCtx.fillRect(0, 0, hueBar.width, hueBar.height);
}

function updateColorCanvas() {
  const w = colorCanvas.width, h = colorCanvas.height;
  // Base hue
  colorCCtx.fillStyle = `hsl(${currentHue}, 100%, 50%)`;
  colorCCtx.fillRect(0, 0, w, h);
  // White gradient left to right
  const whiteGrad = colorCCtx.createLinearGradient(0, 0, w, 0);
  whiteGrad.addColorStop(0, 'rgba(255,255,255,1)');
  whiteGrad.addColorStop(1, 'rgba(255,255,255,0)');
  colorCCtx.fillStyle = whiteGrad;
  colorCCtx.fillRect(0, 0, w, h);
  // Black gradient top to bottom
  const blackGrad = colorCCtx.createLinearGradient(0, 0, 0, h);
  blackGrad.addColorStop(0, 'rgba(0,0,0,0)');
  blackGrad.addColorStop(1, 'rgba(0,0,0,1)');
  colorCCtx.fillStyle = blackGrad;
  colorCCtx.fillRect(0, 0, w, h);
}

colorCanvas.addEventListener('mousedown', (e) => {
  const pick = (ev) => {
    const rect = colorCanvas.getBoundingClientRect();
    const x = Math.max(0, Math.min(colorCanvas.width-1, ev.clientX - rect.left));
    const y = Math.max(0, Math.min(colorCanvas.height-1, ev.clientY - rect.top));
    const pixel = colorCCtx.getImageData(x, y, 1, 1).data;
    const hex = '#' + [pixel[0],pixel[1],pixel[2]].map(v=>v.toString(16).padStart(2,'0')).join('');
    setFGColor(hex);
  };
  pick(e);
  const move = (ev) => pick(ev);
  const up = () => { document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', up); };
  document.addEventListener('mousemove', move);
  document.addEventListener('mouseup', up);
});

hueBar.addEventListener('mousedown', (e) => {
  const pick = (ev) => {
    const rect = hueBar.getBoundingClientRect();
    const x = Math.max(0, Math.min(hueBar.width-1, ev.clientX - rect.left));
    currentHue = (x / hueBar.width) * 360;
    updateColorCanvas();
    const pixel = colorCCtx.getImageData(0, 0, 1, 1).data;
    // Re-pick at current SB position would be complex, just update canvas
  };
  pick(e);
  const move = (ev) => pick(ev);
  const up = () => { document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', up); };
  document.addEventListener('mousemove', move);
  document.addEventListener('mouseup', up);
});

// ===== LAYERS UI =====
function renderLayers() {
  const list = document.getElementById('layers-list');
  list.innerHTML = '';
  // Render in reverse (top layer first)
  for (let i = layers.length - 1; i >= 0; i--) {
    const l = layers[i];
    const item = document.createElement('div');
    item.className = 'layer-item' + (i === activeLayerIdx ? ' active' : '');
    
    const thumb = document.createElement('div');
    thumb.className = 'layer-thumb';
    const tc = document.createElement('canvas');
    tc.width = 36; tc.height = 28;
    const tctx = tc.getContext('2d');
    tctx.drawImage(l.canvas, 0, 0, 36, 28);
    thumb.appendChild(tc);
    
    const info = document.createElement('div');
    info.className = 'layer-info';
    info.innerHTML = `<div class="layer-name">${l.name}</div><div class="layer-blend-info">${l.blendMode === 'source-over' ? 'Normal' : l.blendMode} ¬∑ ${Math.round(l.opacity*100)}%</div>`;
    
    const vis = document.createElement('div');
    vis.className = 'layer-vis' + (l.visible ? '' : ' hidden');
    vis.textContent = l.visible ? 'üëÅ' : 'üëÅ';
    vis.onclick = (e) => { e.stopPropagation(); l.visible = !l.visible; compositeAndDisplay(); renderLayers(); };
    
    item.appendChild(vis);
    item.appendChild(thumb);
    item.appendChild(info);
    item.onclick = () => { activeLayerIdx = i; renderLayers(); updateLayerUI(); };
    item.ondblclick = () => {
      const newName = prompt('Layer name:', l.name);
      if (newName) { l.name = newName; renderLayers(); }
    };
    
    list.appendChild(item);
  }
  updateLayerUI();
}

function updateLayerUI() {
  const l = getActiveLayer();
  if (!l) return;
  document.getElementById('layer-blend').value = l.blendMode;
  document.getElementById('layer-opacity').value = Math.round(l.opacity * 100);
  document.getElementById('layer-opacity-val').textContent = Math.round(l.opacity * 100) + '%';
}

function addLayer() {
  const l = new Layer('Layer ' + (layers.length + 1), W, H);
  layers.splice(activeLayerIdx + 1, 0, l);
  activeLayerIdx = activeLayerIdx + 1;
  compositeAndDisplay();
  saveHistory('New Layer');
  renderLayers();
}

function deleteLayer() {
  if (layers.length <= 1) return;
  layers.splice(activeLayerIdx, 1);
  activeLayerIdx = Math.min(activeLayerIdx, layers.length - 1);
  compositeAndDisplay();
  saveHistory('Delete Layer');
  renderLayers();
}

function duplicateLayer() {
  const l = getActiveLayer().clone();
  layers.splice(activeLayerIdx + 1, 0, l);
  activeLayerIdx++;
  compositeAndDisplay();
  saveHistory('Duplicate Layer');
  renderLayers();
}

function mergeDown() {
  if (activeLayerIdx <= 0) return;
  const upper = layers[activeLayerIdx];
  const lower = layers[activeLayerIdx - 1];
  lower.ctx.save();
  lower.ctx.globalAlpha = upper.opacity;
  lower.ctx.globalCompositeOperation = upper.blendMode;
  lower.ctx.drawImage(upper.canvas, 0, 0);
  lower.ctx.restore();
  layers.splice(activeLayerIdx, 1);
  activeLayerIdx--;
  compositeAndDisplay();
  saveHistory('Merge Down');
  renderLayers();
}

function moveLayerUp() {
  if (activeLayerIdx >= layers.length - 1) return;
  [layers[activeLayerIdx], layers[activeLayerIdx + 1]] = [layers[activeLayerIdx + 1], layers[activeLayerIdx]];
  activeLayerIdx++;
  compositeAndDisplay();
  renderLayers();
}

function moveLayerDown() {
  if (activeLayerIdx <= 0) return;
  [layers[activeLayerIdx], layers[activeLayerIdx - 1]] = [layers[activeLayerIdx - 1], layers[activeLayerIdx]];
  activeLayerIdx--;
  compositeAndDisplay();
  renderLayers();
}

function setLayerBlend(mode) {
  getActiveLayer().blendMode = mode;
  compositeAndDisplay();
  renderLayers();
}

function setLayerOpacity(val) {
  getActiveLayer().opacity = val / 100;
  document.getElementById('layer-opacity-val').textContent = val + '%';
  compositeAndDisplay();
  renderLayers();
}

function clearLayer() {
  getActiveLayer().ctx.clearRect(0, 0, W, H);
  compositeAndDisplay();
  saveHistory('Clear Layer');
  renderLayers();
}

function fillLayer() {
  const ctx = getActiveLayer().ctx;
  ctx.fillStyle = fgColor;
  if (selection) {
    ctx.fillRect(selection.x, selection.y, selection.w, selection.h);
  } else {
    ctx.fillRect(0, 0, W, H);
  }
  compositeAndDisplay();
  saveHistory('Fill');
  renderLayers();
}

function flattenImage() {
  const flat = new Layer('Background', W, H);
  flat.ctx.fillStyle = '#fff';
  flat.ctx.fillRect(0, 0, W, H);
  for (const l of layers) {
    if (!l.visible) continue;
    flat.ctx.save();
    flat.ctx.globalAlpha = l.opacity;
    flat.ctx.globalCompositeOperation = l.blendMode;
    flat.ctx.drawImage(l.canvas, 0, 0);
    flat.ctx.restore();
  }
  layers = [flat];
  activeLayerIdx = 0;
  compositeAndDisplay();
  saveHistory('Flatten');
  renderLayers();
}

// ===== HISTORY UI =====
function renderHistory() {
  const list = document.getElementById('history-list');
  list.innerHTML = '';
  const icons = {Brush:'üñåÔ∏è',Eraser:'üßπ',Pencil:'‚úèÔ∏è',Line:'‚ï±',Rectangle:'‚ñ≠',Ellipse:'‚óØ',Fill:'ü™£',Text:'T',
    'New Canvas':'üìÑ','New Layer':'Ôºã','Delete Layer':'‚úï','Duplicate Layer':'‚ßâ','Merge Down':'‚§ì',
    'Move Layer':'‚ú•','Clear Layer':'üßπ','Flatten':'‚äü',Filter:'üé®',Blur:'üåÄ',Sharpen:'‚óá',
    'Brightness/Contrast':'‚òÄÔ∏è','Hue/Saturation':'üåà',Grayscale:'‚óê',Sepia:'üü§',Invert:'üîÑ',
    'Flip H':'‚Üî','Flip V':'‚Üï','Posterize':'üé®','Noise':'üì∫','Emboss':'üî≤','Edge Detect':'‚¨°'};
  history.forEach((h, i) => {
    const item = document.createElement('div');
    item.className = 'history-item' + (i === historyIdx ? ' active' : '') + (i > historyIdx ? ' future' : '');
    item.innerHTML = `<span class="h-icon">${icons[h.name]||'‚óè'}</span> ${h.name}`;
    item.onclick = () => restoreHistory(i);
    list.appendChild(item);
  });
  list.scrollTop = list.scrollHeight;
}

// ===== FILTERS =====
let currentFilter = null;

function showFilter(type) {
  currentFilter = type;
  const modal = document.getElementById('filter-modal');
  const title = document.getElementById('filter-title');
  const body = document.getElementById('filter-body');
  
  if (type === 'blur') {
    title.textContent = 'Gaussian Blur';
    body.innerHTML = `<div class="filter-row"><label>Radius:</label><input type="range" id="f-blur-r" min="0" max="50" value="5"><span class="val" id="f-blur-val">5</span></div>`;
    document.getElementById('f-blur-r').oninput = (e) => document.getElementById('f-blur-val').textContent = e.target.value;
  } else if (type === 'brightness') {
    title.textContent = 'Brightness / Contrast';
    body.innerHTML = `
      <div class="filter-row"><label>Brightness:</label><input type="range" id="f-bright" min="-100" max="100" value="0"><span class="val" id="f-bright-val">0</span></div>
      <div class="filter-row"><label>Contrast:</label><input type="range" id="f-contrast" min="-100" max="100" value="0"><span class="val" id="f-contrast-val">0</span></div>`;
    document.getElementById('f-bright').oninput = (e) => document.getElementById('f-bright-val').textContent = e.target.value;
    document.getElementById('f-contrast').oninput = (e) => document.getElementById('f-contrast-val').textContent = e.target.value;
  } else if (type === 'huesat') {
    title.textContent = 'Hue / Saturation';
    body.innerHTML = `
      <div class="filter-row"><label>Hue:</label><input type="range" id="f-hue" min="-180" max="180" value="0"><span class="val" id="f-hue-val">0</span></div>
      <div class="filter-row"><label>Saturation:</label><input type="range" id="f-sat" min="-100" max="100" value="0"><span class="val" id="f-sat-val">0</span></div>
      <div class="filter-row"><label>Lightness:</label><input type="range" id="f-light" min="-100" max="100" value="0"><span class="val" id="f-light-val">0</span></div>`;
    document.getElementById('f-hue').oninput = (e) => document.getElementById('f-hue-val').textContent = e.target.value;
    document.getElementById('f-sat').oninput = (e) => document.getElementById('f-sat-val').textContent = e.target.value;
    document.getElementById('f-light').oninput = (e) => document.getElementById('f-light-val').textContent = e.target.value;
  } else if (type === 'sharpen') {
    title.textContent = 'Sharpen';
    body.innerHTML = `<div class="filter-row"><label>Amount:</label><input type="range" id="f-sharp" min="1" max="10" value="3"><span class="val" id="f-sharp-val">3</span></div>`;
    document.getElementById('f-sharp').oninput = (e) => document.getElementById('f-sharp-val').textContent = e.target.value;
  }
  
  modal.classList.remove('hidden');
}

function closeFilterModal() { document.getElementById('filter-modal').classList.add('hidden'); }

function applyFilterModal() {
  const layer = getActiveLayer();
  const ctx = layer.ctx;
  const region = selection || {x:0,y:0,w:W,h:H};
  const imageData = ctx.getImageData(region.x, region.y, region.w, region.h);
  
  if (currentFilter === 'blur') {
    const r = +document.getElementById('f-blur-r').value;
    boxBlur(imageData, region.w, region.h, r);
  } else if (currentFilter === 'brightness') {
    const bright = +document.getElementById('f-bright').value;
    const contrast = +document.getElementById('f-contrast').value;
    adjustBrightnessContrast(imageData, bright, contrast);
  } else if (currentFilter === 'huesat') {
    const hue = +document.getElementById('f-hue').value;
    const sat = +document.getElementById('f-sat').value;
    const light = +document.getElementById('f-light').value;
    adjustHSL(imageData, hue, sat, light);
  } else if (currentFilter === 'sharpen') {
    const amount = +document.getElementById('f-sharp').value;
    convolve(imageData, region.w, region.h, [0,-amount,0,-amount,1+4*amount,-amount,0,-amount,0]);
  }
  
  ctx.putImageData(imageData, region.x, region.y);
  compositeAndDisplay();
  saveHistory(document.getElementById('filter-title').textContent);
  renderLayers();
  closeFilterModal();
}

function applyQuickFilter(type) {
  const layer = getActiveLayer();
  const ctx = layer.ctx;
  const region = selection || {x:0,y:0,w:W,h:H};
  const imageData = ctx.getImageData(region.x, region.y, region.w, region.h);
  const d = imageData.data;
  
  if (type === 'grayscale') {
    for (let i = 0; i < d.length; i += 4) {
      const g = d[i]*0.299 + d[i+1]*0.587 + d[i+2]*0.114;
      d[i] = d[i+1] = d[i+2] = g;
    }
  } else if (type === 'sepia') {
    for (let i = 0; i < d.length; i += 4) {
      const r=d[i],g=d[i+1],b=d[i+2];
      d[i] = Math.min(255, r*0.393+g*0.769+b*0.189);
      d[i+1] = Math.min(255, r*0.349+g*0.686+b*0.168);
      d[i+2] = Math.min(255, r*0.272+g*0.534+b*0.131);
    }
  } else if (type === 'invert') {
    for (let i = 0; i < d.length; i += 4) {
      d[i] = 255-d[i]; d[i+1] = 255-d[i+1]; d[i+2] = 255-d[i+2];
    }
  } else if (type === 'posterize') {
    const levels = 4;
    for (let i = 0; i < d.length; i += 4) {
      d[i] = Math.round(d[i]/255*(levels-1))/(levels-1)*255;
      d[i+1] = Math.round(d[i+1]/255*(levels-1))/(levels-1)*255;
      d[i+2] = Math.round(d[i+2]/255*(levels-1))/(levels-1)*255;
    }
  } else if (type === 'noise') {
    for (let i = 0; i < d.length; i += 4) {
      const n = (Math.random()-0.5)*60;
      d[i]=Math.max(0,Math.min(255,d[i]+n));
      d[i+1]=Math.max(0,Math.min(255,d[i+1]+n));
      d[i+2]=Math.max(0,Math.min(255,d[i+2]+n));
    }
  } else if (type === 'emboss') {
    convolve(imageData, region.w, region.h, [-2,-1,0,-1,1,1,0,1,2]);
  } else if (type === 'edge') {
    convolve(imageData, region.w, region.h, [-1,-1,-1,-1,8,-1,-1,-1,-1]);
  }
  
  ctx.putImageData(imageData, region.x, region.y);
  compositeAndDisplay();
  const names = {grayscale:'Grayscale',sepia:'Sepia',invert:'Invert',posterize:'Posterize',noise:'Noise',emboss:'Emboss',edge:'Edge Detect'};
  saveHistory(names[type] || 'Filter');
  renderLayers();
}

// Filter helpers
function boxBlur(imageData, w, h, radius) {
  if (radius < 1) return;
  const d = imageData.data;
  const copy = new Uint8ClampedArray(d);
  const r = Math.round(radius);
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      let rr=0,gg=0,bb=0,aa=0,count=0;
      for (let dy = -r; dy <= r; dy++) {
        for (let dx = -r; dx <= r; dx++) {
          const nx=x+dx, ny=y+dy;
          if (nx<0||nx>=w||ny<0||ny>=h) continue;
          const i=(ny*w+nx)*4;
          rr+=copy[i]; gg+=copy[i+1]; bb+=copy[i+2]; aa+=copy[i+3]; count++;
        }
      }
      const i=(y*w+x)*4;
      d[i]=rr/count; d[i+1]=gg/count; d[i+2]=bb/count; d[i+3]=aa/count;
    }
  }
}

function convolve(imageData, w, h, kernel) {
  const d = imageData.data;
  const copy = new Uint8ClampedArray(d);
  const kSize = Math.sqrt(kernel.length);
  const half = Math.floor(kSize / 2);
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      let r=0,g=0,b=0;
      for (let ky = 0; ky < kSize; ky++) {
        for (let kx = 0; kx < kSize; kx++) {
          const nx = x + kx - half, ny = y + ky - half;
          if (nx<0||nx>=w||ny<0||ny>=h) continue;
          const i = (ny*w+nx)*4;
          const k = kernel[ky*kSize+kx];
          r += copy[i]*k; g += copy[i+1]*k; b += copy[i+2]*k;
        }
      }
      const i = (y*w+x)*4;
      d[i]=Math.max(0,Math.min(255,r));
      d[i+1]=Math.max(0,Math.min(255,g));
      d[i+2]=Math.max(0,Math.min(255,b));
    }
  }
}

function adjustBrightnessContrast(imageData, bright, contrast) {
  const d = imageData.data;
  const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
  for (let i = 0; i < d.length; i += 4) {
    d[i] = Math.max(0,Math.min(255, factor*(d[i]-128)+128+bright));
    d[i+1] = Math.max(0,Math.min(255, factor*(d[i+1]-128)+128+bright));
    d[i+2] = Math.max(0,Math.min(255, factor*(d[i+2]-128)+128+bright));
  }
}

function adjustHSL(imageData, hueShift, satShift, lightShift) {
  const d = imageData.data;
  for (let i = 0; i < d.length; i += 4) {
    let [h,s,l] = rgbToHsl(d[i],d[i+1],d[i+2]);
    h = (h + hueShift/360 + 1) % 1;
    s = Math.max(0, Math.min(1, s + satShift/100));
    l = Math.max(0, Math.min(1, l + lightShift/100));
    const [r,g,b] = hslToRgb(h,s,l);
    d[i]=r; d[i+1]=g; d[i+2]=b;
  }
}

function rgbToHsl(r,g,b) {
  r/=255;g/=255;b/=255;
  const mx=Math.max(r,g,b),mn=Math.min(r,g,b);
  let h,s,l=(mx+mn)/2;
  if(mx===mn){h=s=0;}else{
    const d=mx-mn;s=l>0.5?d/(2-mx-mn):d/(mx+mn);
    if(mx===r)h=((g-b)/d+(g<b?6:0))/6;
    else if(mx===g)h=((b-r)/d+2)/6;
    else h=((r-g)/d+4)/6;
  }
  return[h,s,l];
}

function hslToRgb(h,s,l) {
  let r,g,b;
  if(s===0){r=g=b=l;}else{
    const hue2rgb=(p,q,t)=>{if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;};
    const q=l<0.5?l*(1+s):l+s-l*s;const p=2*l-q;
    r=hue2rgb(p,q,h+1/3);g=hue2rgb(p,q,h);b=hue2rgb(p,q,h-1/3);
  }
  return[Math.round(r*255),Math.round(g*255),Math.round(b*255)];
}

// ===== FLIP =====
function flipH() {
  const l = getActiveLayer();
  const temp = document.createElement('canvas');
  temp.width = W; temp.height = H;
  const tctx = temp.getContext('2d');
  tctx.translate(W, 0);
  tctx.scale(-1, 1);
  tctx.drawImage(l.canvas, 0, 0);
  l.ctx.clearRect(0, 0, W, H);
  l.ctx.drawImage(temp, 0, 0);
  compositeAndDisplay();
  saveHistory('Flip H');
  renderLayers();
}

function flipV() {
  const l = getActiveLayer();
  const temp = document.createElement('canvas');
  temp.width = W; temp.height = H;
  const tctx = temp.getContext('2d');
  tctx.translate(0, H);
  tctx.scale(1, -1);
  tctx.drawImage(l.canvas, 0, 0);
  l.ctx.clearRect(0, 0, W, H);
  l.ctx.drawImage(temp, 0, 0);
  compositeAndDisplay();
  saveHistory('Flip V');
  renderLayers();
}

// ===== FILE OPS =====
function showNewDialog() { document.getElementById('new-modal').classList.remove('hidden'); }
function createNewCanvas() {
  const w = parseInt(document.getElementById('new-width').value) || 800;
  const h = parseInt(document.getElementById('new-height').value) || 600;
  const bg = document.getElementById('new-bg').value;
  initCanvas(w, h, bg);
  document.getElementById('new-modal').classList.add('hidden');
}

function openFile() { document.getElementById('file-input').click(); }
document.getElementById('file-input').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const img = new Image();
  img.onload = () => {
    initCanvas(img.width, img.height, 'transparent');
    layers[0].ctx.drawImage(img, 0, 0);
    layers[0].name = file.name;
    compositeAndDisplay();
    saveHistory('Open File');
    renderLayers();
    fitToScreen();
  };
  img.src = URL.createObjectURL(file);
  e.target.value = '';
});

function saveFile(format) {
  // Flatten to temp canvas
  const temp = document.createElement('canvas');
  temp.width = W; temp.height = H;
  const tctx = temp.getContext('2d');
  if (format !== 'png') { tctx.fillStyle = '#fff'; tctx.fillRect(0, 0, W, H); }
  for (const l of layers) {
    if (!l.visible) continue;
    tctx.save();
    tctx.globalAlpha = l.opacity;
    tctx.globalCompositeOperation = l.blendMode;
    tctx.drawImage(l.canvas, 0, 0);
    tctx.restore();
  }
  const a = document.createElement('a');
  a.download = `image.${format}`;
  a.href = temp.toDataURL(`image/${format}`, 0.92);
  a.click();
}

// ===== KEYBOARD SHORTCUTS =====
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
  
  const ctrl = e.ctrlKey || e.metaKey;
  
  if (ctrl && e.key === 'z') { e.preventDefault(); undo(); }
  else if (ctrl && e.key === 'y') { e.preventDefault(); redo(); }
  else if (ctrl && e.key === 'n') { e.preventDefault(); showNewDialog(); }
  else if (ctrl && e.key === 'o') { e.preventDefault(); openFile(); }
  else if (ctrl && e.key === 's') { e.preventDefault(); saveFile('png'); }
  else if (ctrl && e.key === '0') { e.preventDefault(); fitToScreen(); }
  else if (ctrl && e.key === '1') { e.preventDefault(); setZoom(1); }
  else if (ctrl && e.key === '=') { e.preventDefault(); zoomIn(); }
  else if (ctrl && e.key === '-') { e.preventDefault(); zoomOut(); }
  else if (e.key === 'Delete') { clearLayer(); }
  else if (e.key === 'd' && ctrl) { e.preventDefault(); deselectAll(); }
  else if (e.key === 'a' && ctrl) { e.preventDefault(); selectAll(); }
  else if (e.key === 'x' && !ctrl) { swapColors(); }
  else {
    // Tool shortcuts
    const toolKeys = {b:'brush',e:'eraser',p:'pencil',l:'line',u:'rect',o:'ellipse',g:'fill',i:'eyedropper',t:'text',m:'select',v:'move',h:'hand',z:'zoom'};
    if (toolKeys[e.key.toLowerCase()] && !ctrl) {
      const tool = toolKeys[e.key.toLowerCase()];
      currentTool = tool;
      document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
      document.querySelector(`.tool-btn[data-tool="${tool}"]`)?.classList.add('active');
      document.getElementById('active-tool-name').textContent = getToolName(tool);
      updateOptionsBar();
    }
    // Brush size with [ ]
    if (e.key === '[') { brushSize = Math.max(1, brushSize - 5); bsSlider.value = brushSize; bsNum.value = brushSize; }
    if (e.key === ']') { brushSize = Math.min(500, brushSize + 5); bsSlider.value = brushSize; bsNum.value = brushSize; }
  }
});

// ===== BRUSH PRESETS =====
function createBrushPresets() {
  const panel = document.querySelector('#panel-brushes .panel-body');
  const presets = [
    {name:'Fine',size:2,hard:100,opacity:100},
    {name:'Soft Small',size:8,hard:30,opacity:80},
    {name:'Medium',size:16,hard:80,opacity:100},
    {name:'Soft Large',size:40,hard:20,opacity:60},
    {name:'Large',size:50,hard:90,opacity:100},
    {name:'Airbrush',size:30,hard:5,opacity:30},
    {name:'Ink',size:4,hard:100,opacity:100},
    {name:'Marker',size:20,hard:60,opacity:85},
    {name:'Spray',size:60,hard:10,opacity:20},
    {name:'Detail',size:1,hard:100,opacity:100},
  ];
  presets.forEach(p => {
    const btn = document.createElement('div');
    btn.style.cssText = `width:48px;height:48px;background:var(--bg-input);border:1px solid var(--border);border-radius:4px;cursor:pointer;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:9px;color:var(--text-dim);gap:2px;`;
    // Draw preview
    const c = document.createElement('canvas');
    c.width = 30; c.height = 24;
    const cx = c.getContext('2d');
    cx.fillStyle = '#aaa';
    cx.beginPath();
    const r = Math.min(p.size, 12);
    cx.arc(15, 12, r, 0, Math.PI * 2);
    cx.globalAlpha = p.opacity / 100;
    cx.fill();
    btn.appendChild(c);
    const label = document.createElement('span');
    label.textContent = p.name;
    btn.appendChild(label);
    btn.onclick = () => {
      brushSize = p.size;
      brushHardness = p.hard;
      brushOpacity = p.opacity;
      bsSlider.value = brushSize; bsNum.value = brushSize;
      boSlider.value = brushOpacity; boNum.value = brushOpacity;
      bhSlider.value = brushHardness;
      // Switch to brush tool
      currentTool = 'brush';
      document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
      document.querySelector('.tool-btn[data-tool="brush"]').classList.add('active');
      updateOptionsBar();
    };
    btn.onmouseenter = () => btn.style.borderColor = 'var(--accent)';
    btn.onmouseleave = () => btn.style.borderColor = 'var(--border)';
    panel.appendChild(btn);
  });
}

function updateStatus() {
  document.getElementById('canvas-size').textContent = `${W} √ó ${H}`;
}

// ===== INIT =====
drawHueBar();
updateColorCanvas();
setFGColor('#000000');
setBGColor('#ffffff');
initCanvas(800, 600, 'white');
createBrushPresets();
updateOptionsBar();
document.getElementById('status-msg').textContent = 'Ready';
</script>
</body>
</html>
