<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Poly Medieval Island Diorama</title>
    <!-- Load Babylon.js from CDN -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    
    <style>
        html, body { overflow: hidden; width: 100%; height: 100%; margin: 0; padding: 0; background: #1a1a1a; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; outline: none; }
        
        /* Loading Overlay */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff; font-size: 24px; text-align: center;
            pointer-events: none; transition: opacity 0.5s;
        }
        
        /* UI Controls Hint */
        #controls {
            position: absolute; bottom: 20px; left: 20px;
            color: rgba(255,255,255,0.7);
            font-family: sans-serif; font-size: 14px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loading">Generating Diorama...<br><span style="font-size:14px; color:#aaa;">Procedurally sculpting terrain & structures...</span></div>
    <div id="controls">Left Click: Rotate | Right Click: Pan | Scroll: Zoom</div>
    <canvas id="renderCanvas"></canvas>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const createScene = function () {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.5, 0.7, 0.85); // Soft Sky Blue

            // --- Camera ---
            const camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2.5, Math.PI / 3, 65, new BABYLON.Vector3(0, 10, 0), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 30;
            camera.upperRadiusLimit = 160;
            camera.wheelPrecision = 50;
            camera.minZ = 0.1; // Near plane for shadows

            // --- Lighting (Handcrafted Miniature Look) ---
            const hemiLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
            hemiLight.intensity = 0.7;
            hemiLight.groundColor = new BABYLON.Color3(0.2, 0.2, 0.2); // Soft bounce
            hemiLight.diffuse = new BABYLON.Color3(1.0, 0.98, 0.95); // Warm sunlight

            const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
            dirLight.position = new BABYLON.Vector3(-50, 100, -50);
            dirLight.intensity = 0.9;

            // --- Shadows ---
            const shadowGenerator = new BABYLON.ShadowGenerator(2048, dirLight);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;
            shadowGenerator.setDarkness(0.4); // Soft, toy-like shadows

            // --- Materials (Stylized/Painted Look) ---
            const mat = {};
            
            mat.grass = new BABYLON.StandardMaterial("grass", scene);
            mat.grass.diffuseColor = new BABYLON.Color3(0.5, 0.65, 0.4); // Vibrant Green
            mat.grass.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1); // Low gloss

            mat.stone = new BABYLON.StandardMaterial("stone", scene);
            mat.stone.diffuseColor = new BABYLON.Color3(0.6, 0.58, 0.55); // Sandstone
            mat.stone.bumpTexture = new BABYLON.NoiseProceduralTexture("noise", 256, scene);
            mat.stone.bumpTexture.uScale = 5;
            mat.stone.bumpTexture.vScale = 5;
            mat.stone.bumpTexture.level = 0.3;

            mat.wood = new BABYLON.StandardMaterial("wood", scene);
            mat.wood.diffuseColor = new BABYLON.Color3(0.55, 0.35, 0.15); // Oak
            
            mat.roofDark = new BABYLON.StandardMaterial("roofDark", scene);
            mat.roofDark.diffuseColor = new BABYLON.Color3(0.6, 0.2, 0.15);

            mat.roofRed = new BABYLON.StandardMaterial("roofRed", scene);
            mat.roofRed.diffuseColor = new BABYLON.Color3(0.75, 0.2, 0.2);

            mat.water = new BABYLON.StandardMaterial("water", scene);
            mat.water.diffuseColor = new BABYLON.Color3(0.3, 0.7, 0.9); // Turquoise
            mat.water.alpha = 0.85;
            mat.water.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);

            mat.leaf = new BABYLON.StandardMaterial("leaf", scene);
            mat.leaf.diffuseColor = new BABYLON.Color3(0.15, 0.35, 0.15);

            mat.rock = new BABYLON.StandardMaterial("rock", scene);
            mat.rock.diffuseColor = new BABYLON.Color3(0.45, 0.45, 0.5); // Slate Grey

            // --- 1. TERRAIN (Procedural Floating Island) ---
            const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 160, height: 160, subdivisions: 200}, scene);
            ground.material = mat.grass;
            ground.receiveShadows = true;

            // Sculpting: Elevation & Cliffs
            const positions = ground.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            for (let i = 0; i < positions.length; i+=3) {
                let x = positions[i];
                let y = positions[i+1]; // Actually Z in world space
                const dist = Math.sqrt(x*x + y*y);
                
                // Island Shape
                let height = 0;
                if (dist < 50) {
                    height = Math.sin(dist * 0.1) * 3 + Math.cos(x*0.1)*2 + Math.sin(y*0.1)*2; // Rolling hills
                } else if (dist < 70) {
                    height = 5 + (dist - 50) * 0.8; // Steep rise to cliff
                } else {
                    height = 20 + Math.random() * 5; // Top of cliff
                }

                // Add Noise/Rocky detail
                height += Math.sin(x*0.5) * Math.cos(y*0.5);

                positions[i+1] = height;
                
                // Carve River Bed (Flat strip at Z approx 0)
                if (Math.abs(x) < 6 && Math.abs(y) < 40) {
                     positions[i+1] = 0; // River bed
                }
            }
            ground.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
            
            // --- 2. RIVER & WATERFALL ---
            const river = BABYLON.MeshBuilder.CreateGround("river", {width: 12, height: 80, subdivisions: 40}, scene);
            river.rotation.x = Math.PI / 2;
            river.position.y = 0.2;
            river.material = mat.water;

            // Animate River Water
            scene.onBeforeRenderObservable.add(() => {
                const v = river.getVerticesData(BABYLON.VertexBuffer.PositionKind);
                for(let i=0; i<v.length; i+=3) {
                    // Ripple effect
                    const time = performance.now() * 0.002;
                    v[i+2] = Math.sin(v[i]*2 + time) * 0.2; // Z is actually Y relative to the rotated mesh
                }
                river.updateVerticesData(BABYLON.VertexBuffer.PositionKind, v);
            });

            // Waterfall (Edge of island at Z approx 40)
            const waterfall = BABYLON.MeshBuilder.CreatePlane("waterfall", {width: 8, height: 12, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
            waterfall.position.set(6, 18, 38); // Top of cliff
            waterfall.rotation.y = Math.PI / 2;
            waterfall.material = mat.water;

            // --- 3. CASTLE (Center) ---
            const castle = new BABYLON.TransformNode("castle", scene);
            castle.position.y = 2;

            // Main Keep
            const keep = BABYLON.MeshBuilder.CreateCylinder("keep", {height: 12, diameter: 8}, scene);
            keep.material = mat.stone;
            keep.parent = castle;
            shadowGenerator.addShadowCaster(keep);

            // Keep Roof
            const keepRoof = BABYLON.MeshBuilder.CreateCylinder("keepRoof", {height: 4, diameterTop: 0, diameterBottom: 9}, scene);
            keepRoof.material = mat.roofDark;
            keepRoof.position.y = 8;
            keepRoof.parent = castle;
            shadowGenerator.addShadowCaster(keepRoof);

            // 4 Towers
            for(let i=0; i<4; i++) {
                const ang = (i/4)*Math.PI*2;
                const tx = Math.cos(ang)*7;
                const tz = Math.sin(ang)*7;
                
                const tower = BABYLON.MeshBuilder.CreateCylinder("tower"+i, {height: 14, diameter: 4}, scene);
                tower.material = mat.stone;
                tower.position.set(tx, 0, tz);
                tower.parent = castle;
                shadowGenerator.addShadowCaster(tower);

                // Crenellations (Battlements) on top
                for(let j=0; j<4; j++) {
                    const c = BABYLON.MeshBuilder.CreateBox("c"+i+j, {width: 1.5, height: 1.5, depth: 1.5}, scene);
                    c.material = mat.stone;
                    const ang2 = (j/4)*Math.PI*2;
                    c.position.set(tx + Math.cos(ang2)*1.5, 7, tz + Math.sin(ang2)*1.5);
                    c.parent = castle;
                }

                // Conical Roofs
                const tRoof = BABYLON.MeshBuilder.CreateCylinder("tRoof"+i, {height: 4, diameterTop: 0, diameterBottom: 5}, scene);
                tRoof.material = mat.roofDark;
                tRoof.position.set(tx, 7.5, tz);
                tRoof.parent = castle;
                shadowGenerator.addShadowCaster(tRoof);
            }

            // Walls
            for(let i=0; i<4; i++) {
                const wall = BABYLON.MeshBuilder.CreateBox("wall"+i, {width: 4, height: 7, depth: 1}, scene);
                wall.material = mat.stone;
                const ang = (i/4)*Math.PI*2;
                wall.position.set(Math.cos(ang)*5, 3.5, Math.sin(ang)*5);
                wall.rotation.y = -ang;
                wall.parent = castle;
                shadowGenerator.addShadowCaster(wall);
            }

            // --- 4. VILLAGE & MARKET ---
            const houseLocs = [
                {x: 25, z: 15}, {x: -20, z: 18}, {x: 18, z: -20}, {x: -22, z: -15}
            ];

            houseLocs.forEach((pos, idx) => {
                const h = new BABYLON.TransformNode("h"+idx, scene);
                h.position.set(pos.x, 1, pos.z);
                
                // Body
                const body = BABYLON.MeshBuilder.CreateBox("body", {width: 4, height: 3.5, depth: 4}, scene);
                body.material = mat.wood;
                body.parent = h;
                shadowGenerator.addShadowCaster(body);
                
                // Door
                const door = BABYLON.MeshBuilder.CreateBox("door", {width: 1, height: 2, depth: 0.2}, scene);
                door.material = mat.stone;
                door.position.set(0, -0.75, 2.01);
                door.parent = body;

                // Roof
                const roof = BABYLON.MeshBuilder.CreateCylinder("roof", {height: 2.5, diameterTop: 0, diameterBottom: 5}, scene);
                roof.material = mat.roofRed;
                roof.parent = h;
                roof.position.y = 3;
                shadowGenerator.addShadowCaster(roof);
            });

            // Market Stalls
            const stalls = [
                {x: 12, z: 25}, {x: 16, z: 25}
            ];
            stalls.forEach((pos, i) => {
                const stall = new BABYLON.TransformNode("stall"+i, scene);
                stall.position.set(pos.x, 0, pos.z);
                
                // Table
                const table = BABYLON.MeshBuilder.CreateBox("table", {width: 3, height: 1.5, depth: 1.5}, scene);
                table.material = mat.wood;
                table.parent = stall;
                
                // Awning
                const awning = BABYLON.MeshBuilder.CreateBox("awn", {width: 3.5, height: 0.2, depth: 2}, scene);
                awning.material = mat.roofRed;
                awning.position.y = 2.8;
                awning.parent = stall;
            });

            // --- 5. RIVERSIDE MILL ---
            const mill = new BABYLON.TransformNode("mill", scene);
            mill.position.set(30, 0, 5); // Near river

            const millHouse = BABYLON.MeshBuilder.CreateBox("mHouse", {width: 5, height: 4, depth: 5}, scene);
            millHouse.material = mat.wood;
            millHouse.parent = mill;
            shadowGenerator.addShadowCaster(millHouse);

            const mRoof = BABYLON.MeshBuilder.CreateCylinder("mRoof", {height: 2, diameterTop: 0, diameterBottom: 6}, scene);
            mRoof.material = mat.roofDark;
            mRoof.parent = mill;
            mRoof.position.y = 3;

            // Water Wheel Animation
            const wheelNode = new BABYLON.TransformNode("wheel", scene);
            wheelNode.parent = mill;
            wheelNode.position.set(0, -2, -3); // In the water

            const wheelRim = BABYLON.MeshBuilder.CreateTorus("rim", {diameter: 4, thickness: 0.3, tessellation: 12}, scene);
            wheelRim.material = mat.wood;
            wheelRim.parent = wheelNode;

            for(let k=0; k<8; k++) {
                const spoke = BABYLON.MeshBuilder.CreateCylinder("spoke", {height: 3.8, diameter: 0.3}, scene);
                spoke.parent = wheelNode;
                spoke.rotation.z = (k/8)*Math.PI*2;
                spoke.material = mat.wood;
            }

            scene.registerBeforeRender(() => {
                wheelNode.rotation.z -= 0.03;
            });

            // Wooden Bridge
            const bridge = new BABYLON.TransformNode("bridge", scene);
            bridge.position.set(18, 1.8, 0);
            
            const bDeck = BABYLON.MeshBuilder.CreateBox("bDeck", {width: 12, height: 0.2, depth: 4}, scene);
            bDeck.material = mat.wood;
            bDeck.parent = bridge;
            shadowGenerator.addShadowCaster(bDeck);
            
            const bRail1 = BABYLON.MeshBuilder.CreateBox("bRail1", {width: 12, height: 0.8, depth: 0.3}, scene);
            bRail1.parent = bridge;
            bRail1.position.z = 1.5;
            bRail1.material = mat.wood;

            const bRail2 = bRail1.clone("bRail2");
            bRail2.position.z = -1.5;
            bRail2.parent = bridge;

            // --- 6. RUINED WATCHTOWER (Edge of Cliff) ---
            const ruin = new BABYLON.TransformNode("ruin", scene);
            ruin.position.set(-40, 0, -30); // On the cliff edge

            const rWall = BABYLON.MeshBuilder.CreateBox("rWall", {width: 6, height: 5, depth: 6}, scene);
            rWall.material = mat.stone;
            rWall.parent = ruin;
            shadowGenerator.addShadowCaster(rWall);

            // Crumbled Roof
            const rRoof = BABYLON.MeshBuilder.CreateCylinder("rRoof", {height: 2, diameterTop: 0, diameterBottom: 7}, scene);
            rRoof.material = mat.roofDark;
            rRoof.parent = ruin;
            rRoof.position.y = 2.5;
            rRoof.rotation.z = 0.3;
            rRoof.scaling.x = 0.6; // Half collapsed

            // --- 7. PINE TREES ---
            const pine = (scene, x, z, scale) => {
                const p = new BABYLON.TransformNode("pine", scene);
                p.position.set(x, 0, z);
                p.scaling.scaleInPlace(scale || 1);

                const trunk = BABYLON.MeshBuilder.CreateCylinder("trunk", {height: 3, diameter: 0.8}, scene);
                trunk.material = mat.wood;
                trunk.parent = p;
                shadowGenerator.addShadowCaster(trunk);

                for(let l=0; l<4; l++) {
                    const layer = BABYLON.MeshBuilder.CreateCylinder("leaf"+l, {height: 2.5, diameterTop: 0, diameterBottom: 4-(l*0.8)}, scene);
                    layer.material = mat.leaf;
                    layer.parent = p;
                    layer.position.y = 2 + l*1.8;
                    shadowGenerator.addShadowCaster(layer);
                }
            };

            // Scatter Trees (avoiding river and castle)
            const treePos = [
                {x: 40, z: 10}, {x: -35, z: 25}, {x: 45, z: -20}, 
                {x: -25, z: -40}, {x: 50, z: 35}, {x: -45, z: -15},
                {x: 35, z: -35}, {x: -10, z: 45}
            ];
            treePos.forEach(pos => pine(scene, pos.x, pos.z, 0.8 + Math.random()*0.5));

            // --- 8. ROCKY CLIFFS & DETAILS ---
            for(let i=0; i<20; i++) {
                const rock = BABYLON.MeshBuilder.CreateSphere("rock"+i, {diameter: 2 + Math.random(), segments: 6}, scene); // Low poly look
                rock.material = mat.rock;
                
                // Place mostly on cliffs
                const r = 40 + Math.random()*20;
                const ang = Math.random()*Math.PI*2;
                rock.position.set(Math.cos(ang)*r, 1, Math.sin(ang)*r);
                rock.scaling.y = 0.4; // Flatten
                rock.rotation.x = Math.random(); rock.rotation.z = Math.random();
                scene.addMesh(rock);
                shadowGenerator.addShadowCaster(rock);
            }

            // Hide Loading Text
            document.getElementById("loading").style.opacity = 0;

            return scene;
        };

        const scene = createScene();
        
        engine.runRenderLoop(function () {
            scene.render();
        });

        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>