<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floating Island Diorama - Medieval Fantasy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        }

        #renderCanvas {
            width: 100%;
            height: 100vh;
            display: block;
            touch-action: none;
        }

        /* Title Overlay */
        .title-overlay {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }

        .title-text {
            font-size: 2.5rem;
            font-weight: bold;
            color: #fff;
            text-shadow:
                0 0 20px rgba(247, 183, 49, 0.5),
                0 2px 4px rgba(0, 0, 0, 0.5);
            letter-spacing: 3px;
        }

        .subtitle-text {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 5px;
            font-style: italic;
        }

        /* Controls Hint */
        .controls-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            padding: 12px 25px;
            border-radius: 25px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85rem;
            pointer-events: none;
            z-index: 100;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-title {
            font-size: 2rem;
            color: #f7b731;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(247, 183, 49, 0.5);
        }

        .loading-bar-container {
            width: 300px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #e94560, #f7b731, #20bf6b);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .loading-text {
            margin-top: 15px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
        }

        /* Info Panel */
        .info-panel {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 20px;
            border-radius: 15px;
            color: #fff;
            font-size: 0.85rem;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-title {
            font-weight: bold;
            color: #f7b731;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .info-item {
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-icon {
            font-size: 1.1rem;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-title">üè∞ Floating Island Diorama</div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loadingBar" style="width: 0%"></div>
        </div>
        <div class="loading-text" id="loadingText">Initializing...</div>
    </div>

    <!-- Main Canvas -->
    <canvas id="renderCanvas"></canvas>

    <!-- Title Overlay -->
    <div class="title-overlay">
        <div class="title-text">üè∞ Realm of Clouds</div>
        <div class="subtitle-text">A Floating Island Adventure</div>
    </div>

    <!-- Controls Hint -->
    <div class="controls-hint">
        üñ±Ô∏è Drag to Rotate &nbsp;|&nbsp; Scroll to Zoom &nbsp;|&nbsp; Right-click Drag to Pan
    </div>

    <!-- Info Panel -->
    <div class="info-panel">
        <div class="info-title">üìç Points of Interest</div>
        <div class="info-item"><span class="info-icon">üè∞</span> Castle Keep</div>
        <div class="info-item"><span class="info-icon">üç∫</span> Village Tavern</div>
        <div class="info-item"><span class="info-icon">‚öôÔ∏è</span> Water Mill</div>
        <div class="info-item"><span class="info-icon">üåâ</span> Stone Bridges</div>
        <div class="info-item"><span class="info-icon">üóº</span> Watchtower Ruins</div>
        <div class="info-item"><span class="info-icon">üíß</span> Waterfalls</div>
    </div>

    <!-- Babylon.js -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <script>
        // ==================== CONFIGURATION ====================
        const COLORS = {
            grass: new BABYLON.Color3(0.35, 0.55, 0.25),
            grassDark: new BABYLON.Color3(0.25, 0.4, 0.18),
            stone: new BABYLON.Color3(0.55, 0.52, 0.48),
            stoneDark: new BABYLON.Color3(0.4, 0.38, 0.35),
            wood: new BABYLON.Color3(0.55, 0.4, 0.25),
            woodDark: new BABYLON.Color3(0.35, 0.25, 0.15),
            water: new BABYLON.Color3(0.2, 0.65, 0.75),
            waterDeep: new BABYLON.Color3(0.15, 0.5, 0.6),
            roof: new BABYLON.Color3(0.6, 0.35, 0.25),
            roofDark: new BABYLON.Color3(0.45, 0.25, 0.18),
            leaves: new BABYLON.Color3(0.2, 0.4, 0.2),
            flowers: [
                new BABYLON.Color3(0.95, 0.3, 0.35),
                new BABYLON.Color3(0.95, 0.8, 0.2),
                new BABYLON.Color3(0.85, 0.4, 0.8),
                new BABYLON.Color3(0.7, 0.35, 0.9)
            ]
        };

        // ==================== MAIN SETUP ====================
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
        let scene, camera;

        // Loading progress
        let loadingProgress = 0;
        const updateLoading = (progress, text) => {
            loadingProgress = progress;
            document.getElementById('loadingBar').style.width = `${progress}%`;
            document.getElementById('loadingText').textContent = text;
        };

        // ==================== CREATE SCENE ====================
        const createScene = async () => {
            updateLoading(5, 'Creating scene...');

            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.45, 0.6, 0.8, 1);
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
            scene.fogDensity = 0.003;
            scene.fogColor = new BABYLON.Color3(0.5, 0.65, 0.85);

            // Camera
            camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 4, Math.PI / 3, 120, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 50;
            camera.upperRadiusLimit = 200;
            camera.lowerBetaLimit = 0.1;
            camera.upperBetaLimit = Math.PI / 2.1;
            camera.wheelPrecision = 20;
            camera.panningSensibility = 100;

            updateLoading(10, 'Setting up lighting...');

            // Lighting
            const hemisphericLight = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0.5, 1, 0), scene);
            hemisphericLight.intensity = 0.7;
            hemisphericLight.diffuse = new BABYLON.Color3(1, 0.98, 0.95);
            hemisphericLight.groundColor = new BABYLON.Color3(0.3, 0.35, 0.4);

            const directionalLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-0.5, -1, -0.3), scene);
            directionalLight.position = new BABYLON.Vector3(80, 120, 50);
            directionalLight.intensity = 0.8;
            directionalLight.diffuse = new BABYLON.Color3(1, 0.95, 0.85);

            // Shadows
            const shadowGenerator = new BABYLON.ShadowGenerator(2048, directionalLight);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;
            shadowGenerator.bias = 0.001;

            // Glow layer for magical feel
            const glowLayer = new BABYLON.GlowLayer("glow", scene);
            glowLayer.intensity = 0.3;

            // Create materials
            updateLoading(15, 'Creating materials...');
            const materials = createMaterials();

            // Create main island base
            updateLoading(20, 'Building floating island...');
            const islandBase = createFloatingIsland(materials, shadowGenerator);

            // Create water below
            updateLoading(30, 'Adding waterfalls and rivers...');
            createWaterfall(materials);
            createRiver(materials);
            createClouds();

            // Create castle
            updateLoading(45, 'Building medieval castle...');
            createCastle(materials, shadowGenerator);

            // Create village
            updateLoading(55, 'Creating village buildings...');
            createVillage(materials, shadowGenerator);

            // Create mill
            updateLoading(65, 'Constructing watermill...');
            createWatermill(materials, shadowGenerator);

            // Add bridges
            updateLoading(70, 'Building bridges...');
            createBridges(materials, shadowGenerator);

            // Create watchtower ruins
            updateLoading(75, 'Adding watchtower ruins...');
            createWatchtower(materials, shadowGenerator);

            // Add vegetation
            updateLoading(80, 'Planting trees and flowers...');
            createVegetation(materials, shadowGenerator);

            // Add decorative elements
            updateLoading(90, 'Adding final details...');
            createDecorations(materials, shadowGenerator);

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
            }, 500);

            return scene;
        };

        // ==================== MATERIALS ====================
        function createMaterials() {
            const materials = {};

            // Grass material
            materials.grass = new BABYLON.StandardMaterial("grass", scene);
            materials.grass.diffuseColor = COLORS.grass;
            materials.grass.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            // Stone material
            materials.stone = new BABYLON.StandardMaterial("stone", scene);
            materials.stone.diffuseColor = COLORS.stone;
            materials.stone.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);

            // Stone dark material
            materials.stoneDark = new BABYLON.StandardMaterial("stoneDark", scene);
            materials.stoneDark.diffuseColor = COLORS.stoneDark;
            materials.stoneDark.specularColor = new BABYLON.Color3(0.15, 0.15, 0.15);

            // Wood material
            materials.wood = new BABYLON.StandardMaterial("wood", scene);
            materials.wood.diffuseColor = COLORS.wood;
            materials.wood.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            // Wood dark material
            materials.woodDark = new BABYLON.StandardMaterial("woodDark", scene);
            materials.woodDark.diffuseColor = COLORS.woodDark;
            materials.woodDark.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);

            // Water material
            materials.water = new BABYLON.StandardMaterial("water", scene);
            materials.water.diffuseColor = COLORS.water;
            materials.water.specularColor = new BABYLON.Color3(0.8, 0.8, 0.8);
            materials.water.specularPower = 64;
            materials.water.alpha = 0.75;

            // Roof material
            materials.roof = new BABYLON.StandardMaterial("roof", scene);
            materials.roof.diffuseColor = COLORS.roof;
            materials.roof.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            // Roof dark material
            materials.roofDark = new BABYLON.StandardMaterial("roofDark", scene);
            materials.roofDark.diffuseColor = COLORS.roofDark;
            materials.roofDark.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);

            // Leaves material
            materials.leaves = new BABYLON.StandardMaterial("leaves", scene);
            materials.leaves.diffuseColor = COLORS.leaves;
            materials.leaves.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            // Dirt/cliff material
            materials.dirt = new BABYLON.StandardMaterial("dirt", scene);
            materials.dirt.diffuseColor = new BABYLON.Color3(0.35, 0.28, 0.22);
            materials.dirt.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);

            // Sand/beach material
            materials.sand = new BABYLON.StandardMaterial("sand", scene);
            materials.sand.diffuseColor = new BABYLON.Color3(0.85, 0.75, 0.6);
            materials.sand.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);

            // Snow material for mountain peaks
            materials.snow = new BABYLON.StandardMaterial("snow", scene);
            materials.snow.diffuseColor = new BABYLON.Color3(0.95, 0.95, 1);
            materials.snow.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);

            // Create flower materials
            materials.flowers = COLORS.flowers.map((color, i) => {
                const mat = new BABYLON.StandardMaterial("flower" + i, scene);
                mat.diffuseColor = color;
                mat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                return mat;
            });

            return materials;
        }

        // ==================== FLOATING ISLAND ====================
        function createFloatingIsland(materials, shadowGenerator) {
            const islandGroup = new BABYLON.TransformNode("island", scene);

            // Main island top
            const islandTop = BABYLON.MeshBuilder.CreateCylinder("islandTop", {
                height: 4,
                diameterTop: 70,
                diameterBottom: 65,
                tessellation: 64
            }, scene);
            islandTop.position.y = -2;
            islandTop.material = materials.grass;
            islandTop.parent = islandGroup;
            shadowGenerator.addShadowCaster(islandTop);
            islandTop.receiveShadows = true;

            // Rocky cliffs (multiple layers)
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const radius = 30 + Math.random() * 5;
                const cliff = createCliffLayer(radius, materials, shadowGenerator);
                cliff.rotation.y = angle + Math.random() * 0.3;
                cliff.parent = islandGroup;
            }

            // Under-island rock formation
            const underRock = BABYLON.MeshBuilder.CreateCylinder("underRock", {
                height: 25,
                diameterTop: 50,
                diameterBottom: 20,
                tessellation: 32
            }, scene);
            underRock.position.y = -18;
            underRock.material = materials.dirt;
            underRock.parent = islandGroup;

            // Floating rock formations below
            for (let i = 0; i < 12; i++) {
                const rock = BABYLON.MeshBuilder.CreateSphere("floatRock" + i, {
                    diameter: 2 + Math.random() * 4,
                    segments: 6
                }, scene);
                const angle = Math.random() * Math.PI * 2;
                const radius = 10 + Math.random() * 25;
                rock.position = new BABYLON.Vector3(
                    Math.cos(angle) * radius,
                    -25 - Math.random() * 15,
                    Math.sin(angle) * radius
                );
                rock.scaling = new BABYLON.Vector3(
                    0.5 + Math.random(),
                    0.3 + Math.random() * 0.5,
                    0.5 + Math.random()
                );
                rock.material = materials.stoneDark;
                rock.parent = islandGroup;
            }

            return islandGroup;
        }

        function createCliffLayer(radius, materials, shadowGenerator) {
            const cliffGroup = new BABYLON.TransformNode("cliffGroup", scene);

            // Main cliff ring segments
            const segments = 6;
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const cliff = BABYLON.MeshBuilder.CreateBox("cliff" + i, {
                    width: 15 + Math.random() * 5,
                    height: 8 + Math.random() * 6,
                    depth: 8 + Math.random() * 4
                }, scene);

                cliff.position.x = Math.cos(angle) * radius;
                cliff.position.z = Math.sin(angle) * radius;
                cliff.position.y = -3 - Math.random() * 2;
                cliff.rotation.y = angle + Math.PI / 2;
                cliff.rotation.z = (Math.random() - 0.5) * 0.2;
                cliff.rotation.x = (Math.random() - 0.5) * 0.1;

                cliff.material = materials.stone;
                cliff.parent = cliffGroup;
                shadowGenerator.addShadowCaster(cliff);
            }

            return cliffGroup;
        }

        // ==================== WATERFALLS ====================
        function createWaterfall(materials) {
            // Main waterfall
            const waterfall = BABYLON.MeshBuilder.CreatePlane("waterfall", {
                width: 8,
                height: 35
            }, scene);
            waterfall.position = new BABYLON.Vector3(-25, -20, 0);
            waterfall.rotation.y = Math.PI / 2;
            waterfall.material = materials.water;

            // Water particles effect
            const particleSystem = new BABYLON.ParticleSystem("waterfallParticles", 500, scene);
            particleSystem.particleTexture = createParticleTexture();
            particleSystem.emitter = new BABYLON.Vector3(-25, 0, 0);
            particleSystem.minEmitBox = new BABYLON.Vector3(-2, 0, -1);
            particleSystem.maxEmitBox = new BABYLON.Vector3(2, 0, 1);
            particleSystem.color1 = new BABYLON.Color4(0.4, 0.8, 0.9, 0.8);
            particleSystem.color2 = new BABYLON.Color4(0.3, 0.7, 0.85, 0.6);
            particleSystem.colorDead = new BABYLON.Color4(0.2, 0.5, 0.6, 0);
            particleSystem.minSize = 0.2;
            particleSystem.maxSize = 0.5;
            particleSystem.minLifeTime = 1;
            particleSystem.maxLifeTime = 2;
            particleSystem.emitRate = 100;
            particleSystem.gravity = new BABYLON.Vector3(0, -15, 0);
            particleSystem.direction1 = new BABYLON.Vector3(0, -1, -0.2);
            particleSystem.direction2 = new BABYLON.Vector3(0.5, -1, 0.2);
            particleSystem.minEmitPower = 2;
            particleSystem.maxEmitPower = 4;
            particleSystem.start();

            // Pool at bottom
            const pool = BABYLON.MeshBuilder.CreateCylinder("waterPool", {
                diameter: 15,
                height: 2
            }, scene);
            pool.position = new BABYLON.Vector3(-25, -35, 0);
            pool.material = materials.water;
        }

        // ==================== RIVER ====================
        function createRiver(materials) {
            // River path
            const riverPath = [
                new BABYLON.Vector3(-35, -2, 15),
                new BABYLON.Vector3(-20, -2, 5),
                new BABYLON.Vector3(0, -2, 0),
                new BABYLON.Vector3(15, -2, -10),
                new BABYLON.Vector3(35, -2, -20)
            ];

            // Create river surface
            const river = BABYLON.MeshBuilder.CreateTube("river", {
                path: riverPath,
                radius: 4,
                tessellation: 16,
                cap: BABYLON.Mesh.CAP_ALL,
                sideOrientation: BABYLON.Mesh.DOUBLESIDE
            }, scene);
            river.material = materials.water;

            // Animate river
            let time = 0;
            scene.registerBeforeRender(() => {
                time += 0.01;
                // Subtle flow animation
            });

            // Riverbanks
            for (let i = 0; i < 20; i++) {
                const t = i / 20;
                const point = BABYLON.Vector3.Lerp(riverPath[0], riverPath[riverPath.length - 1], t);
                const offset = (i % 2 === 0 ? 1 : -1) * (6 + Math.random());

                const rock = BABYLON.MeshBuilder.CreateSphere("riverRock" + i, {
                    diameter: 1 + Math.random() * 2,
                    segments: 6
                }, scene);
                rock.position = new BABYLON.Vector3(
                    point.x + offset + (Math.random() - 0.5),
                    -1 + Math.random() * 0.5,
                    point.z + (Math.random() - 0.5) * 2
                );
                rock.scaling = new BABYLON.Vector3(1, 0.5, 1);
                rock.material = materials.stone;
            }
        }

        // ==================== CLOUDS ====================
        function createClouds() {
            for (let i = 0; i < 8; i++) {
                const cloudGroup = new BABYLON.TransformNode("cloud" + i, scene);
                const cloudParts = 3 + Math.floor(Math.random() * 4);

                for (let j = 0; j < cloudParts; j++) {
                    const puff = BABYLON.MeshBuilder.CreateSphere("cloudPuff" + i + "_" + j, {
                        diameter: 8 + Math.random() * 12,
                        segments: 8
                    }, scene);

                    const mat = new BABYLON.StandardMaterial("cloudMat" + i + "_" + j, scene);
                    mat.diffuseColor = new BABYLON.Color3(1, 1, 1);
                    mat.specularColor = new BABYLON.Color3(0, 0, 0);
                    mat.emissiveColor = new BABYLON.Color3(0.9, 0.95, 1);
                    puff.material = mat;

                    puff.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 15,
                        (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 8
                    );
                    puff.scaling = new BABYLON.Vector3(1, 0.6, 1);
                    puff.parent = cloudGroup;
                }

                cloudGroup.position = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 200,
                    40 + Math.random() * 30,
                    (Math.random() - 0.5) * 150
                );

                // Slow cloud drift
                scene.registerBeforeRender(() => {
                    cloudGroup.position.x += 0.01;
                    if (cloudGroup.position.x > 120) {
                        cloudGroup.position.x = -120;
                    }
                });
            }
        }

        // ==================== CASTLE ====================
        function createCastle(materials, shadowGenerator) {
            const castleGroup = new BABYLON.TransformNode("castle", scene);

            // Castle base platform
            const platform = BABYLON.MeshBuilder.CreateCylinder("castlePlatform", {
                height: 1,
                diameter: 28,
                tessellation: 32
            }, scene);
            platform.position.y = 0.5;
            platform.material = materials.stone;
            platform.parent = castleGroup;
            shadowGenerator.addShadowCaster(platform);
            platform.receiveShadows = true;

            // Main keep
            const keep = BABYLON.MeshBuilder.CreateBox("keep", {
                width: 14,
                height: 16,
                depth: 14
            }, scene);
            keep.position.y = 9;
            keep.material = materials.stone;
            keep.parent = castleGroup;
            shadowGenerator.addShadowCaster(keep);

            // Keep roof (conical)
            const keepRoof = BABYLON.MeshBuilder.CreateCylinder("keepRoof", {
                height: 8,
                diameterTop: 0,
                diameterBottom: 18,
                tessellation: 8
            }, scene);
            keepRoof.position.y = 21;
            keepRoof.material = materials.roofDark;
            keepRoof.parent = castleGroup;
            shadowGenerator.addShadowCaster(keepRoof);

            // Corner towers
            const towerPositions = [
                { x: 8, z: 8 },
                { x: -8, z: 8 },
                { x: 8, z: -8 },
                { x: -8, z: -8 }
            ];

            towerPositions.forEach((pos, i) => {
                // Tower base
                const tower = BABYLON.MeshBuilder.CreateCylinder("tower" + i, {
                    height: 20,
                    diameter: 5,
                    tessellation: 8
                }, scene);
                tower.position = new BABYLON.Vector3(pos.x, 11, pos.z);
                tower.material = materials.stone;
                tower.parent = castleGroup;
                shadowGenerator.addShadowCaster(tower);

                // Tower top
                const towerTop = BABYLON.MeshBuilder.CreateCylinder("towerTop" + i, {
                    height: 6,
                    diameterTop: 0,
                    diameterBottom: 7,
                    tessellation: 8
                }, scene);
                towerTop.position = new BABYLON.Vector3(pos.x, 24, pos.z);
                towerTop.material = materials.roof;
                towerTop.parent = castleGroup;
                shadowGenerator.addShadowCaster(towerTop);

                // Battlements
                for (let j = 0; j < 4; j++) {
                    const merlon = BABYLON.MeshBuilder.CreateBox("merlon" + i + "_" + j, {
                        width: 1.2,
                        height: 1.5,
                        depth: 1.2
                    }, scene);
                    const angle = (j / 4) * Math.PI * 2 + Math.PI / 4;
                    merlon.position = new BABYLON.Vector3(
                        pos.x + Math.cos(angle) * 3.5,
                        21,
                        pos.z + Math.sin(angle) * 3.5
                    );
                    merlon.material = materials.stoneDark;
                    merlon.parent = castleGroup;
                    shadowGenerator.addShadowCaster(merlon);
                }
            });

            // Walls between towers
            const wallPositions = [
                { x: 0, z: 10, rot: 0, scale: 16 },
                { x: 10, z: 0, rot: Math.PI / 2, scale: 16 },
                { x: 0, z: -10, rot: 0, scale: 16 },
                { x: -10, z: 0, rot: Math.PI / 2, scale: 16 }
            ];

            wallPositions.forEach((pos, i) => {
                const wall = BABYLON.MeshBuilder.CreateBox("wall" + i, {
                    width: pos.scale,
                    height: 10,
                    depth: 2
                }, scene);
                wall.position = new BABYLON.Vector3(pos.x, 6, pos.z);
                wall.rotation.y = pos.rot;
                wall.material = materials.stoneDark;
                wall.parent = castleGroup;
                shadowGenerator.addShadowCaster(wall);
            });

            // Gatehouse
            const gatehouse = BABYLON.MeshBuilder.CreateBox("gatehouse", {
                width: 8,
                height: 12,
                depth: 3
            }, scene);
            gatehouse.position = new BABYLON.Vector3(0, 7, 10);
            gatehouse.material = materials.stoneDark;
            gatehouse.parent = castleGroup;
            shadowGenerator.addShadowCaster(gatehouse);

            // Gate arch
            const gateArch = BABYLON.MeshBuilder.CreateTorus("gateArch", {
                diameter: 4,
                thickness: 1,
                tessellation: 16
            }, scene);
            gateArch.position = new BABYLON.Vector3(0, 4, 10);
            gateArch.rotation.x = Math.PI / 2;
            gateArch.material = materials.stoneDark;
            gateArch.parent = castleGroup;

            // Flags on towers
            towerPositions.forEach((pos, i) => {
                const flagPole = BABYLON.MeshBuilder.CreateCylinder("flagPole" + i, {
                    height: 3,
                    diameter: 0.15
                }, scene);
                flagPole.position = new BABYLON.Vector3(pos.x, 28, pos.z);
                flagPole.material = materials.woodDark;
                flagPole.parent = castleGroup;

                const flag = BABYLON.MeshBuilder.CreatePlane("flag" + i, {
                    width: 2,
                    height: 1.5
                }, scene);
                flag.position = new BABYLON.Vector3(pos.x + 1, 28.5, pos.z);
                const flagMat = new BABYLON.StandardMaterial("flagMat" + i, scene);
                flagMat.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
                flagMat.backFaceCulling = false;
                flag.material = flagMat;
                flag.parent = castleGroup;

                // Animate flag
                scene.registerBeforeRender(() => {
                    flag.rotation.y = Math.sin(Date.now() * 0.005 + i) * 0.3;
                });
            });

            return castleGroup;
        }

        // ==================== VILLAGE ====================
        function createVillage(materials, shadowGenerator) {
            const villageGroup = new BABYLON.TransformNode("village", scene);

            // Tavern
            createBuilding({
                x: -15, y: 1, z: 15,
                width: 10, height: 6, depth: 8,
                roofType: 'triangular',
                color: materials.wood,
                roofColor: materials.roof,
                name: 'tavern',
                shadowGenerator: shadowGenerator,
                parent: villageGroup
            });

            // Add tavern sign
            const signPole = BABYLON.MeshBuilder.CreateCylinder("signPole", { height: 4, diameter: 0.2 }, scene);
            signPole.position = new BABYLON.Vector3(-12, 5, 16);
            signPole.material = materials.woodDark;
            signPole.parent = villageGroup;

            const sign = BABYLON.MeshBuilder.CreateBox("sign", { width: 2, height: 1.5, depth: 0.1 }, scene);
            sign.position = new BABYLON.Vector3(-12, 7, 16);
            const signMat = new BABYLON.StandardMaterial("signMat", scene);
            signMat.diffuseColor = new BABYLON.Color3(0.6, 0.4, 0.2);
            sign.material = signMat;
            sign.parent = villageGroup;

            // Houses
            const housePositions = [
                { x: 12, z: 12, rot: 0.3 },
                { x: 18, z: 8, rot: -0.5 },
                { x: -8, z: 22, rot: 0.8 },
                { x: -18, z: 18, rot: -0.3 },
                { x: 20, z: -5, rot: 1.2 },
                { x: 8, z: -18, rot: 2 }
            ];

            housePositions.forEach((pos, i) => {
                createBuilding({
                    x: pos.x, y: 0.8, z: pos.z,
                    width: 6 + Math.random() * 2,
                    height: 5 + Math.random() * 2,
                    depth: 5 + Math.random() * 2,
                    roofType: Math.random() > 0.5 ? 'triangular' : 'flat',
                    color: materials.wood,
                    roofColor: materials.roofDark,
                    name: 'house' + i,
                    shadowGenerator: shadowGenerator,
                    parent: villageGroup,
                    rotation: pos.rot
                });
            });

            // Market stalls
            const stallPositions = [
                { x: 5, z: 20, rot: Math.PI / 2 },
                { x: -3, z: 23, rot: 0 },
                { x: -10, z: 25, rot: -0.3 }
            ];

            stallPositions.forEach((pos, i) => {
                createMarketStall(pos.x, pos.z, pos.rot, materials, shadowGenerator, villageGroup);
            });

            // Well in village square
            const wellBase = BABYLON.MeshBuilder.CreateCylinder("wellBase", {
                height: 2,
                diameter: 4,
                tessellation: 16
            }, scene);
            wellBase.position = new BABYLON.Vector3(-5, 2, 18);
            wellBase.material = materials.stoneDark;
            wellBase.parent = villageGroup;
            shadowGenerator.addShadowCaster(wellBase);

            const wellInner = BABYLON.MeshBuilder.CreateCylinder("wellInner", {
                height: 2.5,
                diameter: 2.5,
                tessellation: 16
            }, scene);
            wellInner.position = new BABYLON.Vector3(-5, 2.2, 18);
            const wellMat = new BABYLON.StandardMaterial("wellMat", scene);
            wellMat.diffuseColor = new BABYLON.Color3(0.1, 0.3, 0.5);
            wellInner.material = wellMat;
            wellInner.parent = villageGroup;

            return villageGroup;
        }

        function createBuilding(config) {
            const {
                x, y, z, width, height, depth,
                roofType, color, roofColor,
                shadowGenerator, parent, rotation = 0
            } = config;

            const building = new BABYLON.TransformNode(config.name, scene);

            // Main structure
            const main = BABYLON.MeshBuilder.CreateBox(config.name + "_main", {
                width: width,
                height: height,
                depth: depth
            }, scene);
            main.position.y = height / 2;
            main.material = color;
            main.parent = building;
            shadowGenerator.addShadowCaster(main);

            // Roof
            let roof;
            if (roofType === 'triangular') {
                roof = BABYLON.MeshBuilder.CreateCylinder(config.name + "_roof", {
                    height: depth,
                    diameterTop: 0,
                    diameterBottom: width + 2,
                    tessellation: 4
                }, scene);
                roof.rotation.z = Math.PI / 2;
                roof.position.y = height + depth / 2 - 0.5;
                roof.rotation.y = Math.PI / 4;
            } else {
                roof = BABYLON.MeshBuilder.CreateBox(config.name + "_roof", {
                    width: width + 2,
                    height: 1,
                    depth: depth + 2
                }, scene);
                roof.position.y = height + 0.5;
            }
            roof.material = roofColor;
            roof.parent = building;
            shadowGenerator.addShadowCaster(roof);

            // Door
            const door = BABYLON.MeshBuilder.CreateBox(config.name + "_door", {
                width: width * 0.25,
                height: height * 0.6,
                depth: 0.2
            }, scene);
            door.position = new BABYLON.Vector3(0, height * 0.3, depth / 2);
            door.material = materials.woodDark;
            door.parent = building;

            // Windows
            const windowPositions = [
                { x: width * 0.25, y: height * 0.6, z: depth / 2 + 0.1 },
                { x: -width * 0.25, y: height * 0.6, z: depth / 2 + 0.1 }
            ];

            windowPositions.forEach((pos, i) => {
                const window = BABYLON.MeshBuilder.CreatePlane(config.name + "_window" + i, {
                    width: width * 0.15,
                    height: height * 0.2
                }, scene);
                window.position = new BABYLON.Vector3(pos.x, pos.y, pos.z);
                const windowMat = new BABYLON.StandardMaterial(config.name + "_windowMat" + i, scene);
                windowMat.diffuseColor = new BABYLON.Color3(0.6, 0.7, 0.8);
                windowMat.emissiveColor = new BABYLON.Color3(0.3, 0.35, 0.4);
                window.material = windowMat;
                window.parent = building;
            });

            building.position = new BABYLON.Vector3(x, y, z);
            building.rotation.y = rotation;
            building.parent = parent;

            return building;
        }

        function createMarketStall(x, z, rot, materials, shadowGenerator, parent) {
            const stall = new BABYLON.TransformNode("marketStall", scene);

            // Posts
            const postPositions = [
                { x: -1.5, z: -1 },
                { x: 1.5, z: -1 },
                { x: -1.5, z: 1 },
                { x: 1.5, z: 1 }
            ];

            postPositions.forEach((pos, i) => {
                const post = BABYLON.MeshBuilder.CreateCylinder("stallPost" + i, {
                    height: 3,
                    diameter: 0.2
                }, scene);
                post.position = new BABYLON.Vector3(pos.x, 1.5, pos.z);
                post.material = materials.woodDark;
                post.parent = stall;
            });

            // Counter
            const counter = BABYLON.MeshBuilder.CreateBox("stallCounter", {
                width: 3.5,
                height: 1,
                depth: 2
            }, scene);
            counter.position.y = 0.5;
            counter.material = materials.wood;
            counter.parent = stall;
            shadowGenerator.addShadowCaster(counter);

            // Roof
            const roof = BABYLON.MeshBuilder.CreateCylinder("stallRoof", {
                height: 2.5,
                diameterTop: 0,
                diameterBottom: 5,
                tessellation: 4
            }, scene);
            roof.rotation.z = Math.PI / 2;
            roof.position.y = 3.5;
            roof.rotation.y = Math.PI / 4;
            roof.material = materials.roof;
            roof.parent = stall;
            shadowGenerator.addShadowCaster(roof);

            stall.position = new BABYLON.Vector3(x, 0, z);
            stall.rotation.y = rot;
            stall.parent = parent;
        }

        // ==================== WATERMILL ====================
        function createWatermill(materials, shadowGenerator) {
            const millGroup = new BABYLON.TransformNode("watermill", scene);

            // Mill base
            const millBase = BABYLON.MeshBuilder.CreateBox("millBase", {
                width: 10,
                height: 8,
                depth: 8
            }, scene);
            millBase.position = new BABYLON.Vector3(25, 4, 10);
            millBase.material = materials.stone;
            millBase.parent = millGroup;
            shadowGenerator.addShadowCaster(millBase);

            // Mill roof
            const millRoof = BABYLON.MeshBuilder.CreateCylinder("millRoof", {
                height: 5,
                diameterTop: 0,
                diameterBottom: 14,
                tessellation: 6
            }, scene);
            millRoof.position = new BABYLON.Vector3(25, 11, 10);
            millRoof.rotation.z = Math.PI / 2;
            millRoof.rotation.y = Math.PI / 6;
            millRoof.material = materials.roofDark;
            millRoof.parent = millGroup;
            shadowGenerator.addShadowCaster(millRoof);

            // Water wheel
            const wheelGroup = new BABYLON.TransformNode("wheelGroup", scene);
            wheelGroup.position = new BABYLON.Vector3(30.5, 4, 10);

            // Wheel rim
            const wheelRim = BABYLON.MeshBuilder.CreateTorus("wheelRim", {
                diameter: 6,
                thickness: 0.5,
                tessellation: 24
            }, scene);
            wheelRim.rotation.y = Math.PI / 2;
            wheelRim.material = materials.wood;
            wheelRim.parent = wheelGroup;

            // Wheel spokes
            for (let i = 0; i < 8; i++) {
                const spoke = BABYLON.MeshBuilder.CreateBox("spoke" + i, {
                    width: 0.3,
                    height: 3,
                    depth: 0.1
                }, scene);
                spoke.rotation.z = (i / 8) * Math.PI * 2;
                spoke.position.z = 0;
                spoke.material = materials.woodDark;
                spoke.parent = wheelGroup;
            }

            // Paddles
            for (let i = 0; i < 8; i++) {
                const paddle = BABYLON.MeshBuilder.CreateBox("paddle" + i, {
                    width: 0.8,
                    height: 1.5,
                    depth: 0.1
                }, scene);
                const angle = (i / 8) * Math.PI * 2;
                paddle.position.x = Math.cos(angle) * 2.5;
                paddle.position.y = Math.sin(angle) * 2.5;
                paddle.rotation.z = angle;
                paddle.material = materials.woodDark;
                paddle.parent = wheelGroup;
            }

            wheelGroup.parent = millGroup;

            // Animate wheel
            scene.registerBeforeRender(() => {
                wheelGroup.rotation.z += 0.01;
            });

            // Water channel
            const channel = BABYLON.MeshBuilder.CreateBox("millChannel", {
                width: 2,
                height: 1,
                depth: 6
            }, scene);
            channel.position = new BABYLON.Vector3(32, 1.5, 10);
            channel.material = materials.stone;
            channel.parent = millGroup;

            // Water flowing through wheel
            const wheelWater = BABYLON.MeshBuilder.CreatePlane("wheelWater", {
                width: 4,
                height: 2
            }, scene);
            wheelWater.position = new BABYLON.Vector3(32, 2.5, 10);
            wheelWater.rotation.x = Math.PI / 2;
            wheelWater.material = materials.water;
            wheelWater.parent = millGroup;

            millGroup.parent = scene;
        }

        // ==================== BRIDGES ====================
        function createBridges(materials, shadowGenerator) {
            // Bridge over river
            createBridge(
                new BABYLON.Vector3(10, 1, 5),
                new BABYLON.Vector3(20, 1, 0),
                materials,
                shadowGenerator
            );

            // Small footbridge
            createBridge(
                new BABYLON.Vector3(-10, 0.5, 20),
                new BABYLON.Vector3(-15, 0.5, 28),
                materials,
                shadowGenerator,
                1.5
            );
        }

        function createBridge(start, end, materials, shadowGenerator, width = 3) {
            const bridge = new BABYLON.TransformNode("bridge", scene);

            const direction = end.subtract(start);
            const length = direction.length();
            const center = start.add(direction.scale(0.5));
            center.y += 1;

            // Bridge deck
            const deck = BABYLON.MeshBuilder.CreateBox("bridgeDeck", {
                width: width,
                height: 0.3,
                depth: length
            }, scene);
            deck.position = center;
            deck.material = materials.wood;
            deck.parent = bridge;
            shadowGenerator.addShadowCaster(deck);

            // Railings
            const railingHeight = 1;
            const railingPositions = [
                { x: width / 2, z: 0 },
                { x: -width / 2, z: 0 }
            ];

            railingPositions.forEach(pos => {
                // Posts
                for (let i = 0; i < Math.floor(length / 3); i++) {
                    const post = BABYLON.MeshBuilder.CreateBox("bridgePost", {
                        width: 0.15,
                        height: railingHeight,
                        depth: 0.15
                    }, scene);
                    const t = i / (Math.floor(length / 3) - 1);
                    post.position = new BABYLON.Vector3(
                        pos.x,
                        center.y + railingHeight / 2,
                        center.z - length / 2 + t * length
                    );
                    post.material = materials.woodDark;
                    post.parent = bridge;
                }

                // Top rail
                const rail = BABYLON.MeshBuilder.CreateBox("bridgeRail", {
                    width: 0.15,
                    height: 0.1,
                    depth: length
                }, scene);
                rail.position = new BABYLON.Vector3(
                    pos.x,
                    center.y + railingHeight,
                    center.z
                );
                rail.material = materials.woodDark;
                rail.parent = bridge;
            });

            // Arch support
            const archHeight = 2;
            const arch = BABYLON.MeshBuilder.CreateBox("bridgeArch", {
                width: width * 0.8,
                height: archHeight,
                depth: 0.5
            }, scene);
            arch.position = new BABYLON.Vector3(center.x, center.y - archHeight / 2 + 0.5, center.z);
            arch.material = materials.stone;
            arch.parent = bridge;
            shadowGenerator.addShadowCaster(arch);

            bridge.lookAt(end);
            bridge.parent = scene;
        }

        // ==================== WATCHTOWER RUINS ====================
        function createWatchtower(materials, shadowGenerator) {
            const towerGroup = new BABYLON.TransformNode("watchtower", scene);

            // Base remains
            const base1 = BABYLON.MeshBuilder.CreateBox("towerBase1", {
                width: 5,
                height: 4,
                depth: 4
            }, scene);
            base1.position = new BABYLON.Vector3(-30, 2, -25);
            base1.rotation.y = 0.3;
            base1.material = materials.stoneDark;
            base1.parent = towerGroup;
            shadowGenerator.addShadowCaster(base1);

            const base2 = BABYLON.MeshBuilder.CreateBox("towerBase2", {
                width: 4,
                height: 3,
                depth: 3
            }, scene);
            base2.position = new BABYLON.Vector3(-28, 1.5, -23);
            base2.rotation.y = -0.2;
            base2.material = materials.stone;
            base2.parent = towerGroup;
            shadowGenerator.addShadowCaster(base2);

            // Fallen debris
            for (let i = 0; i < 8; i++) {
                const debris = BABYLON.MeshBuilder.CreateBox("debris" + i, {
                    width: 0.5 + Math.random(),
                    height: 0.3 + Math.random() * 0.5,
                    depth: 0.5 + Math.random()
                }, scene);
                debris.position = new BABYLON.Vector3(
                    -30 + (Math.random() - 0.5) * 8,
                    0.3,
                    -25 + (Math.random() - 0.5) * 8
                );
                debris.rotation = new BABYLON.Vector3(
                    Math.random() * 0.2,
                    Math.random() * Math.PI * 2,
                    Math.random() * 0.2
                );
                debris.material = materials.stone;
                debris.parent = towerGroup;
            }

            // Vines growing on ruins
            for (let i = 0; i < 5; i++) {
                const vine = BABYLON.MeshBuilder.CreateCylinder("vine" + i, {
                    height: 1 + Math.random() * 2,
                    diameter: 0.1
                }, scene);
                vine.position = new BABYLON.Vector3(
                    -29 + Math.random(),
                    1 + Math.random() * 2,
                    -24 + Math.random()
                );
                vine.rotation.z = (Math.random() - 0.5) * 0.5;
                vine.material = materials.leaves;
                vine.parent = towerGroup;
            }

            towerGroup.parent = scene;
        }

        // ==================== VEGETATION ====================
        function createVegetation(materials, shadowGenerator) {
            // Pine trees
            const treePositions = [
                { x: -20, z: -15 },
                { x: -25, z: 5 },
                { x: 15, z: 25 },
                { x: 28, z: -15 },
                { x: -5, z: -28 },
                { x: 30, z: 20 },
                { x: -28, z: -10 },
                { x: 22, z: 22 },
                { x: -15, z: 30 },
                { x: 35, z: 5 }
            ];

            treePositions.forEach((pos, i) => {
                createPineTree(pos.x, pos.z, materials, shadowGenerator, i);
            });

            // Flower patches
            const flowerPatchPositions = [
                { x: -10, z: 8, radius: 3 },
                { x: 8, z: 15, radius: 4 },
                { x: -18, z: 25, radius: 3 },
                { x: 18, z: -8, radius: 3 },
                { x: -25, z: -5, radius: 2 }
            ];

            flowerPatchPositions.forEach((pos, i) => {
                createFlowerPatch(pos.x, pos.z, pos.radius, materials);
            });

            // Bushes
            const bushPositions = [
                { x: -12, z: 12 },
                { x: 5, z: 10 },
                { x: -8, z: -12 },
                { x: 15, z: 18 },
                { x: -22, z: 20 },
                { x: 25, z: 0 },
                { x: 10, z: -22 },
                { x: -15, z: -20 }
            ];

            bushPositions.forEach((pos, i) => {
                createBush(pos.x, pos.z, materials, shadowGenerator, i);
            });
        }

        function createPineTree(x, z, materials, shadowGenerator, index) {
            const treeGroup = new BABYLON.TransformNode("pineTree" + index, scene);

            // Trunk
            const trunk = BABYLON.MeshBuilder.CreateCylinder("treeTrunk", {
                height: 6 + Math.random() * 3,
                diameterTop: 0.5,
                diameterBottom: 1 + Math.random() * 0.5,
                tessellation: 8
            }, scene);
            trunk.position.y = (6 + Math.random() * 3) / 2;
            trunk.material = materials.woodDark;
            trunk.parent = treeGroup;
            shadowGenerator.addShadowCaster(trunk);

            // Tree layers (pine cone shape)
            const layerCount = 3 + Math.floor(Math.random() * 2);
            for (let i = 0; i < layerCount; i++) {
                const layer = BABYLON.MeshBuilder.CreateCylinder("treeLayer" + i, {
                    height: 3 - i * 0.5,
                    diameterTop: 0,
                    diameterBottom: 5 - i * 0.8,
                    tessellation: 8
                }, scene);
                layer.position.y = 5 + i * 2;
                layer.material = materials.leaves;
                layer.parent = treeGroup;
                shadowGenerator.addShadowCaster(layer);
            }

            treeGroup.position = new BABYLON.Vector3(x, 0, z);
            treeGroup.parent = scene;
        }

        function createFlowerPatch(x, z, radius, materials) {
            const flowerCount = Math.floor(radius * 8);

            for (let i = 0; i < flowerCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * radius;
                const flowerX = x + Math.cos(angle) * dist;
                const flowerZ = z + Math.sin(angle) * dist;

                // Stem
                const stem = BABYLON.MeshBuilder.CreateCylinder("flowerStem" + i, {
                    height: 0.5 + Math.random() * 0.3,
                    diameter: 0.05
                }, scene);
                stem.position = new BABYLON.Vector3(flowerX, 0.3, flowerZ);
                stem.material = materials.woodDark;
                stem.parent = scene;

                // Flower head
                const flower = BABYLON.MeshBuilder.CreateSphere("flower" + i, {
                    diameter: 0.3,
                    segments: 6
                }, scene);
                flower.position = new BABYLON.Vector3(flowerX, 0.6 + Math.random() * 0.2, flowerZ);
                const flowerIndex = Math.floor(Math.random() * materials.flowers.length);
                flower.material = materials.flowers[flowerIndex];
                flower.parent = scene;
            }
        }

        function createBush(x, z, materials, shadowGenerator, index) {
            const bushGroup = new BABYLON.TransformNode("bush" + index, scene);

            const bushParts = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < bushParts; i++) {
                const bushPart = BABYLON.MeshBuilder.CreateSphere("bushPart" + i, {
                    diameter: 1 + Math.random(),
                    segments: 6
                }, scene);
                bushPart.position = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 2,
                    0.5 + Math.random() * 0.3,
                    (Math.random() - 0.5) * 2
                );
                bushPart.scaling = new BABYLON.Vector3(1, 0.8, 1);
                bushPart.material = materials.leaves;
                bushPart.parent = bushGroup;
                shadowGenerator.addShadowCaster(bushPart);
            }

            bushGroup.position = new BABYLON.Vector3(x, 0, z);
            bushGroup.parent = scene;
        }

        // ==================== DECORATIONS ====================
        function createDecorations(materials, shadowGenerator) {
            // Fences around village
            createFence(5, 22, 15, 22, materials, shadowGenerator);
            createFence(-15, 15, -5, 22, materials, shadowGenerator);

            // Hay bales
            const hayPositions = [
                { x: -3, z: 24 },
                { x: 0, z: 25 },
                { x: -6, z: 23 }
            ];

            hayPositions.forEach((pos, i) => {
                const hay = BABYLON.MeshBuilder.CreateCylinder("hay" + i, {
                    height: 1.5,
                    diameter: 1.2,
                    tessellation: 12
                }, scene);
                hay.position = new BABYLON.Vector3(pos.x, 0.75, pos.z);
                const hayMat = new BABYLON.StandardMaterial("hayMat" + i, scene);
                hayMat.diffuseColor = new BABYLON.Color3(0.9, 0.8, 0.4);
                hay.material = hayMat;
                hay.parent = scene;
                shadowGenerator.addShadowCaster(hay);
            });

            // barrels
            const barrelPositions = [
                { x: -12, z: 17 },
                { x: -14, z: 18 },
                { x: 22, z: 5 }
            ];

            barrelPositions.forEach((pos, i) => {
                const barrel = BABYLON.MeshBuilder.CreateCylinder("barrel" + i, {
                    height: 1.5,
                    diameter: 1,
                    tessellation: 16
                }, scene);
                barrel.position = new BABYLON.Vector3(pos.x, 0.75, pos.z);
                barrel.material = materials.wood;
                barrel.parent = scene;
                shadowGenerator.addShadowCaster(barrel);
            });

            // Crates
            for (let i = 0; i < 5; i++) {
                const crate = BABYLON.MeshBuilder.CreateBox("crate" + i, {
                    width: 1 + Math.random() * 0.5,
                    height: 1 + Math.random() * 0.5,
                    depth: 1 + Math.random() * 0.5
                }, scene);
                crate.position = new BABYLON.Vector3(
                    -15 + Math.random() * 5,
                    crate.scaling.y / 2,
                    20 + Math.random() * 5
                );
                crate.rotation.y = Math.random() * Math.PI / 4;
                crate.material = materials.woodDark;
                crate.parent = scene;
                shadowGenerator.addShadowCaster(crate);
            }

            // Birds (simple floating spheres)
            for (let i = 0; i < 6; i++) {
                const bird = BABYLON.MeshBuilder.CreateSphere("bird" + i, {
                    diameter: 0.3
                }, scene);
                const birdMat = new BABYLON.StandardMaterial("birdMat" + i, scene);
                birdMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.3);
                bird.material = birdMat;

                const startX = -30 + Math.random() * 60;
                const startZ = -30 + Math.random() * 60;
                bird.position = new BABYLON.Vector3(startX, 15 + Math.random() * 10, startZ);

                // Bird animation
                let angle = Math.random() * Math.PI * 2;
                scene.registerBeforeRender(() => {
                    angle += 0.02;
                    bird.position.x = startX + Math.cos(angle) * 5;
                    bird.position.z = startZ + Math.sin(angle) * 3;
                    bird.position.y = 15 + Math.sin(angle * 2) * 2;
                });
            }
        }

        function createFence(x1, z1, x2, z2, materials, shadowGenerator) {
            const fenceGroup = new BABYLON.TransformNode("fence", scene);
            const direction = new BABYLON.Vector3(x2 - x1, 0, z2 - z1);
            const length = direction.length();
            const posts = Math.floor(length / 2);

            for (let i = 0; i <= posts; i++) {
                const t = i / posts;
                const x = x1 + direction.x * t;
                const z = z1 + direction.z * t;

                // Post
                const post = BABYLON.MeshBuilder.CreateBox("fencePost", {
                    width: 0.2,
                    height: 1.5,
                    depth: 0.2
                }, scene);
                post.position = new BABYLON.Vector3(x, 0.75, z);
                post.material = materials.woodDark;
                post.parent = fenceGroup;

                // Rails
                if (i < posts) {
                    const rail1 = BABYLON.MeshBuilder.CreateBox("fenceRail1", {
                        width: 2,
                        height: 0.1,
                        depth: 0.1
                    }, scene);
                    rail1.position = new BABYLON.Vector3(x + direction.x / posts, 0.5, z + direction.z / posts);
                    rail1.lookAt(new BABYLON.Vector3(x2, 0.5, z2));
                    rail1.rotation.y += Math.PI / 2;
                    rail1.material = materials.woodDark;
                    rail1.parent = fenceGroup;

                    const rail2 = rail1.clone("fenceRail2");
                    rail2.position.y = 1.2;
                    rail2.parent = fenceGroup;
                }
            }

            fenceGroup.parent = scene;
        }

        // ==================== PARTICLE TEXTURE ====================
        function createParticleTexture() {
            const size = 64;
            const textureCanvas = document.createElement('canvas');
            textureCanvas.width = size;
            textureCanvas.height = size;
            const ctx = textureCanvas.getContext('2d');

            const gradient = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);

            const texture = new BABYLON.Texture(textureCanvas.toDataURL(), scene);
            return texture;
        }

        // ==================== INITIALIZATION ====================
        createScene().then(() => {
            engine.runRenderLoop(() => {
                scene.render();
            });

            window.addEventListener('resize', () => {
                engine.resize();
            });

            console.log('Floating Island Diorama loaded successfully!');
        });
    </script>
</body>
</html>
