<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Equal Earth Projection World Map</title>
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2/dist/svg.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #fff;
        }
        
        h1 {
            color: #4fc3f7;
            margin-bottom: 15px;
            font-weight: 400;
            text-shadow: 0 0 20px rgba(79, 195, 247, 0.3);
        }
        
        #map-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            background: #0a1628;
        }
        
        #drawing {
            cursor: grab;
        }
        
        #drawing:active {
            cursor: grabbing;
        }
        
        #coords-panel {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(10, 22, 40, 0.95);
            padding: 15px 20px;
            border-radius: 10px;
            border: 1px solid rgba(79, 195, 247, 0.3);
            font-family: 'Consolas', monospace;
            font-size: 13px;
            min-width: 220px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        #coords-panel h3 {
            color: #4fc3f7;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .coord-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            color: #aaa;
        }
        
        .coord-row span:last-child {
            color: #4fc3f7;
            font-weight: 600;
        }
        
        #controls {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(10, 22, 40, 0.95);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(79, 195, 247, 0.3);
            font-size: 12px;
        }
        
        #controls h3 {
            color: #4fc3f7;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .control-row {
            margin-bottom: 10px;
        }
        
        .control-row label {
            display: block;
            color: #aaa;
            margin-bottom: 5px;
        }
        
        .control-row input {
            width: 80px;
            padding: 5px 8px;
            border: 1px solid rgba(79, 195, 247, 0.3);
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
        }
        
        button {
            padding: 8px 15px;
            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
            border: none;
            border-radius: 6px;
            color: #000;
            font-weight: 600;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
            transition: all 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(79, 195, 247, 0.4);
        }
        
        #zoom-controls {
            position: absolute;
            bottom: 15px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        #zoom-controls button {
            width: 36px;
            height: 36px;
            padding: 0;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #instructions {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(10, 22, 40, 0.95);
            padding: 12px 15px;
            border-radius: 8px;
            border: 1px solid rgba(79, 195, 247, 0.3);
            font-size: 11px;
            color: #888;
        }
        
        #instructions span {
            color: #4fc3f7;
        }
        
        .marker {
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .marker:hover {
            transform: scale(1.3);
        }
        
        .graticule {
            stroke: rgba(79, 195, 247, 0.15);
            stroke-width: 0.5;
            fill: none;
        }
        
        .land {
            fill: #1e3a5f;
            stroke: #4fc3f7;
            stroke-width: 0.5;
        }
        
        .ocean {
            fill: #0a1628;
        }
    </style>
</head>
<body>
    <h1>üåç Equal Earth Projection</h1>
    
    <div id="map-container">
        <div id="drawing"></div>
        
        <div id="coords-panel">
            <h3>üìç Coordinates</h3>
            <div class="coord-row">
                <span>Latitude:</span>
                <span id="lat-display">--</span>
            </div>
            <div class="coord-row">
                <span>Longitude:</span>
                <span id="lon-display">--</span>
            </div>
            <div class="coord-row">
                <span>Screen X:</span>
                <span id="x-display">--</span>
            </div>
            <div class="coord-row">
                <span>Screen Y:</span>
                <span id="y-display">--</span>
            </div>
            <div class="coord-row">
                <span>Zoom:</span>
                <span id="zoom-display">1.00x</span>
            </div>
        </div>
        
        <div id="controls">
            <h3>üìå Add Marker</h3>
            <div class="control-row">
                <label>Latitude (-90 to 90):</label>
                <input type="number" id="marker-lat" value="48.8566" step="0.1" min="-90" max="90">
            </div>
            <div class="control-row">
                <label>Longitude (-180 to 180):</label>
                <input type="number" id="marker-lon" value="2.3522" step="0.1" min="-180" max="180">
            </div>
            <button onclick="addMarkerFromInput()">Add Marker</button>
            <button onclick="clearMarkers()">Clear All</button>
        </div>
        
        <div id="zoom-controls">
            <button onclick="zoomIn()">+</button>
            <button onclick="zoomOut()">‚àí</button>
            <button onclick="resetView()">‚åÇ</button>
        </div>
        
        <div id="instructions">
            <span>Scroll</span> to zoom | <span>Drag</span> to pan | <span>Click</span> for coordinates
        </div>
    </div>

    <script>
        // Equal Earth Projection Constants
        const A1 = 1.340264;
        const A2 = -0.081106;
        const A3 = 0.000893;
        const A4 = 0.003796;
        const M = Math.sqrt(3) / 2;
        
        // Map configuration
        const WIDTH = 1000;
        const HEIGHT = 500;
        const SCALE = 150;
        const CENTER_X = WIDTH / 2;
        const CENTER_Y = HEIGHT / 2;
        
        // State
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let lastX, lastY;
        let markers = [];
        let draw, mapGroup, markerGroup;
        
        // Convert degrees to radians
        function toRad(deg) {
            return deg * Math.PI / 180;
        }
        
        // Convert radians to degrees
        function toDeg(rad) {
            return rad * 180 / Math.PI;
        }
        
        // Forward projection: lat/lon (degrees) to projected x,y
        function projectForward(lat, lon) {
            const phi = toRad(lat);
            const lambda = toRad(lon);
            
            // Parametric latitude
            const sinTheta = M * Math.sin(phi);
            const theta = Math.asin(Math.max(-1, Math.min(1, sinTheta)));
            const theta2 = theta * theta;
            const theta6 = theta2 * theta2 * theta2;
            
            // Polynomial terms
            const poly = A1 + 3 * A2 * theta2 + theta6 * (7 * A3 + 9 * A4 * theta2);
            
            // Projected coordinates
            const x = (lambda * Math.cos(theta)) / (M * poly);
            const y = theta * (A1 + A2 * theta2 + theta6 * (A3 + A4 * theta2));
            
            return { x, y };
        }
        
        // Inverse projection: projected x,y to lat/lon (degrees)
        function projectInverse(x, y) {
            // Newton-Raphson iteration to find theta
            let theta = y;
            
            for (let i = 0; i < 12; i++) {
                const theta2 = theta * theta;
                const theta6 = theta2 * theta2 * theta2;
                
                const fy = theta * (A1 + A2 * theta2 + theta6 * (A3 + A4 * theta2)) - y;
                const fpy = A1 + 3 * A2 * theta2 + theta6 * (7 * A3 + 9 * A4 * theta2);
                
                const delta = fy / fpy;
                theta -= delta;
                
                if (Math.abs(delta) < 1e-12) break;
            }
            
            const theta2 = theta * theta;
            const theta6 = theta2 * theta2 * theta2;
            const poly = A1 + 3 * A2 * theta2 + theta6 * (7 * A3 + 9 * A4 * theta2);
            
            const lambda = M * x * poly / Math.cos(theta);
            const sinPhi = Math.sin(theta) / M;
            const phi = Math.asin(Math.max(-1, Math.min(1, sinPhi)));
            
            return {
                lat: toDeg(phi),
                lon: toDeg(lambda)
            };
        }
        
        // Convert geographic coordinates to screen coordinates
        function geoToScreen(lat, lon) {
            const proj = projectForward(lat, lon);
            return {
                x: CENTER_X + proj.x * SCALE * zoom + panX,
                y: CENTER_Y - proj.y * SCALE * zoom + panY
            };
        }
        
        // Convert screen coordinates to geographic coordinates
        function screenToGeo(screenX, screenY) {
            const projX = (screenX - CENTER_X - panX) / (SCALE * zoom);
            const projY = -(screenY - CENTER_Y - panY) / (SCALE * zoom);
            return projectInverse(projX, projY);
        }
        
        // Simplified world boundaries data (GeoJSON-like structure)
        const worldData = {
            type: "FeatureCollection",
            features: [
                // Africa
                { coordinates: [[-17,21],[-12,15],[-16,12],[-15,11],[-13,10],[-8,5],[-5,5],[0,6],[3,6],[10,2],[12,4],[15,2],[20,-5],[25,-10],[30,-15],[35,-22],[32,-28],[28,-33],[20,-35],[18,-30],[15,-25],[12,-18],[8,-5],[5,5],[0,10],[-5,15],[-10,20],[-17,21]] },
                // Europe
                { coordinates: [[-10,36],[-5,36],[0,38],[3,42],[0,44],[-2,47],[2,51],[5,52],[8,54],[10,54],[15,55],[20,55],[25,55],[30,60],[28,65],[20,70],[10,70],[5,62],[0,58],[-5,50],[-10,44],[-10,36]] },
                // Asia
                { coordinates: [[30,35],[35,32],[40,38],[45,40],[50,45],[55,50],[60,55],[70,55],[80,50],[90,45],[100,35],[105,25],[110,20],[120,25],[130,35],[140,40],[145,45],[142,50],[135,55],[125,53],[115,50],[100,55],[90,60],[80,65],[70,70],[60,70],[50,60],[40,45],[35,40],[30,35]] },
                // North America
                { coordinates: [[-170,65],[-165,70],[-145,70],[-130,70],[-120,60],[-125,50],[-125,40],[-115,32],[-105,25],[-95,20],[-90,20],[-85,22],[-80,25],[-75,35],[-70,42],[-65,45],[-55,50],[-60,55],[-70,60],[-80,65],[-95,70],[-120,72],[-145,72],[-170,65]] },
                // South America
                { coordinates: [[-80,10],[-75,5],[-70,5],[-60,5],[-50,0],[-45,-5],[-40,-10],[-38,-15],[-40,-22],[-45,-25],[-50,-30],[-55,-35],[-60,-40],[-65,-55],[-70,-50],[-75,-45],[-75,-35],[-75,-25],[-80,-5],[-80,10]] },
                // Australia
                { coordinates: [[115,-35],[120,-35],[130,-32],[140,-38],[150,-38],[155,-28],[150,-22],[145,-15],[140,-12],[130,-12],[125,-15],[115,-22],[113,-28],[115,-35]] },
                // Antarctica
                { coordinates: [[-180,-65],[-120,-70],[-60,-75],[0,-70],[60,-70],[120,-70],[180,-65],[180,-90],[-180,-90],[-180,-65]] }
            ]
        };
        
        // Draw graticule (grid lines)
        function drawGraticule() {
            const graticuleGroup = mapGroup.group().addClass('graticule-group');
            
            // Latitude lines
            for (let lat = -80; lat <= 80; lat += 20) {
                const points = [];
                for (let lon = -180; lon <= 180; lon += 5) {
                    const screen = geoToScreen(lat, lon);
                    points.push([screen.x, screen.y]);
                }
                if (points.length > 1) {
                    graticuleGroup.polyline(points).addClass('graticule');
                }
            }
            
            // Longitude lines
            for (let lon = -180; lon <= 180; lon += 30) {
                const points = [];
                for (let lat = -85; lat <= 85; lat += 5) {
                    const screen = geoToScreen(lat, lon);
                    points.push([screen.x, screen.y]);
                }
                if (points.length > 1) {
                    graticuleGroup.polyline(points).addClass('graticule');
                }
            }
        }
        
        // Draw map outline (projection boundary)
        function drawOutline() {
            const points = [];
            
            // Top edge
            for (let lon = -180; lon <= 180; lon += 2) {
                const screen = geoToScreen(85, lon);
                points.push([screen.x, screen.y]);
            }
            
            // Right edge
            for (let lat = 85; lat >= -85; lat -= 2) {
                const screen = geoToScreen(lat, 180);
                points.push([screen.x, screen.y]);
            }
            
            // Bottom edge
            for (let lon = 180; lon >= -180; lon -= 2) {
                const screen = geoToScreen(-85, lon);
                points.push([screen.x, screen.y]);
            }
            
            // Left edge
            for (let lat = -85; lat <= 85; lat += 2) {
                const screen = geoToScreen(lat, -180);
                points.push([screen.x, screen.y]);
            }
            
            mapGroup.polygon(points).addClass('ocean').back();
        }
        
        // Draw land masses
        function drawLand() {
            const landGroup = mapGroup.group();
            
            worldData.features.forEach(feature => {
                const screenPoints = feature.coordinates.map(coord => {
                    const screen = geoToScreen(coord[1], coord[0]);
                    return [screen.x, screen.y];
                });
                
                if (screenPoints.length > 2) {
                    landGroup.polygon(screenPoints).addClass('land');
                }
            });
        }
        
        // Redraw the entire map
        function redrawMap() {
            mapGroup.clear();
            drawOutline();
            drawGraticule();
            drawLand();
            
            // Redraw markers
            redrawMarkers();
            
            document.getElementById('zoom-display').textContent = zoom.toFixed(2) + 'x';
        }
        
        // Add a marker at geographic coordinates
        function addMarker(lat, lon, color = '#ff5252', label = '') {
            const marker = { lat, lon, color, label };
            markers.push(marker);
            drawMarker(marker);
        }
        
        // Draw a single marker
        function drawMarker(marker) {
            const screen = geoToScreen(marker.lat, marker.lon);
            
            // Check if within valid projection bounds
            if (marker.lat < -85 || marker.lat > 85 || marker.lon < -180 || marker.lon > 180) {
                return;
            }
            
            const group = markerGroup.group().addClass('marker');
            
            // Outer glow
            group.circle(16)
                .center(screen.x, screen.y)
                .fill({ color: marker.color, opacity: 0.3 });
            
            // Main marker
            group.circle(8)
                .center(screen.x, screen.y)
                .fill(marker.color)
                .stroke({ color: '#fff', width: 2 });
            
            // Center dot
            group.circle(3)
                .center(screen.x, screen.y)
                .fill('#fff');
            
            // Label if provided
            if (marker.label) {
                group.text(marker.label)
                    .move(screen.x + 10, screen.y - 8)
                    .font({ size: 12, fill: '#fff', family: 'Segoe UI' });
            }
        }
        
        // Redraw all markers
        function redrawMarkers() {
            markerGroup.clear();
            markers.forEach(marker => drawMarker(marker));
        }
        
        // Clear all markers
        function clearMarkers() {
            markers = [];
            markerGroup.clear();
        }
        
        // Add marker from input fields
        function addMarkerFromInput() {
            const lat = parseFloat(document.getElementById('marker-lat').value);
            const lon = parseFloat(document.getElementById('marker-lon').value);
            
            if (!isNaN(lat) && !isNaN(lon) && lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
                const colors = ['#ff5252', '#ffeb3b', '#69f0ae', '#40c4ff', '#e040fb', '#ff6e40'];
                const color = colors[markers.length % colors.length];
                addMarker(lat, lon, color, `${lat.toFixed(2)}¬∞, ${lon.toFixed(2)}¬∞`);
            } else {
                alert('Please enter valid coordinates.\nLatitude: -90 to 90\nLongitude: -180 to 180');
            }
        }
        
        // Zoom functions
        function zoomIn() {
            zoom = Math.min(zoom * 1.3, 20);
            redrawMap();
        }
        
        function zoomOut() {
            zoom = Math.max(zoom / 1.3, 0.5);
            redrawMap();
        }
        
        function resetView() {
            zoom = 1;
            panX = 0;
            panY = 0;
            redrawMap();
        }
        
        // Handle mouse wheel zoom
        function handleWheel(e) {
            e.preventDefault();
            
            const rect = draw.node.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.5, Math.min(20, zoom * zoomFactor));
            
            // Zoom toward mouse position
            panX = mouseX - (mouseX - panX) * (newZoom / zoom);
            panY = mouseY - (mouseY - panY) * (newZoom / zoom);
            
            zoom = newZoom;
            redrawMap();
        }
        
        // Handle mouse events for panning
        function handleMouseDown(e) {
            if (e.button === 0) {
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
                draw.node.style.cursor = 'grabbing';
            }
        }
        
        function handleMouseMove(e) {
            const rect = draw.node.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Update coordinate display
            const geo = screenToGeo(mouseX, mouseY);
            
            if (geo.lat >= -90 && geo.lat <= 90 && geo.lon >= -180 && geo.lon <= 180) {
                document.getElementById('lat-display').textContent = geo.lat.toFixed(4) + '¬∞';
                document.getElementById('lon-display').textContent = geo.lon.toFixed(4) + '¬∞';
            } else {
                document.getElementById('lat-display').textContent = '--';
                document.getElementById('lon-display').textContent = '--';
            }
            
            document.getElementById('x-display').textContent = mouseX.toFixed(0);
            document.getElementById('y-display').textContent = mouseY.toFixed(0);
            
            // Handle panning
            if (isDragging) {
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                
                panX += dx;
                panY += dy;
                
                lastX = e.clientX;
                lastY = e.clientY;
                
                redrawMap();
            }
        }
        
        function handleMouseUp(e) {
            isDragging = false;
            draw.node.style.cursor = 'grab';
        }
        
        // Handle click to show coordinates and optionally add marker
        function handleClick(e) {
            if (isDragging) return;
            
            const rect = draw.node.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const geo = screenToGeo(mouseX, mouseY);
            
            if (geo.lat >= -90 && geo.lat <= 90 && geo.lon >= -180 && geo.lon <= 180) {
                console.log(`Clicked: Lat ${geo.lat.toFixed(4)}¬∞, Lon ${geo.lon.toFixed(4)}¬∞`);
                
                // Update input fields
                document.getElementById('marker-lat').value = geo.lat.toFixed(4);
                document.getElementById('marker-lon').value = geo.lon.toFixed(4);
            }
        }
        
        // Initialize the map
        function init() {
            draw = SVG().addTo('#drawing').size(WIDTH, HEIGHT);
            
            mapGroup = draw.group();
            markerGroup = draw.group();
            
            redrawMap();
            
            // Add some example markers
            addMarker(48.8566, 2.3522, '#ff5252', 'Paris');
            addMarker(40.7128, -74.0060, '#40c4ff', 'New York');
            addMarker(35.6762, 139.6503, '#ffeb3b', 'Tokyo');
            addMarker(-33.8688, 151.2093, '#69f0ae', 'Sydney');
            addMarker(-22.9068, -43.1729, '#e040fb', 'Rio');
            
            // Event listeners
            const svgNode = draw.node;
            svgNode.addEventListener('wheel', handleWheel, { passive: false });
            svgNode.addEventListener('mousedown', handleMouseDown);
            svgNode.addEventListener('mousemove', handleMouseMove);
            svgNode.addEventListener('mouseup', handleMouseUp);
            svgNode.addEventListener('mouseleave', handleMouseUp);
            svgNode.addEventListener('click', handleClick);
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === '+' || e.key === '=') zoomIn();
                if (e.key === '-') zoomOut();
                if (e.key === '0') resetView();
            });
        }
        
        // Start the application
        window.onload = init;
    </script>
</body>
</html>