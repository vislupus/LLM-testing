<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Equal Earth Interactive Map</title>
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.2.0/dist/svg.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a1929, #0d1f33);
            color: #e0f7fa;
            overflow: hidden;
        }
        
        #map-container {
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }
        
        #map-container.dragging {
            cursor: grabbing;
        }
        
        #coordinates {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(25, 118, 210, 0.15);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 14px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
            z-index: 1000;
        }
        
        #coordinates.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(25, 118, 210, 0.15);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }
        
        #controls h3 {
            margin: 0 0 15px 0;
            color: #4fc3f7;
            font-size: 16px;
            border-bottom: 1px solid rgba(79, 195, 247, 0.3);
            padding-bottom: 10px;
        }
        
        .control-group {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        label {
            font-size: 13px;
            color: #bbdefb;
            min-width: 80px;
        }
        
        input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e0f7fa;
            padding: 5px 8px;
            border-radius: 6px;
            font-size: 13px;
            width: 80px;
        }
        
        button {
            background: linear-gradient(to right, #2196F3, #21CBF3);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
        }
        
        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(25, 118, 210, 0.15);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            font-size: 12px;
            max-width: 250px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .info p {
            margin: 5px 0;
            color: #bbdefb;
        }
        
        .info strong {
            color: #4fc3f7;
        }
    </style>
</head>
<body>
    <div id="map-container"></div>
    <div id="coordinates"></div>
    
    <div id="controls">
        <h3>Add Marker</h3>
        <div class="control-group">
            <label>Lat:</label>
            <input type="number" id="latInput" placeholder="e.g. 40.7128" step="0.0001" min="-90" max="90">
        </div>
        <div class="control-group">
            <label>Lon:</label>
            <input type="number" id="lonInput" placeholder="e.g. -74.0060" step="0.0001" min="-180" max="180">
        </div>
        <div class="control-group">
            <button id="addMarkerBtn">Add Marker</button>
            <button id="clearMarkersBtn">Clear All</button>
        </div>
    </div>
    
    <div class="info">
        <p><strong>Controls:</strong></p>
        <p>• Scroll to zoom</p>
        <p>• Drag to pan</p>
        <p>• Click map for coordinates</p>
    </div>

    <script>
        // Equal Earth Projection Constants
        const PROJ_BOUNDS = {
            minX: -2.003050462579892,
            maxX: 2.003050462579892,
            minY: -1.0,
            maxY: 1.0
        };
        
        // Forward projection: lat/lon (degrees) -> x,y (projection coordinates)
        function equalEarthForward(lat, lon) {
            const phi = lat * Math.PI / 180;
            const lambda = lon * Math.PI / 180;
            
            const a1 = 1.340264;
            const a2 = -0.081106;
            const a3 = 0.000893;
            const a4 = 0.003796;
            
            const theta = Math.asin((Math.sqrt(3) / 2) * Math.sin(phi));
            const cosTheta = Math.cos(theta);
            const sinPhi = Math.sin(phi);
            const term = (Math.sqrt(3) / 2) * sinPhi;
            const denominator = Math.sqrt(1 - term * term);
            
            const x = lambda * cosTheta / denominator;
            const y = term / denominator;
            
            const x2 = x * x;
            const x4 = x2 * x2;
            const x6 = x4 * x2;
            
            const scale = a1 + a2 * x2 + a3 * x4 + a4 * x6;
            
            return {
                x: x * scale,
                y: y * scale
            };
        }
        
        // Inverse projection: x,y (projection coordinates) -> lat/lon (degrees)
        function equalEarthInverse(x, y) {
            // Newton-Raphson for latitude
            let lat = y * 80; // Initial guess in degrees
            
            for (let i = 0; i < 10; i++) {
                const proj = equalEarthForward(lat, 0);
                const error = proj.y - y;
                if (Math.abs(error) < 1e-8) break;
                
                // Numerical derivative
                const projH = equalEarthForward(lat + 0.0001, 0);
                const derivative = (projH.y - proj.y) / 0.0001;
                if (Math.abs(derivative) < 1e-10) break;
                
                lat -= error / derivative;
            }
            
            // Solve for longitude
            const projAtLat = equalEarthForward(lat, 0);
            const projAtLatPlus1 = equalEarthForward(lat, 1);
            const xScale = projAtLatPlus1.x - projAtLat.x;
            
            let lon = x / xScale;
            
            // Normalize longitude to [-180, 180]
            lon = ((lon + 180) % 360 + 360) % 360 - 180;
            
            return {
                lat: Math.max(-90, Math.min(90, lat)),
                lon: lon
            };
        }
        
        // Simplified world map data (major landmasses)
        const worldData = {
            type: "FeatureCollection",
            features: [
                // North America
                {
                    type: "Feature",
                    properties: { name: "North America" },
                    geometry: {
                        type: "Polygon",
                        coordinates: [[
                            [-168, 72], [-60, 72], [-60, 15], [-80, 15], [-80, 25], 
                            [-100, 25], [-100, 35], [-120, 35], [-120, 48], 
                            [-140, 48], [-140, 60], [-168, 60], [-168, 72]
                        ]]
                    }
                },
                // South America
                {
                    type: "Feature",
                    properties: { name: "South America" },
                    geometry: {
                        type: "Polygon",
                        coordinates: [[
                            [-82, 12], [-35, 12], [-35, -55], [-82, -55], [-82, 12]
                        ]]
                    }
                },
                // Europe
                {
                    type: "Feature",
                    properties: { name: "Europe" },
                    geometry: {
                        type: "Polygon",
                        coordinates: [[
                            [-10, 72], [40, 72], [40, 35], [-10, 35], [-10, 72]
                        ]]
                    }
                },
                // Africa
                {
                    type: "Feature",
                    properties: { name: "Africa" },
                    geometry: {
                        type: "Polygon",
                        coordinates: [[
                            [-20, 37], [52, 37], [52, -35], [-20, -35], [-20, 37]
                        ]]
                    }
                },
                // Asia
                {
                    type: "Feature",
                    properties: { name: "Asia" },
                    geometry: {
                        type: "Polygon",
                        coordinates: [[
                            [40, 72], [180, 72], [180, 5], [100, 5], [100, -10],
                            [40, -10], [40, 72]
                        ]]
                    }
                },
                // Australia
                {
                    type: "Feature",
                    properties: { name: "Australia" },
                    geometry: {
                        type: "Polygon",
                        coordinates: [[
                            [112, -10], [154, -10], [154, -45], [112, -45], [112, -10]
                        ]]
                    }
                },
                // Antarctica
                {
                    type: "Feature",
                    properties: { name: "Antarctica" },
                    geometry: {
                        type: "Polygon",
                        coordinates: [[
                            [-180, -60], [180, -60], [180, -85], [-180, -85], [-180, -60]
                        ]]
                    }
                },
                // Greenland
                {
                    type: "Feature",
                    properties: { name: "Greenland" },
                    geometry: {
                        type: "Polygon",
                        coordinates: [[
                            [-50, 82], [-25, 82], [-25, 60], [-50, 60], [-50, 82]
                        ]]
                    }
                }
            ]
        };
        
        // Main map application
        class EqualEarthMap {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                this.width = this.container.clientWidth;
                this.height = this.container.clientHeight;
                
                // Viewport state for pan/zoom
                this.viewport = {
                    zoom: 1,
                    panX: 0,
                    panY: 0,
                    isDragging: false,
                    lastMousePos: { x: 0, y: 0 }
                };
                
                // Markers array
                this.markers = [];
                
                // Initialize SVG
                this.initSVG();
                this.initControls();
                
                // Draw the map
                this.drawMap();
            }
            
            initSVG() {
                this.svg = SVG().addTo(this.container).size(this.width, this.height);
                
                // Main group for all map elements
                this.mapGroup = this.svg.group();
                
                // Group for landmasses
                this.landGroup = this.mapGroup.group();
                
                // Group for graticule (grid)
                this.graticuleGroup = this.mapGroup.group();
                
                // Group for markers
                this.markerGroup = this.mapGroup.group();
                
                // Set background
                this.svg.css({ background: '#0a1929' });
            }
            
            drawMap() {
                // Clear existing
                this.landGroup.clear();
                this.graticuleGroup.clear();
                
                // Draw graticule
                this.drawGraticule();
                
                // Draw landmasses
                for (const feature of worldData.features) {
                    const geometry = feature.geometry;
                    
                    if (geometry.type === 'Polygon') {
                        this.drawPolygon(geometry.coordinates[0]);
                    } else if (geometry.type === 'MultiPolygon') {
                        for (const polygon of geometry.coordinates) {
                            this.drawPolygon(polygon[0]);
                        }
                    }
                }
                
                // Apply viewport transform
                this.updateTransform();
            }
            
            drawGraticule() {
                const strokeColor = '#1e4976';
                const strokeWidth = 0.5;
                
                // Meridians (longitude lines)
                for (let lon = -180; lon <= 180; lon += 30) {
                    let path = '';
                    for (let lat = -90; lat <= 90; lat += 5) {
                        const pt = this.project(lat, lon);
                        path += (path ? ' L' : 'M') + ` ${pt.x} ${pt.y}`;
                    }
                    const line = this.graticuleGroup.path(path);
                    line.fill('none').stroke({ color: strokeColor, width: strokeWidth });
                }
                
                // Parallels (latitude lines)
                for (let lat = -90; lat <= 90; lat += 30) {
                    let path = '';
                    for (let lon = -180; lon <= 180; lon += 5) {
                        const pt = this.project(lat, lon);
                        path += (path ? ' L' : 'M') + ` ${pt.x} ${pt.y}`;
                    }
                    const line = this.graticuleGroup.path(path);
                    line.fill('none').stroke({ color: strokeColor, width: strokeWidth });
                }
            }
            
            drawPolygon(coordinates) {
                let pathData = '';
                
                for (let i = 0; i < coordinates.length; i++) {
                    const [lon, lat] = coordinates[i];
                    const pt = this.project(lat, lon);
                    
                    if (i === 0) {
                        pathData += `M ${pt.x} ${pt.y}`;
                    } else {
                        pathData += ` L ${pt.x} ${pt.y}`;
                    }
                }
                
                pathData += ' Z';
                
                const path = this.landGroup.path(pathData);
                path.fill('#1a3a5f').stroke('#4fc3f7');
                path.stroke({ width: 0.8 });
                path.css({ 'vector-effect': 'non-scaling-stroke' });
            }
            
            // Project geographic coordinates to screen coordinates
            project(lat, lon) {
                const proj = equalEarthForward(lat, lon);
                
                // Normalize to canvas coordinates
                const x = (proj.x - PROJ_BOUNDS.minX) / (PROJ_BOUNDS.maxX - PROJ_BOUNDS.minX) * this.width;
                const y = (1 - (proj.y - PROJ_BOUNDS.minY) / (PROJ_BOUNDS.maxY - PROJ_BOUNDS.minY)) * this.height;
                
                return { x, y };
            }
            
            // Unproject screen coordinates to geographic coordinates
            unproject(screenX, screenY) {
                // Normalize to [0,1]
                const normX = screenX / this.width;
                const normY = screenY / this.height;
                
                // Convert to projection coordinates
                const projX = normX * (PROJ_BOUNDS.maxX - PROJ_BOUNDS.minX) + PROJ_BOUNDS.minX;
                const projY = (1 - normY) * (PROJ_BOUNDS.maxY - PROJ_BOUNDS.minY) + PROJ_BOUNDS.minY;
                
                return equalEarthInverse(projX, projY);
            }
            
            addMarker(lat, lon, label = '') {
                const pt = this.project(lat, lon);
                
                // Create marker group
                const markerGroup = this.markerGroup.group();
                
                // Main marker circle
                const circle = markerGroup.circle(8).center(pt.x, pt.y);
                circle.fill('#ff5252');
                circle.stroke('#ffffff');
                circle.stroke({ width: 2 });
                
                // Label if provided
                if (label) {
                    const text = markerGroup.text(label).font({ 
                        size: 12, 
                        fill: '#ffffff',
                        weight: 'bold'
                    });
                    text.center(pt.x, pt.y - 20);
                }
                
                // Store marker info
                this.markers.push({
                    group: markerGroup,
                    lat: lat,
                    lon: lon,
                    label: label
                });
                
                return markerGroup;
            }
            
            clearMarkers() {
                this.markerGroup.clear();
                this.markers = [];
            }
            
            updateTransform() {
                const { zoom, panX, panY } = this.viewport;
                this.mapGroup.transform({
                    scale: zoom,
                    translateX: -panX * zoom,
                    translateY: -panY * zoom
                });
            }
            
            initControls() {
                // Mouse wheel zoom
                this.container.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    const rect = this.container.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Calculate zoom factor
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const newZoom = Math.max(0.5, Math.min(10, this.viewport.zoom * zoomFactor));
                    
                    // Adjust pan to zoom around mouse position
                    this.viewport.panX = mouseX - (mouseX - this.viewport.panX) * (newZoom / this.viewport.zoom);
                    this.viewport.panY = mouseY - (mouseY - this.viewport.panY) * (newZoom / this.viewport.zoom);
                    
                    this.viewport.zoom = newZoom;
                    this.updateTransform();
                });
                
                // Mouse drag pan
                this.container.addEventListener('mousedown', (e) => {
                    this.viewport.isDragging = true;
                    this.viewport.lastMousePos = { x: e.clientX, y: e.clientY };
                    this.container.classList.add('dragging');
                });
                
                window.addEventListener('mousemove', (e) => {
                    if (!this.viewport.isDragging) return;
                    
                    const dx = e.clientX - this.viewport.lastMousePos.x;
                    const dy = e.clientY - this.viewport.lastMousePos.y;
                    
                    this.viewport.panX -= dx / this.viewport.zoom;
                    this.viewport.panY -= dy / this.viewport.zoom;
                    
                    this.viewport.lastMousePos = { x: e.clientX, y: e.clientY };
                    this.updateTransform();
                });
                
                window.addEventListener('mouseup', () => {
                    this.viewport.isDragging = false;
                    this.container.classList.remove('dragging');
                });
                
                // Click for coordinates
                this.container.addEventListener('click', (e) => {
                    if (this.viewport.isDragging) return;
                    
                    const rect = this.container.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Adjust for viewport transform
                    const adjX = x / this.viewport.zoom + this.viewport.panX;
                    const adjY = y / this.viewport.zoom + this.viewport.panY;
                    
                    const geo = this.unproject(adjX, adjY);
                    
                    // Show coordinates
                    const coordDisplay = document.getElementById('coordinates');
                    coordDisplay.innerHTML = `
                        <strong>Coordinates:</strong><br>
                        Lat: ${geo.lat.toFixed(4)}°<br>
                        Lon: ${geo.lon.toFixed(4)}°
                    `;
                    coordDisplay.classList.add('show');
                    
                    // Hide after 3 seconds
                    setTimeout(() => {
                        coordDisplay.classList.remove('show');
                    }, 3000);
                    
                    // Add temporary marker
                    const tempMarker = this.addMarker(geo.lat, geo.lon);
                    setTimeout(() => {
                        tempMarker.remove();
                    }, 3000);
                });
                
                // Marker controls
                document.getElementById('addMarkerBtn').addEventListener('click', () => {
                    const lat = parseFloat(document.getElementById('latInput').value);
                    const lon = parseFloat(document.getElementById('lonInput').value);
                    
                    if (!isNaN(lat) && !isNaN(lon) && lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {
                        this.addMarker(lat, lon, `(${lat.toFixed(2)}, ${lon.toFixed(2)})`);
                        document.getElementById('latInput').value = '';
                        document.getElementById('lonInput').value = '';
                    } else {
                        alert('Please enter valid coordinates: Lat [-90, 90], Lon [-180, 180]');
                    }
                });
                
                document.getElementById('clearMarkersBtn').addEventListener('click', () => {
                    this.clearMarkers();
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.width = this.container.clientWidth;
                    this.height = this.container.clientHeight;
                    this.svg.size(this.width, this.height);
                    this.drawMap();
                });
            }
        }
        
        // Initialize map when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            const map = new EqualEarthMap('map-container');
            
            // Add some example cities
            map.addMarker(40.7128, -74.0060, "New York");
            map.addMarker(51.5074, -0.1278, "London");
            map.addMarker(35.6762, 139.6503, "Tokyo");
            map.addMarker(-33.8688, 151.2093, "Sydney");
            map.addMarker(19.4326, -99.1332, "Mexico City");
            map.addMarker(-15.7975, -47.8919, "Brasília");
            map.addMarker(55.7558, 37.6176, "Moscow");
            map.addMarker(30.0444, 31.2357, "Cairo");
            map.addMarker(28.6139, 77.2090, "New Delhi");
            map.addMarker(39.9042, 116.4074, "Beijing");
        });
    </script>
</body>
</html>