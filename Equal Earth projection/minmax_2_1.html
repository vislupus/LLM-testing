<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Equal Earth Projection World Map</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.2.4/svg.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            height: 100vh;
            overflow: hidden;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .map-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        #map-container {
            width: 100%;
            height: 100%;
            background: #0d1b2a;
            cursor: grab;
        }
        #map-container:active {
            cursor: grabbing;
        }
        .controls {
            width: 320px;
            background: #16213e;
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #0f3460;
        }
        h2 {
            color: #e94560;
            margin-bottom: 15px;
            font-size: 18px;
        }
        h3 {
            color: #0f9b8e;
            margin: 15px 0 10px;
            font-size: 14px;
        }
        .control-group {
            margin-bottom: 12px;
        }
        .control-group label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 4px;
        }
        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #0f3460;
            outline: none;
            -webkit-appearance: none;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #e94560;
            cursor: pointer;
        }
        .value-display {
            font-size: 11px;
            color: #e94560;
            text-align: right;
        }
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 6px;
            background: #0f3460;
            color: #eee;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        button:hover {
            background: #e94560;
        }
        .coord-display {
            background: #0f3460;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        .coord-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
        }
        .coord-label {
            color: #aaa;
        }
        .coord-value {
            color: #4ade80;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        .marker-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        .marker-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: #0f3460;
            border-radius: 4px;
            margin: 4px 0;
            font-size: 11px;
        }
        .marker-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .marker-delete {
            background: #e94560;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 10px;
            cursor: pointer;
        }
        .info-text {
            font-size: 11px;
            color: #666;
            margin-top: 15px;
            line-height: 1.6;
        }
        .projection-info {
            background: #0f3460;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 15px;
        }
        .projection-info p {
            font-size: 11px;
            color: #888;
            margin: 4px 0;
        }
        .presets {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            margin: 10px 0;
        }
        .preset-btn {
            padding: 6px;
            font-size: 10px;
        }
        #zoom-level {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(15, 52, 96, 0.9);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            color: #e94560;
        }
        .instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(15, 52, 96, 0.9);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 11px;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="map-area">
            <div id="map-container"></div>
            <div id="zoom-level">Zoom: 1.00x</div>
            <div class="instructions">Scroll to zoom • Drag to pan • Click to get coordinates</div>
        </div>
        <div class="controls">
            <h2>Equal Earth Projection</h2>

            <div class="projection-info">
                <p><strong>Equal Earth</strong> is a pseudo-cylindrical projection that maintains relative area sizes correctly while preserving a recognizable world shape.</p>
                <p>Created by: Bojan Savric et al. (2018)</p>
            </div>

            <button onclick="resetView()">Reset View</button>
            <button onclick="fitToScreen()">Fit to Screen</button>

            <h3>Zoom & Pan</h3>
            <div class="control-group">
                <label>Zoom Level: <span class="value-display" id="zoomVal">1.0</span></label>
                <input type="range" id="zoomSlider" min="0.5" max="10" step="0.1" value="1" oninput="setZoom(parseFloat(this.value))">
            </div>
            <div class="control-group">
                <label>Pan X: <span class="value-display" id="panXVal">0</span></label>
                <input type="range" id="panX" min="-500" max="500" value="0" oninput="setPanX(parseFloat(this.value))">
            </div>
            <div class="control-group">
                <label>Pan Y: <span class="value-display" id="panYVal">0</span></label>
                <input type="range" id="panY" min="-300" max="300" value="0" oninput="setPanY(parseFloat(this.value))">
            </div>

            <h3>Quick Locations</h3>
            <div class="presets">
                <button class="preset-btn" onclick="focusLocation(0, 0)">Null Island</button>
                <button class="preset-btn" onclick="focusLocation(40.7128, -74.0060)">New York</button>
                <button class="preset-btn" onclick="focusLocation(51.5074, -0.1278)">London</button>
                <button class="preset-btn" onclick="focusLocation(35.6762, 139.6503)">Tokyo</button>
                <button class="preset-btn" onclick="focusLocation(-33.8688, 151.2093)">Sydney</button>
                <button class="preset-btn" onclick="focusLocation(-22.9068, -43.1729)">Rio de Janeiro</button>
                <button class="preset-btn" onclick="focusLocation(55.7558, 37.6173)">Moscow</button>
                <button class="preset-btn" onclick="focusLocation(28.6139, 77.2090)">New Delhi</button>
            </div>

            <h3>Add Marker</h3>
            <div class="control-group">
                <label>Latitude (-90 to 90): <span class="value-display" id="latVal">0</span></label>
                <input type="range" id="latInput" min="-90" max="90" value="0" oninput="updateMarkerInput('lat')">
            </div>
            <div class="control-group">
                <label>Longitude (-180 to 180): <span class="value-display" id="lonVal">0</span></label>
                <input type="range" id="lonInput" min="-180" max="180" value="0" oninput="updateMarkerInput('lon')">
            </div>
            <div class="control-group">
                <label>Marker Color:</label>
                <input type="color" id="markerColor" value="#e94560" style="width: 100%; height: 30px; border: none; border-radius: 4px;">
            </div>
            <button onclick="addMarkerFromInput()">Add Marker</button>

            <div class="coord-display">
                <h3>Current Coordinates</h3>
                <div class="coord-row">
                    <span class="coord-label">Latitude:</span>
                    <span class="coord-value" id="displayLat">-</span>
                </div>
                <div class="coord-row">
                    <span class="coord-label">Longitude:</span>
                    <span class="coord-value" id="displayLon">-</span>
                </div>
                <div class="coord-row">
                    <span class="coord-label">Screen X:</span>
                    <span class="coord-value" id="displayScreenX">-</span>
                </div>
                <div class="coord-row">
                    <span class="coord-label">Screen Y:</span>
                    <span class="coord-value" id="displayScreenY">-</span>
                </div>
            </div>

            <h3>Markers</h3>
            <div class="marker-list" id="markerList">
                <p style="font-size: 11px; color: #666; text-align: center;">Click map or add markers above</p>
            </div>

            <div class="info-text">
                <strong>About Equal Earth:</strong><br>
                The Equal Earth projection was created to address the need for a world map that shows countries' relative sizes accurately while maintaining an aesthetically pleasing appearance. Unlike the Mercator projection, it doesn't exaggerate the size of polar regions.<br><br>
                <strong>Formulas used:</strong><br>
                Forward: lat/lon → x, y (Equal Earth)<br>
                Inverse: x, y → lat/lon (with Newton-Raphson)
            </div>
        </div>
    </div>

    <script>
        // Equal Earth Projection Parameters
        const A = 6378137; // Semi-major axis of Earth (meters)
        const EQ_EARTH = {
            n: 0.3633788612716053, // Constant related to the projection
            C: 1.003756305613778, // Scaling factor
            phi0: 0 // Reference latitude
        };

        // Map dimensions (base, before zoom)
        const BASE_WIDTH = 1000;
        const BASE_HEIGHT = 500;

        // SVG and transformation state
        let draw;
        let mapGroup;
        let landGroup;
        let markerGroup;
        let markers = [];

        // View state
        let viewState = {
            zoom: 1,
            panX: 0,
            panY: 0,
            basePanX: 0,
            basePanY: 0
        };

        // World map data (simplified low-res)
        const worldData = [
            // North America
            "M-125,25 L-125,30 L-120,32 L-115,30 L-110,31 L-105,29 L-100,28 L-95,26 L-90,28 L-85,29 L-80,30 L-75,28 L-70,25 L-67,26 L-65,30 L-60,33 L-55,35 L-50,34 L-45,33 L-40,35 L-35,38 L-30,40 L-25,38 L-20,35 L-15,35 L-10,32 L-5,30 L0,28 L-5,25 L-10,22 L-15,20 L-20,18 L-25,19 L-30,22 L-35,25 L-40,23 L-45,21 L-50,22 L-55,25 L-60,28 L-65,30 L-70,28 L-75,25 L-80,23 L-85,24 L-90,26 L-95,27 L-100,26 L-105,24 L-110,23 L-115,24 L-120,26 L-125,25 Z",
            // South America
            "M-80,5 L-75,2 L-70,0 L-65,-2 L-60,-3 L-55,-5 L-50,-8 L-45,-10 L-40,-12 L-35,-13 L-30,-12 L-25,-10 L-20,-8 L-15,-5 L-10,-3 L-5,0 L0,2 L-5,5 L-10,7 L-15,8 L-20,7 L-25,5 L-30,3 L-35,2 L-40,3 L-45,5 L-50,7 L-55,8 L-60,7 L-65,5 L-70,3 L-75,2 L-80,5 Z",
            // Europe
            "M-10,35 L-5,36 L0,36 L5,37 L10,36 L15,35 L20,34 L25,35 L30,36 L35,38 L40,40 L45,42 L50,43 L55,42 L60,40 L65,38 L70,36 L75,35 L80,36 L85,38 L90,40 L95,42 L100,40 L95,38 L90,36 L85,35 L80,34 L75,33 L70,32 L65,32 L60,33 L55,34 L50,34 L45,33 L40,32 L35,31 L30,30 L25,30 L20,31 L15,32 L10,33 L5,34 L0,35 L-5,35 L-10,35 Z",
            // Africa
            "M-15,-35 L-10,-33 L-5,-30 L0,-28 L5,-26 L10,-24 L15,-22 L20,-20 L25,-18 L30,-15 L35,-12 L40,-10 L45,-8 L50,-5 L55,-2 L60,0 L65,2 L70,3 L75,2 L80,0 L85,-2 L90,-5 L95,-8 L100,-10 L95,-12 L90,-15 L85,-18 L80,-20 L75,-22 L70,-24 L65,-26 L60,-28 L55,-30 L50,-32 L45,-33 L40,-33 L35,-32 L30,-30 L25,-28 L20,-26 L15,-28 L10,-30 L5,-32 L0,-33 L-5,-34 L-10,-35 L-15,-35 Z",
            // Asia
            "M60,30 L65,32 L70,33 L75,35 L80,37 L85,40 L90,42 L95,45 L100,48 L105,50 L110,52 L115,53 L120,52 L125,50 L130,48 L135,45 L140,42 L145,38 L150,35 L155,32 L160,30 L165,28 L170,27 L175,28 L180,30 L180,35 L175,37 L170,38 L165,40 L160,42 L155,44 L150,45 L145,46 L140,47 L135,48 L130,48 L125,47 L120,46 L115,45 L110,44 L105,43 L100,42 L95,40 L90,38 L85,36 L80,34 L75,32 L70,31 L65,30 L60,30 Z",
            // Australia
            "M115,-35 L120,-33 L125,-30 L130,-28 L135,-25 L140,-23 L145,-20 L150,-18 L155,-20 L160,-22 L165,-25 L170,-28 L175,-30 L180,-32 L180,-38 L175,-40 L170,-42 L165,-43 L160,-42 L155,-40 L150,-38 L145,-36 L140,-34 L135,-33 L130,-33 L125,-34 L120,-35 L115,-35 Z",
            // Antarctica
            "M-180,-70 L-150,-72 L-120,-73 L-90,-74 L-60,-74 L-30,-73 L0,-72 L30,-71 L60,-70 L90,-69 L120,-68 L150,-67 L180,-66 L180,-70 L150,-71 L120,-72 L90,-72 L60,-72 L30,-72 L0,-72 L-30,-72 L-60,-72 L-90,-72 L-120,-72 L-150,-71 L-180,-70 Z",
            // Greenland
            "M-50,75 L-45,77 L-40,78 L-35,77 L-30,75 L-25,73 L-30,71 L-35,70 L-40,69 L-45,70 L-50,72 L-50,75 Z",
            // UK (simplified)
            "M-5,54 L-3,54 L-2,55 L0,55 L2,54 L3,53 L2,52 L0,51 L-2,51 L-4,52 L-5,54 Z",
            // Japan (simplified)
            "M130,35 L135,33 L140,32 L145,33 L150,35 L152,37 L150,39 L145,41 L140,42 L135,42 L130,40 L128,38 L130,35 Z",
            // New Zealand (simplified)
            "M165,-42 L170,-41 L173,-40 L172,-42 L170,-44 L168,-45 L165,-45 L165,-42 Z",
            // Iceland (simplified)
            "M-25,65 L-22,64 L-18,65 L-16,66 L-18,67 L-22,68 L-25,67 L-25,65 Z"
        ];

        function setup() {
            // Initialize SVG.js
            const container = document.getElementById('map-container');
            const containerWidth = container.offsetWidth;
            const containerHeight = container.offsetHeight;

            draw = SVG().addTo('#map-container').size('100%', '100%');

            // Create groups for layering
            mapGroup = draw.group();
            landGroup = mapGroup.group();
            markerGroup = mapGroup.group();

            // Draw the map
            drawMap();

            // Fit to screen initially
            fitToScreen();

            // Setup event listeners
            setupEventListeners();
        }

        function drawMap() {
            // Draw ocean background
            mapGroup.rect(BASE_WIDTH, BASE_HEIGHT).fill('#0d1b2a');

            // Draw grid lines (latitude/longitude)
            drawGrid();

            // Draw land masses
            landGroup.fill('#2d4a3e').stroke({ color: '#4a7c6f', width: 0.5 });

            for (let pathData of worldData) {
                const path = landGroup.path(pathData);
                path.fill('#3d5a4e').stroke({ color: '#5a8a7f', width: 0.8 });
            }

            // Draw equator
            const centerY = BASE_HEIGHT / 2;
            landGroup.line(0, centerY, BASE_WIDTH, centerY)
                .stroke({ color: '#e94560', width: 1, dasharray: '5,5', opacity: 0.5 });

            // Draw prime meridian
            const centerX = BASE_WIDTH / 2;
            landGroup.line(centerX, 0, centerX, BASE_HEIGHT)
                .stroke({ color: '#e94560', width: 1, dasharray: '5,5', opacity: 0.5 });
        }

        function drawGrid() {
            const gridGroup = mapGroup.group().attr({ id: 'grid' });

            // Latitude lines
            for (let lat = -60; lat <= 60; lat += 30) {
                const points = [];
                for (let lon = -180; lon <= 180; lon += 5) {
                    const { x, y } = forwardProjection(lat, lon);
                    points.push([x, y]);
                }
                gridGroup.polyline(points.flat())
                    .fill('none')
                    .stroke({ color: '#1a3a4a', width: 0.5, opacity: 0.5 });
            }

            // Longitude lines
            for (let lon = -180; lon <= 180; lon += 30) {
                const points = [];
                for (let lat = -90; lat <= 90; lat += 5) {
                    const { x, y } = forwardProjection(lat, lon);
                    points.push([x, y]);
                }
                gridGroup.polyline(points.flat())
                    .fill('none')
                    .stroke({ color: '#1a3a4a', width: 0.5, opacity: 0.5 });
            }
        }

        // Equal Earth Forward Projection: (lat, lon) -> (x, y)
        function forwardProjection(lat, lon) {
            const phi = lat * Math.PI / 180;
            const lambda = lon * Math.PI / 180;

            // Equal Earth projection formulas
            const A_CONST = 6378137;
            const n = EQ_EARTH.n;
            const C = EQ_EARTH.C;

            // Calculate x (east-west)
            const x = A_CONST * C * lambda * Math.cos(n * phi) / n;

            // Calculate y (north-south) using series expansion
            const sinPhi = Math.sin(phi);
            const sin2Phi = Math.sin(2 * phi);
            const sin3Phi = Math.sin(3 * phi);
            const sin4Phi = Math.sin(4 * phi);
            const sin5Phi = Math.sin(5 * phi);
            const sin6Phi = Math.sin(6 * phi);

            const y = A_CONST * C * (
                phi +
                n * sinPhi * Math.cos(phi) * (1 - n * n / 6 * (7 - 3 * Math.cos(2 * phi))) +
                n * n * sinPhi * Math.cos(3 * phi) / 48 +
                n * n * n * sinPhi * Math.cos(5 * phi) / 240
            );

            // Scale to map dimensions
            const scale = BASE_WIDTH / (2 * Math.PI * A_CONST);
            x *= scale;
            y *= scale;

            // Offset to center
            const offsetX = BASE_WIDTH / 2;
            const offsetY = BASE_HEIGHT / 2;

            return {
                x: x + offsetX,
                y: offsetY - y  // Flip Y axis for screen coordinates
            };
        }

        // Equal Earth Inverse Projection: (x, y) -> (lat, lon)
        function inverseProjection(screenX, screenY) {
            const offsetX = BASE_WIDTH / 2;
            const offsetY = BASE_HEIGHT / 2;

            // Remove offset and scale
            const scale = BASE_WIDTH / (2 * Math.PI * A);
            let x = (screenX - offsetX) / scale;
            let y = (offsetY - screenY) / scale;

            // Newton-Raphson iteration to solve for latitude
            let phi = y / EQ_EARTH.C;
            for (let i = 0; i < 10; i++) {
                const sinPhi = Math.sin(phi);
                const cosPhi = Math.cos(phi);
                const sin2Phi = 2 * sinPhi * cosPhi;
                const cos2Phi = cosPhi * cosPhi - sinPhi * sinPhi;

                const f = phi +
                    EQ_EARTH.n * sinPhi * cosPhi * (1 - EQ_EARTH.n * EQ_EARTH.n / 6 * (7 - 3 * cos2Phi)) +
                    EQ_EARTH.n * EQ_EARTH.n * sinPhi * Math.cos(3 * phi) / 48 +
                    EQ_EARTH.n * EQ_EARTH.n * EQ_EARTH.n * sinPhi * Math.cos(5 * phi) / 240 - y / EQ_EARTH.C;

                const df = 1 +
                    EQ_EARTH.n * cos2Phi * (1 - EQ_EARTH.n * EQ_EARTH.n / 6 * (7 - 3 * cos2Phi)) +
                    EQ_EARTH.n * sinPhi * sinPhi * (-EQ_EARTH.n * EQ_EARTH.n / 6 * (7 - 3 * cos2Phi)) +
                    EQ_EARTH.n * EQ_EARTH.n * (cos2Phi * Math.cos(3 * phi) - 3 * sinPhi * Math.sin(3 * phi)) / 48 +
                    EQ_EARTH.n * EQ_EARTH.n * EQ_EARTH.n * (cos2Phi * Math.cos(5 * phi) - 5 * sinPhi * Math.sin(5 * phi)) / 240;

                const delta = f / df;
                phi -= delta;

                if (Math.abs(delta) < 1e-10) break;
            }

            // Calculate longitude
            const lambda = n_to_lon(x, phi);

            // Convert to degrees
            const lat = phi * 180 / Math.PI;
            const lon = lambda * 180 / Math.PI;

            return { lat, lon };
        }

        function n_to_lon(x, phi) {
            return x * EQ_EARTH.n / (Math.cos(phi) * EQ_EARTH.C * A);
        }

        function updateTransform() {
            const transformStr = `scale(${viewState.zoom}) translate(${viewState.panX}, ${viewState.panY})`;
            mapGroup.transform({ a: viewState.zoom, d: viewState.zoom, e: viewState.panX, f: viewState.panY });

            document.getElementById('zoomVal').textContent = viewState.zoom.toFixed(2);
            document.getElementById('zoomSlider').value = viewState.zoom;
            document.getElementById('panXVal').textContent = Math.round(viewState.panX);
            document.getElementById('panYVal').textContent = Math.round(viewState.panY);
            document.getElementById('zoom-level').textContent = `Zoom: ${viewState.zoom.toFixed(2)}x`;
        }

        function setupEventListeners() {
            const container = document.getElementById('map-container');

            // Mouse wheel zoom
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(0.5, Math.min(10, viewState.zoom * delta));

                // Zoom towards mouse position
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Calculate offset due to zoom
                viewState.panX = mouseX - (mouseX - viewState.panX) * (newZoom / viewState.zoom);
                viewState.panY = mouseY - (mouseY - viewState.panY) * (newZoom / viewState.zoom);

                viewState.zoom = newZoom;
                updateTransform();
            });

            // Pan with mouse drag
            let isDragging = false;
            let lastX, lastY;

            container.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    isDragging = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    container.style.cursor = 'grabbing';
                }
            });

            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const dx = e.clientX - lastX;
                    const dy = e.clientY - lastY;
                    viewState.panX += dx;
                    viewState.panY += dy;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    updateTransform();
                }
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
                container.style.cursor = 'grab';
            });

            // Click to get coordinates
            container.addEventListener('click', (e) => {
                if (!isDragging) {
                    const rect = container.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Convert screen coordinates to map coordinates
                    const mapX = (x - viewState.panX) / viewState.zoom;
                    const mapY = (y - viewState.panY) / viewState.zoom;

                    // Inverse projection
                    const { lat, lon } = inverseProjection(mapX, mapY);

                    // Update display
                    document.getElementById('displayLat').textContent = lat.toFixed(4) + '°';
                    document.getElementById('displayLon').textContent = lon.toFixed(4) + '°';
                    document.getElementById('displayScreenX').textContent = Math.round(x);
                    document.getElementById('displayScreenY').textContent = Math.round(y);

                    // Update slider values
                    document.getElementById('latInput').value = lat;
                    document.getElementById('lonInput').value = lon;
                    document.getElementById('latVal').textContent = lat.toFixed(1);
                    document.getElementById('lonVal').textContent = lon.toFixed(1);
                }
            });
        }

        function setZoom(level) {
            viewState.zoom = level;
            updateTransform();
        }

        function setPanX(val) {
            viewState.panX = val;
            updateTransform();
        }

        function setPanY(val) {
            viewState.panY = val;
            updateTransform();
        }

        function resetView() {
            viewState.zoom = 1;
            viewState.panX = 0;
            viewState.panY = 0;
            updateTransform();
        }

        function fitToScreen() {
            const container = document.getElementById('map-container');
            const containerWidth = container.offsetWidth;
            const containerHeight = container.offsetHeight;

            const scaleX = containerWidth / BASE_WIDTH;
            const scaleY = containerHeight / BASE_HEIGHT;
            viewState.zoom = Math.min(scaleX, scaleY) * 0.9;

            viewState.panX = (containerWidth - BASE_WIDTH * viewState.zoom) / 2;
            viewState.panY = (containerHeight - BASE_HEIGHT * viewState.zoom) / 2;

            updateTransform();
        }

        function focusLocation(lat, lon) {
            const { x, y } = forwardProjection(lat, lon);

            const container = document.getElementById('map-container');
            const containerWidth = container.offsetWidth;
            const containerHeight = container.offsetHeight;

            viewState.panX = containerWidth / 2 - x * viewState.zoom;
            viewState.panY = containerHeight / 2 - y * viewState.zoom;

            updateTransform();

            // Update coordinate display
            document.getElementById('displayLat').textContent = lat.toFixed(4) + '°';
            document.getElementById('displayLon').textContent = lon.toFixed(4) + '°';
        }

        function updateMarkerInput(type) {
            if (type === 'lat') {
                document.getElementById('latVal').textContent = document.getElementById('latInput').value;
            } else {
                document.getElementById('lonVal').textContent = document.getElementById('lonInput').value;
            }
        }

        function addMarkerFromInput() {
            const lat = parseFloat(document.getElementById('latInput').value);
            const lon = parseFloat(document.getElementById('lonInput').value);
            const color = document.getElementById('markerColor').value;

            addMarker(lat, lon, color);
        }

        function addMarker(lat, lon, color = '#e94560') {
            const { x, y } = forwardProjection(lat, lon);

            // Create marker elements
            const markerContainer = markerGroup.group();

            // Outer ring
            const outerRing = markerContainer.circle(12).fill('none').stroke({ color: color, width: 2 });
            outerRing.center(x, y);

            // Inner dot
            const innerDot = markerContainer.circle(6).fill(color);
            innerDot.center(x, y);

            // Tooltip
            const tooltip = markerContainer.group().hide();
            const tooltipBg = tooltip.rect(100, 24).fill('#16213e').stroke({ color: color, width: 1 }).radius(4);
            const tooltipText = tooltip.text(`${lat.toFixed(2)}°, ${lon.toFixed(2)}°`).font({ size: 11, fill: '#eee', family: 'monospace' });
            tooltipText.center(50, 12);
            tooltip.center(x, y - 20);

            // Hover effects
            markerContainer.on('mouseenter', () => {
                outerRing.animate(100).transform({ scale: 1.3 });
                tooltip.show();
            });

            markerContainer.on('mouseleave', () => {
                outerRing.animate(100).transform({ scale: 1 });
                tooltip.hide();
            });

            // Store marker info
            const markerInfo = {
                id: Date.now(),
                lat,
                lon,
                color,
                group: markerContainer
            };

            markers.push(markerInfo);
            updateMarkerList();
        }

        function removeMarker(id) {
            const index = markers.findIndex(m => m.id === id);
            if (index !== -1) {
                markers[index].group.remove();
                markers.splice(index, 1);
                updateMarkerList();
            }
        }

        function updateMarkerList() {
            const listContainer = document.getElementById('markerList');

            if (markers.length === 0) {
                listContainer.innerHTML = '<p style="font-size: 11px; color: #666; text-align: center;">Click map or add markers above</p>';
                return;
            }

            listContainer.innerHTML = markers.map(m => `
                <div class="marker-item">
                    <div style="display: flex; align-items: center;">
                        <div class="marker-color" style="background: ${m.color};"></div>
                        <span>${m.lat.toFixed(2)}°, ${m.lon.toFixed(2)}°</span>
                    </div>
                    <button class="marker-delete" onclick="removeMarker(${m.id})">×</button>
                </div>
            `).join('');
        }

        // Initialize on load
        window.addEventListener('load', setup);
        window.addEventListener('resize', fitToScreen);
    </script>

<script>
/**
 * Iframe 元素高亮注入脚本
 * 需要在目标网站中引入此脚本来支持跨域 iframe 高亮功能
 *
 * 使用方法：
 * 1. 将此脚本添加到目标网站的 HTML 中
 * 2. 或通过浏览器扩展、用户脚本等方式注入
 */

(function () {
  "use strict";

  // 检查是否在 iframe 中
  if (window.self === window.top) {
    return; // 不在 iframe 中，不执行
  }

  // 检查是否已经初始化过
  if (window.__iframeHighlightInitialized) {
    return;
  }
  window.__iframeHighlightInitialized = true;
  console.log("Iframe 高亮脚本已加载");

  // 创建高亮覆盖层
  var overlay = document.createElement("div");
  overlay.id = "iframe-highlight-overlay";
  overlay.style.cssText = "\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100vw;\n    height: 100vh;\n    pointer-events: none;\n    z-index: 999999;\n    overflow: hidden;\n  ";

  // 创建悬停高亮框（虚线边框）
  var highlightBox = document.createElement("div");
  highlightBox.id = "iframe-highlight-box";
  highlightBox.style.cssText = "\n    position: absolute;\n    border: 2px dashed #007AFF;\n    background: rgba(0, 122, 255, 0.08);\n    pointer-events: none;\n    display: none;\n    transition: all 0.1s ease;\n    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.8);\n    border-radius: 2px;\n  ";

  // 创建选中节点的常驻高亮框（实线边框）
  var selectedBox = document.createElement("div");
  selectedBox.id = "iframe-selected-box";
  selectedBox.style.cssText = "\n    position: absolute;\n    border: 2px solid #007AFF;\n    pointer-events: none;\n    display: none;\n    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.9), 0 0 8px rgba(255, 107, 53, 0.4);\n    border-radius: 2px;\n    z-index: 1000000;\n  ";

  // 创建悬停标签显示
  var tagLabel = document.createElement("div");
  tagLabel.id = "iframe-tag-label";
  tagLabel.style.cssText = "\n    position: absolute;\n    background: #007AFF;\n    color: white;\n    padding: 2px 6px;\n    font-size: 11px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    border-radius: 2px;\n    pointer-events: none;\n    display: none;\n    white-space: nowrap;\n    z-index: 1000001;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    font-weight: 500;\n  ";

  // 创建选中节点标签
  var selectedLabel = document.createElement("div");
  selectedLabel.id = "iframe-selected-label";
  selectedLabel.style.cssText = "\n    position: absolute;\n    background: #007AFF;\n    color: white;\n    padding: 3px 8px;\n    font-size: 11px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    border-radius: 3px;\n    pointer-events: none;\n    display: none;\n    white-space: nowrap;\n    z-index: 1000002;\n    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);\n    font-weight: 600;\n  ";
  overlay.appendChild(highlightBox);
  overlay.appendChild(selectedBox);
  overlay.appendChild(tagLabel);
  overlay.appendChild(selectedLabel);
  document.body.appendChild(overlay);

  // 存储当前选中的元素
  var selectedElement = null;
  var highlightEnabled = false;

  // 更新选中元素的高亮显示
  function updateSelectedHighlight(element) {
    console.log("updateSelectedHighlight called with:", element);
    if (!element) {
      selectedBox.style.display = "none";
      selectedLabel.style.display = "none";
      selectedElement = null;
      console.log("Cleared selected highlight");
      return;
    }
    selectedElement = element;
    var rect = element.getBoundingClientRect();
    console.log("Selected element rect:", rect);

    // 更新选中高亮框位置
    selectedBox.style.display = "block";
    selectedBox.style.left = "".concat(rect.left - 2, "px");
    selectedBox.style.top = "".concat(rect.top - 2, "px");
    selectedBox.style.width = "".concat(rect.width + 4, "px");
    selectedBox.style.height = "".concat(rect.height + 4, "px");

    // 更新选中标签位置和内容
    selectedLabel.style.display = "block";
    selectedLabel.textContent = "\u2713 <".concat(element.tagName.toLowerCase(), ">");

    // 计算标签位置，确保不超出视窗
    var labelTop = rect.top - 28;
    var labelLeft = rect.left;

    // 如果标签会超出顶部，显示在元素下方
    if (labelTop < 5) {
      labelTop = rect.bottom + 5;
    }

    // 如果标签会超出右侧，向左调整
    var labelWidth = selectedLabel.offsetWidth || 100; // 预估宽度
    if (labelLeft + labelWidth > window.innerWidth - 10) {
      labelLeft = window.innerWidth - labelWidth - 10;
    }
    selectedLabel.style.left = "".concat(Math.max(5, labelLeft), "px");
    selectedLabel.style.top = "".concat(labelTop, "px");
    console.log("Selected highlight positioned at:", {
      left: selectedBox.style.left,
      top: selectedBox.style.top,
      width: selectedBox.style.width,
      height: selectedBox.style.height
    });
  }
  function getElementSelector(element) {
    if (!(element instanceof Element)) throw new Error('Argument must be a DOM element');
    var segments = [];
    var current = element;
    while (current !== document.documentElement) {
      var selector = '';
      // 优先检查唯一ID
      if (current.id && document.querySelectorAll("#".concat(current.id)).length === 1) {
        segments.unshift("#".concat(current.id));
        break; // ID唯一，无需继续向上
      }

      // 生成类名选择器（取第一个有效类名）
      var classes = Array.from(current.classList).filter(function (c) {
        return !c.startsWith('js-');
      });
      var className = classes.length > 0 ? ".".concat(classes[0]) : '';

      // 生成位置索引（nth-child）
      var tag = current.tagName.toLowerCase();
      if (!className) {
        var siblings = Array.from(current.parentNode.children);
        var index = siblings.findIndex(function (el) {
          return el === current;
        }) + 1;
        selector = "".concat(tag, ":nth-child(").concat(index, ")");
      } else {
        selector = className;
      }
      segments.unshift(selector);
      current = current.parentElement;
    }

    // 处理根元素
    if (current === document.documentElement) {
      segments.unshift('html');
    }
    return segments.join(' > ');
  }

  // 获取元素文本内容
  function getElementText(element) {
    var _element$textContent;
    if (element.tagName === "INPUT") {
      return element.value || element.placeholder || "";
    }
    if (element.tagName === "TEXTAREA") {
      return element.value || element.placeholder || "";
    }
    var text = ((_element$textContent = element.textContent) === null || _element$textContent === void 0 ? void 0 : _element$textContent.trim()) || "";
    return text.length > 50 ? text.substring(0, 50) + "..." : text;
  }

  // 获取元素属性信息
  function getElementAttributes(element) {
    var attrs = {};
    for (var i = 0; i < element.attributes.length; i++) {
      var attr = element.attributes[i];
      attrs[attr.name] = attr.value;
    }
    return attrs;
  }

  // 鼠标悬停事件处理
  function handleMouseOver(e) {
    if (!highlightEnabled) return;
    var target = e.target;
    if (!target || target === overlay || target === highlightBox || target === tagLabel || target === selectedBox || target === selectedLabel) {
      return;
    }

    // 避免高亮 html 和 body 元素
    if (target === document.documentElement || target === document.body) {
      return;
    }

    // 如果是已选中的元素，不显示悬停高亮
    if (target === selectedElement) {
      highlightBox.style.display = "none";
      tagLabel.style.display = "none";
      return;
    }
    var rect = target.getBoundingClientRect();
    var selector = getElementSelector(target);
    var text = getElementText(target);
    var attributes = getElementAttributes(target);

    // 更新悬停高亮框位置
    highlightBox.style.display = "block";
    highlightBox.style.left = "".concat(rect.left - 2, "px");
    highlightBox.style.top = "".concat(rect.top - 2, "px");
    highlightBox.style.width = "".concat(rect.width + 4, "px");
    highlightBox.style.height = "".concat(rect.height + 4, "px");

    // 更新标签位置和内容
    tagLabel.style.display = "block";
    tagLabel.textContent = "<".concat(target.tagName.toLowerCase(), ">");

    // 计算标签位置，确保不超出视窗
    var labelTop = rect.top - 22;
    var labelLeft = rect.left;

    // 如果标签会超出顶部，显示在元素下方
    if (labelTop < 0) {
      labelTop = rect.bottom + 5;
    }

    // 如果标签会超出右侧，向左调整
    if (labelLeft + tagLabel.offsetWidth > window.innerWidth) {
      labelLeft = window.innerWidth - tagLabel.offsetWidth - 5;
    }
    tagLabel.style.left = "".concat(Math.max(0, labelLeft), "px");
    tagLabel.style.top = "".concat(labelTop, "px");

    // 发送消息到父窗口
    var elementInfo = {
      tagName: target.tagName.toLowerCase(),
      rect: {
        left: rect.left,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.width,
        height: rect.height,
        x: rect.x,
        y: rect.y
      },
      selector: selector,
      text: text,
      attributes: attributes,
      url: window.location.href,
      path: window.location.pathname,
      timestamp: Date.now()
    };
    try {
      window.parent.postMessage({
        type: "iframe-element-hover",
        data: elementInfo,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("无法发送消息到父窗口:", error);
    }
  }

  // 鼠标离开事件处理
  function handleMouseOut(e) {
    if (!highlightEnabled) return;
    var relatedTarget = e.relatedTarget;

    // 如果鼠标移动到高亮相关元素上，不隐藏高亮
    if (relatedTarget && (relatedTarget === highlightBox || relatedTarget === tagLabel || relatedTarget === overlay || relatedTarget === selectedBox || relatedTarget === selectedLabel)) {
      return;
    }
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    try {
      window.parent.postMessage({
        type: "iframe-element-hover",
        data: null,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("无法发送消息到父窗口:", error);
    }
  }

  // 点击事件处理
  function handleClick(e) {
    var target = e.target;
    if (!target || target === overlay || target === highlightBox || target === tagLabel || target === selectedBox || target === selectedLabel) {
      return;
    }

    // 避免处理 html 和 body 元素
    if (target === document.documentElement || target === document.body) {
      return;
    }

    // 检查是否是交互元素，这些元素需要保留默认行为
    var isInteractiveElement = ['input', 'textarea', 'select', 'button', 'a'].includes(target.tagName.toLowerCase());

    // 如果高亮功能启用，对于非交互元素阻止默认行为和事件传播
    if (highlightEnabled) {
      e.preventDefault();
      e.stopPropagation();
    }
    var rect = target.getBoundingClientRect();
    var selector = getElementSelector(target);
    var text = getElementText(target);
    var attributes = getElementAttributes(target);
    console.log("Element clicked:", {
      tagName: target.tagName,
      selector: selector,
      rect: rect
    });

    // 立即更新选中高亮
    updateSelectedHighlight(target);

    // 隐藏悬停高亮，因为现在是选中状态
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    var elementInfo = {
      tagName: target.tagName.toLowerCase(),
      rect: {
        left: rect.left,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        width: rect.width,
        height: rect.height,
        x: rect.x,
        y: rect.y
      },
      selector: selector,
      text: text,
      attributes: attributes,
      url: window.location.href,
      path: window.location.pathname,
      timestamp: Date.now()
    };
    try {
      window.parent.postMessage({
        type: "iframe-element-click",
        data: elementInfo,
        source: "iframe-highlight-injector"
      }, "*");
    } catch (error) {
      console.warn("无法发送消息到父窗口:", error);
    }
  }

  // 监听来自父窗口的消息
  function handleParentMessage(event) {
    console.log("Received message from parent:", event.data);
    if (event.data.type === "iframe-highlight-toggle") {
      var enabled = event.data.enabled;
      console.log("Highlight toggle:", enabled);
      if (enabled) {
        enableHighlight();
      } else {
        disableHighlight();
      }
    } else if (event.data.type === "enable-iframe-highlight") {
      console.log("Enable iframe highlight");
      enableHighlight();
    } else if (event.data.type === "disable-iframe-highlight") {
      console.log("Disable iframe highlight");
      disableHighlight();
    } else if (event.data.type === "toggle-iframe-highlight") {
      var _enabled = event.data.enabled !== undefined ? event.data.enabled : !highlightEnabled;
      console.log("Toggle iframe highlight to:", _enabled);
      if (_enabled) {
        enableHighlight();
      } else {
        disableHighlight();
      }
    } else if (event.data.type === "update-selected-element") {
      var selector = event.data.selector;
      console.log("Update selected element with selector:", selector);
      if (selector) {
        try {
          var element = document.querySelector(selector);
          console.log("Found element by selector:", element);
          updateSelectedHighlight(element);
        } catch (error) {
          console.warn("Failed to select element:", error);
          updateSelectedHighlight(null);
        }
      } else {
        updateSelectedHighlight(null);
      }
    } else if (event.data.type === "clear-selected-element") {
      console.log("Clear selected element");
      updateSelectedHighlight(null);
    }
  }

  // 启用高亮功能
  function enableHighlight() {
    console.log("Enabling highlight");
    document.addEventListener("mouseover", handleMouseOver, true);
    document.addEventListener("mouseout", handleMouseOut, true);
    document.addEventListener("click", handleClick, true);
    highlightEnabled = true;
    overlay.style.display = "block";
  }

  // 禁用高亮功能
  function disableHighlight() {
    console.log("Disabling highlight");
    highlightEnabled = false;
    // 保持事件监听器，但通过 highlightEnabled 变量控制行为
    // 这样可以保留选中状态的显示
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    // 不隐藏 selectedBox 和 selectedLabel，保留选中状态
  }

  // 完全禁用高亮功能（移除所有监听器）
  function fullyDisableHighlight() {
    console.log("Fully disabling highlight");
    highlightEnabled = false;
    document.removeEventListener("mouseover", handleMouseOver, true);
    document.removeEventListener("mouseout", handleMouseOut, true);
    document.removeEventListener("click", handleClick, true);
    overlay.style.display = "none";
    highlightBox.style.display = "none";
    tagLabel.style.display = "none";
    selectedBox.style.display = "none";
    selectedLabel.style.display = "none";
  }

  // 添加事件监听
  enableHighlight();
  window.addEventListener("message", handleParentMessage);

  // 暴露全局函数供外部调用
  window.__iframeHighlightControl = {
    enable: enableHighlight,
    disable: disableHighlight,
    fullyDisable: fullyDisableHighlight,
    isEnabled: function isEnabled() {
      return highlightEnabled;
    },
    getSelectedElement: function getSelectedElement() {
      return selectedElement;
    },
    updateSelected: updateSelectedHighlight,
    // 通过消息发送开关控制
    sendToggleMessage: function sendToggleMessage(enabled) {
      window.parent.postMessage({
        type: 'iframe-highlight-status',
        enabled: enabled || highlightEnabled,
        source: 'iframe-highlight-injector'
      }, '*');
    }
  };

  // 通知父窗口脚本已加载
  try {
    window.parent.postMessage({
      type: "iframe-highlight-ready",
      data: {
        url: window.location.href,
        userAgent: navigator.userAgent,
        timestamp: Date.now()
      },
      source: "iframe-highlight-injector"
    }, "*");
  } catch (error) {
    console.warn("无法发送就绪消息到父窗口:", error);
  }

  // 清理函数
  window.__iframeHighlightCleanup = function () {
    fullyDisableHighlight();
    window.removeEventListener("message", handleParentMessage);
    if (overlay.parentElement) {
      overlay.parentElement.removeChild(overlay);
    }
    delete window.__iframeHighlightInitialized;
    delete window.__iframeHighlightCleanup;
  };
})();

</script>
</body>
</html>
